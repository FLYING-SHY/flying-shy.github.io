<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Netty | 阿华</title><meta name="author" content="HUA"><meta name="copyright" content="HUA"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="第 1 章 Netty 介绍和应用场景1.1      本课程学习要求 本课程不适用于 0 基础的学员  要求已经掌握了 Java  编程， 主要技术构成： Java OOP 编程、Java  多线程编程、Java IO  编程  、Java 网络编程、常用的 Java 设计模式(比如 观察者模式 ，命令模式，职责链模式  )、常用的数据结构(比如 链表)  本课程的 &lt;&lt;Netty">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty">
<meta property="og:url" content="http://example.com/2023/03/20/Netty/index.html">
<meta property="og:site_name" content="阿华">
<meta property="og:description" content="第 1 章 Netty 介绍和应用场景1.1      本课程学习要求 本课程不适用于 0 基础的学员  要求已经掌握了 Java  编程， 主要技术构成： Java OOP 编程、Java  多线程编程、Java IO  编程  、Java 网络编程、常用的 Java 设计模式(比如 观察者模式 ，命令模式，职责链模式  )、常用的数据结构(比如 链表)  本课程的 &lt;&lt;Netty">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/page3.jpg">
<meta property="article:published_time" content="2023-03-20T01:47:09.000Z">
<meta property="article:modified_time" content="2023-09-23T02:24:53.777Z">
<meta property="article:author" content="HUA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/page3.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/20/Netty/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Netty',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-23 10:24:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">阿华</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Netty</h1><div id="post-meta"><div class="meta-firstline"></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>84分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Netty"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="第-1-章-Netty-介绍和应用场景"><a href="#第-1-章-Netty-介绍和应用场景" class="headerlink" title="第 1 章 Netty 介绍和应用场景"></a>第 1 章 Netty 介绍和应用场景</h1><h2 id="1-1-本课程学习要求"><a href="#1-1-本课程学习要求" class="headerlink" title="1.1      本课程学习要求"></a>1.1      本课程学习要求</h2><ol>
<li><p>本课程不适用于 0 基础的学员</p>
</li>
<li><p>要求已经掌握了 Java  编程， 主要技术构成： Java OOP 编程、Java  多线程编程、Java IO  编程  、Java 网络编程、常用的 Java 设计模式(比如 观察者模式 ，命令模式，职责链模式  )、常用的数据结构(比如 链表)</p>
</li>
<li><p>本课程的 &lt;&lt;Netty 核心源码剖析章节&gt;&gt; 要求学员最好有项目开发和阅读源码的经历</p>
</li>
</ol>
<h2 id="1-2-Netty-的介绍"><a href="#1-2-Netty-的介绍" class="headerlink" title="1.2      Netty 的介绍"></a>1.2      Netty 的介绍</h2><ol>
<li><p>Netty 是由 JBOSS 提供的一个 <strong>Java</strong> <strong>开源框架</strong>，现为 <strong>Github</strong> <strong>上的独立项目</strong>。</p>
</li>
<li><p>Netty 是一个<strong>异步</strong>的、<strong>基于事件驱动</strong>的网络应用框架，用以快速开发高性能、高可靠性的网络 IO 程序。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image002.jpg" alt="img"></td>
</tr>
</tbody></table>
<ol start="3">
<li><p>Netty 主要针对在 TCP 协议下，面向 Clients 端的高并发应用，或者 Peer-to-Peer 场景下的大量数据持续传输的应用。</p>
</li>
<li><p>Netty 本质是一个 NIO 框架，适用于服务器通讯相关的多种应用场景</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image004.jpg" alt="img"></p>
<ol start="5">
<li>要透彻理解 Netty ， 需要先学习 NIO ， 这样我们才能阅读 Netty 的源码。</li>
</ol>
<h2 id="1-3-Netty-的应用场景"><a href="#1-3-Netty-的应用场景" class="headerlink" title="1.3      Netty 的应用场景"></a>1.3      Netty 的应用场景</h2><h3 id="1-3-1-互联网行业"><a href="#1-3-1-互联网行业" class="headerlink" title="1.3.1 互联网行业"></a>1.3.1 互联网行业</h3><ol>
<li><p>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。</p>
</li>
<li><p>典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信</p>
</li>
</ol>
<h3 id="1-3-2-游戏行业"><a href="#1-3-2-游戏行业" class="headerlink" title="1.3.2 游戏行业"></a>1.3.2 游戏行业</h3><ol>
<li><p>无论是手游服务端还是大型的网络游戏，Java 语言得到了越来越广泛的应用</p>
</li>
<li><p>Netty 作为高性能的基础通信组件，提供了 TCP&#x2F;UDP 和 HTTP 协议栈，方便定制和开发私有协议栈，账号登录服务器</p>
</li>
<li><p>地图服务器之间可以方便的通过 Netty 进行高性能的通信</p>
</li>
</ol>
<h3 id="1-3-3-大数据领域"><a href="#1-3-3-大数据领域" class="headerlink" title="1.3.3 大数据领域"></a>1.3.3 大数据领域</h3><ol>
<li><p>经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨界点通信</p>
</li>
<li><p>它的 Netty Service 基于 Netty 框架二次封装实现。</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image008.jpg" alt="img"></p>
<h3 id="1-3-4-其它开源项目使用到Netty"><a href="#1-3-4-其它开源项目使用到Netty" class="headerlink" title="1.3.4 其它开源项目使用到Netty"></a>1.3.4 其它开源项目使用到Netty</h3><p>网址: <a target="_blank" rel="noopener" href="https://netty.io/wiki/related-projects.html">https://netty.io/wiki/related-projects.html</a></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image010.jpg" alt="img"></td>
</tr>
</tbody></table>
<h2 id="1-4-Netty-的学习参考资料"><a href="#1-4-Netty-的学习参考资料" class="headerlink" title="1.4      Netty 的学习参考资料"></a>1.4      Netty 的学习参考资料</h2><p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image011.jpg" alt="img"></p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image012.gif" alt="img"></p>
<h1 id="第-2-章-Java-BIO-编程"><a href="#第-2-章-Java-BIO-编程" class="headerlink" title="第 2 章 Java BIO 编程"></a>第 2 章 Java BIO 编程</h1><h2 id="2-1-I-x2F-O-模型"><a href="#2-1-I-x2F-O-模型" class="headerlink" title="2.1      I&#x2F;O 模型"></a>2.1      I&#x2F;O 模型</h2><h3 id="2-1-1-I-x2F-O-模型基本说明"><a href="#2-1-1-I-x2F-O-模型基本说明" class="headerlink" title="2.1.1  I&#x2F;O 模型基本说明"></a>2.1.1  I&#x2F;O 模型基本说明</h3><ol>
<li><p>I&#x2F;O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能</p>
</li>
<li><p>Java 共支持 3 种网络编程模型&#x2F;IO 模式：BIO、NIO、AIO</p>
</li>
<li><p>Java BIO ： 同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image013.jpg" alt="img"></td>
</tr>
</tbody></table>
<ol start="4">
<li>Java NIO ： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I&#x2F;O 请求就进行处理</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image015.gif" alt="img"></p>
<ol start="5">
<li>Java AIO(NIO.2) ： 异步非阻塞，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li>
</ol>
<h2 id="2-2-BIO、NIO、AIO-适用场景分析"><a href="#2-2-BIO、NIO、AIO-适用场景分析" class="headerlink" title="2.2      BIO、NIO、AIO 适用场景分析"></a>2.2      BIO、NIO、AIO 适用场景分析</h2><ol>
<li><p>BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。</p>
</li>
<li><p>NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4 开始支持。</p>
</li>
<li><p>AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作， 编程比较复杂，JDK7 开始支持。</p>
</li>
</ol>
<h2 id="2-3-Java-BIO-基本介绍"><a href="#2-3-Java-BIO-基本介绍" class="headerlink" title="2.3      Java BIO 基本介绍"></a>2.3      Java BIO 基本介绍</h2><ol>
<li><p>Java *<strong>BIO*</strong> 就是传统的 <strong>java io</strong> <strong>编程</strong>，其相关的类和接口在 java.io</p>
</li>
<li><p>BIO(<strong>blocking I&#x2F;O</strong>) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器)。</p>
</li>
<li><p>BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解</p>
</li>
</ol>
<h2 id="2-4-Java-BIO-工作机制"><a href="#2-4-Java-BIO-工作机制" class="headerlink" title="2.4      Java BIO 工作机制                     "></a>2.4      Java BIO 工作机制                     <img src="/img/loading.gif" data-original="file:///C:/Users/DONGIU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></h2><h4 id="对-BIO-编程流程的梳理"><a href="#对-BIO-编程流程的梳理" class="headerlink" title="对 BIO 编程流程的梳理"></a>对 BIO 编程流程的梳理</h4><ol>
<li><p>服务器端启动一个 ServerSocket</p>
</li>
<li><p>客户端启动 Socket 对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯</p>
</li>
<li><p>客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</p>
</li>
<li><p>如果有响应，客户端线程会等待请求结束后，在继续执行</p>
</li>
</ol>
<h2 id="2-5-Java-BIO-应用实例"><a href="#2-5-Java-BIO-应用实例" class="headerlink" title="2.5      Java BIO 应用实例"></a>2.5      Java BIO 应用实例</h2><p>实例说明：</p>
<ol>
<li><p>使用 BIO 模型编写一个服务器端，监听 6666 端口，当有客户端连接时，就启动一个线程与之通讯。</p>
</li>
<li><p>要求使用线程池机制改善，可以连接多个客户端.</p>
</li>
<li><p>服务器端可以接收客户端发送的数据(telnet 方式即可)。</p>
</li>
<li><p>代码演示</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/22 15:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//思路：</span></span><br><span class="line">        <span class="comment">//1. 创建一个线程池</span></span><br><span class="line">        <span class="comment">//2. 如果有客户端连接，就创建一个线程，与之通讯（单独写一个方法）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插件ServerSocker</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到一个客户端&quot;</span>);</span><br><span class="line">            <span class="comment">//创建一个线程，与之通讯（单独写一个方法）</span></span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    handler(accept);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个handler方法，和客户端通讯</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息id：&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;,名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//通过socket 获取输入流</span></span><br><span class="line">            <span class="type">byte</span>[] aByte = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">//循环读取数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> inputStream.read(aByte);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(aByte,<span class="number">0</span>,read));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和client的连接&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221022155235856.png" alt="image-20221022155235856"></p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221022155412156.png" alt="image-20221022155412156"></p>
<h2 id="2-6-Java-BIO-问题分析"><a href="#2-6-Java-BIO-问题分析" class="headerlink" title="2.6      Java BIO 问题分析"></a>2.6      Java BIO 问题分析</h2><ol>
<li><p>每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。</p>
</li>
<li><p>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</p>
</li>
<li><p>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。</p>
</li>
</ol>
<h1 id="第-3-章-Java-NIO-编程"><a href="#第-3-章-Java-NIO-编程" class="headerlink" title="第 3 章 Java NIO 编程"></a>第 3 章 Java NIO 编程</h1><h2 id="3-1-Java-NIO-基本介绍"><a href="#3-1-Java-NIO-基本介绍" class="headerlink" title="3.1      Java NIO 基本介绍"></a>3.1      Java NIO 基本介绍</h2><ol>
<li><p>Java NIO 全称 <strong>java non-blocking IO</strong>，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO(即 New IO)，是同步非阻塞的。</p>
</li>
<li><p>NIO 相关类都被放在 <strong>java.nio</strong> 包及子包下，并且对原 java.io 包中的很多类进行改写。</p>
</li>
<li><p>NIO 有三大核心部分：<strong>Channel(通道</strong>)，<strong>Buffer(缓冲区</strong>), <strong>Selector(选择器)</strong></p>
</li>
<li><p><strong>NIO</strong> <strong>是 面向缓冲区</strong> ，<strong>或者面向 块 编程的</strong>。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络</p>
</li>
<li><p>Java NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入， 这个线程同时可以去做别的事情。</p>
</li>
<li><p>通俗理解：NIO 是可以做到用一个线程来处理多个操作的。假设有 10000 个请求过来,根据实际情况，可以分配50 或者 100 个线程来处理。不像之前的阻塞 IO 那样，非得分配 10000 个。</p>
</li>
<li><p>HTTP2.0 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 HTTP1.1 大了好几个数量级</p>
</li>
<li><p>案例说明 NIO 的 Buffer</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"><span class="keyword">import</span> java.nio.IntBuffer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//举例说明 Buffer 的使用 (简单说明)</span></span><br><span class="line">        <span class="comment">//创建一个 Buffer, 大小为 5, 即可以存放 5 个 int IntBuffer intBuffer = IntBuffer.allocate(5);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//向 buffer 存放数据</span></span><br><span class="line">        <span class="comment">//	intBuffer.put(10);</span></span><br><span class="line">        <span class="comment">//	intBuffer.put(11);</span></span><br><span class="line">        <span class="comment">//	intBuffer.put(12);</span></span><br><span class="line">        <span class="comment">//	intBuffer.put(13);</span></span><br><span class="line">        <span class="comment">//	intBuffer.put(14);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intBuffer.capacity(); i++) &#123; </span><br><span class="line">            intBuffer.put( i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何从 buffer 读取数据</span></span><br><span class="line">        <span class="comment">//将 buffer 转换，读写切换(!!!) intBuffer.flip();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (intBuffer.hasRemaining()) &#123; 									System.out.println(intBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-NIO-和-BIO-的比较"><a href="#3-2-NIO-和-BIO-的比较" class="headerlink" title="3.2      NIO 和 BIO 的比较"></a>3.2      NIO 和 BIO 的比较</h2><ol>
<li><p>BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I&#x2F;O 的效率比流 I&#x2F;O 高很多</p>
</li>
<li><p>BIO 是阻塞的，NIO 则是非阻塞的</p>
</li>
<li><p>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求， 数据到达等），因此使用单个线程就可以监听多个客户端通道。</p>
</li>
</ol>
<h2 id="3-3-NIO-三大核心原理示意图"><a href="#3-3-NIO-三大核心原理示意图" class="headerlink" title="3.3      NIO 三大核心原理示意图"></a>3.3      NIO 三大核心原理示意图</h2><p>一张图描述 NIO 的 Selector 、 Channel 和 Buffer 的关系</p>
<h3 id="3-3-1-Selector-、-Channel-和-Buffer-的关系图-简单版"><a href="#3-3-1-Selector-、-Channel-和-Buffer-的关系图-简单版" class="headerlink" title="3.3.1 Selector 、 Channel 和 Buffer 的关系图(简单版)"></a>3.3.1 Selector 、 Channel 和 Buffer 的关系图(简单版)</h3><p>关系图的说明:</p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image026.jpg" alt="img"></p>
<ol>
<li><p>每个 channel 都会对应一个 Buffer</p>
</li>
<li><p>Selector 对应一个线程， 一个线程对应多个 channel(连接)</p>
</li>
<li><p>该图反应了有三个 channel 注册到 该 selector &#x2F;&#x2F;程序</p>
</li>
<li><p>程序切换到哪个 channel 是有事件决定的, Event 就是一个重要的概念</p>
</li>
<li><p>Selector 会根据不同的事件，在各个通道上切换</p>
</li>
<li><p>Buffer 就是一个内存块 ， 底层是有一个数组</p>
</li>
<li><p>数据的读取写入是通过 Buffer, 这个和 BIO , BIO 中要么是输入流，或者是输出流, 不能双向，但是 NIO 的 Buffer 是可以读也可以写, 需要 flip 方法切换，channel 是双向的, 可以返回底层操作系统的情况, 比如 Linux ， 底层的操作系统通道就是双向的。</p>
</li>
</ol>
<h2 id="3-4-缓冲区-Buffer"><a href="#3-4-缓冲区-Buffer" class="headerlink" title="3.4      缓冲区(Buffer)"></a>3.4      缓冲区(Buffer)</h2><h3 id="3-4-1-基本介绍"><a href="#3-4-1-基本介绍" class="headerlink" title="3.4.1 基本介绍"></a>3.4.1 基本介绍</h3><p>缓冲区（Buffer）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个**容器对象(含数组)**，该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer，如图:    </p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221023120615713.png" alt="image-20221023120615713"></p>
<h3 id="3-4-2-Buffer-类及其子类"><a href="#3-4-2-Buffer-类及其子类" class="headerlink" title="3.4.2 Buffer 类及其子类"></a>3.4.2 Buffer 类及其子类</h3><ol>
<li>在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类, 类的层级关系图:</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221023120811236.png" alt="image-20221023120811236"></p>
<ol start="2">
<li>Buffer 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息:</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221023120828836.png" alt="image-20221023120828836"></p>
<ol start="3">
<li>Buffer 类相关方法一览</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    <span class="comment">//JDK1.4时，引入的api</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">( )</span><span class="comment">//返回此缓冲区的容量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">position</span><span class="params">( )</span><span class="comment">//返回此缓冲区的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">position</span> <span class="params">(<span class="type">int</span> newPositio)</span><span class="comment">//设置此缓冲区的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">limit</span><span class="params">( )</span><span class="comment">//返回此缓冲区的限制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">limit</span> <span class="params">(<span class="type">int</span> newLimit)</span><span class="comment">//设置此缓冲区的限制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">mark</span><span class="params">( )</span><span class="comment">//在此缓冲区的位置设置标记</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">reset</span><span class="params">( )</span><span class="comment">//将此缓冲区的位置重置为以前标记的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">clear</span><span class="params">( )</span><span class="comment">//清除此缓冲区, 即将各个标记恢复到初始状态，但是数据并没有真正擦除, 后面操作会覆盖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">( )</span><span class="comment">//反转此缓冲区</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">rewind</span><span class="params">( )</span><span class="comment">//重绕此缓冲区</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">remaining</span><span class="params">( )</span><span class="comment">//返回当前位置与限制之间的元素数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasRemaining</span><span class="params">( )</span><span class="comment">//告知在当前位置和限制之间是否有元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">( )</span>;<span class="comment">//告知此缓冲区是否为只读缓冲区</span></span><br><span class="line">    <span class="comment">//JDK1.6时引入的api</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">hasArray</span><span class="params">()</span>;<span class="comment">//告知此缓冲区是否具有可访问的底层实现数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title function_">array</span><span class="params">()</span>;<span class="comment">//返回此缓冲区的底层实现数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">arrayOffset</span><span class="params">()</span>;<span class="comment">//返回此缓冲区的底层实现数组中第一个缓冲区元素的偏移量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isDirect</span><span class="params">()</span>;<span class="comment">//告知此缓冲区是否为直接缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-3-ByteBuffer"><a href="#3-4-3-ByteBuffer" class="headerlink" title="3.4.3 ByteBuffer"></a>3.4.3 ByteBuffer</h3><p>从前面可以看出对于 Java 中的基本数据类型(boolean 除外)，都有一个 Buffer 类型与之相对应，最常用的自然是 ByteBuffer 类（二进制数据)，该类的主要方法如下：</p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221023120930058.png" alt="image-20221023120930058"></p>
<h2 id="3-5-通道-Channel"><a href="#3-5-通道-Channel" class="headerlink" title="3.5      通道(Channel)"></a>3.5      通道(Channel)</h2><h3 id="3-5-1基本介绍"><a href="#3-5-1基本介绍" class="headerlink" title="3.5.1	基本介绍"></a>3.5.1	基本介绍</h3><ol>
<li><p>NIO 的通道类似于流，但有些区别如下：</p>
<ul>
<li><p>通道可以同时进行读写，而流只能读或者只能写</p>
</li>
<li><p>通道可以实现异步读写数据</p>
</li>
<li><p>通道可以从缓冲读数据，也可以写数据到缓冲</p>
</li>
</ul>
</li>
<li><p>BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel) 是双向的，可以读操作，也可以写操作。</p>
</li>
<li><p>Channel 在 NIO 中是一个接口<code>public interface Channel extends Closeable&#123;&#125;</code></p>
</li>
<li><p>常 用 的  Channel  类 有 ： <strong>FileChannel</strong> 、 DatagramChannel 、 <strong>ServerSocketChannel</strong>  和 <strong>SocketChannel</strong> 。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</p>
</li>
<li><p>FileChannel 用于文件的数据读写， DatagramChannel 用于 UDP 的数据读写， ServerSocketChannel 和SocketChannel 用于 TCP 的数据读写。</p>
</li>
<li><p>图示</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image035.jpg" alt="img"></td>
</tr>
</tbody></table>
<h3 id="3-5-2-FileChannel-类"><a href="#3-5-2-FileChannel-类" class="headerlink" title="3.5.2 FileChannel 类"></a>3.5.2 FileChannel 类</h3><p>FileChannel 主要用来对本地文件进行 IO 操作，常见的方法有</p>
<ul>
<li>public int read(ByteBuffer dst) ，从通道读取数据并放到缓冲区中</li>
<li>public int write(ByteBuffer src) ，把缓冲区的数据写到通道中</li>
<li>public long transferFrom(ReadableByteChannel src, long position, long count)，从目标通道中复制数据到当前通道</li>
<li>public long transferTo(long position, long count, WritableByteChannel target)，把数据从当前通道复制给目标通道</li>
</ul>
<h3 id="3-5-3-应用实例-1-本地文件写数据"><a href="#3-5-3-应用实例-1-本地文件写数据" class="headerlink" title="3.5.3 应用实例 1-本地文件写数据"></a>3.5.3 应用实例 1-本地文件写数据</h3><p>实例要求:</p>
<ol>
<li><p>使用前面学习后的 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 “hello,尚硅谷” 写入到 file01.txt 中</p>
</li>
<li><p>文件不存在就创建</p>
</li>
<li><p>代码演示</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream; <span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello,尚硅谷&quot;</span>;</span><br><span class="line">        <span class="comment">//创建一个输出流-&gt;channel</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\file01.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过 fileOutputStream  获取 对应的 FileChannel</span></span><br><span class="line">        <span class="comment">//这个 fileChannel 真实 类型是	FileChannelImpl </span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个缓冲区 ByteBuffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 str 放 入 byteBuffer </span></span><br><span class="line">        byteBuffer.put(str.getBytes());</span><br><span class="line">        <span class="comment">//对 byteBuffer 进行 flip </span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 byteBuffer 数据写入到 fileChannel 	</span></span><br><span class="line">        fileChannel.write(byteBuffer); </span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code> byteBuffer.flip();</code>将position的值赋给limit，然后从0开始读</p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221023145444226.png" alt="image-20221023145444226"></p>
<h3 id="3-5-4-应用实例-2-本地文件读数据"><a href="#3-5-4-应用实例-2-本地文件读数据" class="headerlink" title="3.5.4 应用实例 2-本地文件读数据"></a>3.5.4 应用实例 2-本地文件读数据</h3><p>实例要求:</p>
<ol>
<li><p>使用前面学习后的 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 file01.txt 中的数据读入到程序，并显示在控制台屏幕</p>
</li>
<li><p>假定文件已经存在</p>
</li>
<li><p>代码演示</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream; <span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\file01.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过 fileInputStream  获取对应的 FileChannel -&gt; 实际类型FileChannelImpl </span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>) file.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 通道的数据读入到 Buffer </span></span><br><span class="line">        fileChannel.read(byteBuffer);</span><br><span class="line">        <span class="comment">// 将 byteBuffer 的 字 节 数 据 转 成 String </span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array())); </span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-5-应用实例-3-使用一个Buffer-完成文件读取、写入"><a href="#3-5-5-应用实例-3-使用一个Buffer-完成文件读取、写入" class="headerlink" title="3.5.5 应用实例 3-使用一个Buffer 完成文件读取、写入"></a>3.5.5 应用实例 3-使用一个Buffer 完成文件读取、写入</h3><p>实例要求:</p>
<ol>
<li><p>使用 FileChannel(通道) 和 方法 read , write，完成文件的拷贝</p>
</li>
<li><p>拷贝一个文本文件 1.txt  , 放在项目下即可</p>
</li>
<li><p>代码演示</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221023121853120.png" alt="image-20221023121853120"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream; <span class="keyword">import</span> java.io.FileOutputStream; <span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;1.txt&quot;</span>); </span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel01</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;2.txt&quot;</span>); </span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel02</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//循环读取</span></span><br><span class="line">            <span class="comment">//这里有一个重要的操作，一定不要忘了</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public final Buffer clear() &#123; </span></span><br><span class="line"><span class="comment">            position = 0;</span></span><br><span class="line"><span class="comment">            limit = capacity; </span></span><br><span class="line"><span class="comment">            mark = -1; </span></span><br><span class="line"><span class="comment">            return this;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            byteBuffer.clear(); <span class="comment">//清空 buffer</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fileChannel01.read(byteBuffer); </span><br><span class="line">            System.out.println(<span class="string">&quot;read =&quot;</span> + read); </span><br><span class="line">            <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123; <span class="comment">//表示读完</span></span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将 buffer 中的数据写入到 fileChannel02 -- 2.txt </span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            fileChannel02.write(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭相关的流</span></span><br><span class="line">        fileInputStream.close(); </span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-5-6-应用实例-4-拷贝文件transferFrom-方法"><a href="#3-5-6-应用实例-4-拷贝文件transferFrom-方法" class="headerlink" title="3.5.6 应用实例 4-拷贝文件transferFrom 方法"></a>3.5.6 应用实例 4-拷贝文件transferFrom 方法</h3><ol>
<li><p>实例要求:</p>
</li>
<li><p>使用 FileChannel(通道) 和 方法 transferFrom ，完成文件的拷贝</p>
</li>
<li><p>拷贝一张图片</p>
</li>
<li><p>代码演示</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream; <span class="keyword">import</span> java.io.FileOutputStream; <span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>	<span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建相关流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\a.jpg&quot;</span>); </span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\a2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取各个流对应的 filechannel</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">sourceCh</span> <span class="operator">=</span> fileInputStream.getChannel(); </span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">destCh</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 transferForm 完成拷贝</span></span><br><span class="line">        destCh.transferFrom(sourceCh,<span class="number">0</span>,sourceCh.size());</span><br><span class="line">        <span class="comment">//关闭相关通道和流</span></span><br><span class="line">        sourceCh.close(); </span><br><span class="line">        destCh.close(); </span><br><span class="line">        fileInputStream.close(); </span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-5-7-关于Buffer-和-Channel-的注意事项和细节"><a href="#3-5-7-关于Buffer-和-Channel-的注意事项和细节" class="headerlink" title="3.5.7 关于Buffer 和 Channel 的注意事项和细节"></a>3.5.7 关于Buffer 和 Channel 的注意事项和细节</h3><ol>
<li>ByteBuffer 支持类型化的 put 和 get, put 放入的是什么数据类型，get 就应该使用相应的数据类型来取出，否则可能有 BufferUnderflowException 异常。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOByteBufferPutGet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个 Buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类型化方式放入数据</span></span><br><span class="line">        buffer.putInt(<span class="number">100</span>); buffer.putLong(<span class="number">9</span>);</span><br><span class="line">        buffer.putChar(<span class="string">&#x27; 尚 &#x27;</span>); buffer.putShort((<span class="type">short</span>) <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//取出buffer.flip();</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(buffer.getInt()); </span><br><span class="line">        System.out.println(buffer.getLong()); </span><br><span class="line">        System.out.println(buffer.getChar()); </span><br><span class="line">        System.out.println(buffer.getShort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可以将一个普通 Buffer 转成只读 Buffer</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadOnlyBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个 buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123; </span><br><span class="line">            buffer.put((<span class="type">byte</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取buffer.flip();</span></span><br><span class="line">        <span class="comment">//得到一个只读的 Buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">readOnlyBuffer</span> <span class="operator">=</span> buffer.asReadOnlyBuffer(); </span><br><span class="line">        System.out.println(readOnlyBuffer.getClass());</span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="keyword">while</span> (readOnlyBuffer.hasRemaining()) &#123; </span><br><span class="line">            System.out.println(readOnlyBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        readOnlyBuffer.put((<span class="type">byte</span>)<span class="number">100</span>); <span class="comment">//ReadOnlyBufferException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进行修改， 而如何同步到文件由 NIO 来完成。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile; </span><br><span class="line"><span class="keyword">import</span> java.nio.MappedByteBuffer; </span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 说明</span></span><br><span class="line"><span class="comment">* 1. MappedByteBuffer 可让文件直接在内存(堆外内存)修改,  操作系统不需要拷贝* 一次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MappedByteBufferTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对应的通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> randomAccessFile.getChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *	参数 1: FileChannel.MapMode.READ_WRITE 使用的读写模式</span></span><br><span class="line"><span class="comment">        *	参数 2： 0 ： 可以直接修改的起始位置</span></span><br><span class="line"><span class="comment">        *	参数 3:	5: 是映射到内存的大小(不是索引位置) ,即将 1.txt 的多少个字节映射到内存</span></span><br><span class="line"><span class="comment">        *	可以直接修改的范围就是 0-5</span></span><br><span class="line"><span class="comment">        *	实际类型 DirectByteBuffer</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">MappedByteBuffer</span> <span class="variable">mappedByteBuffer</span> <span class="operator">=</span> channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        mappedByteBuffer.put(<span class="number">0</span>, (<span class="type">byte</span>) <span class="string">&#x27;H&#x27;</span>); </span><br><span class="line">        mappedByteBuffer.put(<span class="number">3</span>, (<span class="type">byte</span>) <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">        <span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line">        mappedByteBuffer.put(<span class="number">5</span>, (<span class="type">byte</span>) <span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">       </span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>4. 前面我们讲的读写操作，都是通过一个 Buffer 完成的，NIO 还支持 通过多个 Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering 。
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress; <span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel; <span class="keyword">import</span> java.nio.channels.SocketChannel; <span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入	[分散]</span></span><br><span class="line"><span class="comment">*	Gathering: 从 buffer 读取数据时，可以采用 buffer 数组，依次读[聚集]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScatteringAndGatheringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 ServerSocketChannel  和 SocketChannel 网络</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open(); </span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">7000</span>);</span><br><span class="line">        <span class="comment">//绑定端口到 socket ，并启动</span></span><br><span class="line">        serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line">        <span class="comment">//创建 buffer 数组</span></span><br><span class="line">        ByteBuffer[] byteBuffers = <span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[<span class="number">2</span>];</span><br><span class="line">        byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>); </span><br><span class="line">        byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//等客户端连接(telnet)</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">        <span class="type">int</span> <span class="variable">messageLength</span> <span class="operator">=</span> <span class="number">8</span>;	<span class="comment">//假定从客户端接收 8 个字节</span></span><br><span class="line">        <span class="comment">//循环的读取</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">byteRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (byteRead &lt; messageLength ) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> socketChannel.read(byteBuffers); </span><br><span class="line">                    byteRead += l; <span class="comment">//累计读取的字节数</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;byteRead=&quot;</span> + byteRead);</span><br><span class="line">                <span class="comment">// 使 用 流 打 印 , 看 看 当 前 的 这 个 buffer 的 position 和 limit </span></span><br><span class="line">                    Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="string">&quot;postion=&quot;</span> + buffer.position() + <span class="string">&quot;, limit=&quot;</span> +</span><br><span class="line">                buffer.limit()).forEach(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 所 有 的 buffer 进 行 flip </span></span><br><span class="line">                Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());</span><br><span class="line">            <span class="comment">//将数据读出显示到客户端</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">byteWirte</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (byteWirte &lt; messageLength) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> socketChannel.write(byteBuffers); <span class="comment">// byteWirte += l;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将所有的 buffer 进行 clear</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer-&gt; &#123; </span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;byteRead:=&quot;</span> + byteRead + <span class="string">&quot; byteWrite=&quot;</span> + byteWirte + <span class="string">&quot;, messagelength&quot;</span> + messageLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-7-Selector-选择器"><a href="#3-7-Selector-选择器" class="headerlink" title="3.7    Selector(选择器)"></a>3.7    Selector(选择器)</h2><h3 id="3-7-1-基本介绍"><a href="#3-7-1-基本介绍" class="headerlink" title="3.7.1 基本介绍"></a>3.7.1 基本介绍</h3><ol>
<li><p>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到 Selector(选择器)</p>
</li>
<li><p>Selector 能够检测多个注册的通道上是否有事件发生(注意:多个 Channel 以事件的方式可以注册到同一个Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</p>
</li>
<li><p>只有在 连接&#x2F;通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</p>
</li>
<li><p>避免了多线程之间的上下文切换导致的开销</p>
</li>
</ol>
<h3 id="3-7-2Selector-示意图和特点说明"><a href="#3-7-2Selector-示意图和特点说明" class="headerlink" title="3.7.2	Selector 示意图和特点说明"></a>3.7.2	Selector 示意图和特点说明</h3><p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221023171551026.png" alt="image-20221023171551026"></p>
<p>说明如下：</p>
<ol>
<li><p>Netty 的 IO 线程 NioEventLoop 聚合了 Selector(选择器，也叫多路复用器)，可以同时并发处理成百上千个客户端连接。</p>
</li>
<li><p>当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</p>
</li>
<li><p>线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。</p>
</li>
<li><p>由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 I&#x2F;O 阻塞导致的线程挂起。</p>
</li>
<li><p>一个 I&#x2F;O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I&#x2F;O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p>
</li>
</ol>
<h3 id="3-7-3-Selector-类相关方法"><a href="#3-7-3-Selector-类相关方法" class="headerlink" title="3.7.3   Selector 类相关方法"></a>3.7.3   Selector 类相关方法</h3><p>Selector 类是一个抽象类, 常用方法和说明如下:</p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221023171639122.png" alt="image-20221023171639122"></p>
<h3 id="3-7-4-注意事项"><a href="#3-7-4-注意事项" class="headerlink" title="3.7.4 注意事项"></a>3.7.4 注意事项</h3><ol>
<li><p>NIO 中的 ServerSocketChannel 功能类似 ServerSocket，SocketChannel 功能类似 Socket</p>
</li>
<li><p>selector 相关方法说明</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selector.select()<span class="comment">//阻塞</span></span><br><span class="line"></span><br><span class="line">selector.select(<span class="number">1000</span>);<span class="comment">//阻塞 1000 毫秒，在 1000 毫秒后返回</span></span><br><span class="line"></span><br><span class="line">selector.wakeup();<span class="comment">//唤醒 selector</span></span><br><span class="line"></span><br><span class="line">selector.selectNow();<span class="comment">//不阻塞，立马返还</span></span><br></pre></td></tr></table></figure>

<h2 id="3-8-NIO-非阻塞-网络编程原理分析图"><a href="#3-8-NIO-非阻塞-网络编程原理分析图" class="headerlink" title="3.8    NIO 非阻塞 网络编程原理分析图"></a>3.8    NIO 非阻塞 网络编程原理分析图</h2><p>NIO 非阻塞 网络编程相关的(Selector、SelectionKey、ServerScoketChannel 和 SocketChannel) 关系梳理图</p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221023171735105.png" alt="image-20221023171735105"></p>
<p>对上图的说明:</p>
<ol>
<li><p>当客户端连接时，会通过 ServerSocketChannel 得到 SocketChannel</p>
</li>
<li><p>Selector 进行监听 select 方法, 返回有事件发生的通道的个数.</p>
</li>
<li><p>通过 <code>register(Selector sel, int ops)</code>将 socketChannel 注册到 Selector 上, 一个 selector 上可以注册多个 SocketChannel</p>
</li>
<li><p>注册后返回一个 SelectionKey, 会和该 Selector 关联(集合)</p>
</li>
<li><p>进一步得到各个 SelectionKey (有事件发生)</p>
</li>
<li><p>在通过 SelectionKey  反向获取 SocketChannel , 方法 channel()</p>
</li>
<li><p>可以通过 得到的 channel  , 完成业务处理</p>
</li>
</ol>
<h2 id="3-9-NIO-非阻塞-网络编程快速入门"><a href="#3-9-NIO-非阻塞-网络编程快速入门" class="headerlink" title="3.9    NIO 非阻塞 网络编程快速入门"></a>3.9    NIO 非阻塞 网络编程快速入门</h2><p>案例要求:</p>
<ol>
<li><p>编写一个 NIO 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</p>
</li>
<li><p>目的：理解 NIO 非阻塞网络编程机制</p>
</li>
<li><p>代码演示</p>
</li>
</ol>
<p>NIOServer（服务端）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/24 20:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建serverSocketChannel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//得到一个Select对象</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">//绑定一个端口6666，在服务端监听</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//把serverSocketChannel 注册到 selector ，关心事件为OP_ACCEPT</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">//循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//这里等待1秒，如果没有事件发生，返回</span></span><br><span class="line">            <span class="keyword">if</span> (selector.select(<span class="number">1000</span>) == <span class="number">0</span>)&#123; <span class="comment">//没有事件发生</span></span><br><span class="line">                System.out.println(<span class="string">&quot;服务器等待了1秒。无连接&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果返回的值&gt;0,就获取到相关的selectionKey集合</span></span><br><span class="line">            <span class="comment">//1. 如果返回的值&gt;0,表示已经获取到关注的事件</span></span><br><span class="line">            <span class="comment">//2. selector.selectedKeys() 返回关注事件的集合</span></span><br><span class="line">            <span class="comment">//3. 通过selectionKeys反向获取通道</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//遍历selectionKeys,使用迭代器遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                <span class="comment">//获取到selectionKey</span></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">//根据key 对应的通道发生的事件做相应的处理</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123; <span class="comment">//如果是 OP_ACCEPT (表示有一个新的客户端连接)</span></span><br><span class="line">                    <span class="comment">//该客户端生成一个SocketChannel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    <span class="comment">//将socketChannel设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接成功,生成了一个socketChannel:&quot;</span> + socketChannel.hashCode());</span><br><span class="line">                    <span class="comment">//将 socketChannel 注册到selector,关注事件为OP_READ,同时关联一个buffer(缓冲区),服务器端的buffer</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (key.isReadable())&#123; <span class="comment">//发生OP_READ事件</span></span><br><span class="line">                    <span class="comment">//通过selectionKey 反向获取到对应的channel(通道)</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">//获取到该channel关联的buffer</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="comment">//将数据读取到buffer中</span></span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端发送的信息:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//手动移除当前的selectionKey,防止重复操作</span></span><br><span class="line">                selectionKeys.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NIOClient（客户端）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/24 20:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的IP和端口</span></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">socketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span> (!socketChannel.connect(socketAddress))&#123;</span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;因为连接需要时间,客户端不会阻塞,可以做其他工作...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接成功,就发送数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello,尚硅谷&quot;</span>;</span><br><span class="line">        <span class="comment">//wrap 指定buffer的大小为发送数据的大小</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(str.getBytes());</span><br><span class="line">        <span class="comment">//发送数据,将buffer数据写入channel</span></span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221024210936091.png" alt="image-20221024210936091"></p>
<h2 id="3-10-SelectionKey"><a href="#3-10-SelectionKey" class="headerlink" title="3.10  SelectionKey"></a>3.10  SelectionKey</h2><p>其中SelectionKey表示当前发生事件的key</p>
<p>keys表示所有注册的key</p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221024212254265.png" alt="image-20221024212254265"></p>
<ol>
<li><p>SelectionKey，表示 <strong>Selector</strong> <strong>和网络通道的注册关系</strong>, 共四种:</p>
<ul>
<li><p>int OP_ACCEPT：有新的网络连接可以 accept，值为 16 </p>
</li>
<li><p>int OP_CONNECT：代表连接已经建立，值为 8</p>
</li>
<li><p>int OP_READ：代表读操作，值为 1</p>
</li>
<li><p>int OP_WRITE：代表写操作，值为 4</p>
</li>
</ul>
</li>
</ol>
<p>源码中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_ACCEPT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>SelectionKey 相关方法</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221023172100987.png" alt="image-20221023172100987"></p>
<h2 id="3-11-ServerSocketChannel"><a href="#3-11-ServerSocketChannel" class="headerlink" title="3.11  ServerSocketChannel"></a>3.11  ServerSocketChannel</h2><ol>
<li><p>ServerSocketChannel 在服务器端监听新的客户端 Socket 连接</p>
</li>
<li><p>相关方法如下</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221023172136796.png" alt="image-20221023172136796"></p>
<h2 id="3-12-SocketChannel"><a href="#3-12-SocketChannel" class="headerlink" title="3.12  SocketChannel"></a>3.12  SocketChannel</h2><ol>
<li><p>SocketChannel，网络 IO 通道，具体负责进行读写操作。NIO 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</p>
</li>
<li><p>相关方法如下</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221023172201508.png" alt="image-20221023172201508"></p>
<h2 id="3-13-NIO-网络编程应用实例-群聊系统"><a href="#3-13-NIO-网络编程应用实例-群聊系统" class="headerlink" title="3.13  NIO 网络编程应用实例-群聊系统"></a>3.13  NIO 网络编程应用实例-群聊系统</h2><p>实例要求:</p>
<ol>
<li><p>编写一个 NIO 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</p>
</li>
<li><p>实现多人群聊</p>
</li>
<li><p>服务器端：可以监测用户上线，离线，并实现消息转发功能</p>
</li>
<li><p>客户端：通过 channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(有服务器转发得到)</p>
</li>
<li><p>目的：进一步理解 NIO 非阻塞网络编程机制</p>
</li>
<li><p>示意图分析和代码</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image066.jpg" alt="img"></p>
<p> <strong>代码</strong></p>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.nio.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/25 20:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器 初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//ServerSocketChannel</span></span><br><span class="line">            listenChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));</span><br><span class="line">            <span class="comment">//设置为非阻塞</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//将该 listenChannel 注册到selector</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                <span class="comment">//有事件处理</span></span><br><span class="line">                <span class="keyword">if</span> (select &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//遍历得到SelectionKey集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        <span class="comment">//监听到Accept</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> listenChannel.accept();</span><br><span class="line">                            socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            <span class="comment">//注册到selector</span></span><br><span class="line">                            socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                            <span class="comment">//提示</span></span><br><span class="line">                            System.out.println(socketChannel.getRemoteAddress() + <span class="string">&quot;上线&quot;</span> );</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//通道发送read事件，即通道是可读的状态</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//当前的key进行移除，防止重复操作</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readData</span><span class="params">(SelectionKey key)</span>&#123;</span><br><span class="line">        <span class="comment">//定义一个SocketChannel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建buffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">//读取到buffer</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">            <span class="comment">//根据read的值做处理</span></span><br><span class="line">            <span class="keyword">if</span> (read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//把缓冲区的数据转为字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端发送的消息：&quot;</span> + s);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//向其他客户端转发消息(去掉自己)</span></span><br><span class="line">                sendInfoToOtherClients(s,channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot;离线。。。&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给其他客户（通道）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInfoToOtherClients</span><span class="params">(String msg,SocketChannel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中。。。&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历所有注册到selector上的socketChannel</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys())&#123;</span><br><span class="line">            <span class="comment">//通过key获取对应的socketChannel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> key.channel();</span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span> (targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != channel)&#123;</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) targetChannel;</span><br><span class="line">                <span class="comment">//将msg存储到buffer中</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将buffer的数据写入通道</span></span><br><span class="line">                socketChannel.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        <span class="type">GroupChatServer</span> <span class="variable">groupChatServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.nio.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectableChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/25 20:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClient</span> &#123;</span><br><span class="line">    <span class="comment">//定义相关属性 服务器ip 服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(HOST,PORT));</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//将channel 注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString();</span><br><span class="line">        System.out.println(username + <span class="string">&quot;is ok ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInfo</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        msg = username + <span class="string">&quot; 说：&quot;</span> + msg;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(msg.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取服务端转发的消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> selector.select(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">//有发生事件的通道</span></span><br><span class="line">            <span class="keyword">if</span> (select &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                    <span class="comment">//获取key</span></span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    <span class="comment">//可以读取的通道</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                        <span class="comment">//得到通道</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">//创建buffer</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取数据到buffer</span></span><br><span class="line">                        channel.read(buffer);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                        System.out.println(s);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//输出当前的SelectionKey，防止重复操作</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*System.out.println(&quot;没有可用的通道。。。&quot;);*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//启动客户端</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">GroupChatClient</span> <span class="variable">groupChatClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatClient</span>();</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="comment">//读取数据</span></span><br><span class="line">                    groupChatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">//发送数据给服务器</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            groupChatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221025223251654.png" alt="image-20221025223251654"></p>
<h2 id="3-14-NIO-与零拷贝"><a href="#3-14-NIO-与零拷贝" class="headerlink" title="3.14  NIO 与零拷贝"></a>3.14  NIO 与零拷贝</h2><h3 id="3-14-1-零拷贝基本介绍"><a href="#3-14-1-零拷贝基本介绍" class="headerlink" title="3.14.1   零拷贝基本介绍"></a>3.14.1   零拷贝基本介绍</h3><ol>
<li><p>零拷贝是网络编程的关键，很多性能优化都离不开。</p>
</li>
<li><p>在 Java 程序中，常用的零拷贝有 mmap(内存映射) 和 sendFile。那么，他们在 OS 里，到底是怎么样的一个的设计？我们分析 mmap 和 sendFile 这两个零拷贝</p>
</li>
<li><p>另外我们看下 NIO 中如何使用零拷贝</p>
</li>
</ol>
<h3 id="3-14-2-传统IO-数据读写"><a href="#3-14-2-传统IO-数据读写" class="headerlink" title="3.14.2   传统IO 数据读写"></a>3.14.2   传统IO 数据读写</h3><p>Java 传统 IO 和 网络编程的一段代码</p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221024222506791.png" alt="image-20221024222506791"></p>
<h3 id="3-14-3传统IO-模型"><a href="#3-14-3传统IO-模型" class="headerlink" title="3.14.3	传统IO 模型"></a>3.14.3	传统IO 模型</h3><p>DMA: direct  memory access 直接内存拷贝(不使用 CPU)</p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221024222537370.png" alt="image-20221024222537370"></p>
<h3 id="3-14-4-mmap-优化"><a href="#3-14-4-mmap-优化" class="headerlink" title="3.14.4   mmap 优化"></a>3.14.4   mmap 优化</h3><ol>
<li><p>mmap 通过内存映射，将<strong>文件映射到内核缓冲区</strong>，同时，<strong>用户空间可以共享内核空间的数据</strong>。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</p>
</li>
<li><p>mmap 示意图</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image073.jpg" alt="img"></p>
<h3 id="3-14-5-sendFile-优化"><a href="#3-14-5-sendFile-优化" class="headerlink" title="3.14.5   sendFile 优化"></a>3.14.5   sendFile 优化</h3><ol>
<li><p>Linux 2.1 版本 提供了 sendFile 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换</p>
</li>
<li><p>示意图和小结</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image075.jpg" alt="img"></p>
<ol start="3">
<li><p>提示：<strong>零拷贝是从操作系统角度，没有 cpu 拷贝</strong></p>
</li>
<li><p>Linux 在 2.4 版本中，做了一些修改，避免了从<strong>内核缓冲区</strong>拷贝到 <strong>Socket buffer</strong> 的操作，直接拷贝到协议栈， 从而再一次减少了数据拷贝。具体如下图和小结：</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image077.jpg" alt="img"></p>
<ol start="5">
<li>这里其实有 一次 cpu 拷贝 kernel buffer -&gt; socket buffer 。但是，拷贝的信息很少，比如 lenght , offset , 消耗低，可以忽略</li>
</ol>
<h3 id="3-14-6-零拷贝的再次理解"><a href="#3-14-6-零拷贝的再次理解" class="headerlink" title="3.14.6     零拷贝的再次理解"></a>3.14.6     零拷贝的再次理解</h3><ol>
<li><p>我们说零拷贝，是从<strong>操作系统的角度</strong>来说的。因为内核缓冲区之间，没有数据是重复的（只有 kernel buffer 有一份数据）。</p>
</li>
<li><p>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 CPU 缓存伪共享以及无 CPU 校验和计算。</p>
</li>
</ol>
<h3 id="3-14-7-mmap-和-sendFile-的区别"><a href="#3-14-7-mmap-和-sendFile-的区别" class="headerlink" title="3.14.7     mmap 和 sendFile 的区别"></a>3.14.7     mmap 和 sendFile 的区别</h3><ol>
<li><p>mmap 适合小数据量读写，sendFile 适合大文件传输。</p>
</li>
<li><p>mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要 3 次上下文切换，最少 2 次数据拷贝。</p>
</li>
<li><p>sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝到 Socket 缓冲区）。</p>
</li>
</ol>
<h3 id="3-14-8-NIO-零拷贝案例"><a href="#3-14-8-NIO-零拷贝案例" class="headerlink" title="3.14.8   NIO 零拷贝案例"></a>3.14.8   NIO 零拷贝案例</h3><p>案例要求：</p>
<ol>
<li><p>使用传统的 IO 方法传递一个大文件</p>
</li>
<li><p>使用 NIO 零拷贝方式传递(transferTo)一个大文件</p>
</li>
<li><p>看看两种传递方式耗时时间分别是多少</p>
</li>
</ol>
<p>零拷贝方式</p>
<p>NewIOServer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">7001</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> serverSocketChannel.socket();</span><br><span class="line"></span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">readcount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != readcount) &#123; </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    readcount = socketChannel.read(byteBuffer);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    <span class="comment">// ex.printStackTrace(); break;</span></span><br><span class="line">                &#125;</span><br><span class="line">                byteBuffer.rewind(); <span class="comment">//倒带 position = 0 mark 作废</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                         </span><br></pre></td></tr></table></figure>

<p> NewIOClient.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open(); </span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>)); </span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;protoc-3.6.1-win32.zip&quot;</span>;</span><br><span class="line">        <span class="comment">//得到一个文件 channel</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">FileInputStream</span>(filename).getChannel();</span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//在 linux 下一个 transferTo 方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//在 windows 下 一次调用 transferTo 只能发送 8m , 就需要分段传输文件, 而且要主要</span></span><br><span class="line">        <span class="comment">//传输时的位置 =》 课后思考...</span></span><br><span class="line">        <span class="comment">//transferTo 底层使用到零拷贝</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">transferCount</span> <span class="operator">=</span> fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line">        System.out.println(<span class="string">&quot; 发送的总的字节数	=&quot;</span> + transferCount + <span class="string">&quot; 耗 时 :&quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        <span class="comment">//关闭fileChannel.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-15-Java-AIO-基本介绍"><a href="#3-15-Java-AIO-基本介绍" class="headerlink" title="3.15  Java AIO 基本介绍"></a>3.15  Java AIO 基本介绍</h2><ol>
<li><p>JDK 7 引入了 Asynchronous I&#x2F;O，即 AIO。在进行 I&#x2F;O 编程中，常用到两种模式：Reactor 和 Proactor。Java 的NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理</p>
</li>
<li><p>AIO 即 NIO2.0，叫做异步不阻塞的 IO。AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写， 有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</p>
</li>
<li><p>目前 AIO 还没有广泛应用，Netty 也是基于 NIO, 而不是 AIO， 因此我们就不详解AIO 了，有兴趣的同学可以 参 考 &lt;&lt;Java 新 一 代 网 络 编 程 模 型 AIO 原 理 及 Linux 系 统 AIO 介 绍 &gt;&gt;<a target="_blank" rel="noopener" href="http://www.52im.net/thread-306-1-1.html"> http://www.52im.net/thread-306-1-1.html</a></p>
</li>
</ol>
<h2 id="3-16-BIO、NIO、AIO-对比表"><a href="#3-16-BIO、NIO、AIO-对比表" class="headerlink" title="3.16  BIO、NIO、AIO 对比表"></a>3.16  BIO、NIO、AIO 对比表</h2><p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221024222901203.png" alt="image-20221024222901203"></p>
<h1 id="第-4-章-Netty-概述"><a href="#第-4-章-Netty-概述" class="headerlink" title="第 4 章 Netty 概述"></a>第 4 章 Netty 概述</h1><h2 id="4-1原生-NIO-存在的问题"><a href="#4-1原生-NIO-存在的问题" class="headerlink" title="4.1	原生 NIO 存在的问题"></a>4.1	原生 NIO 存在的问题</h2><ol>
<li><p>NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</p>
</li>
<li><p>需要具备其他的额外技能：要熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。</p>
</li>
<li><p>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。</p>
</li>
<li><p>JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。直到 JDK 1.7</p>
</li>
</ol>
<p>版本该问题仍旧存在，没有被根本解决。</p>
<h2 id="4-2-Netty-官网说明"><a href="#4-2-Netty-官网说明" class="headerlink" title="4.2      Netty 官网说明"></a>4.2      Netty 官网说明</h2><p>官网：<a target="_blank" rel="noopener" href="https://netty.io/">https://netty.io/</a></p>
<p>Netty is an asynchronous event-driven network application framework</p>
<p>for rapid development of maintainable high performance protocol servers &amp; clients</p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image083.jpg" alt="img"></p>
<h2 id="4-3-Netty-的优点"><a href="#4-3-Netty-的优点" class="headerlink" title="4.3      Netty 的优点"></a>4.3      Netty 的优点</h2><p>Netty 对 JDK 自带的 NIO 的 API 进行了封装，解决了上述问题。</p>
<ol>
<li><p>设计优雅：适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池。</p>
</li>
<li><p>使用方便：详细记录的 Javadoc，用户指南和示例；没有其他依赖项，JDK 5（Netty 3.x）或 6（Netty 4.x）就足够了。</p>
</li>
<li><p>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</p>
</li>
<li><p>安全：完整的 SSL&#x2F;TLS 和 StartTLS 支持。</p>
</li>
<li><p>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复，同时，更多的新功能会被加入。</p>
</li>
</ol>
<h2 id="4-4-Netty-版本说明"><a href="#4-4-Netty-版本说明" class="headerlink" title="4.4      Netty 版本说明"></a>4.4      Netty 版本说明</h2><ol>
<li>netty 版本分为 netty3.x  和 netty4.x、netty5.x</li>
<li>因为 Netty5 出现重大 bug，已经被官网废弃了，目前推荐使用的是 Netty4.x 的稳定版本。</li>
<li>目前在官网可下载的版本 netty3.x netty4.0.x 和 netty4.1.x</li>
<li>在本套课程中，我们讲解 Netty4.1.x 版本</li>
</ol>
<h1 id="第-5-章-Netty-高性能架构设计"><a href="#第-5-章-Netty-高性能架构设计" class="headerlink" title="第 5 章 Netty 高性能架构设计"></a>第 5 章 Netty 高性能架构设计</h1><h2 id="5-1-线程模型基本介绍"><a href="#5-1-线程模型基本介绍" class="headerlink" title="5.1      线程模型基本介绍"></a>5.1      线程模型基本介绍</h2><ol>
<li><p>不同的线程模式，对程序的性能有很大影响，为了搞清 Netty 线程模式，我们来系统的讲解下 各个线程模式， 最后看看 Netty 线程模型有什么优越性.</p>
</li>
<li><p>目前存在的线程模型有： 传统阻塞 I&#x2F;O 服务模型，Reactor 模式</p>
</li>
<li><p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现</p>
</li>
</ol>
<p>单 Reactor 单线程； 单 Reactor 多线程； 主从 Reactor 多线程</p>
<ol start="4">
<li>Netty 线程模式(Netty 主要基于主从 Reactor 多线程模型做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor)</li>
</ol>
<h2 id="5-2-传统阻塞-I-x2F-O-服务模型"><a href="#5-2-传统阻塞-I-x2F-O-服务模型" class="headerlink" title="5.2      传统阻塞 I&#x2F;O 服务模型"></a>5.2      传统阻塞 I&#x2F;O 服务模型</h2><h3 id="5-2-1-工作原理图"><a href="#5-2-1-工作原理图" class="headerlink" title="5.2.1 工作原理图"></a>5.2.1 工作原理图</h3><p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221026214347530.png" alt="image-20221026214347530"></p>
<ol>
<li><p>黄色的框表示对象， 蓝色的框表示线程</p>
</li>
<li><p>白色的框表示方法(API)</p>
</li>
</ol>
<h3 id="5-2-2-模型特点"><a href="#5-2-2-模型特点" class="headerlink" title="5.2.2 模型特点"></a>5.2.2 模型特点</h3><ol>
<li><p>采用阻塞 IO 模式获取输入的数据</p>
</li>
<li><p>每个连接都需要独立的线程完成数据的输入，业务处理, 数据返回</p>
</li>
</ol>
<h3 id="5-2-3-问题分析"><a href="#5-2-3-问题分析" class="headerlink" title="5.2.3 问题分析"></a>5.2.3 问题分析</h3><ol>
<li><p>当并发数很大，就会创建大量的线程，占用很大系统资源</p>
</li>
<li><p>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 read 操作，造成线程资源浪费</p>
</li>
</ol>
<h2 id="5-3-Reactor-模式"><a href="#5-3-Reactor-模式" class="headerlink" title="5.3      Reactor 模式"></a>5.3      Reactor 模式</h2><h3 id="5-3-1-针对传统阻塞-I-x2F-O-服务模型的-2-个缺点，解决方案："><a href="#5-3-1-针对传统阻塞-I-x2F-O-服务模型的-2-个缺点，解决方案：" class="headerlink" title="5.3.1 针对传统阻塞 I&#x2F;O 服务模型的 2 个缺点，解决方案："></a>5.3.1 针对传统阻塞 I&#x2F;O 服务模型的 2 个缺点，解决方案：</h3><ol>
<li>基于 I&#x2F;O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</li>
</ol>
<p>Reactor 对应的叫法: 1. 反应器模式 2. 分发者模式(Dispatcher) 3. 通知者模式(notifier)</p>
<ol start="2">
<li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理， 一个线程可以处理多个连接的业务。</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image003.jpg" alt="img"></p>
<h3 id="5-3-2-I-x2F-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图"><a href="#5-3-2-I-x2F-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图" class="headerlink" title="5.3.2 I&#x2F;O 复用结合线程池，就是 Reactor 模式基本设计思想，如图"></a>5.3.2 I&#x2F;O 复用结合线程池，就是 Reactor 模式基本设计思想，如图</h3><p> <img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221027195853479.png" alt="image-20221027195853479"></p>
<p>对上图说明:</p>
<ol>
<li><p>Reactor 模式，通过一个或多个输入同时传递给服务处理器的模式(基于事件驱动)。</p>
</li>
<li><p>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程， 因此 Reactor 模式也叫 Dispatcher模式。</p>
</li>
<li><p>Reactor 模式使用 IO 复用监听事件, 收到事件后，分发给某个线程(进程), 这点就是网络服务器高并发处理关键。</p>
</li>
</ol>
<h3 id="5-3-3-Reactor-模式中-核心组成："><a href="#5-3-3-Reactor-模式中-核心组成：" class="headerlink" title="5.3.3 Reactor 模式中 核心组成："></a>5.3.3 Reactor 模式中 核心组成：</h3><ol>
<li><p>Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</p>
</li>
<li><p>Handlers：处理程序执行 I&#x2F;O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I&#x2F;O 事件，处理程序执行非阻塞操作。</p>
</li>
</ol>
<h3 id="5-3-4-Reactor-模式分类："><a href="#5-3-4-Reactor-模式分类：" class="headerlink" title="5.3.4 Reactor 模式分类："></a>5.3.4 Reactor 模式分类：</h3><p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现</p>
<ol>
<li><p>单 Reactor 单线程</p>
</li>
<li><p>单 Reactor 多线程</p>
</li>
<li><p>主从 Reactor 多线程</p>
</li>
</ol>
<h2 id="5-4-单-Reactor-单线程"><a href="#5-4-单-Reactor-单线程" class="headerlink" title="5.4      单 Reactor 单线程"></a>5.4      单 Reactor 单线程</h2><p>原理图，并使用 NIO 群聊系统验证</p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image007.jpg" alt="img"></p>
<h3 id="5-4-1-方案说明："><a href="#5-4-1-方案说明：" class="headerlink" title="5.4.1 方案说明："></a>5.4.1 方案说明：</h3><ol>
<li><p>Select 是前面 I&#x2F;O 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求。</p>
</li>
<li><p>Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发。</p>
</li>
<li><p>如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理。</p>
</li>
<li><p>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应。</p>
</li>
<li><p>Handler 会完成 Read→业务处理→Send 的完整业务流程</p>
</li>
</ol>
<p>结合实例：服务器端用一个线程通过多路复用搞定所有的 IO 操作（包括连接，读、写等），编码简单，清晰明了， 但是如果客户端连接数量较多，将无法支撑，前面的 NIO 案例就属于这种模型。</p>
<h3 id="5-4-2-方案优缺点分析："><a href="#5-4-2-方案优缺点分析：" class="headerlink" title="5.4.2 方案优缺点分析："></a>5.4.2 方案优缺点分析：</h3><ol>
<li><p>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成。</p>
</li>
<li><p>缺点：性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈。</p>
</li>
<li><p>缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</p>
</li>
<li><p>使用场景：客户端的数量有限，业务处理非常快速，比如 Redis 在业务处理的时间复杂度 O(1) 的情况。</p>
</li>
</ol>
<h2 id="5-5-单Reactor-多线程"><a href="#5-5-单Reactor-多线程" class="headerlink" title="5.5      单Reactor 多线程"></a>5.5      单Reactor 多线程</h2><h3 id="5-5-1-原理图"><a href="#5-5-1-原理图" class="headerlink" title="5.5.1 原理图"></a>5.5.1 原理图</h3><p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image009.jpg" alt="img"></p>
<h3 id="5-5-2-对上图的小结"><a href="#5-5-2-对上图的小结" class="headerlink" title="5.5.2 对上图的小结"></a>5.5.2 对上图的小结</h3><ol>
<li><p>Reactor 对象通过 select 监控客户端请求事件, 收到事件后，通过 dispatch 进行分发。</p>
</li>
<li><p>如果建立连接请求, 则右 Acceptor 通过accept 处理连接请求, 然后创建一个 Handler 对象处理完成连接后的各种事件。</p>
</li>
<li><p>如果不是连接请求（读写请求），则由 reactor 分发调用连接对应的 handler 来处理。</p>
</li>
<li><p>handler 只负责响应事件，不做具体的业务处理, 通过 read 读取数据后，会分发给后面的 worker 线程池的某个线程处理业务。</p>
</li>
<li><p>worker 线程池会分配独立线程完成真正的业务，并将结果返回给 handler。</p>
</li>
<li><p>handler 收到响应后，通过 send 将结果返回给 client。</p>
</li>
</ol>
<h3 id="1-5-3-方案优缺点分析："><a href="#1-5-3-方案优缺点分析：" class="headerlink" title="1.5.3 方案优缺点分析："></a>1.5.3 方案优缺点分析：</h3><ol>
<li><p>优点：可以充分的利用多核 cpu 的处理能力。</p>
</li>
<li><p>缺点：多线程数据共享和访问比较复杂， reactor 处理所有的事件的监听和响应，在单线程运行， 在高并发场景容易出现性能瓶颈。</p>
</li>
</ol>
<h2 id="5-6-主从-Reactor-多线程"><a href="#5-6-主从-Reactor-多线程" class="headerlink" title="5.6      主从 Reactor 多线程"></a>5.6      主从 Reactor 多线程</h2><h3 id="5-6-1-工作原理图"><a href="#5-6-1-工作原理图" class="headerlink" title="5.6.1 工作原理图"></a>5.6.1 工作原理图</h3><p>针对单 Reactor 多线程模型中，Reactor 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 Reactor 在多线程中运行。</p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image011-166662187911410.jpg" alt="img"></p>
<h3 id="5-6-2-上图的方案说明"><a href="#5-6-2-上图的方案说明" class="headerlink" title="5.6.2 上图的方案说明"></a>5.6.2 上图的方案说明</h3><ol>
<li><p>Reactor 主线程 MainReactor 对象通过 select 监听连接事件, 收到事件后，通过 Acceptor 处理连接事件（MainReactor 只进行接收操作，其他操作交予子线程操作）。</p>
</li>
<li><p>当 Acceptor  处理连接事件后，MainReactor 将连接分配给 SubReactor。</p>
</li>
<li><p>subreactor 将连接加入到连接队列进行监听,并创建 handler 进行各种事件处理。</p>
</li>
<li><p>当有新事件发生时， subreactor 就会调用对应的 handler 处理。</p>
</li>
<li><p>handler 通过 read 读取数据，分发给后面的 worker 线程处理。</p>
</li>
<li><p>worker 线程池分配独立的 worker 线程进行业务处理，并返回结果。</p>
</li>
<li><p>handler 收到响应的结果后，再通过 send 将结果返回给 client。</p>
</li>
<li><p>Reactor 主线程可以对应多个 Reactor 子线程, 即 MainRecator 可以关联多个 SubReactor。</p>
</li>
</ol>
<h3 id="5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解："><a href="#5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解：" class="headerlink" title="5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解："></a>5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解：</h3><p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221027201345433.png" alt="image-20221027201345433"></p>
<h3 id="5-6-4-方案优缺点说明："><a href="#5-6-4-方案优缺点说明：" class="headerlink" title="5.6.4 方案优缺点说明："></a>5.6.4 方案优缺点说明：</h3><ol>
<li><p>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</p>
</li>
<li><p>优点：父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</p>
</li>
<li><p>缺点：编程复杂度较高</p>
</li>
<li><p>结合实例：这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持。</p>
</li>
</ol>
<h2 id="5-7-Reactor-模式小结"><a href="#5-7-Reactor-模式小结" class="headerlink" title="5.7      Reactor 模式小结"></a>5.7      Reactor 模式小结</h2><h3 id="5-7-1-3种模式用生活案例来理解"><a href="#5-7-1-3种模式用生活案例来理解" class="headerlink" title="5.7.1 3种模式用生活案例来理解"></a>5.7.1 3种模式用生活案例来理解</h3><ol>
<li><p>单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服务。</p>
</li>
<li><p>单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待。</p>
</li>
<li><p>主从 Reactor 多线程，多个前台接待员，多个服务生。</p>
</li>
</ol>
<h3 id="5-7-2-Reactor-模式具有如下的优点："><a href="#5-7-2-Reactor-模式具有如下的优点：" class="headerlink" title="5.7.2 Reactor 模式具有如下的优点："></a>5.7.2 Reactor 模式具有如下的优点：</h3><ol>
<li><p>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的</p>
</li>
<li><p>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销</p>
</li>
<li><p>扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源</p>
</li>
<li><p>复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性</p>
</li>
</ol>
<h2 id="5-8-Netty-模型"><a href="#5-8-Netty-模型" class="headerlink" title="5.8      Netty 模型"></a>5.8      Netty 模型</h2><h3 id="5-8-1-工作原理示意图-1-简单版"><a href="#5-8-1-工作原理示意图-1-简单版" class="headerlink" title="5.8.1 工作原理示意图 1-简单版"></a>5.8.1 工作原理示意图 1-简单版</h3><p> Netty 主要基于主从 Reactors 多线程模型（如图）做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor。</p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221027201653118.png" alt="image-20221027201653118"></p>
<h3 id="5-8-2-对上图说明"><a href="#5-8-2-对上图说明" class="headerlink" title="5.8.2 对上图说明"></a>5.8.2 对上图说明</h3><ol>
<li><p>BossGroup 线程维护 Selector , 只关注 Accecpt。</p>
</li>
<li><p>当接收到 Accept 事件，获取到对应的 SocketChannel, 封装成 NIOScoketChannel 并注册到Worker 线程(事件循环), 并进行维护。</p>
</li>
<li><p>当 Worker 线程监听到 selector 中通道发生自己感兴趣的事件后，就进行处理(就由 handler)， 注意 handler 已经加入到通道。</p>
</li>
</ol>
<h3 id="5-8-3-工作原理示意图-2-进阶版"><a href="#5-8-3-工作原理示意图-2-进阶版" class="headerlink" title="5.8.3 工作原理示意图 2-进阶版"></a>5.8.3 工作原理示意图 2-进阶版</h3><p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221027201724857.png" alt="image-20221027201724857"></p>
<h3 id="5-8-4-工作原理示意图-详细版"><a href="#5-8-4-工作原理示意图-详细版" class="headerlink" title="5.8.4 工作原理示意图-详细版"></a>5.8.4 工作原理示意图-详细版</h3><p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image019.jpg" alt="img"></p>
<h3 id="1-8-5-对上图的说明小结"><a href="#1-8-5-对上图的说明小结" class="headerlink" title="1.8.5 对上图的说明小结"></a>1.8.5 对上图的说明小结</h3><ol>
<li><p>Netty 抽象出两组线程池 BossGroup 专门负责接收客户端的连接, WorkerGroup 专门负责网络的读写。</p>
</li>
<li><p>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup。</p>
</li>
<li><p>NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环 ，每一个事件循环是 NioEventLoop。</p>
</li>
<li><p>NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个 NioEventLoop 都有一个 selector , 用于监听绑定在其上的 socket 的网络通讯。</p>
</li>
<li><p>NioEventLoopGroup 可以有多个线程, 即可以含有多个 NioEventLoop。</p>
</li>
<li><p>每个 Boss NioEventLoop 循环执行的步骤有 3 步</p>
<ul>
<li>轮询 accept 事件</li>
<li>处理 accept 事件 , 与 client 建立连接 , 生成 NioScocketChannel , 并将其注册到某个 worker NIOEventLoop 上的 selector</li>
<li>处理任务队列的任务 ， 即 runAllTasks</li>
</ul>
</li>
<li><p>每个 Worker NIOEventLoop 循环执行的步骤</p>
<ul>
<li>轮询 read, write 事件</li>
<li>处理 i&#x2F;o 事件， 即 read , write 事件，在对应 NioScocketChannel 处理</li>
<li>处理任务队列的任务 ， 即 runAllTasks</li>
</ul>
</li>
<li><p>每个Worker NIOEventLoop  处理业务时，会使用pipeline(管道), pipeline 中包含了 channel , 即通过pipeline 可以获取到对应通道, 管道中维护了很多的 处理器。</p>
</li>
</ol>
<h3 id="5-8-6-Netty-快速入门实例-TCP-服务"><a href="#5-8-6-Netty-快速入门实例-TCP-服务" class="headerlink" title="5.8.6 Netty 快速入门实例-TCP 服务"></a>5.8.6 Netty 快速入门实例-TCP 服务</h3><p>实例要求：使用 IDEA 创建 Netty 项目</p>
<ol>
<li><p>Netty 服务器在 6668 端口监听，客户端能发送消息给服务器 “hello, 服务器~”</p>
</li>
<li><p>服务器可以回复消息给客户端 “hello, 客户端~”</p>
</li>
<li><p>目的：对 Netty 线程模型 有一个初步认识, 便于理解 Netty 模型理论</p>
</li>
<li><p>看老师代码演示</p>
</li>
</ol>
<p>5.1 编写服务端 5.2 编写客户端 5.3 <strong>对</strong> <strong>netty</strong> <strong>程序进行分析，看看</strong> <strong>netty</strong> <strong>模型特</strong>点</p>
<p>说明: 创建 Maven 项目，并引入 Netty 包</p>
<ol start="5">
<li>代码如下</li>
</ol>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NettyServer.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/27 21:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建BossGroup 和 WorkGroup</span></span><br><span class="line">        <span class="comment">//说明：</span></span><br><span class="line">        <span class="comment">//1. 创建两个线程组 bossGroup workGroup</span></span><br><span class="line">        <span class="comment">//2. boosGroup 只处理连接请求，真正的和客户端业务处理，会交给workGroup处理</span></span><br><span class="line">        <span class="comment">//3. 两个都是无限循环</span></span><br><span class="line">        <span class="comment">//4. bossGroup 和 workGroup 含有的子线程（NioEventLoopGroup） 默认 cpu核数*2</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(bossGroup,workGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//使用NioSocketChannel 作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>) <span class="comment">//设置线程队列的连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="literal">true</span>) <span class="comment">//设置连接保持活动连接状态</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123; <span class="comment">//创建一个通道测试对象</span></span><br><span class="line">                        <span class="comment">// 给pipeline设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">//给 workGroup的NioEventLoop 对应的管道设置处理器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器 is ready ....&quot;</span>);</span><br><span class="line">            <span class="comment">//启动服务器，绑定一个端口并且同步，生成了一个ChannelFuture对象</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">sync</span> <span class="operator">=</span> bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            sync.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自定义NettyServerHandler.java</span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/27 21:50</span></span><br><span class="line"><span class="comment"> * 自定义一个handler 需要继承netty 规定好的某个HandlerAdapter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据（这里我们可以读取客户端发送的消息）</span></span><br><span class="line"><span class="comment">     * 1. ChannelHandlerContext ctx:上下文对象，含有管道pipeline,通道channel,地址</span></span><br><span class="line"><span class="comment">     * 2. Object msg:客户都发送的消息 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;server ctx = &quot;</span> + ctx);</span><br><span class="line">        <span class="comment">//将 msg 转成 ByteBuffer</span></span><br><span class="line">        <span class="comment">//ByteBuf 是netty提供的，不是NIO的ByteBuffer</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送的消息：&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端地址：&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕后操作</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将数据写入到缓冲区并刷新</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello，客户端~&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常，一般需要关闭通道</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NettyClient.java</span><br><span class="line">    </span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/29 13:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是ServerBootstrap 而是BootStrap</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(eventExecutors) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">//设置客户端通道的实现类（反射）</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 is OK....&quot;</span>);</span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端  ChannelFuture涉及到netty的异步模型</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给channelFuture注册监听器,监控我们关心的事件</span></span><br><span class="line">            channelFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">if</span> (channelFuture.isSuccess())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口6668成功&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口6668成功&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自定义NettyClientHandler.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/29 13:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道就绪时就会出发</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;client：&quot;</span> + ctx);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,server!&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时会触发</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息：&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的地址：&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221030111949451.png" alt="image-20221030111949451"></p>
<h3 id="5-8-7-任务队列中的-Task-有-3-种典型使用场景"><a href="#5-8-7-任务队列中的-Task-有-3-种典型使用场景" class="headerlink" title="5.8.7 任务队列中的 Task 有 3 种典型使用场景"></a>5.8.7 任务队列中的 Task 有 3 种典型使用场景</h3><ol>
<li><p>用户程序自定义的普通任务 [举例说明]</p>
</li>
<li><p>用户自定义定时任务 </p>
</li>
<li><p>非当前 Reactor 线程调用 Channel 的各种方法</p>
</li>
</ol>
<p>例如在推送系统的业务线程里面，根据用户的标识，找到对应的 Channel 引用，然后调用 Write 类方法向该用户推送消息，就会进入到这种场景。最终的 Write 会提交到任务队列中后被异步消费</p>
<ol start="4">
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/27 21:50</span></span><br><span class="line"><span class="comment"> * 自定义一个handler 需要继承netty 规定好的某个HandlerAdapter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据（这里我们可以读取客户端发送的消息）</span></span><br><span class="line"><span class="comment">     * 1. ChannelHandlerContext ctx:上下文对象，含有管道pipeline,通道channel,地址</span></span><br><span class="line"><span class="comment">     * 2. Object msg:客户都发送的消息 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;server ctx = &quot;</span> + ctx);</span><br><span class="line">        <span class="comment">//将 msg 转成 ByteBuffer</span></span><br><span class="line">        <span class="comment">//ByteBuf 是netty提供的，不是NIO的ByteBuffer</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送的消息：&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端地址：&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比如我们这里有一个非常耗时的业务-&gt;异步执行-&gt;提交该channel对应的请求</span></span><br><span class="line">        <span class="comment">// 解决方案1. 用户程序自定义的普通方法 -&gt; NIOEventLoop 的taskQueue中</span></span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端,自定义任务!&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解决方案2. 用户自定义定时任务 -&gt; 该任务是提交到scheduleTaskQueue4</span></span><br><span class="line">        ctx.channel().eventLoop().schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端,自定义任务!&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕后操作</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将数据写入到缓冲区并刷新</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello，客户端~&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常，一般需要关闭通道</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221030112334830.png" alt="image-20221030112334830"></p>
<h3 id="5-8-8-方案再说明"><a href="#5-8-8-方案再说明" class="headerlink" title="5.8.8 方案再说明"></a>5.8.8 方案再说明</h3><ol>
<li><p>Netty 抽象出两组线程池，BossGroup 专门负责接收客户端连接，WorkerGroup 专门负责网络读写操作。</p>
</li>
<li><p>NioEventLoop 表示一个不断循环执行处理任务的线程，每个 NioEventLoop 都有一个 selector，用于监听绑定在其上的 socket 网络通道。</p>
</li>
<li><p>NioEventLoop 内部采用串行化设计，从消息的读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送，始终由 IO 线程 NioEventLoop负责</p>
</li>
<li><p>NioEventLoopGroup 下包含多个 NioEventLoop</p>
<ul>
<li>每个 NioEventLoop 中包含有一个 Selector，一个 taskQueue</li>
<li>每个 NioEventLoop 的 Selector 上可以注册监听多个 NioChannel</li>
<li>每个 NioChannel 只会绑定在唯一的 NioEventLoop 上</li>
<li>每个 NioChannel 都绑定有一个自己的 ChannelPipeline</li>
</ul>
</li>
</ol>
<h2 id="5-9-异步模型"><a href="#5-9-异步模型" class="headerlink" title="5.9      异步模型"></a>5.9      异步模型</h2><h3 id="5-9-1-基本介绍"><a href="#5-9-1-基本介绍" class="headerlink" title="5.9.1 基本介绍"></a>5.9.1 基本介绍</h3><ol>
<li><p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</p>
</li>
<li><p>Netty 中的 I&#x2F;O 操作是异步的，包括 Bind、Write、Connect 等操作会简单的返回一个 ChannelFuture。</p>
</li>
<li><p>调用者并不能立刻获得结果，而是通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得IO 操作结果。</p>
</li>
<li><p>Netty 的异步模型是建立在 future 和 callback 的之上的。callback 就是回调。重点说 Future，它的核心思想是：假设一个方法 fun，计算过程可能非常耗时，等待 fun 返回显然不合适。那么可以在调用 fun 的时候，立马返回一个 Future，后续可以通过 Future 去监控方法 fun 的处理过程(即 ： Future-Listener 机制)。</p>
</li>
</ol>
<h3 id="5-9-2-Future-说明"><a href="#5-9-2-Future-说明" class="headerlink" title="5.9.2 Future 说明"></a>5.9.2 Future 说明</h3><ol>
<li><p>表示<strong>异步的执行结果</strong>, 可以通过它提供的方法来检测执行是否完成，比如检索计算等等。</p>
</li>
<li><p>ChannelFuture 是一个接口 ： <code>public interface ChannelFuture extends Future&lt;Void&gt;</code>我们可以添<strong>加监听器，当监听的事件发生时，就会通知到监听器</strong>。</p>
</li>
</ol>
<h3 id="5-9-3-工作原理示意图"><a href="#5-9-3-工作原理示意图" class="headerlink" title="5.9.3 工作原理示意图"></a>5.9.3 工作原理示意图</h3><p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image029.jpg" alt="img"></p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221027202429972.png" alt="image-20221027202429972"></p>
<p>说明:</p>
<ol>
<li><p>在使用 Netty 进行编程时，拦截操作和转换出入站数据只需要您提供 callback 或利用 future 即可。这使得链式操作简单、高效, 并有利于编写可重用的、通用的代码。</p>
</li>
<li><p>Netty 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来</p>
</li>
</ol>
<h3 id="5-9-4-Future-Listener-机制"><a href="#5-9-4-Future-Listener-机制" class="headerlink" title="5.9.4 Future-Listener 机制"></a>5.9.4 Future-Listener 机制</h3><ol>
<li><p>当 Future 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 ChannelFuture 来获取操作执行的状态， 注册监听函数来执行完成后的操作。</p>
</li>
<li><p>常见有如下操作</p>
<ul>
<li>通过 isDone 方法来判断当前操作是否完成；</li>
<li>通过 isSuccess 方法来判断已完成的当前操作是否成功；</li>
<li>通过 getCause 方法来获取已完成的当前操作失败的原因；</li>
<li>通过 isCancelled 方法来判断已完成的当前操作是否被取消；</li>
<li>通过 addListener 方法来注册监听器，当操作已完成(isDone 方法返回完成)，将会通知指定的监听器；如果Future 对象已完成，则通知指定的监听器。</li>
</ul>
</li>
</ol>
<p>​	3. 举例说明</p>
<p>演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/29 13:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是ServerBootstrap 而是BootStrap</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(eventExecutors) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">//设置客户端通道的实现类（反射）</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 is OK....&quot;</span>);</span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端  ChannelFuture涉及到netty的异步模型</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给channelFuture注册监听器,监控我们关心的事件</span></span><br><span class="line">            channelFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">if</span> (channelFuture.isSuccess())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口6668成功&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口6668成功&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-10-快速入门实例-HTTP-服务"><a href="#5-10-快速入门实例-HTTP-服务" class="headerlink" title="5.10   快速入门实例-HTTP 服务"></a>5.10   快速入门实例-HTTP 服务</h2><ol>
<li><p>实例要求：使用 IDEA 创建 Netty 项目</p>
</li>
<li><p>Netty 服务器在 6668 端口监听，浏览器发出请求 “<a target="_blank" rel="noopener" href="http://localhost:6668/">http://localhost:6668/</a> “</p>
</li>
<li><p>服务器可以回复消息给客户端 “Hello! 我是服务器  “ , 并对特定请求资源进行过滤。</p>
</li>
<li><p>目的：Netty 可以做 Http 服务开发，并且理解 Handler 实例和客户端及其请求的关系。</p>
</li>
<li><p>代码演示</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestHttpServer.java</span><br><span class="line">    </span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.sctp.nio.NioSctpServerChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/29 15:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHttpServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">TestServerInitializer</span>());</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/29 15:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//向管道加入处理器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到管道</span></span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入一个netty提供的httpServerCodec codec =&gt;[coder decoder]</span></span><br><span class="line">        <span class="comment">//HttpServerCodec 是netty提供编解码器</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyHttpServerCodec&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加一个自定义的handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyTestHttpServerHandler&quot;</span>,<span class="keyword">new</span> <span class="title class_">TestHttpServerHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/29 15:27</span></span><br><span class="line"><span class="comment"> * SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter的子类</span></span><br><span class="line"><span class="comment"> * HttpObject 表示客户端和服务器端相互通讯的数据被封装成 HttpObject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpObject&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端数据</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断msg是不是httpRequest请求</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;msg地址：&quot;</span> + msg.getClass());</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端地址：&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="type">HttpRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> (HttpRequest) msg;</span><br><span class="line">            <span class="comment">//获取uri</span></span><br><span class="line">            <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URI</span>(httpRequest.uri());</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath()))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请求了favicon.ico，不做响应&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回复信息给浏览器[http协议]</span></span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;hello,我是服务器&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">            <span class="comment">//构造一个http的响应</span></span><br><span class="line">            <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, buf);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH,buf.readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将构建好的 response返回</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="第-6-章-Netty核心模块组件"><a href="#第-6-章-Netty核心模块组件" class="headerlink" title="第 6 章 Netty核心模块组件"></a>第 6 章 Netty核心模块组件</h1><h2 id="6-1-Bootstrap、ServerBootstrap"><a href="#6-1-Bootstrap、ServerBootstrap" class="headerlink" title="6.1   Bootstrap、ServerBootstrap"></a>6.1   Bootstrap、ServerBootstrap</h2><ol>
<li><p>Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p>
</li>
<li><p>常见的方法有</p>
</li>
</ol>
<ul>
<li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端， 用来设置两个 EventLoop</li>
<li><code>public B group(EventLoopGroup group)</code> ，该方法用于客户端，用来设置一个 EventLoop </li>
<li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li>
<li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 ServerChannel 添加配置</li>
<li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li>
<li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>， 该方法用来设置业务处理类（ 自定义的handler）</li>
<li><code>public ChannelFuture bind(int inetPort)</code> ，该方法用于服务器端，用来设置占用的端口号</li>
<li><code>public ChannelFuture connect(String inetHost, int inetPort) </code>，该方法用于客户端，用来连接服务器端</li>
</ul>
<h2 id="6-2-Future、ChannelFuture"><a href="#6-2-Future、ChannelFuture" class="headerlink" title="6.2      Future、ChannelFuture"></a>6.2      Future、ChannelFuture</h2><p>Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和ChannelFutures，<strong>他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</strong></p>
<p>常见的方法有：</p>
<ul>
<li><code>Channel channel()</code>，返回当前正在进行 IO 操作的通道</li>
<li><code>ChannelFuture sync()</code>，等待异步操作执行完毕</li>
</ul>
<h2 id="6-3-Channel"><a href="#6-3-Channel" class="headerlink" title="6.3      Channel"></a>6.3      Channel</h2><ol>
<li><p><strong>Netty 网络通信的组件，能够用于执行网络 I&#x2F;O 操作。</strong></p>
</li>
<li><p>通过 Channel 可获得当前网络连接的通道的状态</p>
</li>
<li><p>通过 Channel 可获得 网络连接的配置参数 （例如接收缓冲区大小）</p>
</li>
<li><p>Channel 提供异步的网络 I&#x2F;O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I&#x2F;O 调用都将立即返回，并且不保证在调用结束时所请求的 I&#x2F;O 操作已完成</p>
</li>
<li><p>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I&#x2F;O 操作成功、失败或取消时回调通知调用方</p>
</li>
<li><p>支持关联 I&#x2F;O 操作与对应的处理程序</p>
</li>
<li><p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，常用的 Channel 类型: NioSocketChannel，异步的客户端 TCP Socket 连接。</p>
</li>
</ol>
<p>NioServerSocketChannel，异步的服务器端 TCP Socket 连接。</p>
<p>NioDatagramChannel，异步的 UDP 连接。</p>
<p>NioSctpChannel，异步的客户端 Sctp 连接。</p>
<p>NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</p>
<h2 id="6-4-Selector"><a href="#6-4-Selector" class="headerlink" title="6.4      Selector"></a>6.4      Selector</h2><ol>
<li><p><strong>Netty 基于 Selector 对象实现 I&#x2F;O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。</strong></p>
</li>
<li><p>当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的Channel 是否有已就绪的 I&#x2F;O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel。</p>
</li>
</ol>
<h2 id="6-5-ChannelHandler-及其实现类"><a href="#6-5-ChannelHandler-及其实现类" class="headerlink" title="6.5      ChannelHandler 及其实现类"></a>6.5      ChannelHandler 及其实现类</h2><ol>
<li><p><strong>ChannelHandler 是一个接口，处理 I&#x2F;O 事件或拦截 I&#x2F;O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。</strong></p>
</li>
<li><p>ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</p>
</li>
<li><p>ChannelHandler 及其实现类一览图(后)</p>
</li>
</ol>
<p> <img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221030113954905.png" alt="image-20221030113954905"></p>
<ol start="4">
<li>我们经常需要自定义一个 Handler 类去继承 ChannelInboundHandlerAdapter，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image002-16671008194122.jpg" alt="img"></p>
<h2 id="6-6-Pipeline-和-ChannelPipeline"><a href="#6-6-Pipeline-和-ChannelPipeline" class="headerlink" title="6.6      Pipeline 和 ChannelPipeline"></a>6.6      Pipeline 和 ChannelPipeline</h2><p><strong>ChannelPipeline 是一个重点：</strong></p>
<ol>
<li><p>ChannelPipeline 是一个 Handler 的集合，<strong>它负责处理和拦截 inbound 或者 outbound 的事件和操作，相当于一个贯穿 Netty 的链</strong>。(也可以这样理解：ChannelPipeline 是 保存 ChannelHandler 的 List，用于处理或拦截Channel 的入站事件和出站操作)。</p>
</li>
<li><p>ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel中各个的 ChannelHandler 如何相互交互。</p>
</li>
<li><p>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image004.gif" alt="img"></p>
<ol start="4">
<li>常用方法</li>
</ol>
<ul>
<li><code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>，把一个业务处理类（handler）添加到链中的第一个位置</li>
<li><code>ChannelPipeline addLast(ChannelHandler... handlers)</code>，把一个业务处理类（handler）添加到链中的最后一个位置</li>
</ul>
<h2 id="6-7-ChannelHandlerContext"><a href="#6-7-ChannelHandlerContext" class="headerlink" title="6.7      ChannelHandlerContext"></a>6.7      ChannelHandlerContext</h2><ol>
<li><p><strong>保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象。</strong></p>
</li>
<li><p>即 ChannelHandlerContext  中 包 含 一 个 具 体 的事件处理器ChannelHandler，同 时ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler 进行调用。</p>
</li>
<li><p>常用方法</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image006.gif" alt="img"></p>
<h2 id="6-8-ChannelOption"><a href="#6-8-ChannelOption" class="headerlink" title="6.8      ChannelOption"></a>6.8      ChannelOption</h2><ol>
<li><p>Netty 在创建 Channel 实例后,一般都需要设置 ChannelOption 参数。</p>
</li>
<li><p>ChannelOption 参数如下:</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221030114308015.png" alt="image-20221030114308015"></p>
<h2 id="6-9-EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#6-9-EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="6.9      EventLoopGroup 和其实现类 NioEventLoopGroup"></a>6.9      EventLoopGroup 和其实现类 NioEventLoopGroup</h2><ol>
<li><p>EventLoopGroup 是一组 EventLoop 的抽象，Netty 为了更好的利用多核 CPU 资源，一般会有多个 EventLoop同时工作，每个 EventLoop 维护着一个 Selector 实例。</p>
</li>
<li><p>EventLoopGroup 提供 next 接口，可以从组里面按照一定规则获取其中一个 EventLoop 来处理任务。在 Netty 服 务 器 端 编 程 中 ， 我 们 一 般 都 需 要 提 供 两 个 EventLoopGroup ， 例 如 ： BossEventLoopGroup 和WorkerEventLoopGroup。</p>
</li>
<li><p>通常一个服务端口即一个 ServerSocketChannel 对应一个 Selector 和一个EventLoop 线程。BossEventLoop 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理，如下图所示</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/clip_image009.gif" alt="img"></p>
<ol start="4">
<li>常用方法</li>
</ol>
<ul>
<li><code>public NioEventLoopGroup()</code>，构造方法</li>
<li><code>public Future&lt;?&gt; shutdownGracefully()</code>，断开连接，关闭线程</li>
</ul>
<h2 id="6-10-Unpooled-类"><a href="#6-10-Unpooled-类" class="headerlink" title="6.10   Unpooled 类"></a>6.10   Unpooled 类</h2><ol>
<li><p>Netty 提供一个专门用来操作缓冲区(即 Netty 的数据容器)的工具类。</p>
</li>
<li><p>常用方法如下所示</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221030114407908.png" alt="image-20221030114407908"></p>
<ol start="3">
<li>举例说明 Unpooled 获取 Netty 的数据容器 ByteBuf 的基本使用 【案例演示】</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221030114423892.png" alt="image-20221030114423892"></p>
<p>案例 1</p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221030125618460.png" alt="image-20221030125618460"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 12:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyByteBuf01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个ByteBuf</span></span><br><span class="line">        <span class="comment">//说明：</span></span><br><span class="line">        <span class="comment">// 1. 创建对象，该对象包含一个数组byte[10]</span></span><br><span class="line">        <span class="comment">// 2. 在netty的buffer中，不需要flip进行反转，因为底层维护了readerIndex和writerIndex</span></span><br><span class="line">        <span class="comment">// 3. 通过 readerIndex 和 writerIndex 和 capacity,将buffer分成三个区域：</span></span><br><span class="line">        <span class="comment">//     0 -&gt; readerIndex 已经读取的区域   readerIndex -&gt; writerIndex 可读的区域    writerIndex -&gt; capacity 可写的区域</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buffer.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;capacity：&quot;</span> + buffer.capacity());</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            System.out.println(buffer.getByte(i));</span><br><span class="line">            System.out.println(buffer.readByte()   );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例 2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 12:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NettyByteBuf02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建ByteBuf</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;hello,world!&quot;</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        <span class="comment">//使用相关的方法</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuf.hasArray())&#123;</span><br><span class="line">            <span class="type">byte</span>[] array = byteBuf.array();</span><br><span class="line">            <span class="comment">//将array转成字符串</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(array,Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line">            System.out.println(<span class="string">&quot;byteBuf：&quot;</span> + byteBuf);</span><br><span class="line"></span><br><span class="line">            System.out.println(byteBuf.arrayOffset()); <span class="comment">//0</span></span><br><span class="line">            System.out.println(byteBuf.readerIndex()); <span class="comment">//0</span></span><br><span class="line">            System.out.println(byteBuf.writerIndex()); <span class="comment">//12</span></span><br><span class="line">            System.out.println(byteBuf.capacity());  <span class="comment">//36</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> byteBuf.readableBytes(); <span class="comment">//可读字节数 12</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//输出指定区域的值</span></span><br><span class="line">            System.out.println(byteBuf.getCharSequence(<span class="number">2</span>,<span class="number">4</span>,Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221030131357338.png" alt="image-20221030131357338"></p>
<h2 id="6-11-Netty-应用实例-群聊系统"><a href="#6-11-Netty-应用实例-群聊系统" class="headerlink" title="6.11   Netty 应用实例-群聊系统"></a>6.11   Netty 应用实例-群聊系统</h2><p>实例要求:</p>
<ol>
<li><p>编写一个 Netty 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</p>
</li>
<li><p>实现多人群聊</p>
</li>
<li><p>服务器端：可以监测用户上线，离线，并实现消息转发功能</p>
</li>
<li><p>客户端：通过 channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(有服务器转发得到)</p>
</li>
<li><p>目的：进一步理解 Netty 非阻塞网络编程机制</p>
</li>
<li><p>代码演示</p>
</li>
</ol>
<p>代码如下：</p>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221030144924319.png" alt="image-20221030144924319"></p>
<p>服务端</p>
<p>GroupChatServer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 13:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line">    <span class="comment">//监听端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">(<span class="type">int</span> port)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写run方法，处理客户端的请求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="literal">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//获取到pipeline</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            <span class="comment">//向pipeline加入解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            <span class="comment">//向pipeline加入编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                            <span class="comment">//加入自己的业务处理handler</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">GroupChatServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;netty 服务器启动&quot;</span>);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">//监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>(<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> GroupChatServerHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 13:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个channel组，管理所有的channel</span></span><br><span class="line"><span class="comment">     * GlobalEventExecutor.INSTANCE 是全局的事件执行器，是一个单例</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ChannelGroup</span> <span class="variable">channelGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelGroup</span>(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handlerAdded 表示连接建立，一旦连接，第一个被执行</span></span><br><span class="line"><span class="comment">     * 将当前channel 加入到 channelGroup</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        <span class="comment">//将该客户加入聊天的信息推送给其他在线的客户端</span></span><br><span class="line">        <span class="comment">//writeAndFlush会将 channelGroup 中所有的channel 遍历并发送消息</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端] &quot;</span> + channel.remoteAddress() + <span class="string">&quot; 加入聊天\n&quot;</span>);</span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示channel 处于活动状态，提示xx上线</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot; 上线了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示channel 处于不活动状态，提示xx离线了</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot; 离线了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开连接，将xx客户离开信息推送给其他在线的客户</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 离开了&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;channelGroup size：&quot;</span> + channelGroup.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        <span class="comment">//遍历channelGroup，根据不同的情况，回送不同的消息</span></span><br><span class="line">        channelGroup.forEach(channel1 -&gt; &#123;</span><br><span class="line">            <span class="comment">//给不是当前的channel，转发消息</span></span><br><span class="line">            <span class="keyword">if</span> (channel1 != channel)&#123;</span><br><span class="line">                channel1.writeAndFlush(<span class="string">&quot;[客户]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 发送的消息：&quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                channel1.writeAndFlush(<span class="string">&quot;你已发送消息：&quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生异常时</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端</p>
<p>GroupChatClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 14:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> PORT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClient</span><span class="params">(String host,<span class="type">int</span> port)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.HOST = host;</span><br><span class="line">        <span class="built_in">this</span>.PORT = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bootstrap.group(eventExecutors)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//得到pipeline</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            <span class="comment">//加入相关的handler</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br><span class="line">                                    .addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">StringEncoder</span>())</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> <span class="title class_">GroupChatClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(HOST, PORT).sync();</span><br><span class="line"></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;--------&quot;</span> + channel.localAddress() + <span class="string">&quot;---------&quot;</span>);</span><br><span class="line">            <span class="comment">//客户端需要输入信息，创建一个扫描器</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="comment">//通过channel发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(s + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GroupChatClient</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>GroupChatClientHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 14:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-12-Netty-心跳检测机制案例"><a href="#6-12-Netty-心跳检测机制案例" class="headerlink" title="6.12   Netty 心跳检测机制案例"></a>6.12   Netty 心跳检测机制案例</h2><p>实例要求:</p>
<ol>
<li><p>编写一个 Netty 心跳检测机制案例, 当服务器超过 3 秒没有读时，就提示读空闲</p>
</li>
<li><p>当服务器超过 5 秒没有写操作时，就提示写空闲</p>
</li>
<li><p>实现当服务器超过 7 秒没有读或者写操作时，就提示读写空闲</p>
</li>
<li><p>代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.heartbeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 16:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO)) <span class="comment">//在bossGroup添加一个日志处理器</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            <span class="comment">//加入一个netty 提供的IdleStateHandler：处理空闲状态的处理器</span></span><br><span class="line">                            <span class="comment">// long readerIdleTime：表示多长时间没有读，就会发送一个心跳检测包，检测是否连接</span></span><br><span class="line">                            <span class="comment">// long writerIdleTime：表示多长时间没有写，就会发送一个心跳检测包，检测是否连接</span></span><br><span class="line">                            <span class="comment">// long allIdleTime：表示多长时间没有读写，就会发送一个心跳检测包，检测是否连接</span></span><br><span class="line">                            <span class="comment">//当IdleStateHandler触发后，就会传递给管道的下一个handler去处理，通过调用（触发）下一个handler的userEventTriggered去处理</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line">                            <span class="comment">//加入一个对空闲检测进一步处理的handler（自定义）</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//启动服务器</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.heartbeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 17:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt 事件</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            <span class="comment">//将evt 向下转型 IdleStateEvent</span></span><br><span class="line">            <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">            <span class="type">String</span> <span class="variable">eventType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state())&#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读空闲&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;写空闲&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读写空闲&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot;--超时时间--&quot;</span> + eventType);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221030173646593.png" alt="image-20221030173646593"></p>
<h2 id="6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接"><a href="#6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接" class="headerlink" title="6.13   Netty 通过 WebSocket 编程实现服务器和客户端长连接"></a>6.13   Netty 通过 WebSocket 编程实现服务器和客户端长连接</h2><p>实例要求:</p>
<ol>
<li><p>Http 协议是无状态的, 浏览器和服务器间的请求响应一次，下一次会重新创建连接.</p>
</li>
<li><p>要求：实现基于 webSocket 的长连接的全双工的交互</p>
</li>
<li><p>改变 Http 协议多次请求的约束，实现长连接了， 服务器可以发送消息给浏览器</p>
</li>
<li><p>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</p>
</li>
<li><p>运行界面</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2023/03/20/Netty/image-20221030114911232.png" alt="image-20221030114911232"></p>
<p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.websocket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.heartbeat.MyServerHandler; <span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture; <span class="keyword">import</span> io.netty.channel.ChannelInitializer; <span class="keyword">import</span> io.netty.channel.ChannelPipeline; <span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup; <span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler; <span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler; <span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler; <span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); <span class="comment">//8 个 NioEventLoop try &#123;</span></span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line">        serverBootstrap.group(bossGroup, workerGroup); </span><br><span class="line">        serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">        serverBootstrap.handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO)); </span><br><span class="line">        serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">                <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                <span class="comment">//因为基于 http 协议，使用 http 的编码和解码器</span></span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">                <span class="comment">//是以块方式写，添加 ChunkedWriteHandler 处理器</span></span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                说明</span></span><br><span class="line"><span class="comment">                1.	http 数据在传输过程中是分段, HttpObjectAggregator ，就是可以将多个段聚合</span></span><br><span class="line"><span class="comment">                2.	这就就是为什么，当浏览器发送大量数据时，就会发出多次 http 请求</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">8192</span>));</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                说明</span></span><br><span class="line"><span class="comment">                1.	对应 websocket ，它的数据是以 帧(frame) 形式传递</span></span><br><span class="line"><span class="comment">                2.	可以看到 WebSocketFrame 下面有六个子类</span></span><br><span class="line"><span class="comment">                3.	浏览器请求时 ws://localhost:7000/hello  表示请求的 uri</span></span><br><span class="line"><span class="comment">                4.	WebSocketServerProtocolHandler 核心功能是将 http 协议升级为 ws 协议 , 保持长连接</span></span><br><span class="line"><span class="comment">                5.	是通过一个 状态码 101</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> <span class="title class_">WebSocketServerProtocolHandler</span>(<span class="string">&quot;/hello2&quot;</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//自定义的 handler ，处理业务逻辑</span></span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyTextWebSocketFrameHandler</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动服务器</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">7000</span>).sync(); </span><br><span class="line">        channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully(); </span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.websocket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里 TextWebSocketFrame 类型，表示一个文本帧(frame)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt;&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到消息 &quot;</span> + msg.text());</span><br><span class="line">        <span class="comment">//回复消息</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(<span class="string">&quot; 服 务 器 时 间 &quot;</span> + LocalDateTime.now() + <span class="string">&quot; &quot;</span> + msg.text()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当 web 客户端连接后， 触发方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span></span><br><span class="line">            System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">            System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asShortText());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;handlerRemoved 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常发生 &quot;</span> + cause.getMessage());</span><br><span class="line">            ctx.close(); <span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            <span class="keyword">var</span> socket;</span><br><span class="line">            <span class="comment">//判断当前浏览器是否支持 websocket if(window.WebSocket) &#123;</span></span><br><span class="line">            <span class="comment">//go on</span></span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:7000/hello2&quot;</span>);</span><br><span class="line">            <span class="comment">//相当于 channelReado, ev 收到服务器端回送的消息</span></span><br><span class="line">            socket.onmessage = function (ev) &#123;</span><br><span class="line">            	<span class="type">var</span> <span class="variable">rt</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;responseText&quot;</span>); </span><br><span class="line">                rt.value = rt.value + <span class="string">&quot;\n&quot;</span> + ev.data;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//相当于连接开启(感知到连接开启)</span></span><br><span class="line">            socket.onopen = function (ev) &#123;</span><br><span class="line">                <span class="type">var</span> <span class="variable">rt</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;responseText&quot;</span>);</span><br><span class="line">                rt.value = <span class="string">&quot;连接开启了..&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//相当于连接关闭(感知到连接关闭) </span></span><br><span class="line">			socket.onclose = function (ev) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">var</span> <span class="variable">rt</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;responseText&quot;</span>); </span><br><span class="line">                rt.value = rt.value + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;连接关闭了..&quot;</span></span><br><span class="line">                alert(<span class="string">&quot;当前浏览器不支持 websocket&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送消息到服务器function send(message) &#123;</span></span><br><span class="line">            <span class="keyword">if</span>(!window.socket) &#123; <span class="comment">//先判断 socket 是否创建好</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket.readyState == WebSocket.OPEN) &#123;</span><br><span class="line">                <span class="comment">//通过 socket 发送消息</span></span><br><span class="line">                socket.send(message)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(<span class="string">&quot;连接没有开启&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;form onsubmit=<span class="string">&quot;return false&quot;</span>&gt;</span><br><span class="line">            &lt;textarea name=<span class="string">&quot;message&quot;</span> style=<span class="string">&quot;height: 300px; width: 300px&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;发生消息&quot;</span> onclick=<span class="string">&quot;send(this.form.message.value)&quot;</span>&gt;</span><br><span class="line">            &lt;textarea id=<span class="string">&quot;responseText&quot;</span> style=<span class="string">&quot;height: 300px; width: 300px&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;清空内容&quot;</span> onclick=<span class="string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">HUA</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/20/Netty/">http://example.com/2023/03/20/Netty/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">阿华</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/page3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/10/Docker/"><img class="prev-cover" src="/img/loading.gif" data-original="/img/page4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Docker</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/28/Nginx/"><img class="next-cover" src="/img/loading.gif" data-original="/img/page2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Nginx</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HUA</div><div class="author-info__description">不要放弃</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/TINGTING-GIT" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromld=45&amp;fromSubld=1&amp;subcmd=all&amp;uin=2164277973&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:2164277973@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div></div><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople1.js"></script><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/zdog.dist.js"></script><script id="rendered-js" src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0-Netty-%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">第 1 章 Netty 介绍和应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%9C%AC%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%A6%81%E6%B1%82"><span class="toc-number">1.1.</span> <span class="toc-text">1.1      本课程学习要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Netty-%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">1.2      Netty 的介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Netty-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.</span> <span class="toc-text">1.3      Netty 的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1 互联网行业</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E6%B8%B8%E6%88%8F%E8%A1%8C%E4%B8%9A"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2 游戏行业</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%86%E5%9F%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.3.3 大数据领域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-%E5%85%B6%E5%AE%83%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E5%88%B0Netty"><span class="toc-number">1.3.4.</span> <span class="toc-text">1.3.4 其它开源项目使用到Netty</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Netty-%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.4.</span> <span class="toc-text">1.4      Netty 的学习参考资料</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-Java-BIO-%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">第 2 章 Java BIO 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-I-x2F-O-%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">2.1      I&#x2F;O 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-I-x2F-O-%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1  I&#x2F;O 模型基本说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-BIO%E3%80%81NIO%E3%80%81AIO-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">2.2      BIO、NIO、AIO 适用场景分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Java-BIO-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.3.</span> <span class="toc-text">2.3      Java BIO 基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Java-BIO-%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">2.4      Java BIO 工作机制                     </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9-BIO-%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E7%9A%84%E6%A2%B3%E7%90%86"><span class="toc-number">2.4.0.1.</span> <span class="toc-text">对 BIO 编程流程的梳理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Java-BIO-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.5.</span> <span class="toc-text">2.5      Java BIO 应用实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-Java-BIO-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">2.6.</span> <span class="toc-text">2.6      Java BIO 问题分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-Java-NIO-%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">第 3 章 Java NIO 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Java-NIO-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">3.1      Java NIO 基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-NIO-%E5%92%8C-BIO-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.2.</span> <span class="toc-text">3.2      NIO 和 BIO 的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-NIO-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">3.3.</span> <span class="toc-text">3.3      NIO 三大核心原理示意图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-Selector-%E3%80%81-Channel-%E5%92%8C-Buffer-%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE-%E7%AE%80%E5%8D%95%E7%89%88"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 Selector 、 Channel 和 Buffer 的关系图(简单版)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%BC%93%E5%86%B2%E5%8C%BA-Buffer"><span class="toc-number">3.4.</span> <span class="toc-text">3.4      缓冲区(Buffer)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-Buffer-%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%AD%90%E7%B1%BB"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2 Buffer 类及其子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-ByteBuffer"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3 ByteBuffer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E9%80%9A%E9%81%93-Channel"><span class="toc-number">3.5.</span> <span class="toc-text">3.5      通道(Channel)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1	基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-FileChannel-%E7%B1%BB"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2 FileChannel 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-1-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">3.5.3.</span> <span class="toc-text">3.5.3 应用实例 1-本地文件写数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-2-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">3.5.4.</span> <span class="toc-text">3.5.4 应用实例 2-本地文件读数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-5-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-3-%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AABuffer-%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E3%80%81%E5%86%99%E5%85%A5"><span class="toc-number">3.5.5.</span> <span class="toc-text">3.5.5 应用实例 3-使用一个Buffer 完成文件读取、写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-6-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-4-%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6transferFrom-%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.6.</span> <span class="toc-text">3.5.6 应用实例 4-拷贝文件transferFrom 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-7-%E5%85%B3%E4%BA%8EBuffer-%E5%92%8C-Channel-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">3.5.7.</span> <span class="toc-text">3.5.7 关于Buffer 和 Channel 的注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-Selector-%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">3.6.</span> <span class="toc-text">3.7    Selector(选择器)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.6.1.</span> <span class="toc-text">3.7.1 基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2Selector-%E7%A4%BA%E6%84%8F%E5%9B%BE%E5%92%8C%E7%89%B9%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="toc-number">3.6.2.</span> <span class="toc-text">3.7.2	Selector 示意图和特点说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3-Selector-%E7%B1%BB%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.3.</span> <span class="toc-text">3.7.3   Selector 类相关方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-4-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.6.4.</span> <span class="toc-text">3.7.4 注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-NIO-%E9%9D%9E%E9%98%BB%E5%A1%9E-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%9B%BE"><span class="toc-number">3.7.</span> <span class="toc-text">3.8    NIO 非阻塞 网络编程原理分析图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-NIO-%E9%9D%9E%E9%98%BB%E5%A1%9E-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">3.8.</span> <span class="toc-text">3.9    NIO 非阻塞 网络编程快速入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-SelectionKey"><span class="toc-number">3.9.</span> <span class="toc-text">3.10  SelectionKey</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-11-ServerSocketChannel"><span class="toc-number">3.10.</span> <span class="toc-text">3.11  ServerSocketChannel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-12-SocketChannel"><span class="toc-number">3.11.</span> <span class="toc-text">3.12  SocketChannel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-13-NIO-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.12.</span> <span class="toc-text">3.13  NIO 网络编程应用实例-群聊系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-14-NIO-%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.13.</span> <span class="toc-text">3.14  NIO 与零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-1-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.13.1.</span> <span class="toc-text">3.14.1   零拷贝基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-2-%E4%BC%A0%E7%BB%9FIO-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-number">3.13.2.</span> <span class="toc-text">3.14.2   传统IO 数据读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-3%E4%BC%A0%E7%BB%9FIO-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.13.3.</span> <span class="toc-text">3.14.3	传统IO 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-4-mmap-%E4%BC%98%E5%8C%96"><span class="toc-number">3.13.4.</span> <span class="toc-text">3.14.4   mmap 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-5-sendFile-%E4%BC%98%E5%8C%96"><span class="toc-number">3.13.5.</span> <span class="toc-text">3.14.5   sendFile 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-6-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3"><span class="toc-number">3.13.6.</span> <span class="toc-text">3.14.6     零拷贝的再次理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-7-mmap-%E5%92%8C-sendFile-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.13.7.</span> <span class="toc-text">3.14.7     mmap 和 sendFile 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-8-NIO-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%A1%88%E4%BE%8B"><span class="toc-number">3.13.8.</span> <span class="toc-text">3.14.8   NIO 零拷贝案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-15-Java-AIO-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.14.</span> <span class="toc-text">3.15  Java AIO 基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-16-BIO%E3%80%81NIO%E3%80%81AIO-%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">3.15.</span> <span class="toc-text">3.16  BIO、NIO、AIO 对比表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-Netty-%E6%A6%82%E8%BF%B0"><span class="toc-number">4.</span> <span class="toc-text">第 4 章 Netty 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E5%8E%9F%E7%94%9F-NIO-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">4.1	原生 NIO 存在的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Netty-%E5%AE%98%E7%BD%91%E8%AF%B4%E6%98%8E"><span class="toc-number">4.2.</span> <span class="toc-text">4.2      Netty 官网说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Netty-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">4.3.</span> <span class="toc-text">4.3      Netty 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Netty-%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="toc-number">4.4.</span> <span class="toc-text">4.4      Netty 版本说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-Netty-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">第 5 章 Netty 高性能架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.</span> <span class="toc-text">5.1      线程模型基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9E-I-x2F-O-%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">5.2      传统阻塞 I&#x2F;O 服务模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1 工作原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E6%A8%A1%E5%9E%8B%E7%89%B9%E7%82%B9"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2 模型特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3 问题分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Reactor-%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">5.3      Reactor 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E9%92%88%E5%AF%B9%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9E-I-x2F-O-%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E7%9A%84-2-%E4%B8%AA%E7%BC%BA%E7%82%B9%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1 针对传统阻塞 I&#x2F;O 服务模型的 2 个缺点，解决方案：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-I-x2F-O-%E5%A4%8D%E7%94%A8%E7%BB%93%E5%90%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E5%B0%B1%E6%98%AF-Reactor-%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%EF%BC%8C%E5%A6%82%E5%9B%BE"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2 I&#x2F;O 复用结合线程池，就是 Reactor 模式基本设计思想，如图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-Reactor-%E6%A8%A1%E5%BC%8F%E4%B8%AD-%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%EF%BC%9A"><span class="toc-number">5.3.3.</span> <span class="toc-text">5.3.3 Reactor 模式中 核心组成：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-Reactor-%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">5.3.4.</span> <span class="toc-text">5.3.4 Reactor 模式分类：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%8D%95-Reactor-%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.4.</span> <span class="toc-text">5.4      单 Reactor 单线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E6%96%B9%E6%A1%88%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1 方案说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2 方案优缺点分析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E5%8D%95Reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.5.</span> <span class="toc-text">5.5      单Reactor 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">5.5.1.</span> <span class="toc-text">5.5.1 原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2-%E5%AF%B9%E4%B8%8A%E5%9B%BE%E7%9A%84%E5%B0%8F%E7%BB%93"><span class="toc-number">5.5.2.</span> <span class="toc-text">5.5.2 对上图的小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-3-%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">5.5.3.</span> <span class="toc-text">1.5.3 方案优缺点分析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E4%B8%BB%E4%BB%8E-Reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.6.</span> <span class="toc-text">5.6      主从 Reactor 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">5.6.1.</span> <span class="toc-text">5.6.1 工作原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-2-%E4%B8%8A%E5%9B%BE%E7%9A%84%E6%96%B9%E6%A1%88%E8%AF%B4%E6%98%8E"><span class="toc-number">5.6.2.</span> <span class="toc-text">5.6.2 上图的方案说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-3-Scalable-IO-in-Java-%E5%AF%B9-Multiple-Reactors-%E7%9A%84%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3%EF%BC%9A"><span class="toc-number">5.6.3.</span> <span class="toc-text">5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-4-%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">5.6.4.</span> <span class="toc-text">5.6.4 方案优缺点说明：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-Reactor-%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%BB%93"><span class="toc-number">5.7.</span> <span class="toc-text">5.7      Reactor 模式小结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-1-3%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%94%A8%E7%94%9F%E6%B4%BB%E6%A1%88%E4%BE%8B%E6%9D%A5%E7%90%86%E8%A7%A3"><span class="toc-number">5.7.1.</span> <span class="toc-text">5.7.1 3种模式用生活案例来理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-2-Reactor-%E6%A8%A1%E5%BC%8F%E5%85%B7%E6%9C%89%E5%A6%82%E4%B8%8B%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">5.7.2.</span> <span class="toc-text">5.7.2 Reactor 模式具有如下的优点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-Netty-%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.8.</span> <span class="toc-text">5.8      Netty 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE-1-%E7%AE%80%E5%8D%95%E7%89%88"><span class="toc-number">5.8.1.</span> <span class="toc-text">5.8.1 工作原理示意图 1-简单版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-2-%E5%AF%B9%E4%B8%8A%E5%9B%BE%E8%AF%B4%E6%98%8E"><span class="toc-number">5.8.2.</span> <span class="toc-text">5.8.2 对上图说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-3-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE-2-%E8%BF%9B%E9%98%B6%E7%89%88"><span class="toc-number">5.8.3.</span> <span class="toc-text">5.8.3 工作原理示意图 2-进阶版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-4-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE-%E8%AF%A6%E7%BB%86%E7%89%88"><span class="toc-number">5.8.4.</span> <span class="toc-text">5.8.4 工作原理示意图-详细版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-5-%E5%AF%B9%E4%B8%8A%E5%9B%BE%E7%9A%84%E8%AF%B4%E6%98%8E%E5%B0%8F%E7%BB%93"><span class="toc-number">5.8.5.</span> <span class="toc-text">1.8.5 对上图的说明小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-6-Netty-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B-TCP-%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.8.6.</span> <span class="toc-text">5.8.6 Netty 快速入门实例-TCP 服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-7-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84-Task-%E6%9C%89-3-%E7%A7%8D%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.8.7.</span> <span class="toc-text">5.8.7 任务队列中的 Task 有 3 种典型使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-8-%E6%96%B9%E6%A1%88%E5%86%8D%E8%AF%B4%E6%98%8E"><span class="toc-number">5.8.8.</span> <span class="toc-text">5.8.8 方案再说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.9.</span> <span class="toc-text">5.9      异步模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.9.1.</span> <span class="toc-text">5.9.1 基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-2-Future-%E8%AF%B4%E6%98%8E"><span class="toc-number">5.9.2.</span> <span class="toc-text">5.9.2 Future 说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-3-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">5.9.3.</span> <span class="toc-text">5.9.3 工作原理示意图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-4-Future-Listener-%E6%9C%BA%E5%88%B6"><span class="toc-number">5.9.4.</span> <span class="toc-text">5.9.4 Future-Listener 机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B-HTTP-%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.10.</span> <span class="toc-text">5.10   快速入门实例-HTTP 服务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-6-%E7%AB%A0-Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6"><span class="toc-number">6.</span> <span class="toc-text">第 6 章 Netty核心模块组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Bootstrap%E3%80%81ServerBootstrap"><span class="toc-number">6.1.</span> <span class="toc-text">6.1   Bootstrap、ServerBootstrap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Future%E3%80%81ChannelFuture"><span class="toc-number">6.2.</span> <span class="toc-text">6.2      Future、ChannelFuture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-Channel"><span class="toc-number">6.3.</span> <span class="toc-text">6.3      Channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-Selector"><span class="toc-number">6.4.</span> <span class="toc-text">6.4      Selector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-ChannelHandler-%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">6.5.</span> <span class="toc-text">6.5      ChannelHandler 及其实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-Pipeline-%E5%92%8C-ChannelPipeline"><span class="toc-number">6.6.</span> <span class="toc-text">6.6      Pipeline 和 ChannelPipeline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-ChannelHandlerContext"><span class="toc-number">6.7.</span> <span class="toc-text">6.7      ChannelHandlerContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-ChannelOption"><span class="toc-number">6.8.</span> <span class="toc-text">6.8      ChannelOption</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-EventLoopGroup-%E5%92%8C%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB-NioEventLoopGroup"><span class="toc-number">6.9.</span> <span class="toc-text">6.9      EventLoopGroup 和其实现类 NioEventLoopGroup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10-Unpooled-%E7%B1%BB"><span class="toc-number">6.10.</span> <span class="toc-text">6.10   Unpooled 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-11-Netty-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.11.</span> <span class="toc-text">6.11   Netty 应用实例-群聊系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-12-Netty-%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6%E6%A1%88%E4%BE%8B"><span class="toc-number">6.12.</span> <span class="toc-text">6.12   Netty 心跳检测机制案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-13-Netty-%E9%80%9A%E8%BF%87-WebSocket-%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="toc-number">6.13.</span> <span class="toc-text">6.13   Netty 通过 WebSocket 编程实现服务器和客户端长连接</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/07/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/" title="无题"><img src="/img/loading.gif" data-original="/img/page3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/10/07/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/" title="无题">无题</a><time datetime="2023-10-07T15:09:36.518Z" title="发表于 2023-10-07 23:09:36">2023-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/06/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程"><img src="/img/loading.gif" data-original="/img/page4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC并发编程"/></a><div class="content"><a class="title" href="/2023/10/06/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程">JUC并发编程</a><time datetime="2023-10-06T06:55:28.000Z" title="发表于 2023-10-06 14:55:28">2023-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/04/PandaSearch/" title="无题"><img src="/img/loading.gif" data-original="/img/page6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/10/04/PandaSearch/" title="无题">无题</a><time datetime="2023-10-04T04:59:36.140Z" title="发表于 2023-10-04 12:59:36">2023-10-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/01/Elasticsearch/" title="无题"><img src="/img/loading.gif" data-original="/img/page4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/10/01/Elasticsearch/" title="无题">无题</a><time datetime="2023-10-01T01:50:57.541Z" title="发表于 2023-10-01 09:50:57">2023-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/29/DeBug/" title="无题"><img src="/img/loading.gif" data-original="/img/page5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/09/29/DeBug/" title="无题">无题</a><time datetime="2023-09-29T02:59:28.368Z" title="发表于 2023-09-29 10:59:28">2023-09-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By HUA</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/tzy13755126023/BLOG_SOURCE/theme_f/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(e){e.imageLazyLoadSetting.processImages=t;var n=e.imageLazyLoadSetting.isSPA,i=e.imageLazyLoadSetting.preloadRatio||1,r=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){n&&(r=o());for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(e.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];e=function(){r=r.filter(function(t){return o!==t})},(t=o).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,t.removeAttribute("data-original"),e&&e()},t.src!==i&&(n.src=i))}()}function a(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",a),e.addEventListener("resize",a),e.addEventListener("orientationchange",a)}(this);</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>