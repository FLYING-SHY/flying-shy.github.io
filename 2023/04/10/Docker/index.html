<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Docker | 阿华</title><meta name="author" content="HUA"><meta name="copyright" content="HUA"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="一、基本篇1、Docker简介1.1、Docker理念Docker用Go编程语言编写，并利用Linux内核的多种功能来交付其功能。 Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次镜像，处处运行”。  Li">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="http://example.com/2023/04/10/Docker/index.html">
<meta property="og:site_name" content="阿华">
<meta property="og:description" content="一、基本篇1、Docker简介1.1、Docker理念Docker用Go编程语言编写，并利用Linux内核的多种功能来交付其功能。 Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次镜像，处处运行”。  Li">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/page4.jpg">
<meta property="article:published_time" content="2023-04-10T01:47:09.000Z">
<meta property="article:modified_time" content="2023-10-14T08:26:16.539Z">
<meta property="article:author" content="HUA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/page4.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/10/Docker/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-14 16:26:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">阿华</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Docker</h1><div id="post-meta"><div class="meta-firstline"></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">47.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>193分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Docker"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="一、基本篇"><a href="#一、基本篇" class="headerlink" title="一、基本篇"></a>一、基本篇</h1><h2 id="1、Docker简介"><a href="#1、Docker简介" class="headerlink" title="1、Docker简介"></a>1、Docker简介</h2><h3 id="1-1、Docker理念"><a href="#1-1、Docker理念" class="headerlink" title="1.1、Docker理念"></a>1.1、Docker理念</h3><p>Docker用Go编程语言编写，并利用Linux内核的多种功能来交付其功能。</p>
<p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“<strong>一次镜像，处处运行</strong>”。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141613150.png" alt="img"></p>
<p>Linux容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用打成镜像，通过镜像成为运行在Docker容器上面的实例，而 Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</p>
<p><strong>一句话解决了运行环境和配置问题的软件容器， 方便做持续集成并有助于整体发布的容器虚拟化技术。</strong></p>
<p><strong>小结：</strong></p>
<ul>
<li><strong>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</strong><ul>
<li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>
<li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li>
</ul>
</li>
<li><strong>Docker如何解决开发、测试、生产环境有差异的问题？</strong><ul>
<li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li>
</ul>
</li>
<li><strong>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</strong><ul>
<li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li>
<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>
<li>启动、移除都可以通过一行命令完成，方便快捷</li>
</ul>
</li>
</ul>
<h3 id="1-2、容器与虚拟机比较"><a href="#1-2、容器与虚拟机比较" class="headerlink" title="1.2、容器与虚拟机比较"></a>1.2、容器与虚拟机比较</h3><h4 id="传统虚拟机技术"><a href="#传统虚拟机技术" class="headerlink" title="传统虚拟机技术"></a>传统虚拟机技术</h4><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在Windows10系统里面运行Linux系统CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。</p>
<table>
<thead>
<tr>
<th>Win10</th>
<th>VMWare</th>
<th>Centos7</th>
<th>各种cpu、内存网络额配置+各种软件</th>
<th>虚拟机实例</th>
</tr>
</thead>
</table>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141613219.png" alt="img"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141613766.png" alt="img"></p>
<p>虚拟机的缺点：</p>
<ul>
<li>资源占用多</li>
<li>冗余步骤多</li>
<li>启动慢</li>
</ul>
<h4 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h4><p>由于前面虚拟机存在某些缺点，Linux发展出了另一种虚拟化技术：<strong>Linux容器(Linux Containers，缩写为 LXC)<strong>Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。 <strong>Linux 容器不是模拟一个完整的操作系统而是对进程进行隔离。</strong>有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。</strong>容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。</strong>系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141613834.png" alt="img"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141614708.png" alt="img"></p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141614138.png" alt="image-20220531104245070"></p>
<p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p>
<p><em>容器内的应用进程直接运行于宿主的内核，<strong>容器内没有自己的内核且也没有进行硬件虚拟</strong>。因此容器要比传统虚拟机更为轻便。</em></p>
<p> 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p>
<h3 id="1-3、Docker-如何工作？"><a href="#1-3、Docker-如何工作？" class="headerlink" title="1.3、Docker 如何工作？"></a>1.3、Docker 如何工作？</h3><p> Docker 技术使用 Linux 内核和内核功能（例如 Cgroups 和 namespaces）来分隔进程，以便各进程相互独立运行。这种独立性正是采用容器的目的所在；它可以独立运行多种进程、多个应用程序，更加充分地发挥基础设施的作用，同时保持各个独立系统的安全性。</p>
<p> 容器工具（包括 Docker）可提供基于镜像的部署模式。这使得它能够轻松跨多种环境，与其依赖程序共享应用或服务组。Docker 还可在这一容器环境中自动部署应用程序（或者合并多种流程，以构建单个应用程序）。</p>
<h3 id="1-4、Docker去哪下"><a href="#1-4、Docker去哪下" class="headerlink" title="1.4、Docker去哪下"></a>1.4、Docker去哪下</h3><ul>
<li>官网<ul>
<li><a target="_blank" rel="noopener" href="http://www.docker.com/">Docker 官网(opens new window)</a></li>
</ul>
</li>
<li>仓库<ul>
<li><a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub 官网(opens new window)</a></li>
</ul>
</li>
<li>相关官网<ul>
<li>Docker 官方主页: <a target="_blank" rel="noopener" href="https://www.docker.com/">https://www.docker.com(opens new window)</a></li>
<li>Docker 官方博客: <a target="_blank" rel="noopener" href="https://blog.docker.com/">https://blog.docker.com(opens new window)</a></li>
<li>Docker 官方文档: <a target="_blank" rel="noopener" href="https://docs.docker.com/">https://docs.docker.com(opens new window)</a></li>
<li>Docker 安装文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install">https://docs.docker.com/engine/install(opens new window)</a></li>
<li>Docker Store: <a target="_blank" rel="noopener" href="https://store.docker.com/">https://store.docker.com(opens new window)</a></li>
<li>Docker Cloud: <a target="_blank" rel="noopener" href="https://cloud.docker.com/">https://cloud.docker.com(opens new window)</a></li>
<li>Docker Hub: <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com(opens new window)</a></li>
<li>Docker 中文文档：<a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/">https://vuepress.mirror.docker-practice.com/</a></li>
</ul>
</li>
</ul>
<h2 id="2、Docker架构"><a href="#2、Docker架构" class="headerlink" title="2、Docker架构"></a>2、Docker架构</h2><h3 id="2-1、镜像、容器和仓库"><a href="#2-1、镜像、容器和仓库" class="headerlink" title="2.1、镜像、容器和仓库"></a>2.1、镜像、容器和仓库</h3><p>Docker中有几个重要的概念：</p>
<ul>
<li><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</li>
</ul>
<p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，<strong>一个镜像可以创建很多容器</strong>。</p>
<p>它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。</p>
<p>相当于容器的“源代码”，<strong>docker镜像文件类似于Java的类模板，而docker容器实例类似于java中new出来的实例对象</strong>。</p>
<p>容器与镜像的关系类似于面向对象编程中的对象与类：</p>
<table>
<thead>
<tr>
<th>Docker</th>
<th>面向对象</th>
</tr>
</thead>
<tbody><tr>
<td>容器</td>
<td>对象</td>
</tr>
<tr>
<td>镜像</td>
<td>类</td>
</tr>
</tbody></table>
<ul>
<li><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</li>
</ul>
<ol>
<li><strong>从面向对象角度</strong></li>
</ol>
<p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，<strong>容器是用镜像创建的运行实例</strong>。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p>
<ol>
<li><strong>从镜像容器角度</strong></li>
</ol>
<p><strong>可以把容器看做是一个简易版的</strong> <strong>Linux</strong> <strong>环境</strong>（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
<ul>
<li><strong>仓库(repository)</strong></li>
</ul>
<p>仓库（Repository）是集中存放镜像文件的场所。</p>
<p>类似于Maven仓库，存放各种jar包的地方；github仓库，存放各种git项目的地方；Docker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。</p>
<p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p>
<p><strong>最大的公开仓库是 DockerHub</strong>(<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/ (opens new window)</a>)，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141614375.png" alt="image-20220531104638396"></p>
<p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p>
<p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p>
<p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中运行，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p>
<p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p>
<h3 id="2-2、DockerHub"><a href="#2-2、DockerHub" class="headerlink" title="2.2、DockerHub"></a>2.2、DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如<code>Redis</code>、<code>MySQL</code>镜像放到网络上，共享使用，就像<code>GitHub</code>的代码共享一样。</p>
<ul>
<li><strong>DockerHub</strong>：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</li>
<li>国内也有类似于DockerHub 的公开服务，比如 <a target="_blank" rel="noopener" href="https://c.163yun.com/hub">网易云镜像服务</a>、<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</li>
</ul>
<p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141614897.png" alt="image-20220531105015867"></p>
<h3 id="2-3、Doker架构-入门版"><a href="#2-3、Doker架构-入门版" class="headerlink" title="2.3、Doker架构(入门版)"></a>2.3、Doker架构(入门版)</h3><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141614200.png" alt="image-20221008204201004"></p>
<blockquote>
<p>K8S：CRI（Container Runtime Interface）</p>
<p>Client： 客户端；操作docker服务器的客户端（命令行或者界面）</p>
<p>Docker_Host：Docker主机；安装Docker服务的主机</p>
<p>Docker_Daemon：后台进程；运行在Docker服务器的后台进程</p>
<p>Containers：容器；在Docker服务器中的容器（一个容器一般是一个应用实例，容器间互相隔离）</p>
<p>Images：镜像、映像、程序包；Image是只读模板，其中包含创建Docker容器的说明。容器是由Image运行而来，Image固定不变。</p>
<p>Registries：仓库；存储Docker Image的地方。官方远程仓库地址： <a target="_blank" rel="noopener" href="https://hub.docker.com/search">https://hub.docker.com/search</a></p>
</blockquote>
<p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p>
<p>Docker是一个CS架构的程序，由两部分组成：</p>
<ul>
<li>**服务端(server)**：Docker守护进程，负责处理Docker指令，管理镜像、容器等</li>
<li>**客户端(client)**：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li>
</ul>
<h3 id="2-4、Docker平台架构图解-架构版"><a href="#2-4、Docker平台架构图解-架构版" class="headerlink" title="2.4、Docker平台架构图解(架构版)"></a>2.4、Docker平台架构图解(架构版)</h3><p>Docker 是一个 C&#x2F;S 模式的架构，后端是一个松耦合架构，众多模块各司其职。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141614638.webp" alt="image"></p>
<p>Docker运行的基本流程：</p>
<ol>
<li>用户是使用Docker Client与 Docker Daemon建立通信，并发送请求给后者。</li>
<li>Docker Daemon作为Docker架构中的主体部分，首先提供Docker Server的功能使其可以接受Docker Client 的请求。</li>
<li>Docker Engine执行Docker 内部的一系列工作，每一项工作都是以一个Job的形式的存在。</li>
<li>Job的运行过程中，当需要容器镜像时，则从Docker Registry 中下载镜像，并通过镜像管理驱动Graph driver将下载镜像以Graph的形式存储。</li>
<li>当需要为Docker创建网络环境时，通过网络管理驱动Network driver创建并配置Docker容器网络环境。</li>
<li>当需要限制Docker容器运行资源或执行用户指令等操作时，则通过Exec driver来完成。</li>
<li>Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。</li>
</ol>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141614360.webp" alt="image"></p>
<h3 id="2-5、小结"><a href="#2-5、小结" class="headerlink" title="2.5、小结"></a>2.5、小结</h3><p>镜像：</p>
<ul>
<li>将应用程序及其依赖、环境、配置打包在一起</li>
</ul>
<p>容器：</p>
<ul>
<li>镜像运行起来就是容器，一个镜像可以运行多个容器</li>
</ul>
<p>Docker结构：</p>
<ul>
<li>服务端：接收命令或远程请求，操作镜像或容器</li>
<li>客户端：发送命令或者请求到Docker服务端</li>
</ul>
<p>DockerHub：</p>
<ul>
<li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li>
</ul>
<h2 id="3、Docker隔离原理"><a href="#3、Docker隔离原理" class="headerlink" title="3、Docker隔离原理"></a>3、Docker隔离原理</h2><ul>
<li><strong>namespace 6 项隔离 （资源隔离）</strong></li>
</ul>
<table>
<thead>
<tr>
<th><strong>namespace</strong></th>
<th><strong>系统调用参数</strong></th>
<th><strong>隔离内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>主机和域名</td>
</tr>
<tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>信号量、消息队列和共享内存</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>进程编号</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>网络设备、网络栈、端口等</td>
</tr>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>挂载点(文件系统)</td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>用户和用户组</td>
</tr>
</tbody></table>
<ul>
<li><strong>cgroups 资源限制 （资源限制）</strong></li>
</ul>
<p>cgroup提供的主要功能如下：</p>
<ul>
<li><ul>
<li>资源限制：限制任务使用的资源总额，并在超过这个 配额 时发出提示</li>
<li>优先级分配：分配CPU时间片数量及磁盘IO带宽大小、控制任务运行的优先级</li>
<li>资源统计：统计系统资源使用量，如CPU使用时长、内存用量等</li>
<li>任务控制：对任务执行挂起、恢复等操作</li>
</ul>
</li>
</ul>
<blockquote>
<p>cgroup资源控制系统，每种子系统独立地控制一种资源。功能如下</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>子系统</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>cpu</td>
<td>使用调度程序控制任务对CPU的使用</td>
</tr>
<tr>
<td>cpuacct(CPU Accounting)</td>
<td>自动生成cgroup中任务对CPU资源使用情况的报告</td>
</tr>
<tr>
<td>cpuset</td>
<td>为cgroup中的任务分配独立的CPU(多处理器系统时)和内存</td>
</tr>
<tr>
<td>devices</td>
<td>开启或关闭cgroup中任务对设备的访问</td>
</tr>
<tr>
<td>freezer</td>
<td>挂起或恢复cgroup中的任务</td>
</tr>
<tr>
<td>memory</td>
<td>设定cgroup中任务对内存使用量的限定，并生成这些任务对内存资源使用情况的报告</td>
</tr>
<tr>
<td>perf_event(Linux CPU性能探测器)</td>
<td>使cgroup中的任务可以进行统一的性能测试</td>
</tr>
<tr>
<td>net_cls(Docker未使用)</td>
<td>通过等级识别符标记网络数据包，从而允许Linux流量监控程序(Tra?icController)识别从具体cgroup中生成的数据包</td>
</tr>
</tbody></table>
<h2 id="4、Docker安装"><a href="#4、Docker安装" class="headerlink" title="4、Docker安装"></a>4、Docker安装</h2><blockquote>
<p>以下以centos为例；</p>
<p>更多其他安装方式，详细参照文档： <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141614835.webp" alt="image"></p>
<h3 id="4-1、前提条件"><a href="#4-1、前提条件" class="headerlink" title="4.1、前提条件"></a>4.1、<strong>前提条件</strong></h3><p>目前，CentOS 仅发行版本中的内核支持 Docker。<strong>Docker 运行在CentOS 7 (64-bit)上，</strong></p>
<p><strong>要求系统为64位、Linux系统内核版本为 3.8以上，这里选用Centos7.x</strong></p>
<p><strong>查看自己的内核</strong></p>
<p>uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua ~]# cat /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.9.2009 (Core)</span><br><span class="line">[root@hua ~]# uname -r</span><br><span class="line">3.10.0-1160.el7.x86_64</span><br><span class="line">[root@hua ~]#</span><br></pre></td></tr></table></figure>

<p>该 <code>centos-extras</code> 库必须启用。默认情况下启用此存储库，但如果您已禁用它，则需要 <a target="_blank" rel="noopener" href="https://wiki.centos.org/AdditionalResources/Repositories">重新启用它 (opens new window)</a>。</p>
<p><code>overlay2</code> 推荐使用存储驱动。</p>
<h3 id="4-2、安装步骤"><a href="#4-2、安装步骤" class="headerlink" title="4.2、安装步骤"></a>4.2、安装步骤</h3><h4 id="4-2-1、卸载旧版本"><a href="#4-2-1、卸载旧版本" class="headerlink" title="4.2.1、卸载旧版本"></a>4.2.1、卸载旧版本</h4><p>旧版本的 Docker 被称为 <code>docker</code> 或 <code>docker-engine</code>。如果安装了这些，请卸载它们以及相关的依赖项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                docker-client \</span><br><span class="line">                docker-client-latest \</span><br><span class="line">                docker-common \</span><br><span class="line">                docker-latest \</span><br><span class="line">                docker-latest-logrotate \</span><br><span class="line">                docker-logrotate \</span><br><span class="line">                docker-engine</span><br></pre></td></tr></table></figure>

<p>如果 <code>yum</code> 报告没有安装这些软件包，那也没关系，只是说明曾经没安装过，不影响任何东西。</p>
<p>卸载并不会全部卸载，如图像、容器、卷和网络，将被保留，以及 <code>/var/lib/docker/</code> 的内容</p>
<p>Docker 引擎包现在被称为 <code>docker-ce</code>。</p>
<h4 id="4-2-2、yum安装gcc相关"><a href="#4-2-2、yum安装gcc相关" class="headerlink" title="4.2.2、yum安装gcc相关"></a>4.2.2、yum安装gcc相关</h4><p>保证CentOS能够正常上网。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3、安装软件包"><a href="#4-2-3、安装软件包" class="headerlink" title="4.2.3、安装软件包"></a>4.2.3、安装软件包</h4><p>首先说明下：Docker 安装路径是 <code>/var/lib/docker</code>，安装 Docker 成功后，在该路径中有一个 image 和 containers 文件夹，分别存放镜像和实例。</p>
<p>您可以根据需要以不同方式安装 Docker Engine：</p>
<ul>
<li>从 Docker 的存储库或者其他镜像库里下载，这是最推荐的方法</li>
<li>下载 RPM 包并手动安装并完全手动管理升级。这在某些情况下非常有用，例如在无法访问互联网的气隙系统上安装 Docker</li>
<li>便捷脚本安装 Docker，可以在测试和开发环境中安装</li>
</ul>
<p>在新主机上首次安装 Docker Engine 之前，您需要设置 Docker 存储库。之后，您可以从存储库安装和更新 Docker。</p>
<p>安装 <code>yum-utils</code> 包，它提供 <code>yum-config-manager</code> 实用程序</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4、设置镜像仓库"><a href="#4-2-4、设置镜像仓库" class="headerlink" title="4.2.4、设置镜像仓库"></a>4.2.4、<strong>设置镜像仓库</strong></h4><p>设置稳定版本的仓库</p>
<p>官网（国外）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">		--add-repo \</span><br><span class="line">		https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>阿里云（国内）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    	--add-repo \</span><br><span class="line">		http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>阿里云仓库也是定期从官网仓库进行更新引用，两者仓库量无太大区别，如果配置了阿里云仓库，也要配置阿里云镜像加速，即下载速度源由官网改为阿里云。</p>
<ul>
<li>最新版本安装</li>
<li>特定版本安装</li>
</ul>
<h4 id="4-2-5、更新yum软件包索引"><a href="#4-2-5、更新yum软件包索引" class="headerlink" title="4.2.5、更新yum软件包索引"></a>4.2.5、更新yum软件包索引</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<h4 id="4-2-6、安装Docker-CE"><a href="#4-2-6、安装Docker-CE" class="headerlink" title="4.2.6、安装Docker CE"></a>4.2.6、安装Docker CE</h4><p>安装 <strong>最新版本</strong> 的 Docker Engine 和 containerd：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum -y install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<p>如果希望自己手动确认一些安装条件，则把 <code>-y</code> 去掉。</p>
<p>如果报如下错误：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">No package docker-ce available.</span><br><span class="line">No package docker-ce-cli available.</span><br><span class="line">No package containerd.io available.</span><br></pre></td></tr></table></figure>

<p>要么你的 Linux 版本没到达 3.10.+，要么你忽略了上方的设置存储库，请设置官方或者阿里云的存储库，否则无法找到 Docker。</p>
<p>还有一种可能就是你的 yum 版本太低，请更新它。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新 yum</span></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS 7 更新索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS 8 更新索引</span></span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<p>安装 <strong>特定版本</strong> 的 Docker Engine，请在 repo 中列出可用版本，然后选择并安装</p>
<p>首先列出可以安装的版本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">docker-ce.x86_643:18.09.1-3.el7			docker-ce-stable</span><br><span class="line">docker-ce.x86_643:18.09.0-3.el7			docker-ce-stable</span><br><span class="line">docker-ce.x86_6418.06.1.ce-3.el7		docker-ce-stable</span><br><span class="line">docker-ce.x86_6418.06.e.ce-3.el7		docker-ce-stable</span><br></pre></td></tr></table></figure>

<p>返回的列表取决于启用的存储库，并且特定于您的 CentOS 版本（e17 就是 CentOS 7.x 版本，如果是 CentOS 8.2，则是 e18）</p>
<p>通过完全限定的包名称安装特定版本，即包名称 (<code>docker-ce</code>) 加上从第一个冒号 (<code>:</code>)开始的版本字符串（第 2 列），直到第一个连字符，由连字符 (<code>-</code>)分隔。例如：<code>docker-ce-18.09.1</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce-&lt;version&gt; docker-ce-cli-&lt;version&gt; containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line">sudo yum install docker-ce-18.09.1 docker-ce-cli-18.09.1 containerd.io</span><br></pre></td></tr></table></figure>

<p>此命令会安装 Docker，但不会启动 Docker。它还会创建一个 <code>docker</code> 组，但是，默认情况下它不会向该组添加任何用户。</p>
<h4 id="4-2-7、安装进阶"><a href="#4-2-7、安装进阶" class="headerlink" title="4.2.7、安装进阶"></a>4.2.7、安装进阶</h4><h5 id="以非root用户管理Docker"><a href="#以非root用户管理Docker" class="headerlink" title="以非root用户管理Docker"></a>以非root用户管理Docker</h5><p>Docker 守护进程绑定到 Unix 套接字而不是 TCP 端口。默认情况下，Unix 套接字归用户所有 <code>root</code>，其他用户只能使用 <code>sudo</code>. Docker 守护进程始终以<code>root</code> 用户身份运行。</p>
<p>如果您不想在 <code>docker</code> 命令前加上 <code>sudo</code>，请创建一个 <code>docker</code> 用户组并向其中添加用户。当 Docker 守护进程启动时，它会创建一个可由 <code>docker</code> 组成员访问的 Unix 套接字。</p>
<ol>
<li>创建 <code>docker</code> 组</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>

<p>​	2. 将您的用户添加到 <code>docker</code> 组中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注销并重新登录，以便重新评估您的组成员身份。</li>
</ol>
<p>如果在虚拟机上进行测试，可能需要重新启动虚拟机以使更改生效。</p>
<p>在桌面 Linux 环境（例如 X Windows）上，完全注销会话，然后重新登录。</p>
<p>在 Linux 上，您还可以运行以下命令来激活对组的更改：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">newgrp docker </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>验证您可以在<code>docker</code>没有<code>sudo</code>.</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>此命令下载测试映像并在容器中运行它。当容器运行时，它会打印一条消息并退出。</p>
<p>如果您 <code>sudo</code> 在将用户添加到 <code>docker</code> 组之前最初使用 Docker CLI 命令运行，您可能会看到以下错误，这表明您的 <code>~/.docker/</code> 目录由于 <code>sudo</code> 命令而使用不正确的权限创建。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WARNING: Error loading config file: /home/user/.docker/config.json -</span><br><span class="line"><span class="built_in">stat</span> /home/user/.docker/config.json: permission denied</span><br></pre></td></tr></table></figure>

<p>要解决此问题，请删除 <code>~/.docker/</code> 目录（它会自动重新创建，但所有自定义设置都将丢失），或使用以下命令更改其所有权和权限：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> <span class="string">&quot;<span class="variable">$USER</span>&quot;</span>:<span class="string">&quot;<span class="variable">$USER</span>&quot;</span> /home/<span class="string">&quot;<span class="variable">$USER</span>&quot;</span>/.docker -R</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rwx <span class="string">&quot;<span class="variable">$HOME</span>/.docker&quot;</span> -R</span><br></pre></td></tr></table></figure>

<h5 id="配置Docker开机启动"><a href="#配置Docker开机启动" class="headerlink" title="配置Docker开机启动"></a>配置Docker开机启动</h5><p>多数当前的 Linux 发行版（RHEL、CentOS、Fedora、Debian、Ubuntu 16.04 及更高版本）用于 systemd 管理系统启动时启动的服务（就是 <code>systemctl</code> 命令）。在 Debian 和 Ubuntu 上，Docker 服务默认配置为在启动时启动。要在引导时为其他发行版自动启动 Docker 和 Containerd，请使用以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可省略 .service</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> containerd.servic</span><br></pre></td></tr></table></figure>

<p>要禁用此开机启动，请改用为 <code>disable</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可省略 .service</span></span><br><span class="line">sudo systemctl <span class="built_in">disable</span> docker.service</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> containerd.service</span><br></pre></td></tr></table></figure>

<h3 id="4-3、启动Docker"><a href="#4-3、启动Docker" class="headerlink" title="4.3、启动Docker"></a>4.3、启动Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p>测试是否启动成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行该命令</span></span><br><span class="line">sudo systemctl status docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行结果，出现 active (running) 代表启动成功</span></span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 五 2021-11-19 15:40:03 CST; 1s ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 29970 (dockerd)</span><br><span class="line">    Tasks: 11</span><br><span class="line">   Memory: 114.0M</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           └─29970 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure>

<p>其他命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 docker 的状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 docker 服务开启自启动</span></span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<p><strong>验证安装</strong></p>
<p>查看 Docker 版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p>查看 Docker 信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p><strong>测试运行</strong></p>
<p>通过运行 <code>hello-world</code> 映像验证 Docker Engine 是否已正确安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行该命令</span></span><br><span class="line">docker run hello-world</span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>

<p>此命令下载测试映像并在容器中运行它。当容器运行时，它会打印一条消息并退出。</p>
<h3 id="4-4、其他安装方式"><a href="#4-4、其他安装方式" class="headerlink" title="4.4、其他安装方式"></a>4.4、其他安装方式</h3><h4 id="4-4-1、从包安装"><a href="#4-4-1、从包安装" class="headerlink" title="4.4.1、从包安装"></a>4.4.1、从包安装</h4><p>如果您无法使用 Docker 的存储库来安装 Docker，您可以下载该<code>.rpm</code>版本的 文件并手动安装。每次要升级 Docker Engine 时都需要下载一个新文件。</p>
<p>前往 <a target="_blank" rel="noopener" href="https://download.docker.com/linux/centos/">https://download.docker.com/linux/centos/ (opens new window) (opens new window)</a>并选择您的 CentOS 版本。然后浏览 <code>x86_64/stable/Packages/</code> 并下载 <code>.rpm</code> 要安装的 Docker 版本的文件。</p>
<blockquote>
<p><strong>安装</strong></p>
</blockquote>
<p>安装 Docker Engine，将下面的路径更改为您下载 Docker 包的路径。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum install /path/to/package.rpm</span><br></pre></td></tr></table></figure>

<p>Docker 已安装但未启动。该 <code>docker</code> 组被创建，但没有用户添加到组。</p>
<blockquote>
<p><strong>启动 Docker</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p>其他命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 docker 的状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="comment"># 重启 docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 设置 docker 服务开启自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>验证安装</strong></p>
</blockquote>
<p>查看 Docker 版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p>查看 Docker 信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>测试运行</strong></p>
</blockquote>
<p>通过运行 <code>hello-world</code> 映像验证 Docker Engine 是否已正确安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>此命令下载测试映像并在容器中运行它。当容器运行时，它会打印一条消息并退出。</p>
<h4 id="4-4-2、便利脚本安装"><a href="#4-4-2、便利脚本安装" class="headerlink" title="4.4.2、便利脚本安装"></a>4.4.2、便利脚本安装</h4><p>Docker 在 <a target="_blank" rel="noopener" href="https://get.docker.com/">get.docker.com (opens new window) (opens new window)</a>上提供了一个方便的脚本，可以快速且非交互式地将 Docker 安装到开发环境中。不建议将便捷脚本用于生产环境，但可以用作示例来创建适合您需求的配置脚本。</p>
<p>在本地运行之前，请务必检查从 Internet 下载的脚本。在安装之前，让自己熟悉便利脚本的潜在风险和限制：</p>
<ul>
<li>脚本需要 <code>root</code> 或 <code>sudo</code> 特权才能运行。</li>
<li>该脚本会尝试检测您的 Linux 发行版和版本并为您配置包管理系统，并且不允许您自定义大多数安装参数。</li>
<li>该脚本无需确认即可安装依赖项和建议。这可能会安装大量软件包，具体取决于主机的当前配置。</li>
<li>默认情况下，该脚本会安装 Docker、containerd 和 runc 的最新稳定版本。使用此脚本配置机器时，可能会导致 Docker 的主要版本意外升级。在部署到生产系统之前，始终在测试环境中测试（主要）升级。</li>
<li>该脚本并非旨在升级现有的 Docker 安装。使用脚本更新现有安装时，依赖项可能不会更新到预期版本，从而导致使用过时的版本。</li>
</ul>
<blockquote>
<p><strong>安装</strong></p>
</blockquote>
<p>此示例从 <a target="_blank" rel="noopener" href="https://get.docker.com/">get.docker.com (opens new window) (opens new window)</a>下载脚本并运行它以在 Linux 上安装 Docker 的最新稳定版本，另外可以通过 <code>--mirror</code> 选项使用国内下载源进行安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh --mirror</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>启动 Docker</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p>其他命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 docker 的状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="comment"># 重启 docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 设置 docker 服务开启自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>创建 docker 用户组</strong></p>
</blockquote>
<p>便利脚本安装不会自动创建 docker 用户组，请手动安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>验证测试</strong></p>
</blockquote>
<p>查看 Docker 版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p>查看 Docker 信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>测试运行</strong></p>
</blockquote>
<p>通过运行 <code>hello-world</code> 映像验证 Docker Engine 是否已正确安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>此命令下载测试映像并在容器中运行它。当容器运行时，它会打印一条消息并退出。</p>
<h3 id="4-5、阿里云镜像加速器"><a href="#4-5、阿里云镜像加速器" class="headerlink" title="4.5、阿里云镜像加速器"></a>4.5、阿里云镜像加速器</h3><blockquote>
<p><strong>Docker 安装好以后，我们就要开始为拉取镜像准备了；国内从 DockerHub 拉取镜像有时会特别慢，此时可以配置镜像加速器。</strong></p>
</blockquote>
<p>Docker 官方和国内很多云服务商都提供了国内加速器服务，比如：</p>
<ul>
<li>阿里云的加速器：<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/60750.html">https://help.aliyun.com/document_detail/60750.html</a></li>
<li>网易加速器：<a target="_blank" rel="noopener" href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></li>
<li>Docker 官方中国加速器：<a target="_blank" rel="noopener" href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></li>
<li>ustc 的镜像：<a target="_blank" rel="noopener" href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></li>
<li>daocloud：<a target="_blank" rel="noopener" href="https://www.daocloud.io/mirror#accelerator-doc%EF%BC%88%E6%B3%A8%E5%86%8C%E5%90%8E%E4%BD%BF%E7%94%A8%EF%BC%89">https://www.daocloud.io/mirror#accelerator-doc（注册后使用）</a></li>
</ul>
<p>对于使用 systemd 的系统（CentOS 7.x 以上），请在 &#x2F;etc&#x2F;docker&#x2F;daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://registry.docker-cn.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种方式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="comment"># 下面是一个步骤，全部复制</span></span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://registry.docker-cn.com&quot;</span>]</span><br><span class="line">	&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>之后重新启动服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="4-5-1、配置阿里云镜像加速器"><a href="#4-5-1、配置阿里云镜像加速器" class="headerlink" title="4.5.1、配置阿里云镜像加速器"></a>4.5.1、配置阿里云镜像加速器</h4><ul>
<li>访问阿里云登录自己的账号查看 docker 镜像加速服务：<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors">https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors(opens new window)</a></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141614502.webp" alt="image"></p>
<p>操作步骤是统一的，不存在不同用户不同的操作步骤，我已经放到下面代码块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">阿里云的镜像是从docker hub来的，我们配置了加速，默认是从阿里云（缓存）下载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以后docker下载直接从阿里云拉取相关镜像</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/etc/docker/daemon.json 是Docker的核心配置文件。</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://gib4mdsy.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>之后重新启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载配置文件</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启Docker</span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>验证 docker 的镜像加速器是否生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# docker info</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">结果</span></span><br><span class="line">Client:</span><br><span class="line"> Context:    default</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> ...</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line"> Labels:</span><br><span class="line"> Experimental: false</span><br><span class="line"> Insecure Registries:</span><br><span class="line">  127.0.0.0/8</span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https://gib4mdsy.mirror.aliyuncs.com/</span><br><span class="line"> Live Restore Enabled: false</span><br></pre></td></tr></table></figure>

<h4 id="4-5-2、镜像查看和拉取"><a href="#4-5-2、镜像查看和拉取" class="headerlink" title="4.5.2、镜像查看和拉取"></a>4.5.2、镜像查看和拉取</h4><blockquote>
<p><strong>拉一个 docker 镜像试试吧？</strong></p>
</blockquote>
<p>拉取 hello world</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行改命令</span></span><br><span class="line">[root@master ~]<span class="comment"># docker pull hello-world:latest</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">Digest: sha256:2498fce14358aa50ead0cc6c19990fc6ff866ce72aeb5546e1d59caac3d0d60f</span><br><span class="line">Status: Image is up to <span class="built_in">date</span> <span class="keyword">for</span> hello-world:latest</span><br><span class="line">docker.io/library/hello-world:latest</span><br></pre></td></tr></table></figure>

<p>看本地仓库是否有这个库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行改命令</span></span><br><span class="line">[root@master ~]<span class="comment"># docker images</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   11 months ago   13.3kB</span><br></pre></td></tr></table></figure>

<p>运行这个镜像的实例，即容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># docker run hello-world</span></span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意, 如果你在没有镜像的时候，直接 <code>docker run hello-world</code> 也是可以的；它会先检查本地是否有这个镜像，没有的话会先从指定仓库中拉取。</p>
</blockquote>
<ul>
<li>run干了什么？</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141614339.webp" alt="image"></p>
<h3 id="4-6、为什么Docker会比VM虚拟机快"><a href="#4-6、为什么Docker会比VM虚拟机快" class="headerlink" title="4.6、为什么Docker会比VM虚拟机快"></a>4.6、为什么Docker会比VM虚拟机快</h3><ol>
<li><strong>docker有着比虚拟机更少的抽象层</strong></li>
</ol>
<p>由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p>
<ol>
<li><strong>docker利用的是宿主机的内核,而不需要加载操作系统OS内核</strong></li>
</ol>
<p>当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141614158.webp" alt="image"></p>
<table>
<thead>
<tr>
<th></th>
<th>Docker容器</th>
<th>虚拟机(VM)</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>与宿主机共享OS</td>
<td>宿主机OS上运行虚拟机OS</td>
</tr>
<tr>
<td>存储大小</td>
<td>镜像小，便于存储与运输</td>
<td>镜像庞大(vmdk、vdi等)</td>
</tr>
<tr>
<td>运行性能</td>
<td>几乎无额外性能损失</td>
<td>操作系统额外的CPU、内存消耗</td>
</tr>
<tr>
<td>移植性</td>
<td>轻便、灵活、适应于Linux</td>
<td>笨重，与虚拟机技术耦合度高</td>
</tr>
<tr>
<td>硬件亲和性</td>
<td>面向软件开发者</td>
<td>面向硬件运维者</td>
</tr>
<tr>
<td>部署速度</td>
<td>快速，秒级</td>
<td>较慢。10s以上</td>
</tr>
</tbody></table>
<h3 id="4-7、卸载Docker引擎"><a href="#4-7、卸载Docker引擎" class="headerlink" title="4.7、卸载Docker引擎"></a>4.7、卸载Docker引擎</h3><blockquote>
<p><strong>卸载 Docker Engine、CLI 和 Containerd 包</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>主机上的映像、容器、卷或自定义配置文件不会自动删除。删除所有镜像、容器和卷</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line">sudo <span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>

<p>您必须手动删除任何已编辑的配置文件</p>
<h2 id="5、Docker常用命令"><a href="#5、Docker常用命令" class="headerlink" title="5、Docker常用命令"></a>5、Docker常用命令</h2><p>所有Docker命令手册:<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a></p>
<h3 id="5-1、帮助启动类命令"><a href="#5-1、帮助启动类命令" class="headerlink" title="5.1、帮助启动类命令"></a>5.1、帮助启动类命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动docker：</span> </span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止docker：</span> </span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker：</span> </span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker状态：</span> </span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机启动：</span> </span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker概要信息：</span> </span><br><span class="line">docker info</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker总体帮助文档：</span> </span><br><span class="line">docker --help</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker命令帮助文档：</span> </span><br><span class="line">docker 具体命令 --help</span><br></pre></td></tr></table></figure>

<h3 id="5-2、镜像命令"><a href="#5-2、镜像命令" class="headerlink" title="5.2、镜像命令"></a>5.2、镜像命令</h3><p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</p>
<blockquote>
<p>注意</p>
<p>镜像的唯一标识是 id 和 tag（版本）。（大部分情况下）能以 id 操作镜像，则也能以 tag 操作镜像，反之亦然。</p>
<p>下面的例子可能只写一个标识如 id，忽略另一个，但请记住，两者使用任意一个标识都可以。</p>
</blockquote>
<p>指令语法标签介绍：</p>
<ul>
<li>[xxx]：xxx 是可选的</li>
<li><xxx>：xxx 是必选的</xxx></li>
<li>|：或者</li>
<li>&amp;：和</li>
</ul>
<h4 id="5-2-1、镜像本机"><a href="#5-2-1、镜像本机" class="headerlink" title="5.2.1、镜像本机"></a>5.2.1、镜像本机</h4><p>查看本机中所有镜像命令格式：<code>docker images [options] [镜像名]</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地镜像格式</span></span><br><span class="line">docker images [options] [镜像名]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有镜像（包含中间映像层）</span></span><br><span class="line">docker iamges -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示出镜像 id</span></span><br><span class="line">docker iamges -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 专门查询某个镜像</span></span><br><span class="line">docker images &lt;镜像名&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 1：查询全部镜像</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">[root@master ~]<span class="comment"># docker images</span></span><br><span class="line"></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   11 months ago   13.3kB</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 2：查询 hello-world 镜像</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># docker images hello-world</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   11 months ago   13.3kB</span><br></pre></td></tr></table></figure>

<p>各个选项说明:</p>
<ul>
<li>REPOSITORY：镜像的仓库源</li>
<li>TAG：镜像的标签，同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本。<strong>唯一</strong></li>
<li>IMAGE ID：镜像 ID。<strong>唯一</strong></li>
<li>CREATED：镜像的创建时间</li>
<li>SIZE：镜像的大小</li>
</ul>
<h4 id="5-2-2、镜像搜索"><a href="#5-2-2、镜像搜索" class="headerlink" title="5.2.2、镜像搜索"></a>5.2.2、镜像搜索</h4><blockquote>
<p><strong>Docker Hub 网页搜索镜像</strong></p>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141614294.webp" alt="image"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141614579.webp" alt="image"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141614781.webp" alt="image"></p>
<blockquote>
<p><strong>命令搜索镜像</strong></p>
</blockquote>
<p>去 Docker Hub 上查询镜像命令格式：<code>docker search [options] &lt;镜像名&gt;[:TAG]</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询指定的镜像格式</span></span><br><span class="line">docker search [options] &lt;镜像名&gt;[:TAG]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出收藏数不少于指定值的镜像</span></span><br><span class="line">docker search -s &lt;收藏数/指定值&gt; &lt;镜像名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示完整的镜像信息</span></span><br><span class="line">docker search --no-trunc &lt;镜像名&gt;</span><br></pre></td></tr></table></figure>

<p>通过命令无法列出版本，只能指定查询某个版本是否存在，所以建议还是去 Docker Hub 查看版本号</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker search &lt;镜像名:版本号&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 1：查询 MySQL</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># docker search mysql</span></span><br><span class="line">NAME                            DESCRIPTION                                     STARS                                                                                                 OFFICIAL   AUTOMATED</span><br><span class="line">mysql                           MySQL is a widely used, open-source relation…   13234                                                                                                 [OK]</span><br><span class="line">mariadb                         MariaDB Server is a high performing open sou…   5062                                                                                                  [OK]</span><br><span class="line">phpmyadmin                      phpMyAdmin - A web interface <span class="keyword">for</span> MySQL and M…   640                                                                                                   [OK]</span><br><span class="line">percona                         Percona Server is a fork of the MySQL relati…   588                                                                                                   [OK]</span><br><span class="line">bitnami/mysql                   Bitnami MySQL Docker Image                      77  </span><br></pre></td></tr></table></figure>

<ul>
<li>NAME: 镜像仓库源的名称</li>
<li>DESCRIPTION: 镜像的描述</li>
<li>OFFICIAL: 是否为官方发布，OK 代表是官方发布，空白代表是个人发布</li>
<li>STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思</li>
<li>AUTOMATED: 是否自动构建</li>
</ul>
<h4 id="4-5-3、镜像下载"><a href="#4-5-3、镜像下载" class="headerlink" title="4.5.3、镜像下载"></a>4.5.3、镜像下载</h4><p>从远程仓库下载镜像命令格式：<code>docker pull &lt;镜像名&gt;[:TAG | @DIGEST]</code></p>
<ul>
<li>TAG：版本号、标签</li>
<li>DIGEST：摘要</li>
</ul>
<p>推荐通过「版本号」下载镜像，如果不指定版本，默认最新版 <code>latest</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载镜像格式</span></span><br><span class="line">docker pull &lt;镜像名&gt;[:TAG | @DIGEST]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过「版本号」下载镜像</span></span><br><span class="line">docker pull &lt;镜像名:TAG&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过「摘要」下载镜像</span></span><br><span class="line">docker pull &lt;镜像名:@DIGEST&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>查看摘要</strong></p>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141615752.webp" alt="image"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141615528.webp" alt="image"></p>
<blockquote>
<p><strong>例子 1：通过「版本」下载 MySQL 的 latest 版本</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker pull mysql:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不指定版本号，默认下载 latest 版本</span></span><br><span class="line">docker pull mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">a10c77af2613: Pull complete </span><br><span class="line">b76a7eb51ffd: Pull complete </span><br><span class="line">258223f927e4: Pull complete </span><br><span class="line">2d2c75386df9: Pull complete </span><br><span class="line">63e92e4046c9: Pull complete </span><br><span class="line">f5845c731544: Pull complete </span><br><span class="line">bd0401123a9b: Pull complete </span><br><span class="line">3ef07ec35f1a: Pull complete </span><br><span class="line">c93a31315089: Pull complete </span><br><span class="line">3349ed800d44: Pull complete </span><br><span class="line">6d01857ca4c1: Pull complete </span><br><span class="line">4cc13890eda8: Pull complete </span><br><span class="line">Digest: sha256:aeecae58035f3868bf4f00e5fc623630d8b438db9d05f4d8c6538deb14d4c31b</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:latest</span><br><span class="line">docker.io/library/mysql:latest</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 2：通过「摘要」下载 MySQL 的 latest 版本</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker pull mysql:sha256:1ea233722275afb6bf54bdb53bcb162bdb9f3ceed69c64836250f72bc641f63a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">a10c77af2613: Pull complete </span><br><span class="line">b76a7eb51ffd: Pull complete </span><br><span class="line">258223f927e4: Pull complete </span><br><span class="line">2d2c75386df9: Pull complete </span><br><span class="line">63e92e4046c9: Pull complete </span><br><span class="line">f5845c731544: Pull complete </span><br><span class="line">bd0401123a9b: Pull complete </span><br><span class="line">3ef07ec35f1a: Pull complete </span><br><span class="line">c93a31315089: Pull complete </span><br><span class="line">3349ed800d44: Pull complete </span><br><span class="line">6d01857ca4c1: Pull complete </span><br><span class="line">4cc13890eda8: Pull complete </span><br><span class="line">Digest: sha256:aeecae58035f3868bf4f00e5fc623630d8b438db9d05f4d8c6538deb14d4c31b</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:latest</span><br><span class="line">docker.io/library/mysql:latest</span><br></pre></td></tr></table></figure>

<h4 id="5-2-4、查看镜像-x2F-容器-x2F-数据卷所占的空间"><a href="#5-2-4、查看镜像-x2F-容器-x2F-数据卷所占的空间" class="headerlink" title="5.2.4、查看镜像&#x2F;容器&#x2F;数据卷所占的空间"></a>5.2.4、查看镜像&#x2F;容器&#x2F;数据卷所占的空间</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># docker system df</span></span><br><span class="line">TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE</span><br><span class="line">Images          3         1         177MB     177MB (99%)</span><br><span class="line">Containers      2         0         0B        0B</span><br><span class="line">Local Volumes   0         0         0B        0B</span><br><span class="line">Build Cache     0         0         0B        0B</span><br></pre></td></tr></table></figure>

<ul>
<li>镜像，容器，本地卷，构建的缓存</li>
</ul>
<h4 id="5-2-5、镜像删除"><a href="#5-2-5、镜像删除" class="headerlink" title="5.2.5、镜像删除"></a>5.2.5、镜像删除</h4><p>在本地仓库删除镜像命令格式：</p>
<ul>
<li>完整：<code>docker image rm [options] &lt;镜像名&gt;[:TAG | IMAGE ID]</code></li>
<li>简写： <code>docker rmi [options] &lt;镜像名&gt;[:TAG | IMAGE ID]</code></li>
</ul>
<p><code>i</code> 指的是 image</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除镜像 完整格式</span></span><br><span class="line">docker image <span class="built_in">rm</span> [options] &lt;镜像名&gt;[:TAG | IMAGE ID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像 简写格式</span></span><br><span class="line">docker rmi [options] &lt;镜像名&gt;[:TAG | IMAGE ID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除镜像</span></span><br><span class="line">docker image <span class="built_in">rm</span> -f &lt;镜像名&gt;</span><br><span class="line">docker rmi -f &lt;镜像名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过「版本号」删除镜像</span></span><br><span class="line">docker rmi &lt;镜像名&gt;:TAG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过「镜像 id」删除镜像</span></span><br><span class="line">docker rmi &lt;镜像名&gt;:IMAGE ID</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 1：直接删除 hello-world 镜像</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 完整格式</span></span><br><span class="line">docker image <span class="built_in">rm</span> hello-world</span><br><span class="line"><span class="comment"># 简写格式</span></span><br><span class="line">docker rmi hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">Error response from daemon: conflict: unable to remove repository reference <span class="string">&quot;hello-world&quot;</span> (must force) - container 2be48e124757 is using its referenced image feb5d9fea6a5</span><br></pre></td></tr></table></figure>

<p>返回结果报错了，原因有两点，要么是容器（container）曾经运行过（类似于 Windows 里运行的软件无法删除），要么存在镜像依赖。</p>
<p>两种解决方案：</p>
<ul>
<li>使用强制删除镜像命令</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi -f hello-world</span><br></pre></td></tr></table></figure>

<p>这将会让它产生的历史容器也被删除。</p>
<blockquote>
<p>注意</p>
<p>正在运行容器的镜像无法删除，先停止运行的容器才可以强制删除对应镜像。</p>
</blockquote>
<ul>
<li>报错的结果已经给了容器的 id，先删除容器 id，再重新删除 hello-world 镜像</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> feb5d9fea6a5</span><br><span class="line">docker rmi hello-world</span><br></pre></td></tr></table></figure>

<p>删除容器id不需要 <code>i</code></p>
<blockquote>
<p><strong>例子 2：通过 hello-world 镜像的唯一标识符(tag、id)进行删除</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># docker images hello-world</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   11 months ago   13.3kB</span><br></pre></td></tr></table></figure>

<p>删除 hello-world 镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi hello-world:latest</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker rmi hello-world:feb5d9fea6a5</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 3：删除全部镜像</strong></p>
</blockquote>
<p>如果不强制删除，需要先删除容器id（如果容器存在）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi -f $(docker images -q)</span><br></pre></td></tr></table></figure>

<p><code>$()</code> 类似于 Linux 的管道符号 <code>|</code>，先执行括号里的命令，再执行外面的命令。</p>
<h4 id="5-2-6、docker虚悬镜像是什么？"><a href="#5-2-6、docker虚悬镜像是什么？" class="headerlink" title="5.2.6、docker虚悬镜像是什么？"></a>5.2.6、docker虚悬镜像是什么？</h4><p>仓库名、标签都是<code>&lt;none&gt;</code>的镜像，被称为虚悬镜像。</p>
<h4 id="5-2-7、镜像命名"><a href="#5-2-7、镜像命名" class="headerlink" title="5.2.7、镜像命名"></a>5.2.7、镜像命名</h4><p>如果你觉得下载的镜像名或者镜像 TAG 太长，可以进行重命名。</p>
<p>我们可以手动新增镜像的版本，也就是设置 TAG，并改名，格式为：<code>docker tag &lt;ID&gt; | &lt;镜像名:原来 TAG&gt; &lt;镜像名&gt;:&lt;新的 TAG&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手动新增镜像的 TAG</span></span><br><span class="line">docker tag &lt;ID&gt; | &lt;镜像名:原来 TAG&gt; &lt;镜像名&gt;:&lt;新的 TAG&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 1：新增 hello-world 的版本 TAG 为 1.0</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker tag feb5d9fea6a5 hello-world:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   8 weeks ago   13.3kB</span><br><span class="line">hello-world   v1.0      feb5d9fea6a5   8 weeks ago   13.3kB</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 2：下载的镜像名和版本名太长，可以新增一个短的版本，并修改镜像名，再删除掉长的版本</strong></p>
</blockquote>
<p>我刚下载了 Tomcat 镜像，因为版本太长，可以先新增一个短的版本名，再删除掉长的版本名，将 <code>8.5.73-jre8-temurin-focal</code> 改为 <code>8.5.73</code>，顺便把 tomcat 改为 tom</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker images tomcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY    TAG                         IMAGE ID       CREATED        SIZE</span><br><span class="line">tomcat        8.5.73-jre8-temurin-focal   7ec084df520c   24 hours ago   249MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增短版本</span></span><br><span class="line">docker tag 7ec084df520c tom:8.5.73</span><br><span class="line"><span class="comment"># 删除长版本</span></span><br><span class="line">docker rmi tomcat:8.5.73-jre8-temurin-focal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询查看镜像</span></span><br><span class="line">docker images tom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY    TAG                         IMAGE ID       CREATED        SIZE</span><br><span class="line">tom        	  8.5.73                      7ec084df520c   24 hours ago   249MB</span><br></pre></td></tr></table></figure>

<h4 id="5-2-8、镜像打包"><a href="#5-2-8、镜像打包" class="headerlink" title="5.2.8、镜像打包"></a>5.2.8、镜像打包</h4><p>利用 <code>save</code> 可以打包镜像，格式有两个，分别为：</p>
<ul>
<li><code>docker save &gt; &lt;名称.tar&gt; &lt;镜像 ID&gt;</code></li>
<li><code>docker save &lt;镜像名&gt;[:TAG | ID] -o &lt;名称.tar&gt;</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save &gt; &lt;名称.tar&gt; &lt;镜像 ID&gt;</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker save &lt;镜像名&gt;[:TAG | ID] -o &lt;名称.tar&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这里的镜像 ID 不能修改为镜像版本 TAG。</strong></p>
<blockquote>
<p><strong>例子 1：打包 hello-world 镜像为 myHelloWorld.tar</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">tomcat        8.5.73    7ec084df520c   24 hours ago   249MB</span><br><span class="line">mysql         latest    b05128b000dd   2 days ago     516MB</span><br><span class="line">hello-world   latest    feb5d9fea6a5   8 weeks ago    13.3kB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包命令</span></span><br><span class="line">docker save &gt; myHelloWorld.tar feb5d9fea6a5</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker save hello-world -o myHelloWorld.tar</span><br></pre></td></tr></table></figure>

<h4 id="5-2-9、镜像载入"><a href="#5-2-9、镜像载入" class="headerlink" title="5.2.9、镜像载入"></a>5.2.9、镜像载入</h4><p>利用 <code>load</code> 可以导入镜像，格式为：<code>docker load -i &lt;名称.tar&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker load -i &lt;名称.tar&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 1：解压 myHelloWorl.tar</strong></p>
</blockquote>
<p>进入镜像包目录下执行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker load -i myHelloWorld.tar</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker load &lt; myHelloWorld.tar</span><br></pre></td></tr></table></figure>

<p><code>-i</code> 或者 <code>&lt;</code> 表示从文件输入。会成功导入镜像及相关元数据，包括 tag 信息</p>
<h4 id="5-2-10、镜像信息"><a href="#5-2-10、镜像信息" class="headerlink" title="5.2.10、镜像信息"></a>5.2.10、镜像信息</h4><p>镜像是由一层一层的文件系统组成，在下载镜像的时候就发现，下载了很多文件，那么如何查看这些文件信息呢？</p>
<p>在 Windows 系统，如果查看文件夹的信息，<strong>右键 -&gt; 属性</strong> 即可查看文件夹里的文件个数、创建时间等信息。镜像也可以查看自己的信息。</p>
<p>查看镜像信息的命令格式：<code>docker images inspect &lt;镜像名&gt;[:TAG | ID]</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker images inspect &lt;镜像名&gt;[:TAG | ID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以简写</span></span><br><span class="line">docker inspect &lt;镜像名&gt;[:TAG | ID]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 1：查看 tomcat 的组成文件</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">tomcat        8.5.73    7ec084df520c   24 hours ago   249MB</span><br><span class="line">mysql         latest    b05128b000dd   2 days ago     516MB</span><br><span class="line">hello-world   latest    feb5d9fea6a5   8 weeks ago    13.3kB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 tomcat 的组成文件</span></span><br><span class="line">docker image inspect tomcat:8.5.73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果太长，自行实践</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h3 id="5-3、容器命令"><a href="#5-3、容器命令" class="headerlink" title="5.3、容器命令"></a>5.3、容器命令</h3><blockquote>
<p>切记</p>
<p>容器的唯一标识是 id 和 names（名字）。（大部分情况下）能以 id 操作容器，则也能以 name 操作容器，反之亦然。</p>
<p>内容例子可能只写一个标识如 id，忽略另一个，但请记住，两者使用任意一个标识都可以。</p>
</blockquote>
<h4 id="5-3-1、容器启动"><a href="#5-3-1、容器启动" class="headerlink" title="5.3.1、容器启动"></a>5.3.1、容器启动</h4><p>启动容器内容比较长，大纲如下：</p>
<ul>
<li>概念</li>
<li>简单启动，不涉及后台启动，端口映射。外界无法访问该容器</li>
<li>宿主机端口与容器端口映射</li>
<li>后台启动</li>
<li>指定名称启动</li>
</ul>
<blockquote>
<p><strong>概念</strong></p>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141615038.webp" alt="image"></p>
<p>首先我们要知道，Docker 启动一个容器，这个容器与操作系统是隔离的，比如 Tomcat 容器的端口是 8080，操作系统的 IP 是 <code>http://192.168.199.27</code>，则访问 Tomcat 的界面 <code>http://192.168.199.27:8080</code> 是失败的，这就是容器的隔离效果。你访问的是操作系统的 8080 端口，不是容器的 8080 端口。所以 <strong>我们在启动容器时要将容器的端口和操作系统的端口进行绑定（映射）</strong>，这样，外界访问操作系统的端口，就会转发给容器的端口。</p>
<p>通过镜像启动一个容器，格式为：<code>docker run [options] &lt;镜像名[:tag | 镜像 id]&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run [options] &lt;镜像名[:tag | 镜像 <span class="built_in">id</span>]&gt;</span><br><span class="line">			-p       <span class="comment"># 指定端口号，将容器的端口和操作系统端口进行绑定</span></span><br><span class="line">			-d       <span class="comment"># 启动守护式容器，在后台启动容器</span></span><br><span class="line">			--name   <span class="comment"># 为容器起一个别名</span></span><br><span class="line">			-it      <span class="comment"># 打开窗口以交互模式启动容器，进入容器进程内容会有讲解</span></span><br><span class="line">			--restart=always     <span class="comment"># 固定格式，容器一旦关闭就会自启动，一般用于经常发生意外而宕机的容器</span></span><br><span class="line">			--<span class="built_in">rm</span>     <span class="comment"># 容器启动成功并进入容器，再退出来后，容器自动停止并删除，一般在测试情况下使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整格式</span></span><br><span class="line">docker run -p 系统端口:容器端口 -p 系统端口:容器端口 ... -d --name 容器别名 镜像名:tag | 镜像 <span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>其中 tag（TAG） 或者容器 id（IMAGE ID）选一个即可。</p>
<p><strong>options 常用参数说明：</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-d</td>
<td>启动守护式容器，在后台启动容器，并返回容器的id！</td>
</tr>
<tr>
<td align="left">-i</td>
<td>以交互(interactive)模式运行容器，通过和 -t 一起使用</td>
</tr>
<tr>
<td align="left">-t</td>
<td>给容器重新分配一个终端(tty)，通常和 -i 一起使用</td>
</tr>
<tr>
<td align="left">-P</td>
<td>随机端口映射（大写）</td>
</tr>
<tr>
<td align="left">-p</td>
<td>指定端口映射（小写），将容器的端口和操作系统端口进行绑定（映射），多个 <code>-p</code> 可以指定多个端口号</td>
</tr>
<tr>
<td align="left">–name&#x3D;”x”</td>
<td>给容器指定一个名字，如果不设置别名，启动容器会自动给该容器取一个名字</td>
</tr>
</tbody></table>
<h5 id="简单启动"><a href="#简单启动" class="headerlink" title="简单启动"></a><strong>简单启动</strong></h5><p>简单启动一个容器，不涉及后台启动，端口映射，外界无法访问该容器。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker images tomcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">tomcat       8.5.73    7ec084df520c   24 hours ago   249MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动命令 1，默认启动 latest 版本</span></span><br><span class="line">docker run tomcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动命令 2，启动 8.5.73 版本</span></span><br><span class="line">docker run hello-world:8.5.73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动命令 3，启动 id 为 7ec084df520c 的镜像</span></span><br><span class="line">docker run hello-world:7ec084df520c</span><br></pre></td></tr></table></figure>

<h5 id="宿主机端口与容器端口映射"><a href="#宿主机端口与容器端口映射" class="headerlink" title="宿主机端口与容器端口映射"></a><strong>宿主机端口与容器端口映射</strong></h5><p>如果想外界访问容器，比如容器启动了 Tomcat，外界想访问 Tomcat，则需要将 Tomcat 容器和操作系统端口进行绑定（映射），这样，访问操作系统端口就会转发到容器端口。</p>
<p>用 <code>-p</code> 进行映射。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -p 8080:8080 tomcat:8.5.73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想多个映射</span></span><br><span class="line">docker run -p 8080:8080 -p 8081:8080 tomcat:8.5.73</span><br></pre></td></tr></table></figure>

<p>8080&#x2F;8080 中前面的 8080 是操作系统的端口，后面的 8080 端口是容器的端口，操作系统的端口只要不占用，随便写，但是容器的端口是固定的。</p>
<p>此时启动还是前台启动。</p>
<h5 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a><strong>后台启动</strong></h5><p>前台启动导致无法操作界面，只能看控制台输出发呆，所以需要后台启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -p 8080:8080 -d tomcat:8.5.73</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>指定名称启动</strong></p>
</blockquote>
<p><strong>如何精确找到并操作某一个 Docker 容器？</strong></p>
<ul>
<li>容器 id</li>
<li>容器名称</li>
</ul>
<p>可以通过 id 操作容器，但是启动容器时会自动生成随机的 id，很难记住，不可能每次想操作容器都要查看一下容器的 id，所以容器的名称非常重要，默认启动容器会自动生成随机的名称，我们也可以指定名称，通过 <code>--name</code> 选项</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动 tomcat</span></span><br><span class="line">docker run -d --name tomcat01 tomcat:8.5.73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器运行状态，后面有讲解</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回容器运行状态</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                                       NAMES</span><br><span class="line">e323fce921be   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   5 seconds ago    Up 4 seconds    8080/tcp                                    tomcat01</span><br></pre></td></tr></table></figure>

<h5 id="交互模式启动容器"><a href="#交互模式启动容器" class="headerlink" title="交互模式启动容器"></a><strong>交互模式启动容器</strong></h5><p>在启动容器的时候，我们可以启动完成后 <strong>直接进入容器内部</strong>。使用 <code>-it</code> 即可实现，需要指定的容器内部使用窗口如 shell 窗口、bash 窗口。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">[root@master ~]<span class="comment"># docker run -it tomcat:8.5.73 bash</span></span><br><span class="line"><span class="comment"># 此时已经进入了 Tomcat 容器内部，长什么样子呢？和 Windows 下的根目录类似</span></span><br><span class="line">root@8d9ffc09a8e8:/usr/local/tomcat<span class="comment"># ls</span></span><br><span class="line">BUILDING.txt     LICENSE  README.md      RUNNING.txt  conf  logs            temp     webapps.dist</span><br><span class="line">CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin          lib   native-jni-lib  webapps  work</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>交互模式启动容器，不能加入 <code>-d</code>，否则启动后无法进入容器。</p>
</blockquote>
<p>上面的例子都是单独针对某个选项而言，实际使用，我们需要将它们组合在一起，如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d  --name tomcat01 -p 8080:8080 tomcat:8.5.73</span><br></pre></td></tr></table></figure>

<h4 id="5-3-2、容器查看"><a href="#5-3-2、容器查看" class="headerlink" title="5.3.2、容器查看"></a>5.3.2、容器查看</h4><p>容器查看的格式：<code>docker ps [options]</code></p>
<p><strong>options 常用参数说明：</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>表示 all，所有的，列出当前所有正在运行的容器 + 历史运行过的容器</td>
</tr>
<tr>
<td>-l</td>
<td>显示最近创建的容器</td>
</tr>
<tr>
<td>-n&#x3D;?</td>
<td>显示最近n个创建的容器</td>
</tr>
<tr>
<td>-q</td>
<td>静默模式，返回正在运行的容器 id。</td>
</tr>
</tbody></table>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看正在运行的容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS      NAMES</span><br><span class="line">e323fce921be   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   12 minutes ago   Up 12 minutes   8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有容器，包括历史运行的容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS                        PORTS      NAMES</span><br><span class="line">8d9ffc09a8e8   tomcat:8.5.73   <span class="string">&quot;bash&quot;</span>              10 minutes ago   Exited (0) 9 minutes ago                 nifty_goldstine</span><br><span class="line">e323fce921be   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   12 minutes ago   Up 12 minutes                 8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有容器的 ID，包括历史运行的容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps -aq</span></span><br><span class="line">8d9ffc09a8e8</span><br><span class="line">e323fce921be</span><br></pre></td></tr></table></figure>

<p>返回结果参数名：</p>
<ul>
<li>CONTAINER ID：容器 id（唯一）</li>
<li>IMAGE：生成容器的镜像名</li>
<li>COMMAND：容器启动后，内部执行的命令</li>
<li>CREATED：创建时间</li>
<li>STATUS：当前状态</li>
<li>PORTS：容器监听的端口</li>
<li>NAMES：容器的别名</li>
</ul>
<h4 id="5-3-3、容器退出"><a href="#5-3-3、容器退出" class="headerlink" title="5.3.3、容器退出"></a>5.3.3、容器退出</h4><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>exit</td>
<td>容器停止退出</td>
</tr>
<tr>
<td>ctrl+P+Q</td>
<td>容器不停止退出</td>
</tr>
</tbody></table>
<h4 id="5-3-4、容器再启动"><a href="#5-3-4、容器再启动" class="headerlink" title="5.3.4、容器再启动"></a>5.3.4、容器再启动</h4><p>容器再启动命令格式：<code>docker start &lt;容器 id | 容器名&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker start &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br></pre></td></tr></table></figure>

<p>首先查看历史运行的容器 id 或者名称，再启动历史运行的容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有容器，包括曾经运行的容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED              STATUS                        PORTS      NAMES</span><br><span class="line">5d3f5ce66c6f   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>         About a minute ago   Up About a minute                        nifty_brown</span><br><span class="line">e86b30e440cb   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>         11 minutes ago       Exited (130) 8 minutes ago               hungry_poincare</span><br><span class="line">8d9ffc09a8e8   tomcat:8.5.73   <span class="string">&quot;bash&quot;</span>              50 minutes ago       Exited (0) 48 minutes ago                nifty_goldstine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再启动容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker start 8d9ffc09a8e8</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-5、容器停止和重启"><a href="#4-3-5、容器停止和重启" class="headerlink" title="4.3.5、容器停止和重启"></a>4.3.5、容器停止和重启</h4><p>容器正常停止命令格式：<code>docker stop &lt;容器 id | 容器名&gt;</code></p>
<p>容器立即停止命令格式：<code>docker kill &lt;容器 id | 容器名&gt;</code></p>
<p>容器重启命令格式：<code>docker restart &lt;容器 id | 容器名&gt;</code></p>
<p>先正常停止 Tomcat 容器，再启动 Tomcat 容器，然后重启 Tomcat 容器，最后立即停止 Tomcat 容器。（这里演示 id，其实 name 也可以）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看历史运行的容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS                        PORTS      NAMES</span><br><span class="line">5d3f5ce66c6f   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>         6 minutes ago    Up 6 minutes                             nifty_brown</span><br><span class="line">e86b30e440cb   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>         16 minutes ago   Exited (130) 13 minutes ago              hungry_poincare</span><br><span class="line">8d9ffc09a8e8   tomcat:8.5.73   <span class="string">&quot;bash&quot;</span>              55 minutes ago   Up 3 minutes                  8080/tcp   nifty_goldstine</span><br><span class="line">e323fce921be   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   56 minutes ago   Up 7 seconds                  8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常停止容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker stop tomcat01</span></span><br><span class="line">tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Tomcat 容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker start tomcat01</span></span><br><span class="line">tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker restart tomcat01</span></span><br><span class="line">tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立即停止容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker kill tomcat01</span></span><br><span class="line">tomcat01</span><br></pre></td></tr></table></figure>

<p>如果容器处于特殊状态，立即停止 <code>kill</code> 命令可能造成严重后果。</p>
<h4 id="5-3-6、容器删除和清除"><a href="#5-3-6、容器删除和清除" class="headerlink" title="5.3.6、容器删除和清除"></a>5.3.6、容器删除和清除</h4><p>容器删除命令格式：<code>docker rm [options] &lt;容器 id | 容器名&gt;</code></p>
<p>容器清除命令格式：<code>docker container prune</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除命令格式</span></span><br><span class="line">docker <span class="built_in">rm</span> [options] &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除</span></span><br><span class="line">docker <span class="built_in">rm</span> -f &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br></pre></td></tr></table></figure>

<p>例子：删除Tomcat的历史容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看历史运行容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED             STATUS                           PORTS      NAMES</span><br><span class="line">5d3f5ce66c6f   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>         11 minutes ago      Up 11 minutes                               nifty_brown</span><br><span class="line">e86b30e440cb   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>         21 minutes ago      Exited (130) 18 minutes ago                 hungry_poincare</span><br><span class="line">8d9ffc09a8e8   tomcat:8.5.73   <span class="string">&quot;bash&quot;</span>              About an hour ago   Up 9 minutes                     8080/tcp   nifty_goldstine</span><br><span class="line">42e9b9dfa967   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   About an hour ago   Exited (143) 56 minutes ago                 elegant_hawking</span><br><span class="line">9c5812be9efd   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   About an hour ago   Exited (130) About an hour ago              dazzling_herschel</span><br><span class="line">fb74a2687495   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   About an hour ago   Exited (130) About an hour ago              reverent_curran</span><br><span class="line">f27f7f59368f   feb5d9fea6a5    <span class="string">&quot;/hello&quot;</span>            3 days ago          Exited (0) 3 days ago                       happy_mayer</span><br><span class="line">c7b6f05514ea   feb5d9fea6a5    <span class="string">&quot;/hello&quot;</span>            3 days ago          Exited (0) 3 days ago                       hopeful_lalande</span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">[root@master ~]<span class="comment"># docker rm 42e9b9dfa967 9c5812be9efd fb74a2687495 f27f7f59368f c7b6f05514ea</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>只是演示</p>
</blockquote>
<p>有时候删除会报错，原因在于它处于运行状态，Windows 里正在运行的进程也不能删除。</p>
<p><strong>那么如何删除一个正在运行的容器呢？</strong></p>
<p>我们可以使用强制删除命令 <code>-f</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND       CREATED             STATUS                        PORTS      NAMES</span><br><span class="line">5d3f5ce66c6f   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>   13 minutes ago      Up 13 minutes                            nifty_brown</span><br><span class="line">e86b30e440cb   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>   23 minutes ago      Exited (130) 20 minutes ago              hungry_poincare</span><br><span class="line">8d9ffc09a8e8   tomcat:8.5.73   <span class="string">&quot;bash&quot;</span>        About an hour ago   Up 11 minutes                 8080/tcp   nifty_goldstine</span><br><span class="line">[root@master ~]<span class="comment"># docker rm -f 8d9ffc09a8e8</span></span><br></pre></td></tr></table></figure>

<p><strong>如何删除所有的历史容器呢？</strong></p>
<p>别忘了，之前提到过的 <code>$()</code>，按照数学运算符号优先级来说，括号的执行优先级很高。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -a -q)</span><br></pre></td></tr></table></figure>

<p>也有专门的清除历史容器命令：<code>docker container prune</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker container prune</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">WARNING! This will remove all stopped containers.</span><br><span class="line"><span class="comment"># 输入 y 确定清除</span></span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N] y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询查看历史容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure>

<p>删除容器并不会删除它的镜像，此时可以理解镜像是安装包，容器是安装后的软件，只要保存好镜像（安装包），容器（软件）删除了可以再通过镜像（安装包） <code>run</code> 出来。</p>
<h4 id="5-3-7、查看容器进程"><a href="#5-3-7、查看容器进程" class="headerlink" title="5.3.7、查看容器进程"></a>5.3.7、查看容器进程</h4><p>查看容器进程命令格式：<code>docker top &lt;容器 id | 容器名&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker top &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>查看 Tomcat 容器的进程</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND             CREATED          STATUS          PORTS      NAMES</span><br><span class="line">0c6e3fc4a28d   tomcat    <span class="string">&quot;catalina.sh run&quot;</span>   11 seconds ago   Up 10 seconds   8080/tcp   tomcat01</span><br><span class="line">5d3f5ce66c6f   ubuntu    <span class="string">&quot;/bin/bash&quot;</span>         46 minutes ago   Up 46 minutes              nifty_brown</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">[root@master ~]<span class="comment"># docker top 0c6e3fc4a28d</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                8573                8554                7                   23:20               ?                   00:00:02            /usr/local/openjdk-11/bin/java -Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=0027 -Dignore.endorsed.dirs= -classpath /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar -Dcatalina.base=/usr/local/tomcat -Dcatalina.home=/usr/local/tomcat -Djava.io.tmpdir=/usr/local/tomcat/temp org.apache.catalina.startup.Bootstrap start</span><br></pre></td></tr></table></figure>

<p>可以查看容器的一些进程信息，如 UID，已经运行时间等。</p>
<h4 id="5-3-8、查看容器细节"><a href="#5-3-8、查看容器细节" class="headerlink" title="5.3.8、查看容器细节"></a>5.3.8、查看容器细节</h4><p>这个命令还是很常用的，要求容器必须运行起来。</p>
<p>查看容器内部细节命令格式：<code>docker inspect &lt;容器 id | 容器名&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker inspect &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>查看 Tomcat 容器的内部细节</strong></p>
</blockquote>
<p>首先查看 Tomcat 容器的 id 或者 names（名字）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED             STATUS          PORTS                                       NAMES</span><br><span class="line">1365f332be6b   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   About an hour ago   Up 12 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01</span><br></pre></td></tr></table></figure>

<p>接着查看 Tomcat 容器的内部细节</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker inspect 1365f332be6b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果（部分内容）</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;70983c5ab3c77ce3bbc8c341e3debc866e5c797bdf6d18cbfb89fa0def4e79cb&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2022-09-08T15:26:42.214308916Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Path&quot;</span>: <span class="string">&quot;catalina.sh&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;run&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;State&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Status&quot;</span>: <span class="string">&quot;running&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Running&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;Paused&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Restarting&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;OOMKilled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Dead&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Pid&quot;</span>: 8842,</span><br><span class="line">            <span class="string">&quot;ExitCode&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;Error&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;StartedAt&quot;</span>: <span class="string">&quot;2022-09-08T15:26:42.504365515Z&quot;</span>,</span><br><span class="line">            <span class="string">&quot;FinishedAt&quot;</span>: <span class="string">&quot;0001-01-01T00:00:00Z&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">			<span class="string">&quot;Networks&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;bridge&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;IPAMConfig&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;Links&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;Aliases&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;NetworkID&quot;</span>: <span class="string">&quot;88ffcfc688e0d2e932751871441b70c7cc7ebf3b44aa4d087879328e97a7587f&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;a18572b17e13c83d569c771694b26c4c0240a4963b9631c381ae26e019a190c5&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.17.0.1&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.17.0.3&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;IPPrefixLen&quot;</span>: 16,</span><br><span class="line">                    <span class="string">&quot;IPv6Gateway&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;GlobalIPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;GlobalIPv6PrefixLen&quot;</span>: 0,</span><br><span class="line">                    <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:11:00:03&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;DriverOpts&quot;</span>: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>只截取一部分内容，可以看出有容器的状态，和操作系统绑定的端口等等信息。</p>
<h4 id="5-3-9、查询运行日志"><a href="#5-3-9、查询运行日志" class="headerlink" title="5.3.9、查询运行日志"></a>5.3.9、查询运行日志</h4><p>查询容器的 <strong>运行</strong> 日志命令格式：<code>docker logs [options] &lt;容器 id | 容器名&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询容器的运行日志命令格式</span></span><br><span class="line">docker logs [options] &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入时间戳</span></span><br><span class="line">docker logs -t &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听日志的输出，一旦日志更新，显示在控制台上</span></span><br><span class="line">docker logs -f &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示日志的最后多少条数据，取决于数字</span></span><br><span class="line">docker logs --<span class="built_in">tail</span> 数字 &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-t</td>
<td>显示时间戳</td>
</tr>
<tr>
<td>-f</td>
<td>监听日志，一旦更新，立即打印在控制台</td>
</tr>
<tr>
<td>–tail N</td>
<td>显示日志的最后 N 条数据</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>例子 1：查看容器的日志(显示时间戳)</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED        STATUS         PORTS                                       NAMES</span><br><span class="line">1365f332be6b   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   13 hours ago   Up 5 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器日志(显示时间戳)</span></span><br><span class="line">docker logs -t 1365f332be6b</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 2：实时监听容器的日志</strong></p>
</blockquote>
<p>要求：先运行容器才能实时监听容器的日志</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED        STATUS         PORTS                                       NAMES</span><br><span class="line">1365f332be6b   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   13 hours ago   Up 5 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器日志(显示时间戳)</span></span><br><span class="line">docker logs -tf 1365f332be6b</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 3：查看日志的最后 5 行记录</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED        STATUS         PORTS                                       NAMES</span><br><span class="line">1365f332be6b   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   13 hours ago   Up 5 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器日志(显示时间戳)</span></span><br><span class="line">docker logs -t --<span class="built_in">tail</span> 5 1365f332be6b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">2021-11-20T04:11:38.947501511Z 20-Nov-2021 04:11:38.947 INFO [main] org.apache.catalina.startup.Catalina.load Initialization processed <span class="keyword">in</span> 2190 ms</span><br><span class="line">2021-11-20T04:11:39.030048052Z 20-Nov-2021 04:11:39.029 INFO [main] org.apache.catalina.core.StandardService.startInternal Starting service [Catalina]</span><br><span class="line">2021-11-20T04:11:39.030143031Z 20-Nov-2021 04:11:39.029 INFO [main] org.apache.catalina.core.StandardEngine.startInternal Starting Servlet engine: [Apache Tomcat/8.5.73]</span><br><span class="line">2021-11-20T04:11:39.069039566Z 20-Nov-2021 04:11:39.068 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [<span class="string">&quot;http-nio-8080&quot;</span>]</span><br><span class="line">2021-11-20T04:11:39.080909086Z 20-Nov-2021 04:11:39.080 INFO [main] org.apache.catalina.startup.Catalina.start Server startup <span class="keyword">in</span> 133 ms</span><br></pre></td></tr></table></figure>

<h4 id="5-3-10、进入容器进程"><a href="#5-3-10、进入容器进程" class="headerlink" title="5.3.10、进入容器进程"></a>5.3.10、进入容器进程</h4><p>先启动 Tomcat</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS                        PORTS     NAMES</span><br><span class="line">1365f332be6b   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   39 minutes ago   Exited (143) 34 minutes ago             tomcat01</span><br><span class="line">156e574bee6a   hello-world     <span class="string">&quot;/hello&quot;</span>            3 hours ago      Exited (0) 2 hours ago                  sweet_kare</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Tomcat</span></span><br><span class="line">docker start 1365f332be6b</span><br></pre></td></tr></table></figure>

<ul>
<li>第一种命令：<code>docker attach</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                                       NAMES</span><br><span class="line">1365f332be6b   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   42 minutes ago   Up 20 seconds   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器内</span></span><br><span class="line">docker attach 1365f332be6b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>可以看出，该命令进入容器后，如果退出容器，容器自动结束运行。</p>
<ul>
<li>第二种命令：<code>docker exec</code>，格式为：<code>docker exec [options] &lt;容器 id&gt; &lt;容器使用的终端窗口&gt;</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> [options] &lt;容器 <span class="built_in">id</span>&gt; &lt;容器使用的终端窗口&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以交互模式运行容器，通常与 -t 一起使用</span></span><br><span class="line">docker <span class="built_in">exec</span> -i &lt;容器 <span class="built_in">id</span>&gt; &lt;容器使用的终端窗口&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#分配一个伪终端，如 shell窗口、base 窗口</span></span><br><span class="line">docker <span class="built_in">exec</span> -t &lt;容器 <span class="built_in">id</span>&gt; &lt;容器使用的终端窗口&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#建议一起使用</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;容器 <span class="built_in">id</span>&gt; &lt;容器使用的终端窗口&gt;</span><br></pre></td></tr></table></figure>

<p><code>-i</code>：以交互模式运行容器，通常与 -t 一起使用</p>
<p><code>-t</code>：分配一个伪终端，如 shell窗口、base 窗口</p>
<blockquote>
<p><strong>进入 Tomcat 容器内部</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 1365f332be6b bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器内部，查看容器内部</span></span><br><span class="line">root@1365f332be6b:/usr/local/tomcat<span class="comment"># ls</span></span><br><span class="line">bin  BUILDING.txt  conf  CONTRIBUTING.md  lib  LICENSE  logs  native-jni-lib  NOTICE  README.md  RELEASE-NOTES  RUNNING.txt  temp  webapps  webapps.dist  work</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从容器内部退出</span></span><br><span class="line">root@1365f332be6b:/usr/local/tomcat<span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器是否停止运行</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                                       NAMES</span><br><span class="line">1365f332be6b   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   51 minutes ago   Up 26 seconds   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第 6 行是不是很熟悉，就是 Tomcat 的根目录，这就是 Tomcat 容器的根目录。</p>
<p><code>exit</code> 退出容器后，Docker 不会停止运行容器</p>
</li>
</ul>
<p><strong>区别：</strong></p>
<p>使用 <code>docker attach</code> 进入容器后，exit 退出来便容器也停止运行了。而 <code>docker exec</code> 则不会这样操作导致停止运行容器。</p>
<p>推荐使用 <code>docker exec</code> 命令，因为该命令退出容器终端，不会导致容器的停止。</p>
<h4 id="5-3-11、宿主机文件-gt-容器"><a href="#5-3-11、宿主机文件-gt-容器" class="headerlink" title="5.3.11、宿主机文件 &gt; 容器"></a>5.3.11、宿主机文件 &gt; 容器</h4><p>将宿主机的文件拷贝到容器里命令格式：<code>docker cp &lt;宿主机文件 | 目录&gt; &lt;容器 id:容器路径&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> &lt;宿主机文件 | 目录&gt; &lt;容器 <span class="built_in">id</span>:容器路径&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>将宿主机的 杂文.txt 文件拷贝到 Tomcat 容器里</strong></p>
</blockquote>
<p>杂文.txt 文件在 &#x2F;opt 目录下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">activemq  containerd  dump.rdb  jdk  mysql  README.md  redis  rh  tomcat 杂文.txt</span><br></pre></td></tr></table></figure>

<p>Tomcat 容器的 id是 1365f332be6b，拷贝到的路径是 &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 杂文.txt 1365f332be6b:/usr/local/tomcat/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 1365f332be6b bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前路径内容</span></span><br><span class="line">oot@1365f332be6b:/usr/local/tomcat<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">bin           conf             lib      logs            NOTICE     RELEASE-NOTES  temp     webapps.dist  杂文.txt</span><br><span class="line">BUILDING.txt  CONTRIBUTING.md  LICENSE  native-jni-lib  README.md  RUNNING.txt    webapps  work</span><br></pre></td></tr></table></figure>

<h4 id="5-3-12、容器导入-x2F-导出"><a href="#5-3-12、容器导入-x2F-导出" class="headerlink" title="5.3.12、容器导入&#x2F;导出"></a>5.3.12、容器导入&#x2F;导出</h4><ul>
<li>导入和导出容器</li>
<li>export 导出容器的内容留作为一个tar归档文件[对应import命令]</li>
<li>import 从tar包中的内容创建一个新的文件系统再导入为镜像[对应export]</li>
<li>命令</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">export</span> 容器ID &gt; 文件名.tar</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号</span><br></pre></td></tr></table></figure>

<ul>
<li>案例</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND             CREATED             STATUS             PORTS                                         NAMES</span><br><span class="line">70983c5ab3c7   tomcat    <span class="string">&quot;catalina.sh run&quot;</span>   35 minutes ago      Up 18 minutes      0.0.0.0:49154-&gt;8080/tcp, :::49154-&gt;8080/tcp   tomcat01</span><br><span class="line">5d3f5ce66c6f   ubuntu    <span class="string">&quot;/bin/bash&quot;</span>         About an hour ago   Up About an hour                                                 nifty_brown</span><br><span class="line">[root@master ~]<span class="comment"># docker export 70983c5ab3c7 &gt; ABCD.tar</span></span><br><span class="line">[root@master ~]<span class="comment"># ls</span></span><br><span class="line">          anaconda-ks.cfg  BUILDING.txt  initial-setup-ks.cfg  nodes-6379.conf  公共  视频  文档  音乐</span><br><span class="line">ABCD.tar  appendonly.aof   dump.rdb      lua_demo              postfile         模板  图片  下载  桌面</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">docker <span class="built_in">rm</span> -f tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从tar包中的内容创建一个新的文件系统再导入为镜像</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># cat ABCD.tar | docker import - frx01/tomcat02:8.5.27</span></span><br><span class="line">sha256:bc554c9488cc1b4ff0649eaeb9cd6fa0ffc763f4a48a6796499fc05cb37eaf6b</span><br></pre></td></tr></table></figure>

<h4 id="5-3-13、常用命令总结"><a href="#5-3-13、常用命令总结" class="headerlink" title="5.3.13、常用命令总结"></a>5.3.13、常用命令总结</h4><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141615426.webp" alt="image"></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>官方说明</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>attach</td>
<td>Attach local standard input, output, and error streams to a running container</td>
<td>当前 shell 下 attach 连接指定运行镜像</td>
</tr>
<tr>
<td>build</td>
<td>Build an image from a Dockerfile</td>
<td>通过 Dockerfile 定制镜像</td>
</tr>
<tr>
<td>commit</td>
<td>Create a new image from a container’s changes</td>
<td>提交当前容器为新的镜像</td>
</tr>
<tr>
<td>cp</td>
<td>Copy files&#x2F;folders between a container and the local filesystem</td>
<td>从容器中拷贝指定文件或者目录到宿主机中</td>
</tr>
<tr>
<td>create</td>
<td>Create a new container</td>
<td>创建一个新的容器，同 run，但不启动容器</td>
</tr>
<tr>
<td>diff</td>
<td>Inspect changes to files or directories on a container’s filesystem</td>
<td>查看 docker 容器变化</td>
</tr>
<tr>
<td>events</td>
<td>Get real time events from the server</td>
<td>从 docker 服务获取容 器实时事件</td>
</tr>
<tr>
<td>exec</td>
<td>Run a command in a running container</td>
<td>在已存在的容器上运行命令</td>
</tr>
<tr>
<td>export</td>
<td>Export a container’s filesystem as a tar archive</td>
<td>导出容器的内 容流作为一个 tar 归档文件[对应 import ]</td>
</tr>
<tr>
<td>history</td>
<td>Show the history of an image</td>
<td>展示一个镜像形成历史</td>
</tr>
<tr>
<td>images</td>
<td>List images</td>
<td>列出系统当前镜像</td>
</tr>
<tr>
<td>import</td>
<td>Import the contents from a tarball to create a filesystem image</td>
<td>从 tar包中的内容创建一个新的文件系统映像[对应export]</td>
</tr>
<tr>
<td>info</td>
<td>Display system-wide information</td>
<td>显示系统相关信息</td>
</tr>
<tr>
<td>inspect</td>
<td>Return low-level information on Docker objects</td>
<td>查看容器详细信息</td>
</tr>
<tr>
<td>kill</td>
<td>Kill one or more running containers</td>
<td>杀掉 指定 docker 容器</td>
</tr>
<tr>
<td>load</td>
<td>Load an image from a tar archive or STDIN</td>
<td>从一个 tar 包中加载一 个镜像[对应 save]</td>
</tr>
<tr>
<td>login</td>
<td>Log in to a Docker registry</td>
<td>登陆一个 docker 源服务器</td>
</tr>
<tr>
<td>logout</td>
<td>Log out from a Docker registry</td>
<td>从当前 Docker registry 退出</td>
</tr>
<tr>
<td>logs</td>
<td>Fetch the logs of a container</td>
<td>输出当前容器日志信息</td>
</tr>
<tr>
<td>pause</td>
<td>Pause all processes within one or more containers</td>
<td>暂停容器</td>
</tr>
<tr>
<td>port</td>
<td>List port mappings or a specific mapping for the container</td>
<td>查看映射端口对应的容器内部源端口</td>
</tr>
<tr>
<td>ps</td>
<td>List containers</td>
<td>列出容器列表</td>
</tr>
<tr>
<td>pull</td>
<td>Pull an image or a repository from a registry</td>
<td>从docker镜像源服务器拉取指定镜像或者库镜像</td>
</tr>
<tr>
<td>push</td>
<td>Push an image or a repository to a registry</td>
<td>推送指定镜像或者库镜像至docker源服务器</td>
</tr>
<tr>
<td>rename</td>
<td>Rename a container</td>
<td>给一个容器改名</td>
</tr>
<tr>
<td>restart</td>
<td>Restart one or more containers</td>
<td>重启运行的容器</td>
</tr>
<tr>
<td>rm</td>
<td>Remove one or more containers</td>
<td>移除一个或者多个容器</td>
</tr>
<tr>
<td>rmi</td>
<td>Remove one or more images</td>
<td>移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</td>
</tr>
<tr>
<td>run</td>
<td>Run a command in a new container</td>
<td>创建一个新的容器并运行 一个命令</td>
</tr>
<tr>
<td>save</td>
<td>Save one or more images to a tar archive (streamed to STDOUT by default)</td>
<td>保存一个镜像为一个 tar 包[对应 load]</td>
</tr>
<tr>
<td>search</td>
<td>Search the Docker Hub for images</td>
<td>在 docker hub 中搜 索镜像</td>
</tr>
<tr>
<td>start</td>
<td>Start one or more stopped containers</td>
<td>启动容器</td>
</tr>
<tr>
<td>stats</td>
<td>Display a live stream of container(s) resource usage statistics</td>
<td>显示容器资源使用统计信息的实时信息</td>
</tr>
<tr>
<td>stop</td>
<td>Stop one or more running containers</td>
<td>停止容器</td>
</tr>
<tr>
<td>tag</td>
<td>Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</td>
<td>给源中镜像打标签</td>
</tr>
<tr>
<td>top</td>
<td>Display the running processes of a container</td>
<td>查看容器中运行的进程信 息</td>
</tr>
<tr>
<td>unpause</td>
<td>Unpause all processes within one or more containers</td>
<td>取消暂停容器</td>
</tr>
<tr>
<td>update</td>
<td>Update configuration of one or more containers</td>
<td>更新容器配置</td>
</tr>
<tr>
<td>version</td>
<td>Show the Docker version information</td>
<td>查看 docker 版本号</td>
</tr>
<tr>
<td>wait</td>
<td>Block until one or more containers stop, then print their exit codes</td>
<td>截取容器停止时的退出状态值</td>
</tr>
</tbody></table>
<h4 id="5-3-14、总结图片"><a href="#5-3-14、总结图片" class="headerlink" title="5.3.14、总结图片"></a>5.3.14、总结图片</h4><h5 id="镜像命令图片"><a href="#镜像命令图片" class="headerlink" title="镜像命令图片"></a>镜像命令图片</h5><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141615028.png" alt="image-20211120172453603"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141615549.png" alt="image-20211120172716950"></p>
<h5 id="容器命令图片"><a href="#容器命令图片" class="headerlink" title="容器命令图片"></a>容器命令图片</h5><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141615333.png" alt="image-20211120172301522"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141615502.png" alt="image-20211120172319882"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141615717.png" alt="image-20211120172737409"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141615787.png" alt="image-20211120172743635"></p>
<h2 id="6、Docker-镜像原理"><a href="#6、Docker-镜像原理" class="headerlink" title="6、Docker 镜像原理"></a>6、Docker 镜像原理</h2><h3 id="6-1、什么是镜像"><a href="#6-1、什么是镜像" class="headerlink" title="6.1、什么是镜像"></a>6.1、什么是镜像</h3><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141615303.webp" alt="image"></p>
<p><strong>镜像就是花卷，多个镜像组成一个完整的镜像</strong></p>
<ul>
<li>UnionFS（联合文件系统）</li>
</ul>
<p>Union 文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文代系统下。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。Union 文件系统是 Docker 镜像的基础。</p>
<p>这种文件系统特性就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<h3 id="6-2、Docker-镜像原理"><a href="#6-2、Docker-镜像原理" class="headerlink" title="6.2、Docker 镜像原理"></a>6.2、Docker 镜像原理</h3><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616596.webp" alt="image"></p>
<blockquote>
<p><strong>docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统 UnionFS。</strong></p>
</blockquote>
<ul>
<li>典型的 Linux 文件系统由 <strong>bootfs</strong> 和 <strong>rootfs</strong> 两部分组成</li>
<li><strong>bootfs（boot file system）</strong>主要包含 <strong>bootloader</strong> 和 <strong>kernel</strong>，<strong>bootloader</strong> 主要是引导加载 <strong>kernel</strong>，<strong>Linux</strong> 刚启动时会加载 <strong>bootfs</strong> 文件系统，<strong>在 Docker 镜像的最底层是 bootfs</strong>。这一层与我们典型的 Linux&#x2F;Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。</li>
<li><strong>rootfs (root file system)</strong> ，在 bootfs 之上。包含的就是典型 Linux 系统中的 &#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc 等标准目录和文件。rootfs 就是各种不同的操作系统发行版，比如 Ubuntu，Centos 等等</li>
<li>我们平时安装进虚拟机的 CentOS 都有 1 到几个 GB，为什么 Docker 这里才 200MB？对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用 Host 的 Kemal,自己只需要提供 rootfs 就行了。由此可见不同的 Linux 发行版，他们的 bootfs 是一致的，rootfs 会有差别。<strong>因此不同的发行版可以共用 bootfs</strong></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat              8.5.27              a92c139758db        4 years ago         558MB</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616407.webp" alt="image"></p>
<h3 id="6-3、为什么Docker镜像要采用这种分层结构呢"><a href="#6-3、为什么Docker镜像要采用这种分层结构呢" class="headerlink" title="6.3、为什么Docker镜像要采用这种分层结构呢"></a>6.3、为什么Docker镜像要采用这种分层结构呢</h3><p><strong>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</strong></p>
<p>比如：有多个镜像都是从相同的 base 镜像构建而来的，那么宿主机只需在磁盘中保存一份 base 镜像。同时内存中也只需要加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker 镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。</p>
<blockquote>
<p><strong>如何查看镜像分层？</strong></p>
</blockquote>
<p>使用 <code>docker inspect</code> 命令，查看容器细节</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos              latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat              8.5.27              a92c139758db        4 years ago         558MB</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker inspect tomcat:8.5.27</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616379.webp" alt="image"></p>
<p>所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p>
<p>举一个简单的例子，假如基于 Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python 包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。</p>
<p>该镜像当前已经包含 3 个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616291.webp" alt="image"></p>
<p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含 3 个文件，而镜像包含了来自两个镜像层的 6 个文件。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616039.webp" alt="image"></p>
<p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。</p>
<p>Docker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p>
<p>Linux 上可用的存储引擎有 AUFS、Overlay2、Device Mapper、Btrfs 以及 ZFS。顾名思义，每种存储引擎都基于 Linux 中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p>
<p>Docker 在 Windows 上仅支持 windowsfilter 一种存储引擎，该引擎基于 NTFS 文件系统之上实现了分层和 COW。</p>
<p>下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616746.webp" alt="image"></p>
<h3 id="6-4、重点理解"><a href="#6-4、重点理解" class="headerlink" title="6.4、重点理解"></a>6.4、重点理解</h3><p><strong>Docker镜像层都是只读的，容器层是可写的</strong> 。当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>
<p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616264.png" alt="img"></p>
<h3 id="6-5、核心架构图"><a href="#6-5、核心架构图" class="headerlink" title="6.5、核心架构图"></a>6.5、核心架构图</h3><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616169.webp" alt="image"></p>
<h3 id="6-6、Docker镜像commit操作案例"><a href="#6-6、Docker镜像commit操作案例" class="headerlink" title="6.6、Docker镜像commit操作案例"></a>6.6、Docker镜像commit操作案例</h3><ul>
<li>docker commit提交容器副本使之成为一个新的镜像</li>
<li>docker commit -m&#x3D;”提交的描述信息” -a&#x3D;”作者” 容器ID 要创建的目标镜像名:[标签名]</li>
<li>案例演示ubuntu安装vim<ul>
<li>从Hub上下载ubuntu镜像到本地并成功运行</li>
<li>原始的默认Ubuntu镜像是不带着vim命令的</li>
</ul>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker run -it ubuntu /bin/bash</span></span><br><span class="line">root@e4a6abf80ca5:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@e4a6abf80ca5:/<span class="comment"># vim a.txt</span></span><br><span class="line">bash: vim: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<ul>
<li>外网连通的情况下，安装vim，docker容器内执行以下两条命令：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先更新我们的包管理工具</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="comment">#然后安装我们需要的vim</span></span><br><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure>

<ul>
<li>安装完成后，commit我们自己的新镜像</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">e4a6abf80ca5        ubuntu              <span class="string">&quot;/bin/bash&quot;</span>         21 minutes ago      Up 21 minutes                           nostalgic_mclaren</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker commit -m=&quot;add vim cmd&quot; -a=&quot;frx&quot; e4a6abf80ca5 frx01/myubuntu:1.3</span></span><br><span class="line">sha256:64df8ffb7faf445aa2c8e0e69e67819c4abe549dae7f6ddea943b1a62588b190</span><br></pre></td></tr></table></figure>

<ul>
<li>启动我们的新镜像并和原来的对比</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">frx01/myubuntu      1.3                 64df8ffb7faf        40 seconds ago      179MB</span><br><span class="line">ubuntu              latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos              latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat              8.5.27              a92c139758db        4 years ago         558MB</span><br></pre></td></tr></table></figure>

<ol>
<li>官网是默认下载的Ubuntu没有vim命令</li>
<li>我们自己commit构建的镜像，新增加了vim功能，可以成功使用。</li>
</ol>
<h3 id="6-7、小总结"><a href="#6-7、小总结" class="headerlink" title="6.7、小总结"></a>6.7、小总结</h3><p>Docker中的镜像分层，<strong>支持通过扩展现有镜像，创建新的镜像</strong>。类似Java继承于一个Base基础类，自己再按需扩展。</p>
<p>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616738.webp" alt="image"></p>
<h2 id="7、本地镜像发布到阿里云"><a href="#7、本地镜像发布到阿里云" class="headerlink" title="7、本地镜像发布到阿里云"></a>7、本地镜像发布到阿里云</h2><h3 id="7-1、流程"><a href="#7-1、流程" class="headerlink" title="7.1、流程"></a>7.1、流程</h3><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616093.webp" alt="image"></p>
<h3 id="7-2、镜像的生成方法"><a href="#7-2、镜像的生成方法" class="headerlink" title="7.2、镜像的生成方法"></a>7.2、镜像的生成方法</h3><ul>
<li>第一种：基于当前容器创建一个新的镜像，新功能增强<ul>
<li><a target="_blank" rel="noopener" href="https://frxcat.fun/project-management/Docker/Docker_images_principle/#docker%E9%95%9C%E5%83%8Fcommit%E6%93%8D%E4%BD%9C%E6%A1%88%E4%BE%8B">具体步骤</a></li>
</ul>
</li>
<li>第二种：DockerFile章节</li>
</ul>
<h3 id="7-3、将本地镜像推送到阿里云"><a href="#7-3、将本地镜像推送到阿里云" class="headerlink" title="7.3、将本地镜像推送到阿里云"></a>7.3、将本地镜像推送到阿里云</h3><h4 id="本地镜像原型"><a href="#本地镜像原型" class="headerlink" title="本地镜像原型"></a>本地镜像原型</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">frx01/myubuntu      1.3                 64df8ffb7faf        3 days ago          179MB</span><br><span class="line">ubuntu              latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos              latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat              8.5.27              a92c139758db        4 years ago         558MB</span><br></pre></td></tr></table></figure>

<ul>
<li>阿里云开发者平台:<a target="_blank" rel="noopener" href="https://promotion.aliyun.com/ntms/act/kubernetes.html">https://promotion.aliyun.com/ntms/act/kubernetes.html(opens new window)</a></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616645.webp" alt="image"></p>
<ul>
<li>选择控制台，进入容器镜像服务</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616331.webp" alt="image"></p>
<ul>
<li>进入个人实例</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616996.webp" alt="image"></p>
<ul>
<li>创建命名空间</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616711.webp" alt="image"></p>
<ul>
<li>创建镜像仓库</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616619.webp" alt="image"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616977.webp" alt="image"></p>
<ul>
<li>进入管理页面获得脚本</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616670.webp" alt="image"></p>
<h3 id="7-4、将镜像推送到阿里云"><a href="#7-4、将镜像推送到阿里云" class="headerlink" title="7.4、将镜像推送到阿里云"></a>7.4、将镜像推送到阿里云</h3><ul>
<li>将镜像推送到阿里云registy</li>
<li>管理页面脚本</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141617301.png" alt="image-20221011222329891"></p>
<ul>
<li>执行3的命令</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker login --username=shyflying registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">$ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/hylflying/dockertest:[镜像版本号]</span><br><span class="line">$ docker push registry.cn-hangzhou.aliyuncs.com/hylflying/dockertest:[镜像版本号]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>密码是自己容器镜像下面的访问凭证设置的密码</p>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141616615.webp" alt="image"></p>
<blockquote>
<p>设置image id和版本号</p>
</blockquote>
<ul>
<li>在阿里云上面查看结果</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141617251.webp" alt="image"></p>
<h3 id="7-5、将阿里云的镜像下载到本地"><a href="#7-5、将阿里云的镜像下载到本地" class="headerlink" title="7.5、将阿里云的镜像下载到本地"></a>7.5、将阿里云的镜像下载到本地</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos              latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat              8.5.27              a92c139758db        4 years ago         558MB</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker pull registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3:1.3</span></span><br><span class="line">1.3: Pulling from frx01/myubuntu1.3</span><br><span class="line">7b1a6ab2e44d: Already exists</span><br><span class="line">bc4c9551ae8d: Pull complete</span><br><span class="line">Digest: sha256:76bc84ede8beac0565b660ce31f588d6d2a1bcbc02f34b6c5b0563023f9b537e</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3:1.3</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3   1.3                 64df8ffb7faf        3 days ago          179MB</span><br><span class="line">ubuntu                                                latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos                                                latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat                                                8.5.27              a92c139758db        4 years ago         558MB</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker run -it 64df8ffb7faf /bin/bash</span></span><br><span class="line">root@a7795849ec26:/<span class="comment"># vim a.text</span></span><br></pre></td></tr></table></figure>

<h2 id="8、将本地镜像推送到私有库"><a href="#8、将本地镜像推送到私有库" class="headerlink" title="8、将本地镜像推送到私有库"></a>8、将本地镜像推送到私有库</h2><h3 id="8-1、本地镜像发布到私有库流程"><a href="#8-1、本地镜像发布到私有库流程" class="headerlink" title="8.1、本地镜像发布到私有库流程"></a>8.1、本地镜像发布到私有库流程</h3><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141617781.png" alt="img"></p>
<h3 id="8-2、什么是Docker-Registry"><a href="#8-2、什么是Docker-Registry" class="headerlink" title="8.2、什么是Docker Registry"></a>8.2、什么是Docker Registry</h3><ol>
<li>官方Docker Hub地址：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/ (opens new window)</a>，中国大陆访问太慢了且准备被阿里云取代的趋势，不太主流。</li>
<li>Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。</li>
</ol>
<p> Docker Registry是官方提供的工具，可以用于构建私有镜像仓库。</p>
<h3 id="8-3、将本地镜像推送到私有库"><a href="#8-3、将本地镜像推送到私有库" class="headerlink" title="8.3、将本地镜像推送到私有库"></a>8.3、将本地镜像推送到私有库</h3><ol>
<li>下载镜像Docker Registry</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker pull registry</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/registry</span><br><span class="line">79e9f2f55bf5: Pull complete</span><br><span class="line">0d96da54f60b: Pull complete</span><br><span class="line">5b27040df4a2: Pull complete</span><br><span class="line">e2ead8259a04: Pull complete</span><br><span class="line">3790aef225b9: Pull complete</span><br><span class="line">Digest: sha256:169211e20e2f2d5d115674681eb79d21a217b296b43374b8e39f97fcf866b375</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> registry:latest</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3   1.3                 64df8ffb7faf        3 days ago          179MB</span><br><span class="line">registry                                              latest              b8604a3fe854        10 months ago       26.2MB</span><br><span class="line">ubuntu                                                latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos                                                latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat                                                8.5.27              a92c139758db        4 years ago         558MB</span><br></pre></td></tr></table></figure>

<p>​	2. 运行私有库Registry，相当于本地有个私有库Docker Hub</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000  -v /zzyyuse/myregistry/:/tmp/registry --privileged=<span class="literal">true</span> registry</span><br></pre></td></tr></table></figure>

<p>默认情况，仓库被创建在容器的&#x2F;var&#x2F;lib&#x2F;registry目录下，建议自行用容器卷映射，方便于宿主机联调。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker run -d -p 5000:5000  -v /zzyyuse/myregistry/:/tmp/registry --privileged=true registry</span></span><br><span class="line">ac3ec6f2ef9bfc9e7293e9e962622d043a5696c49e2613d8b4dca7ef2ff75faf</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">ac3ec6f2ef9b        registry            <span class="string">&quot;/entrypoint.sh /etc…&quot;</span>   19 seconds ago      Up 18 seconds       0.0.0.0:5000-&gt;5000/tcp   elated_stallman</span><br></pre></td></tr></table></figure>

<p>​	3. 案例演示创建一个新镜像，<code>ubuntu</code>安装<code>ifconfig</code>命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker run -it ubuntu /bin/bash</span></span><br><span class="line">root@016aba0aa47c:/<span class="comment"># ifconfig</span></span><br><span class="line">bash: ifconfig: <span class="built_in">command</span> not found</span><br><span class="line">root@016aba0aa47c:/<span class="comment"># apt-get update</span></span><br><span class="line">Get:1 http://security.ubuntu.com/ubuntu focal-security InRelease [114 kB]</span><br><span class="line">Get:2 http://archive.ubuntu.com/ubuntu focal InRelease [265 kB]</span><br><span class="line">......</span><br><span class="line">root@016aba0aa47c:/<span class="comment"># apt-get install net-tools</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  net-tools</span><br><span class="line">0 upgraded, 1 newly installed, 0 to remove and 34 not upgraded.</span><br><span class="line">......</span><br><span class="line">root@016aba0aa47c:/<span class="comment"># ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 8467  bytes 24172245 (24.1 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 7644  bytes 417236 (417.2 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>​	4. 安装完成后，commit我们自己的新镜像</p>
<p>公式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker commit -m=<span class="string">&quot;提交的描述信息&quot;</span> -a=<span class="string">&quot;作者&quot;</span> 容器ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure>

<p>命令：在容器外执行，</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker commit -m=<span class="string">&quot;ifconfig cmd add&quot;</span> -a=<span class="string">&quot;zzyy&quot;</span> a69d7c825c4f zzyyubuntu:1.2</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">016aba0aa47c        ubuntu              <span class="string">&quot;/bin/bash&quot;</span>              3 minutes ago       Up 3 minutes                                 relaxed_jackson</span><br><span class="line">ac3ec6f2ef9b        registry            <span class="string">&quot;/entrypoint.sh /etc…&quot;</span>   28 minutes ago      Up 28 minutes       0.0.0.0:5000-&gt;5000/tcp   elated_stallman</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker commit -m=&quot;ifconfig cmd add&quot; -a=&quot;zzyy&quot; 016aba0aa47c zzyyubuntu:1.2</span></span><br><span class="line">sha256:6581250435309a04a2ea6bf1f94f12bfeadee801e0a77e59b29cdf8d78b46194</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">zzyyubuntu                                            1.2                 658125043530        7 seconds ago       112MB</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3   1.3                 64df8ffb7faf        3 days ago          179MB</span><br><span class="line">registry                                              latest              b8604a3fe854        10 months ago       26.2MB</span><br><span class="line">ubuntu                                                latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos                                                latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat                                                8.5.27              a92c139758db        4 years ago         558MB</span><br></pre></td></tr></table></figure>

<p>​	5. 启动我们的新镜像和原来的对比</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker run -it zzyyubuntu:1.2 /bin/bash</span></span><br><span class="line">root@3657253e6268:/<span class="comment"># ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.4  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:04  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 6  bytes 516 (516.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>​	6. curl验证私服库上有什么镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -XGET http://192.168.182.129:5000/v2/_catalog</span><br></pre></td></tr></table></figure>

<p>可以看到，目前私服库没有任何镜像上传过。。。。。。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># curl -XGET http://192.168.182.129:5000/v2/_catalog</span></span><br><span class="line">&#123;<span class="string">&quot;repositories&quot;</span>:[]&#125;</span><br></pre></td></tr></table></figure>

<p>​	7. 将新镜像zzyyubuntu:1.2修改符合私服规范的Tag</p>
<p>按照公式： <code>docker tag 镜像:Tag Host:Port/Repository:Tag</code></p>
<p>自己host主机IP地址，填写你们自己的，不要粘贴错误，O(∩_∩)O</p>
<p>使用命令 docker tag 将zzyyubuntu:1.2 这个镜像修改为192.168.182.129:5000&#x2F;zzyyubuntu:1.2</p>
<p><code>docker tag zzyyubuntu:1.2 192.168.182.129:5000/zzyyubuntu:1.2</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker tag  zzyyubuntu:1.2  192.168.91.166:5000/zzyyubuntu:1.2</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.91.166:5000/zzyyubuntu                        1.2                 658125043530        7 minutes ago       112MB</span><br><span class="line">zzyyubuntu                                            1.2                 658125043530        7 minutes ago       112MB</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3   1.3                 64df8ffb7faf        3 days ago          179MB</span><br><span class="line">registry                                              latest              b8604a3fe854        10 months ago       26.2MB</span><br><span class="line">ubuntu                                                latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos                                                latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat                                                8.5.27              a92c139758db        4 years ago         558MB</span><br></pre></td></tr></table></figure>

<p>​	8. vim命令新增如下红色内容：vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://aa25jngu.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;192.168.182.129:5000&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述理由：docker默认不允许http方式推送镜像，通过配置选项来取消这个限制。&#x3D;&#x3D;&#x3D;&#x3D;&gt; 修改完后如果不生效，建议重启docker</p>
<p>​	9. 推送到私服库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker push 192.168.182.129:5000/zzyyubuntu:1.2</span></span><br><span class="line">The push refers to repository [192.168.91.166:5000/zzyyubuntu]</span><br><span class="line">fa04f996f230: Pushed</span><br><span class="line">9f54eef41275: Pushed</span><br><span class="line">1.2: digest: sha256:fb2ac08ef38b9ff478d209ce1912294ee3471c9ecc572adeaa9dd6cec4d4529a size: 741</span><br></pre></td></tr></table></figure>

<p>​	10. curl验证私服库上有什么镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># curl -XGET http://192.168.91.166:5000/v2/_catalog</span></span><br><span class="line">&#123;<span class="string">&quot;repositories&quot;</span>:[<span class="string">&quot;zzyyubuntu&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>​	11. pull到本地并运行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.182.129:5000/zzyyubuntu                        1.2                 658125043530        19 minutes ago      112MB</span><br><span class="line">zzyyubuntu                                            1.2                 658125043530        19 minutes ago      112MB</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker rmi -f 192.168.182.129:5000/zzyyubuntu:1.2</span></span><br><span class="line">Untagged: 192.168.182.129:5000/zzyyubuntu:1.2</span><br><span class="line">Untagged: 192.168.91.166:5000/zzyyubuntu@sha256:fb2ac08ef38b9ff478d209ce1912294ee3471c9ecc572adeaa9dd6cec4d4529a</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker rmi -f zzyyubuntu:1.2</span></span><br><span class="line">Untagged: zzyyubuntu:1.2</span><br><span class="line">Deleted: sha256:6581250435309a04a2ea6bf1f94f12bfeadee801e0a77e59b29cdf8d78b46194</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3   1.3                 64df8ffb7faf        3 days ago          179MB</span><br><span class="line">registry                                              latest              b8604a3fe854        10 months ago       26.2MB</span><br><span class="line">ubuntu                                                latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos                                                latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat                                                8.5.27              a92c139758db        4 years ago         558MB</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker pull 192.168.182.129:5000/zzyyubuntu:1.2</span></span><br><span class="line">1.2: Pulling from zzyyubuntu</span><br><span class="line">7b1a6ab2e44d: Already exists</span><br><span class="line">0c8559be87f8: Already exists</span><br><span class="line">Digest: sha256:fb2ac08ef38b9ff478d209ce1912294ee3471c9ecc572adeaa9dd6cec4d4529a</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> 192.168.91.166:5000/zzyyubuntu:1.2</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.182.129:5000/zzyyubuntu                        1.2                 658125043530        22 minutes ago      112MB</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3   1.3                 64df8ffb7faf        3 days ago          179MB</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker run -it 192.168.182.129:5000/zzyyubuntu:1.2 /bin/bash</span></span><br><span class="line">root@749c02466301:/<span class="comment"># ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 6  bytes 516 (516.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<h2 id="9、Docker数据卷"><a href="#9、Docker数据卷" class="headerlink" title="9、Docker数据卷"></a>9、Docker数据卷</h2><blockquote>
<p>注</p>
<p> Docker挂载主机目录访问如果出现<strong>cannot open directory .: Permission</strong> denied解决办法：在挂载目录后多加一个**–privileged&#x3D;true**参数即可 </p>
<p>如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了，如果要开启，我们一般使用–privileged&#x3D;true命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p>
</blockquote>
<h3 id="9-1、什么是数据卷"><a href="#9-1、什么是数据卷" class="headerlink" title="9.1、什么是数据卷"></a>9.1、什么是数据卷</h3><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：卷的设计目的就是<strong>数据的持久化</strong>，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p>
<p><strong>数据卷</strong> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性:</p>
<ul>
<li><strong>数据卷</strong> 可以在容器之间共享和享用</li>
<li>对 <strong>数据卷</strong> 的修改立马生效</li>
<li>对 <strong>数据卷</strong> 的更新，不会影响镜像</li>
<li><strong>数据卷</strong> 默认会一直存在，即时容器被删除</li>
</ul>
<p>注意</p>
<p><strong>数据卷</strong> 的使用，类似于 Linux 下对目录或者文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷（仅数据卷为空时复制）</p>
<h3 id="9-2、为什么使用数据卷"><a href="#9-2、为什么使用数据卷" class="headerlink" title="9.2、为什么使用数据卷"></a>9.2、为什么使用数据卷</h3><ul>
<li>当创建一个容器的时候，容器运行，数据能不能持久化</li>
<li>如果能够持久化，数据存储在哪？由于 docker 是隔离的，数据能不能存储在容器外</li>
<li>如果部署很多容器，每次都需要进入容器中进行配置嘛？能不能外部进行配置</li>
</ul>
<p>docker 数据卷呈现给 docker 容器的一个形式就是目录，该目录支持多个容器间共享，修改不会影响到镜像。使用 Docker 的数据卷，类似在系统中使用 mount 挂载一个文件系统。</p>
<h3 id="9-3、数据卷挂载操作"><a href="#9-3、数据卷挂载操作" class="headerlink" title="9.3、数据卷挂载操作"></a>9.3、数据卷挂载操作</h3><p>三种挂载数据卷格式</p>
<ul>
<li>具体目录挂载：<code>docker run [options] -v &lt;宿主机绝对路径:容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</code></li>
<li>默认目录挂载：<code>docker run [options] -v &lt;任意别名:容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</code></li>
<li>匿名目录挂载：<code>docker run [options] -v &lt;容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</code></li>
</ul>
<p>默认目录挂载和匿名目录挂载的目录默认在 <code>/var/lib/docker/volumes/</code> 目录下。</p>
<p>宿主机挂载目录里，都会生成 <code>_data</code> 目录，该目录存放容器挂载目录下的数据。</p>
<h4 id="9-3-1、具体目录挂载"><a href="#9-3-1、具体目录挂载" class="headerlink" title="9.3.1、具体目录挂载"></a>9.3.1、具体目录挂载</h4><p>自定义数据卷目录。</p>
<p>在用 docker run 命令的时候，使用 -v 标记来创建一个数据卷并挂载到容器里。</p>
<p>格式：<code>docker run [options] -v &lt;宿主机绝对路径 | 任意别名:容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run [options] -v &lt;宿主机绝对路径 | 任意别名:容器内的路径:[:ro | rw]&gt; &lt;镜像名&gt;</span><br></pre></td></tr></table></figure>

<p><strong>宿主机路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。</strong></p>
<p><code>ro</code>：代表 read-only，容器的路径只允许读，不允许写。不影响宿主机的路径可读可写</p>
<p><code>rw</code>：默认值，代表可读可写</p>
<blockquote>
<p><strong>例子 1：具名挂载</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8080 --name tomcat02 -v /opt/aa:/usr/local/tomcat/webapps tomcat:8.5.73</span><br></pre></td></tr></table></figure>

<p><strong>特点：宿主机的的挂载目录内容覆盖到容器的挂载目录内容</strong></p>
<p>因为 &#x2F;opt&#x2F;aa 目录为空，所以容器的 webapps 目录被 aa 目录覆盖，也为空。</p>
<p><strong>验证是否成功挂载</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE                                COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">3302e930a1a8        tomcat:8.5.27                        <span class="string">&quot;catalina.sh run&quot;</span>        42 seconds ago      Up 40 seconds       0.0.0.0:8081-&gt;8080/tcp   tomcat02</span><br><span class="line">749c02466301        192.168.91.166:5000/zzyyubuntu:1.2   <span class="string">&quot;/bin/bash&quot;</span>              3 days ago          Up 3 days                                    pedantic_gagarin</span><br><span class="line">ad5ee6156b1c        registry                             <span class="string">&quot;/entrypoint.sh /etc…&quot;</span>   3 days ago          Up 3 days           0.0.0.0:5000-&gt;5000/tcp   competent_meninsky</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看挂载信息</span></span><br><span class="line">docker inspect 3302e930a1a8</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141617712.webp" alt="image"></p>
<blockquote>
<p><strong>例子 2：测试容器和宿主机之间数据共享</strong></p>
</blockquote>
<p>在 tomcat02 容器里创建 test.txt 文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 tomcat02 容器</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># docker exec -it tomcat02 bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器挂载目录</span></span><br><span class="line">root@3302e930a1a8:/usr/local/tomcat<span class="comment"># cd webapps/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 test.txt 文件</span></span><br><span class="line">root@3302e930a1a8:/usr/local/tomcat/webapps<span class="comment"># touch text.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否创建成功</span></span><br><span class="line">root@3302e930a1a8:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">text.txt</span><br></pre></td></tr></table></figure>

<p>在宿主机查看文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 宿主机挂载目录</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># cd /opt/aa</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 返回结果</span></span><br><span class="line">text.txt</span><br></pre></td></tr></table></figure>

<p>说明挂载成功，双方挂载的目录实现共享。</p>
<blockquote>
<p><strong>例子 3：容器停止运行，宿主机添加 test2.txt，再启动容器，文件是否同步到容器里？</strong></p>
</blockquote>
<p>宿主机添加 test2.txt</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 宿主机挂载目录</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># cd /opt/aa</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 test2.txt 文件 </span></span><br><span class="line">[root@frx01 aa]<span class="comment"># touch text2.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">text2.txt  text.txt</span><br></pre></td></tr></table></figure>

<p>启动 tomcat02 容器，查看挂载目录是否有 test2.txt</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动 tomcat02 容器</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># docker start tomcat02</span></span><br><span class="line">tomcat02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 tomcat02 容器</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># docker exec -it tomcat02 bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器挂载目录</span></span><br><span class="line">root@3302e930a1a8:/usr/local/tomcat<span class="comment"># cd webapps/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件</span></span><br><span class="line">root@3302e930a1a8:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">text.txt  text2.txt</span><br></pre></td></tr></table></figure>

<p>说明数据依旧同步</p>
<blockquote>
<p><strong>例子 4：删除容器</strong></p>
</blockquote>
<p>我们删除容器，看主机上数据是否会被删除</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># docker ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID        IMAGE                                COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">3302e930a1a8        tomcat:8.5.27                        <span class="string">&quot;catalina.sh run&quot;</span>        16 minutes ago      Up 16 minutes       0.0.0.0:8081-&gt;8080/tcp   tomcat02</span><br><span class="line">749c02466301        192.168.91.166:5000/zzyyubuntu:1.2   <span class="string">&quot;/bin/bash&quot;</span>              3 days ago          Up 3 days                                    pedantic_gagarin</span><br><span class="line">ad5ee6156b1c        registry                             <span class="string">&quot;/entrypoint.sh /etc…&quot;</span>   3 days ago          Up 3 days           0.0.0.0:5000-&gt;5000/tcp   competent_meninsky</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># docker rm -f 3302e930a1a8</span></span><br><span class="line">3302e930a1a8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 aa 目录</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># cd /opt/aa &amp;&amp; ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">text2.txt  text.txt</span><br></pre></td></tr></table></figure>

<p>说明没有删除。</p>
<h4 id="9-3-2、默认目录挂载"><a href="#9-3-2、默认目录挂载" class="headerlink" title="9.3.2、默认目录挂载"></a>9.3.2、默认目录挂载</h4><p>数据卷目录路径是固定的。</p>
<p>格式：<code>docker run [options] -v &lt;任意别名:容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run [options] -v &lt;任意别名:容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</span><br></pre></td></tr></table></figure>

<p>任意别名是一个数据卷名字，名字可以随便写，Docker 会在 <code>/var/lib/docker/volumes</code> 目录下生成该数据卷，这是 docker 默认的数据卷目录。并且在数据卷里生成 <code>_data</code> 目录用于与容器目录同步数据。</p>
<p><code>ro</code>：代表 read-only，容器的路径只允许读，不允许写。不影响宿主机的路径可读可写</p>
<p><code>rw</code>：默认值，代表可读可写</p>
<blockquote>
<p><strong>例子 1：</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># docker run -d -p 8080:8081 --name tomcat -v aa:/usr/local/tomcat/webapps tomcat:8.5.27</span></span><br><span class="line"></span><br><span class="line">[root@frx01 aa]<span class="comment"># find / -name aa</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">/var/lib/docker/volumes/aa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入宿主机挂载</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/aa/_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">docs  examples  host-manager  manager  ROOT</span><br></pre></td></tr></table></figure>

<p>aa 代表一个数据卷名字，可以是任意，这相当于相对路径，它会在 <code>/var/lib/docker/volumes</code> 下创建 aa 目录作为数据卷。</p>
<p>特点：容器的挂载目录内容覆盖到宿主机的挂载目录内容</p>
<p>其他例子和 具体目录挂载一样。</p>
<h4 id="9-3-3、匿名目录挂载"><a href="#9-3-3、匿名目录挂载" class="headerlink" title="9.3.3、匿名目录挂载"></a>9.3.3、匿名目录挂载</h4><p>没指定名字的挂载都是匿名挂载，-v 只写了容器内路径，并没写宿主机路径。</p>
<p>匿名目录挂载的目录是：<code>/var/lib/docker/volumes/</code>，它会在这个目录生成匿名数据卷目录。</p>
<p>格式：<code>docker run [options] -v &lt;容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run [options] -v &lt;容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</span><br></pre></td></tr></table></figure>

<p><code>ro</code>：代表 read-only，容器的路径只允许读，不允许写。不影响宿主机的路径可读可写</p>
<p><code>rw</code>：默认值，代表可读可写</p>
<blockquote>
<p><strong>例子 1：匿名创建 tomcat3 容器，找到匿名的目录位置</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d -P 8080:8081 --name tomcat03 -v /usr/local/tomcat/webapps tomcat:8.5.27</span><br></pre></td></tr></table></figure>

<p>创建容器时，没有指定宿主机的目录，那么它在哪呢？</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 volumes]<span class="comment"># cd /var/lib/docker/volumes/</span></span><br><span class="line"></span><br><span class="line">[root@frx01 volumes]<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line">75b754f7602e8b946432ad871b0c4b43408dde92f06ce5574ff8352a85c39858</span><br></pre></td></tr></table></figure>

<p>我们可以得知：没有指定宿主机目录，docker 会自动在 <code>/var/lib/docker/volumes</code> 生成很长的字符串，这是什么呢？</p>
<p>这里透露 docker 数据卷操作命令：<code>docker volume ls</code>，查看数据卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     75b754f7602e8b946432ad871b0c4b43408dde92f06ce5574ff8352a85c39858</span><br></pre></td></tr></table></figure>

<p>可以看出匿名目录挂载生成的目录名就是 <strong>随机生成的数据卷名字</strong>。</p>
<h4 id="9-3-4、哪个挂载方法好？"><a href="#9-3-4、哪个挂载方法好？" class="headerlink" title="9.3.4、哪个挂载方法好？"></a>9.3.4、哪个挂载方法好？</h4><p>首先排除掉 <strong>匿名目录挂载</strong>，它的缺点是不好维护，数据卷名随机生成且太长，不清楚目录挂载的是哪个容器。</p>
<p><strong>默认目录挂载</strong> 指定了一个默认目录，无论挂载目录有多少，都集中在默认目录下管理。但是缺点是 <strong>不能指定文件挂载</strong>，只能指定目录进行挂载。它和具体目录挂载的另一个区别是：第一次启动容器挂载时，<strong>容器的挂载目录内容会覆盖宿主机的挂载目录内容</strong>。</p>
<p><strong>具体目录挂载</strong> 可以指定宿主机的任意位置，但是一旦挂载目录多了起来，可能目录过于分散导致无法集中管理，但是它更加灵活，而且 <strong>能指定文件挂载</strong>。值得注意的是：第一次启动容器挂载时，必须确保容器的挂载目录数据备份好，因为该挂载方式会将 <strong>宿主机的挂载目录内容覆盖掉容器的挂载目录内容</strong>。所以，有数据则备份，再挂载。</p>
<p>总之：<strong>匿名目录挂载</strong> 不推荐，根据需求选择 <strong>默认目录挂载</strong> 和 <strong>具体目录挂载</strong>，前者不能挂载文件，挂载在默认目录；后者能挂载文件，且挂载在宿主机任意位置，但是会覆盖容器的挂载目录。我喜欢 <strong>具体目录挂载</strong>。</p>
<h4 id="9-3-5、读写权限"><a href="#9-3-5、读写权限" class="headerlink" title="9.3.5、读写权限"></a>9.3.5、读写权限</h4><p>三个挂载方式我都提到了读写的权限，这个读写权限仅针对 <strong>容器的挂载目录</strong>，如果不指定权限，默认就是可读可写。</p>
<p><strong>什么时候用到呢？</strong> 当我们希望只操作宿主机的挂载目录，然后同步给容器的挂载目录，但是不希望容器的挂载目录也能操作，影响宿主机的挂载目录。</p>
<p>拿默认目录挂载的命令格式来说：<code>docker run [options] -v &lt;任意别名:容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run [options] -v &lt;任意别名:容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</span><br></pre></td></tr></table></figure>

<p><code>ro</code>：代表 read-only，容器的路径只允许读，不允许写。不影响宿主机的路径可读可写</p>
<p><code>rw</code>：默认值，代表可读可写</p>
<blockquote>
<p><strong>例子 1：启动 tomcat04 容器，挂载到 kele 数据卷里，并赋予只读权限</strong></p>
</blockquote>
<p>为了方便，不指定端口映射，<code>-P</code>（大写）直接让 Docker 随机生成端口映射</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d -P --name tomcat04 -v frx:/usr/local/tomcat/webapps:ro tomcat:8.5.27</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果</span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               75b754f7602e8b946432ad871b0c4b43408dde92f06ce5574ff8352a85c39858</span><br><span class="line"><span class="built_in">local</span>               frx</span><br></pre></td></tr></table></figure>

<p><strong>宿主机操作</strong>：找到 docker 的数据卷默认目录，进入 kele 目录下的 _data 目录，创建 test.txt 文件，测试读写权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 frx 目录下的 _data 目录</span></span><br><span class="line">[root@frx01 _data]<span class="comment"># cd /var/lib/docker/volumes/frx/_data/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 test.txt 文件，测试写权限</span></span><br><span class="line">[root@frx01 _data]<span class="comment"># touch text.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件，测试读权限</span></span><br><span class="line">[root@frx01 _data]<span class="comment"># ls </span></span><br><span class="line">docs  examples  host-manager  manager  ROOT  text.txt</span><br></pre></td></tr></table></figure>

<p>说明宿主机可读可写。如果不可写会报错。</p>
<p><strong>容器操作：</strong> 进入 tomcat04 容器的挂载目录，测试读写权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 tomcat04 容器</span></span><br><span class="line">[root@frx01 _data]<span class="comment"># docker exec -it tomcat04 bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入挂载目录</span></span><br><span class="line">root@83d20336795b:/usr/local/tomcat<span class="comment"># cd webapps/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件，测试读权限</span></span><br><span class="line">root@83d20336795b:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">ROOT  docs  examples  host-manager  manager  text.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试写权限</span></span><br><span class="line">root@83d20336795b:/usr/local/tomcat/webapps<span class="comment"># touch text2.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果，报错</span></span><br><span class="line"><span class="built_in">touch</span>: cannot <span class="built_in">touch</span> <span class="string">&#x27;text2.txt&#x27;</span>: Read-only file system</span><br></pre></td></tr></table></figure>

<p>结果告诉我们，无法执行写操作，只能执行读操作。</p>
<blockquote>
<p><strong>例子 2：</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 赋予读写权限</span></span><br><span class="line">docker run -d -P --name tomcat04 -v kele:/usr/local/tomcat/webapps:ro tomcat:8.5.27</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不写权限，默认赋予读写权限</span></span><br><span class="line">docker run -d -P --name tomcat04 -v kele:/usr/local/tomcat/webapps tomcat:8.5.27</span><br></pre></td></tr></table></figure>

<h3 id="9-4、数据卷操作命令"><a href="#9-4、数据卷操作命令" class="headerlink" title="9.4、数据卷操作命令"></a>9.4、数据卷操作命令</h3><p>数据卷在 Docker 称为 volume，所以相关命令都要有 volume。</p>
<h4 id="9-4-1、数据卷命令"><a href="#9-4-1、数据卷命令" class="headerlink" title="9.4.1、数据卷命令"></a>9.4.1、数据卷命令</h4><p>看注释：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker volume --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">Usage:  docker volume COMMAND</span><br><span class="line">Manage volumes</span><br><span class="line">Commands:</span><br><span class="line"></span><br><span class="line">  create      Create a volume  <span class="comment"># 创建一个数据卷</span></span><br><span class="line">  inspect     Display detailed information on one or more volumes  <span class="comment"># 查看数据卷的详细信息</span></span><br><span class="line">  <span class="built_in">ls</span>          List volumes  <span class="comment"># 查看所有数据卷列表</span></span><br><span class="line">  prune       Remove all unused <span class="built_in">local</span> volumes  <span class="comment"># 删除所有未使用的数据卷</span></span><br><span class="line">  <span class="built_in">rm</span>          Remove one or more volumes   <span class="comment"># 删除指定的数据卷</span></span><br><span class="line">  </span><br><span class="line">Run <span class="string">&#x27;docker volume COMMAND --help&#x27;</span> <span class="keyword">for</span> more information on a <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure>

<h4 id="9-4-2、数据卷查看"><a href="#9-4-2、数据卷查看" class="headerlink" title="9.4.2、数据卷查看"></a>9.4.2、数据卷查看</h4><p>查看数据卷的命令已经在上面透露过了。</p>
<p>格式：<code>docker volume ls</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p><strong>例子 1：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 _data]<span class="comment"># docker volume ls</span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               75b754f7602e8b946432ad871b0c4b43408dde92f06ce5574ff8352a85c39858</span><br><span class="line"><span class="built_in">local</span>               aa</span><br><span class="line"><span class="built_in">local</span>               frx</span><br></pre></td></tr></table></figure>

<h4 id="9-4-3、数据卷信息"><a href="#9-4-3、数据卷信息" class="headerlink" title="9.4.3、数据卷信息"></a>9.4.3、数据卷信息</h4><p>格式：<code>docker volume inspect &lt;数据卷名&gt;</code></p>
<blockquote>
<p><strong>例子 1：查看 frx 数据卷的具体信息</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 _data]<span class="comment"># docker volume ls</span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               75b754f7602e8b946432ad871b0c4b43408dde92f06ce5574ff8352a85c39858</span><br><span class="line"><span class="built_in">local</span>               aa</span><br><span class="line"><span class="built_in">local</span>               frx</span><br><span class="line">[root@frx01 _data]<span class="comment"># docker volume inspect frx</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2022-09-18T22:19:07+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/frx/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;frx&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="9-4-5、数据卷创建"><a href="#9-4-5、数据卷创建" class="headerlink" title="9.4.5、数据卷创建"></a>9.4.5、数据卷创建</h4><p>如果不想在启动容器的时候利用 <code>-v</code>「被迫」创建数据卷，这个命令让你收益实用。</p>
<p>格式：<code>docker volumn create &lt;数据卷名&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volumn create &lt;数据卷名&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 1：创建一个MyVolumn 数据卷</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 _data]<span class="comment"># docker volume create MyVolume</span></span><br><span class="line">MyVolume</span><br><span class="line">[root@frx01 _data]<span class="comment"># docker volume ls</span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               75b754f7602e8b946432ad871b0c4b43408dde92f06ce5574ff8352a85c39858</span><br><span class="line"><span class="built_in">local</span>               aa</span><br><span class="line"><span class="built_in">local</span>               frx</span><br><span class="line"><span class="built_in">local</span>               MyVolume</span><br></pre></td></tr></table></figure>

<p>创建的数据卷目录依然在 <code>/var/lib/docker/volumes</code> 下</p>
<h4 id="5-4-6、数据卷删除"><a href="#5-4-6、数据卷删除" class="headerlink" title="5.4.6、数据卷删除"></a>5.4.6、数据卷删除</h4><p>数据卷太多怎么办？可以删除指定名字的数据卷，也可以删除全部未被使用的数据卷。</p>
<ul>
<li>删除指定名字的数据卷命令格式：<code>docker rm &lt;数据卷名&gt;</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> &lt;数据卷名&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除全部未被使用的数据卷命令格式：<code>docker volume prune</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 1：删除 620fb …. 的数据卷</strong></p>
</blockquote>
<p><strong>例子 1：删除 75b …. 的数据卷</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume rm -f 75b754f7602e8b946432ad871b0c4b43408dde92f06ce5574ff8352a85c39858</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 2：删除所有未使用的数据卷</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker volume prune</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">[root@frx01 _data]<span class="comment"># docker volume prune</span></span><br><span class="line">WARNING! This will remove all <span class="built_in">local</span> volumes not used by at least one container.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认 y，取消 N</span></span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N] y</span><br></pre></td></tr></table></figure>

<h3 id="9-5、数据卷容器"><a href="#9-5、数据卷容器" class="headerlink" title="9.5、数据卷容器"></a>9.5、数据卷容器</h3><h4 id="9-5-1、继承"><a href="#9-5-1、继承" class="headerlink" title="9.5.1、继承"></a>9.5.1、继承</h4><p>容器1完成和宿主机的映射</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=<span class="literal">true</span> -v /mydocker/u:/tmp --name u1 ubuntu</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 _data]<span class="comment"># docker run -it  --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu</span></span><br><span class="line">WARNING: IPv4 forwarding is disabled. Networking will not work.</span><br><span class="line">root@a817d0f97c01:/<span class="comment"># cd /tmp/</span></span><br><span class="line">root@a817d0f97c01:/tmp<span class="comment"># ls -l</span></span><br><span class="line">total 0</span><br><span class="line">root@a817d0f97c01:/tmp<span class="comment"># touch u1_data.txt</span></span><br><span class="line">root@a817d0f97c01:/tmp<span class="comment"># ls -l</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r--. 1 root root 0 Sep 18 14:58 u1_data.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 _data]<span class="comment"># cd /mydocker/u/</span></span><br><span class="line">[root@frx01 u]<span class="comment"># pwd</span></span><br><span class="line">/mydocker/u</span><br><span class="line">[root@frx01 u]<span class="comment"># ls -l</span></span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r--. 1 root root 0 9月  18 22:58 u1_data.txt</span><br></pre></td></tr></table></figure>

<p>容器2继承容器1的卷规则</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=<span class="literal">true</span> --volumes-from 父类 --name u2 ubuntu</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 u]<span class="comment"># docker run -it  --privileged=true --volumes-from u1 --name u2 ubuntu</span></span><br><span class="line">root@9c23dc4755bd:/<span class="comment"># cd /tmp/</span></span><br><span class="line">root@9c23dc4755bd:/tmp<span class="comment"># ls</span></span><br><span class="line">u1_data.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 u]<span class="comment"># docker run -it  --privileged=true --volumes-from u1 --name u2 ubuntu</span></span><br><span class="line">root@9c23dc4755bd:/<span class="comment"># cd /tmp/</span></span><br><span class="line">root@9c23dc4755bd:/tmp<span class="comment"># ls</span></span><br><span class="line">u1_data.txt</span><br><span class="line">root@9c23dc4755bd:/tmp<span class="comment"># touch u2_data.txt</span></span><br><span class="line">root@9c23dc4755bd:/tmp<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@frx01 u]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@frx01 u]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">9c23dc4755bd        ubuntu              <span class="string">&quot;bash&quot;</span>              2 minutes ago       Exited (0) 19 seconds ago                       u2</span><br><span class="line">5d80a700eff5        ubuntu              <span class="string">&quot;bash&quot;</span>              2 minutes ago       Exited (0) 2 minutes ago                        u1</span><br><span class="line">[root@frx01 u]<span class="comment"># docker start u1</span></span><br><span class="line">u1</span><br><span class="line">[root@frx01 u]<span class="comment"># docker exec -it 5d80a700eff5 bash</span></span><br><span class="line">root@5d80a700eff5:/<span class="comment"># cd /tmp/</span></span><br><span class="line">root@5d80a700eff5:/tmp<span class="comment"># ls</span></span><br><span class="line">u1_data.txt  u2_data.txt <span class="comment">#u1中也有u2的</span></span><br></pre></td></tr></table></figure>

<h4 id="9-5-2、数据共享"><a href="#9-5-2、数据共享" class="headerlink" title="9.5.2、数据共享"></a>9.5.2、数据共享</h4><p>上面讲述的是主机和容器之间共享数据，那么如何实现容器和容器之间的共享数据呢？那就是创建 <strong>创建数据卷容器</strong>。</p>
<p>命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为 **数据卷容器(Data Volume Container)**。</p>
<p>通俗地来说，docker 容器数据卷可以看成使我们生活中常用的 U 盘，它存在于一个或多个的容器中，由 docker 挂载到容器，但不属于联合文件系统，Docker 不会在容器删除时删除其挂载的数据卷。在创建一个容器时候，使用命令绑定一个父容器，这个父容器就是 <strong>数据卷容器</strong>。</p>
<p>特点：</p>
<ul>
<li>数据卷可以在容器之间共享或重用数据</li>
<li>数据卷中的更改可以直接生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ul>
<p>命令格式：<code>docker run --volumes-from &lt;数据卷容器名&gt; &lt;镜像名[:TAG | ID]&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --volumes-from &lt;数据卷容器名&gt; &lt;镜像名[:TAG | ID]&gt;</span><br></pre></td></tr></table></figure>

<p><code>--volumes-from</code> 可以多次使用来挂载多个容器里的多个数据卷。即该命令是 <strong>链式</strong> 的。</p>
<p><strong>使用 –volumes-from 参数所挂载数据卷的容器自己并不需要保持在运行状态。</strong></p>
<p>注意</p>
<p><code>--volumes-from</code> 后的容器名才是 <strong>数据卷容器</strong>，并不是启动的这个容器。</p>
<blockquote>
<p><strong>例子 1：创建三个容器 tomcat10、tomcat11、tomcat12，其中 tomcat10 是数据卷容器</strong></p>
</blockquote>
<p>为了方便，不指定端口映射，<code>-P</code>（大写）直接让 Docker 随机生成端口映射。</p>
<p>创建数据卷容器的命令和创建容器的命令一样，创建 tomcat10 数据卷容器的时候指定一个数据卷。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">tomcat        8.5.73    7ec084df520c   2 days ago    249MB</span><br><span class="line">mysql         latest    b05128b000dd   3 days ago    516MB</span><br><span class="line">hello-world   latest    feb5d9fea6a5   8 weeks ago   13.3kB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动镜像，创建容器</span></span><br><span class="line">docker run -d -P --name tomcat10 -v tomcat10:/usr/local/tomcat/webapps tomcat:8.5.73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                     NAMES</span><br><span class="line">5516f026bf78   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   29 seconds ago   Up 29 seconds   0.0.0.0:49155-&gt;8080/tcp   tomcat10</span><br></pre></td></tr></table></figure>

<p>创建 tomcat11 和 tomcat12 容器，绑定 tomcat10 容器，也就是绑定数据卷容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行两个命令</span></span><br><span class="line">docker run -d -P --name tomcat11 --volumes-from tomcat10 tomcat:8.5.73</span><br><span class="line">docker run -d -P --name tomcat12 --volumes-from tomcat10 tomcat:8.5.73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                     NAMES</span><br><span class="line">2cc6944ab955   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   15 seconds ago   Up 14 seconds   0.0.0.0:49157-&gt;8080/tcp   tomcat12</span><br><span class="line">0bd657b306d3   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   45 seconds ago   Up 44 seconds   0.0.0.0:49156-&gt;8080/tcp   tomcat11</span><br><span class="line">5516f026bf78   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   6 minutes ago    Up 6 minutes    0.0.0.0:49155-&gt;8080/tcp   tomcat10</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 2：证明三个容器的数据是否共享</strong></p>
</blockquote>
<p><strong>例子 1</strong> 已经创建好三个容器，并且 tomcat10 容器的数据卷目录是 tomcat10。我们可以在 tomcat10 容器的 webapps 目录下创建一个 test.txt 文件，看看 tomcat11 容器和 tomcat12 容器的 webapps 是否同步数据。</p>
<p>首先进入 tomcat10 容器的 webapps 目录，创建 test.txt 文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 tomcat10 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat10 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 webapps 目录</span></span><br><span class="line">root@f45ea598ee8d:/usr/local/tomcat<span class="comment"># cd webapps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 test.txt 文件</span></span><br><span class="line">root@f45ea598ee8d:/usr/local/tomcat/webapps<span class="comment"># touch test.txt</span></span><br></pre></td></tr></table></figure>

<p>然后我们进入 tomcat11 容器，看文件是否同步过来，并且创建 test2.txt 文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 tomcat11 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat11 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 webapps 目录</span></span><br><span class="line">root@31220638e2dc:/usr/local/tomcat<span class="comment"># cd webapps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 test.txt 文件</span></span><br><span class="line">root@31220638e2dc:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 test2.txt 文件</span></span><br><span class="line">root@31220638e2dc:/usr/local/tomcat/webapps<span class="comment"># touch test2.txt</span></span><br></pre></td></tr></table></figure>

<p>然后我们进入 tomcat12 容器，看文件是否同步过来</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 tomcat12 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat12 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 webapps 目录</span></span><br><span class="line">root@31220638e2dc:/usr/local/tomcat<span class="comment"># cd webapps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 test.txt 文件</span></span><br><span class="line">root@31220638e2dc:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">test2.txt  test.txt</span><br></pre></td></tr></table></figure>

<p>我们可以知道，数据是实现了共享。只要 tomcat10 数据卷容器的更新内容，其他绑定的容器都会同步内容。</p>
<p>最后我们看看宿主机的挂载目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入宿主机挂载目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/tomcat10/_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">test2.txt  test.txt</span><br></pre></td></tr></table></figure>

<p>说明无论是 tomcat10 容器的挂载目录，还是映射的宿主机挂载目录，只要任意一个发生改变，绑定的普通容器也会发生改变，实现共享。</p>
<p><strong>笔记</strong></p>
<p>普通容器绑定数据卷容器，其实就是绑定数据卷容器的数据卷。</p>
<p>所以删除 tomcat10 容器后 ，tomcat11 容器修改文件后， tomcat12 容器还可以正常共享数据，因为 tomcat10 容器的数据卷没有被删除。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141617257.webp" alt="image"></p>
<p>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。 存储在本机的文件则会一直保留。</p>
<p><strong>如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 docker rm -v 命令来指定同时删除关联的容器。这可以让用户在容器之间升级和移动数据卷。</strong></p>
<h4 id="9-5-3、数据备份"><a href="#9-5-3、数据备份" class="headerlink" title="9.5.3、数据备份"></a>9.5.3、数据备份</h4><p>可以利用数据卷对其中的数据进行进行备份、恢复。</p>
<p>数据备份命令格式：<code>docker run [options] --volumes-from &lt;数据卷容器&gt; [-v &lt;宿主机绝对路径&gt;:&lt;随机路径&gt;] &lt;镜像名&gt;:[TAG | ID] tar cvf &lt;随机路径/备份名&gt; &lt;数据卷容器路径&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run [options] --volumes-from &lt;数据卷容器&gt; [-v &lt;宿主机绝对路径&gt;:&lt;随机路径&gt;] &lt;镜像名&gt;:[TAG | ID] tar cvf &lt;随机路径/备份名&gt; &lt;数据卷容器路径&gt;</span><br></pre></td></tr></table></figure>

<p><strong>两个随机路径必须保持一致</strong>。备份路径默认在 <code>/var/lib/docker/overlay2/</code> 下的容器 ID 目录下生成。</p>
<blockquote>
<p><strong>例子 1：不指定宿主机挂载目录下和容器备份目录，备份 tomcat10 容器的数据卷 webapps 目录</strong></p>
</blockquote>
<p>这里是 tomcat10 容器，这个容器已经创建，并且容器的 <code>/usr/local/tomcat/webapps</code> 有 test.txt 和 test2.txt 文件，具体步骤在 数据共享实现了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line">docker run --name tomcat-backup --volumes-from tomcat10 tomcat:8.5.73 tar cvf /backup.tar /usr/local/tomcat/webapps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找备份的文件</span></span><br><span class="line">find / -name backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">/var/lib/docker/overlay2/a9ef07977088b96970d926e95650a4810acf60429f9b9ca66625b6366597ff12/diff/backup.tar</span><br></pre></td></tr></table></figure>

<p>容器启动后，使用了 tar 命令来将容器的 &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps 目录备份到宿主机里，宿主机备份的路径看第 8 行数据，备份的文件是 backup.tar。</p>
<p><strong>如果容器删除，那么该方式的备份文件也被删除，并且备份目录是容器 ID 命名，并非容器名，看一长串字符串就知道了。</strong></p>
<p>如果解决删除问题，以及想要指定的路径进行备份，例子 2 方式可以解决。</p>
<blockquote>
<p><strong>例子 2：指定宿主机挂载目录下和容器备份目录，备份 tomcat10 容器的数据卷 webapps 目录</strong></p>
</blockquote>
<p><strong>这种方式如果容器删除，备份文件不会被删除。</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line">docker run --volumes-from tomcat10 -v /opt/backup:/backup tomcat:8.5.73 tar cvf /backup/backup.tar /usr/local/tomcat/webapps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找备份的文件</span></span><br><span class="line">find / -name backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">/opt/backup/backup.tar</span><br><span class="line">/var/lib/docker/overlay2/a9ef07977088b96970d926e95650a4810acf60429f9b9ca66625b6366597ff12/diff/backup.tar</span><br></pre></td></tr></table></figure>

<p>容器的挂载路径要和备份的文件路径保持一致，才能指定备份路径。否则如例子 3 报错：</p>
<blockquote>
<p><strong>例子 3：容器挂载路径和备份文件的路径不一致情况</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line">docker run --volumes-from tomcat10 -v /opt/backup:/a tomcat:8.5.73 tar cvf /b/backup.tar /usr/local/tomcat/webapps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">tar: /b/backup.tar: Cannot open: No such file or directory</span><br><span class="line">tar: Error is not recoverable: exiting now</span><br></pre></td></tr></table></figure>

<p>容器的挂载路径是 a，但是备份的路径是 b，所以报错了，如果路径保持一致：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除例子 2的备份文件</span></span><br><span class="line"><span class="built_in">rm</span> -f /opt/backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份</span></span><br><span class="line">docker run --volumes-from tomcat10 -v /opt/backup:/a tomcat:8.5.73 tar cvf /a/backup.tar /usr/local/tomcat/webapps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找备份的文件</span></span><br><span class="line">find / -name backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">/opt/backup/backup.tar</span><br><span class="line">/var/lib/docker/overlay2/a9ef07977088b96970d926e95650a4810acf60429f9b9ca66625b6366597ff12/diff/backup.tar</span><br></pre></td></tr></table></figure>

<p>说明容器的挂载路径要和备份的文件路径保持一致，才能备份成功。建议使用路径 <code>/backup</code> 。</p>
<p>原理：首先将宿主机和容器的目录进行挂载，实现连通，接着容器内压缩成备份文件到 <code>/a</code> 目录下，实际上也会压缩到与 <code>/a</code> 挂载的 <code>/opt/backup</code> 目录下，所以这就是为什么将压缩文件的目录和宿主机的挂载目录保持一致，它们连通才能互相同步数据。</p>
<h4 id="9-5-4、数据恢复"><a href="#9-5-4、数据恢复" class="headerlink" title="9.5.4、数据恢复"></a>9.5.4、数据恢复</h4><p>备份了数据，那么就需要进行数据恢复。</p>
<p>恢复命令格式：<code>docker run --volumes-from &lt;恢复到哪个数据卷容器&gt; [-v &lt;宿主机绝对路径&gt;:&lt;随机路径&gt;] &lt;镜像名&gt;[:TAG | ID] tar xvf &lt;随机路径 | 路径&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --volumes-from &lt;恢复到哪个数据卷容器&gt; [-v &lt;宿主机绝对路径&gt;:&lt;随机路径&gt;] &lt;镜像名&gt;[:TAG | ID] tar xvf &lt;随机路径 | 路径&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>例子 1：数据恢复到 tomcat20 容器的数据卷里</strong></p>
</blockquote>
<p>如果要恢复数据到 tomcat20 容器，首先创建一个带有数据卷的容器 tomcat20，因为只能恢复数据到数据卷里。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name tomcat20 -v tomcat20:/usr/local/tomcat/webapps tomcat:8.5.73</span><br></pre></td></tr></table></figure>

<p>然后创建另一个容器，挂载 tomcat20 的容器，并使用 untar 解压备份文件到挂载的容器卷中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --volumes-from tomcat20 -v /opt/backup:/backup tomcat:8.5.73 tar xvf /backup/backup.tar -C /</span><br></pre></td></tr></table></figure>

<p><code>-C /</code> 代表解压到根目录下，因为压缩包的文件基于根目录的，否则解压的目录是基于 <code>/backup</code>。</p>
<p>原理：此时 tomcat20 挂载目录是 <code>/usr/local/tomcat/webapps</code>，而新的容器只要挂载了 tomcat20 容器，它们两个的 <code>/usr/local/tomcat/webapps</code> 形成关联，新的容器的这个目录发生改变，则 tomcat20 的挂载目录也会发生改变，所以解压文件到新的容器的该目录下，实际上也是解压文件到 tomcat20 的挂载目录下，也就是实现恢复数据。</p>
<h3 id="9-6、挂载特性"><a href="#9-6、挂载特性" class="headerlink" title="9.6、挂载特性"></a>9.6、挂载特性</h3><p>关于到底是宿主机的挂载目录覆盖容器的挂载目录，还是反过来覆盖：</p>
<ul>
<li>默认目录挂载：<ul>
<li>当宿主机挂载目录已经存在时，双方挂载完成后，<strong>宿主机挂载目录覆盖容器挂载目录</strong></li>
<li>当宿主机挂载目录不存在时，双方挂载完成后，<strong>容器挂载目录覆盖宿主机挂载目录</strong></li>
</ul>
</li>
<li>具体目录挂载<ul>
<li>当宿主机挂载目录无论存不存在，双方挂载完成后，<strong>宿主机挂载目录都会覆盖容器挂载目录</strong></li>
</ul>
</li>
</ul>
<p><strong>默认目录挂载</strong></p>
<table>
<thead>
<tr>
<th>宿主机</th>
<th>容器</th>
<th>运行结果</th>
</tr>
</thead>
<tbody><tr>
<td>文件存在</td>
<td>文件存在</td>
<td>挂载成功，<strong>宿主机文件内容覆盖容器文件内容</strong></td>
</tr>
<tr>
<td>目录存在</td>
<td>目录存在</td>
<td>挂载成功，<strong>宿主机目录内容覆盖容器目录内容</strong></td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>文件不存在</td>
<td>文件存在</td>
<td>挂载成功，<strong>容器文件内容覆盖宿主机文件内容</strong></td>
</tr>
<tr>
<td>目录不存在</td>
<td>目录存在</td>
<td>挂载成功，<strong>容器目录内容覆盖宿主机目录内容</strong></td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>其他和 <strong>具体目录挂载</strong> 类似</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>具体目录挂载</strong></p>
<table>
<thead>
<tr>
<th>宿主机</th>
<th>容器</th>
<th>运行结果</th>
</tr>
</thead>
<tbody><tr>
<td>文件存在</td>
<td>文件存在</td>
<td>挂载成功，<strong>宿主机文件内容覆盖容器文件内容</strong></td>
</tr>
<tr>
<td>目录存在</td>
<td>目录存在</td>
<td>挂载成功，<strong>宿主机目录内容覆盖容器目录内容</strong></td>
</tr>
<tr>
<td>——</td>
<td>——</td>
<td>——</td>
</tr>
<tr>
<td>文件不存在</td>
<td>文件存在</td>
<td>挂载成功，<strong>宿主机创建空文件，并覆盖掉容器的文件，导致也为空</strong></td>
</tr>
<tr>
<td>目录不存在</td>
<td>目录存在</td>
<td>挂载成功，<strong>宿主机创建空目录，并覆盖掉容器的文件，导致也为空</strong></td>
</tr>
<tr>
<td>——</td>
<td>——</td>
<td>——</td>
</tr>
<tr>
<td>文件存在</td>
<td>文件不存在</td>
<td>挂载成功</td>
</tr>
<tr>
<td>目录存在</td>
<td>目录不存在</td>
<td>挂载成功</td>
</tr>
<tr>
<td>——</td>
<td>——</td>
<td>——</td>
</tr>
<tr>
<td>文件存在</td>
<td>目录存在</td>
<td>容器启动失败</td>
</tr>
<tr>
<td>目录存在</td>
<td>文件存在</td>
<td>容器启动失败</td>
</tr>
<tr>
<td>——</td>
<td>——</td>
<td>——</td>
</tr>
<tr>
<td>目录不存在</td>
<td>目录不存在</td>
<td>挂载成功，<strong>Docker 会自动在宿主机和容器内新建目录</strong></td>
</tr>
<tr>
<td>目录不存在</td>
<td>文件存在</td>
<td>容器启动失败</td>
</tr>
<tr>
<td>目录不存在</td>
<td>目录存在</td>
<td>挂载成功，<strong>宿主机空目录内容覆盖容器内目录（空）</strong></td>
</tr>
</tbody></table>
<h2 id="10、Docker-软件安装"><a href="#10、Docker-软件安装" class="headerlink" title="10、Docker 软件安装"></a>10、Docker 软件安装</h2><h3 id="10-1、Tomcat安装使用"><a href="#10-1、Tomcat安装使用" class="headerlink" title="10.1、Tomcat安装使用"></a>10.1、Tomcat安装使用</h3><p>tomcat 版本网址：<a target="_blank" rel="noopener" href="https://registry.hub.docker.com/_/tomcat">https://registry.hub.docker.com/_&#x2F;tomcat(opens new window)</a></p>
<h4 id="10-1-1、版本选择"><a href="#10-1-1、版本选择" class="headerlink" title="10.1.1、版本选择"></a>10.1.1、版本选择</h4><p>tomcat 有很多的版本分支，一个版本可能有多个分支，如 <code>8-jre</code> 代表 Tomcat 8 内置 jre8 的版本、 <code>8-jdk8</code> 代表 Tomcat 8 内置 jdk8 的版本等等。所以根据需求进行版本选择。（jdk 包括了 jre，但是相对而言比较大）</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141617656.webp" alt="image"></p>
<h4 id="10-1-2、安装修改"><a href="#10-1-2、安装修改" class="headerlink" title="10.1.2、安装修改"></a>10.1.2、安装修改</h4><p>这里选择的是 <code>8.5.82-jre8-temurin-focal</code> 版本，先下载：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull tomcat:8.5.82-jre8-temurin-jammy</span><br></pre></td></tr></table></figure>

<p>下载的版本名太长，我们可以创建短的版本，然后删除掉长的版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY                                            TAG                         IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.91.166:5000/zzyyubuntu                        1.2                         658125043530        4 days ago          112MB</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3   1.3                         64df8ffb7faf        8 days ago          179MB</span><br><span class="line">tomcat                                                8.5.82-jre8-temurin-jammy   0065fb7141cd        2 weeks ago         240MB</span><br><span class="line">registry                                              latest                      b8604a3fe854        10 months ago       26.2MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增短版本</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># docker tag 0065fb7141cd tomcat:8.5.82</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除长版本</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># docker rmi tomcat:8.5.82-jre8-temurin-jammy</span></span><br><span class="line">Untagged: tomcat:8.5.82-jre8-temurin-jammy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询查看镜像</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images tomcat</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">tomcat              8.5.82              0065fb7141cd        2 weeks ago         240MB</span><br><span class="line">tomcat              8.5.27              a92c139758db        4 years ago         558MB</span><br></pre></td></tr></table></figure>

<h4 id="10-1-3、启动使用"><a href="#10-1-3、启动使用" class="headerlink" title="10.1.3、启动使用"></a>10.1.3、启动使用</h4><p>Tomcat 的使用相比较其他还是非常简单的，Tomcat 启动后，进入容器的默认目录是 <code>/usr/local/tomcat</code>，这里提供几个启动命令：</p>
<ul>
<li>命名后台启动</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name tomcat01 -p 8080:8080 tomcat:8.5.82</span><br></pre></td></tr></table></figure>

<ul>
<li>webapps 启动：创建 webapps 的数据卷，在宿主机的挂载目录部署项目，就会同步到容器的 webapps 目录下</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name tomcat01 -p 8080:8080 -v tomcat01-webapps:/usr/local/tomcat/webapps tomcat:8.5.82</span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件启动：创建配置文件的数据卷，在宿主机的挂载目录修改配置文件，就会同步到容器的配置文件中</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name tomcat01 -p 8080:8080 -v tomcat01-webapps:/usr/local/tomcat/webapps -v tomcat01-conf:/usr/local/tomcat/conf tomcat:8.5.82</span><br></pre></td></tr></table></figure>

<p><code>tomcat01-webapps</code> 和 <code>tomcat01-conf</code> 根据需求创建数据卷名。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker run -d --name tomcat01 -p 8080:8080 -v tomcat01-webapps:/usr/local/tomcat/webapps tomcat:8.5.73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat01 bash</span><br></pre></td></tr></table></figure>

<p>进入 webapps 目录，查看内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@efc01854d5e1:/usr/local/tomcat<span class="comment"># cd webapps</span></span><br><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#内容为空</span></span><br></pre></td></tr></table></figure>

<p>会发现为空，这是因为 Tomcat 官方把所有的初始化文件放到了 webapps.dist 目录下，我们去看看：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps<span class="comment"># cd ../webapps.dist/</span></span><br><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps.dist<span class="comment"># ls</span></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">docs  examples  host-manager  manager  ROOT</span><br></pre></td></tr></table></figure>

<p>所以我们需要把 webapps.dist 的内容拷贝到 webapps 目录中，为什么不删除 webapps 目录然后把 webapps.dist 重命名呢？因为容器运行期间无法删除文件，而不运行我们无法进入容器内部，所以只能一个一个拷贝过去</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps.dist<span class="comment"># cp -r docs/ ../webapps</span></span><br><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps.dist<span class="comment"># cp -r examples/ ../webapps</span></span><br><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps.dist<span class="comment"># cp -r host-manager/ ../webapps</span></span><br><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps.dist<span class="comment"># cp -r manager/ ../webapps</span></span><br><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps.dist<span class="comment"># cp -r ROOT/ ../webapps</span></span><br></pre></td></tr></table></figure>

<p>此时我们进入默认目录 <code>/var/lib/docker/volumes/tomcat01-webapps/_data</code> 下查看拷贝的内容是否同步过来：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入默认目录并查看内容</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/tomcat01-webapps/_data</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">docs  examples  host-manager  manager  ROOT</span><br></pre></td></tr></table></figure>

<p>虽然同步过来了，但是这样子会很累对吧，而且重新启动一个新的 Tomcat 容器，必须要重新执行 5 个拷贝操作，我们可以利用数据卷来同步数据。</p>
<h4 id="10-1-4、挂载特性"><a href="#10-1-4、挂载特性" class="headerlink" title="10.1.4、挂载特性"></a>10.1.4、挂载特性</h4><p>可以利用数据卷特性：</p>
<ul>
<li>默认目录挂载：<ul>
<li>当宿主机挂载目录已经存在时，双方挂载完成后，<strong>宿主机挂载目录覆盖容器挂载目录</strong></li>
<li>当宿主机挂载目录不存在时，双方挂载完成后，<strong>容器挂载目录覆盖宿主机挂载目录</strong></li>
</ul>
</li>
<li>具体目录挂载<ul>
<li>当宿主机挂载目录无论存不存在，双方挂载完成后，<strong>宿主机挂载目录都会覆盖容器挂载目录</strong></li>
</ul>
</li>
</ul>
<p>所以我们有两种方式：</p>
<p>首先我们手动拷贝一份 tomcat01 的宿主机挂载目录，该目录已经将数据同步过来，目录有 webapps 的内容了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝一份 tomcat01 的宿主机挂载目录，新的目录名叫 tomcat02-webapps</span></span><br><span class="line"><span class="built_in">cp</span> -r tomcat01-webapps tomcat02-webapps</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>方式 1：默认目录挂载</strong></p>
</blockquote>
<p>启动第二个 Tomcat 容器，利用 <strong>默认目录挂载</strong> 的第一个特性进行与容器的挂载</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name tomcat02 -p 8081:8080 -v tomcat02-webapps:/usr/local/tomcat/webapps tomcat:8.5.73</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 tomcat02 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat02  bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 webapps 目录，并查看内容</span></span><br><span class="line">root@50edd2a86a8d:/usr/local/tomcat<span class="comment"># cd webapps</span></span><br><span class="line">root@50edd2a86a8d:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">docs  examples  host-manager  manager  ROOT</span><br></pre></td></tr></table></figure>

<p>说明同步成功。</p>
<blockquote>
<p><strong>方式 2：具体目录挂载</strong></p>
</blockquote>
<p>启动第三个 Tomcat 容器，利用 <strong>具体目录挂载</strong> 方式进行与容器的挂载（缺点：指定到 _data 目录，因为该方式是从指定的目录覆盖容器的目录）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name tomcat03 -p 8082:8080 -v /var/lib/docker/volumes/tomcat02-webapps/_data:/usr/local/tomcat/webapps tomcat:8.5.73</span><br></pre></td></tr></table></figure>

<p>进入容器看看，是否同步过来了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 tomcat03 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat03 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 webapps 目录，并查看内容</span></span><br><span class="line">root@ba7961226856:/usr/local/tomcat<span class="comment"># cd webapps</span></span><br><span class="line">root@ba7961226856:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">docs  examples  host-manager  manager  ROOT</span><br></pre></td></tr></table></figure>

<p>说明同步成功。</p>
<blockquote>
<p><strong>总结：</strong></p>
</blockquote>
<p>推荐方式 1，因为方式 2 必须指定到 _data 目录，不灵活。而使用方式 1，必须先确保宿主机存在该目录，并且目录里有想要的内容。</p>
<p>Tomcat 也有配置文件，里面可以修改 8080 端口，上面的第三个启动命令就是给配置文件进行数据卷挂载，步骤和 webapps 的两个例子一样，这里不演示了。</p>
<p>值得注意的是：修改完配置文件的端口后，需要重新 run 一个新的 Tomcat 容器，然后该容器和宿主机修改后的配置文件目录挂载，才能真正实现端口的修改，因为第一次端口映射在 run 时是 8080:8080，无法修改为 8080:XXXX(修改的端口)，需要重新 run 才行，而 run 出来的配置文件默认端口还是 8080，所以需要利用数据卷特性，让宿主机的配置文件覆盖容器的 8080 端口配置文件。</p>
<h4 id="10-1-5、相关指令"><a href="#10-1-5、相关指令" class="headerlink" title="10.1.5、相关指令"></a>10.1.5、相关指令</h4><p>进入 Tomcat 容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;容器名或 <span class="built_in">id</span>&gt; bash</span><br></pre></td></tr></table></figure>

<p>查看 Tomcat 容器的日志</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加 -f 代表实时监听日志动态</span></span><br><span class="line">docker logs [-f] &lt;容器名或 <span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="10-2、MySQL安装"><a href="#10-2、MySQL安装" class="headerlink" title="10.2、MySQL安装"></a>10.2、MySQL安装</h3><p>MySQL 版本网址：<a target="_blank" rel="noopener" href="https://registry.hub.docker.com/_/mysql">https://registry.hub.docker.com/_&#x2F;mysql(opens new window)</a></p>
<h4 id="10-2-1、安装启动"><a href="#10-2-1、安装启动" class="headerlink" title="10.2.1、安装启动"></a>10.2.1、安装启动</h4><ul>
<li>拉取镜像到本地</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<ul>
<li>简单运行 MySQL 服务，将需要挂载的目录拷贝出来</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name mysql -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure>

<p>密码自行修改。使用 3307 是因为宿主机可能已经安装了 MySQL，它占用了 3306 端口。</p>
<p>拷贝挂载的目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先创建挂载目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /docker/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL的相关文件同步到挂载目录</span></span><br><span class="line">docker <span class="built_in">cp</span> mysql:/var/lib/mysql /docker/mysql/data</span><br><span class="line">docker <span class="built_in">cp</span> mysql:/etc/mysql/conf.d /docker/mysql/conf</span><br><span class="line">docker <span class="built_in">cp</span> mysql:/var/log /docker/mysql/log</span><br></pre></td></tr></table></figure>

<p>为什么要拷贝出来呢？因为一旦挂载成功，宿主机的挂载目录会覆盖容器的目录，所以我们确保宿主机的挂载目录不能为空，必须要有原来容器目录的文件。</p>
<ul>
<li><p>宿主机与容器实现挂载，保证数据安全，对应上方拷贝出来的目录</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://frxcat.fun/project-management/Docker/Docker_Software_installation/#%E6%97%A0%E6%B3%A8%E8%A7%A3%E7%89%88(%E5%8F%AF%E7%94%A8)">无注解版(可用)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://frxcat.fun/project-management/Docker/Docker_Software_installation/#%E6%9C%89%E6%B3%A8%E8%A7%A3%E7%89%88(%E5%8F%AA%E7%9C%8B%E4%B8%8D%E7%94%A8)">有注解版(只看不用)</a></p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --name mysql \</span><br><span class="line">    --restart always \</span><br><span class="line">    -p 3307:3306 \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">    -v /docker/mysql/data:/var/lib/mysql \</span><br><span class="line">    -v /docker/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">    -v /docker/mysql/log:/var/log \</span><br><span class="line">    mysql:5.7</span><br></pre></td></tr></table></figure>

<p>宿主机的挂载目录、conf.d 目录、data 数据目录、日志目录根据需求决定，包括密码。</p>
<p>这里说明一下：主配置文件名叫 my.cnf，位置在 <code>/etc/mysql</code>，但是不建议直接操作 my.cnf 主配置文件，官方也是如此，所以官方提供了 conf.d 目录，只要在 conf.d 目录下创建 xx.cnf 配置文件，那么该配置文件自动被引入 my.cnf 主配置文件，避免直接操作 my.cnf 引起安全问题。</p>
<p>my.cnf 文件里有这么一句代码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">includedir /etc/mysql/conf.d/</span><br></pre></td></tr></table></figure>

<p>可以看出，my.cnf 会自动读取该目录下的所有 .cnf 配置文件。</p>
<p><strong>笔记</strong></p>
<p>确保简单启动的密码和挂载启动的保持一致，因为启动后，密码保存在 <code>/var/lib/mysql</code> 目录下，而挂载的时候，宿主机的该目录会覆盖容器的目录，导致密码是简单启动的密码。所以确保两种启动方式密码保持一致。</p>
<ul>
<li><strong>配置 UTF-8 编码</strong></li>
</ul>
<p>进入宿主机的配置文件挂载目录：<code>/docker/mysql/conf</code>，有一个 mysql.cnf 配置文件，编辑它</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /docker/mysql/conf</span><br><span class="line">vim mysql.cnf</span><br></pre></td></tr></table></figure>

<p>添加如下内容（如果文件有 <code>[mysql]</code>，必须先删除掉）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>

<ul>
<li>进入 MySQL 容器，配置 UTF-8 编码</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器名 | 容器<span class="built_in">id</span> bash</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql bash</span><br></pre></td></tr></table></figure>

<p>进入容器后，登录 MySQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>查看数据库的编码是否是 UTF-8</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%char%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如图则代表配置成功：</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141618593.webp" alt="image"></p>
<ul>
<li>外部查看 MySQL 日志（可选）</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker logs 容器<span class="built_in">id</span> | 容器名</span><br></pre></td></tr></table></figure>

<h4 id="10-2-2、其他命令"><a href="#10-2-2、其他命令" class="headerlink" title="10.2.2、其他命令"></a>10.2.2、其他命令</h4><ul>
<li>将 MySQL 数据库备份为 sql 文件<ul>
<li>导出全部数据库的数据为 sql 文件</li>
</ul>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> 容器名 | 容器 <span class="built_in">id</span> bash -c <span class="string">&#x27;exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27;</span> &gt; /opt/all-database.sql </span><br></pre></td></tr></table></figure>

<ul>
<li>用户名要根据需求替换、<code>/opt/all-database</code> 是导出文件的路径，需要根据需求修改。密码不需要修改，它会自动获取登录的密码。</li>
<li>导出指定的数据库数据的 sql 文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> 容器名 | 容器 bash -c <span class="string">&#x27;exec mysqldump --databases 库名 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27;</span> &gt; /opt/one-database.sql</span><br></pre></td></tr></table></figure>

<ul>
<li>导出指定的数据库，但是不要数据</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> 容器名 | 容器 bash -c <span class="string">&#x27;exec mysqldump --no-data --databases 库名 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27;</span> &gt; /opt/one-database.sql</span><br></pre></td></tr></table></figure>

<ul>
<li>执行 sql 文件到 MySQL 中</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> 容器名 | 容器<span class="built_in">id</span> bash -c <span class="string">&#x27;exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27;</span> &lt; /opt/xxx.sql</span><br></pre></td></tr></table></figure>

<p><code>/opt/xxx.sql</code> 是 sql 文件的路径。</p>
<h3 id="10-3、Redis安装"><a href="#10-3、Redis安装" class="headerlink" title="10.3、Redis安装"></a>10.3、Redis安装</h3><h4 id="10-3-1、安装"><a href="#10-3-1、安装" class="headerlink" title="10.3.1、安装"></a>10.3.1、安装</h4><p>Redis 版本网址：<a target="_blank" rel="noopener" href="https://registry.hub.docker.com/_/redis">https://registry.hub.docker.com/_&#x2F;redis(opens new window)</a></p>
<p>Redis 的安装还是比较简单的，这里安装 6.62 版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull redis:6.2.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 docker 容器</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>

<h4 id="10-3-2、启动"><a href="#10-3-2、启动" class="headerlink" title="10.3.2、启动"></a>10.3.2、启动</h4><p>Redis 启动后，进入容器的默认目录是 <code>/data</code></p>
<p>启动指令：</p>
<ul>
<li>简单的启动，也是最快速的个人使用启动：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis -p 6379:6379 redis:6.2.6</span><br></pre></td></tr></table></figure>

<ul>
<li><p>AOP 持久化启动</p>
<p>指定持久化的 .aop 文件路径，宿主机的文件路径根据需求存放，容器的文件路径默认在 <code>/data</code></p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis -p 6379:6379 -v redis_data:/data redis:6.2.6 redis-server --appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>容器的 <code>/data</code> 是 AOP 文件的默认路径，<code>redis_data</code> 根据需求修改，是宿主机的挂载目录，而 <code>redis-server --appendonly yes</code> 是必须的，这个命令会覆盖默认的命令，默认的命令是关闭持久化。</p>
<ul>
<li>自定义配置文件启动：指定配置文件的路径和容器的 <code>/usr/local/etc/redis</code> 挂载，一旦挂载后，容器的该目录获得配置文件，然后通过 <code>redis-server /usr/local/etc/redis/redis.conf</code> 启动该配置文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis -p 6379:6379 -v /opt/redis.conf:/usr/local/etc/redis/redis.conf -d redis:6.2.6 redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<p><code>/opt/redis_conf</code> 是在宿主机的配置文件路径，根据需求修改。</p>
<blockquote>
<p><strong>注意：Redis 容器内没有 redis.conf 文件，启动的配置信息都是默认的。我们需要自己准备好一份 redis.conf 文件，然后通过数据卷传进容器内</strong></p>
</blockquote>
<p>如何准备一份 redis.conf 文件呢？</p>
<ul>
<li><p>去官网下载对应的 Windows 版本，然后拷贝 redis.conf 到 Linux 下，再启动配置，这样很麻烦对吧</p>
</li>
<li><p>直接 Linux 下创建一个 redis.conf 文件，虽然不如原生的全面，但是我们只需要加入自己的一些配置即可，其他配置 Redis 自动使用默认的</p>
<p>比如：</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据需求指定创建路径</span></span><br><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">vim redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 redis.conf 加入如下内容</span></span><br><span class="line"><span class="comment"># 限制能访问 redis 的地址，根据需求修改</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认是 yes，开启保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 redis 连接密码，可选</span></span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以守护进程方式启动，可后台启动</span></span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改本地 redis 数据库存放文件夹（可选）</span></span><br><span class="line"><span class="built_in">dir</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># AOP 持久化</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<ul>
<li>redis.conf常用配置</li>
</ul>
<blockquote>
<ul>
<li><p>bind 0.0.0</p>
<p>限制 redis 只能本地访问，根据需求修改</p>
</li>
<li><p>protected-mode no</p>
<p>默认是 yes，开启保护模式，限制为本地访问</p>
</li>
<li><p>requirepass 123456</p>
<p>配置redis连接密码，默认是注释的</p>
</li>
<li><p>daemonize no</p>
<p>默认 no，改为 yes 代表以守护进程方式启动，可后台运行，除非kill进程（可选），改为 yes 会使配置文件方式启动 redis 失败</p>
</li>
<li><p>dir .&#x2F;</p>
<p>更改本地 redis 数据库存放文件夹（可选）</p>
</li>
<li><p>appendonly yes</p>
<p>redis 持久化（开启了这个，redis 就不会每次重启时自动清空了）</p>
</li>
</ul>
</blockquote>
<p>如果不加入 <code>appendonly yes</code>，可以利用 AOP 持久化启动来指定 <code>appendonly yes</code> 启动。</p>
<h4 id="10-3-3、其他"><a href="#10-3-3、其他" class="headerlink" title="10.3.3、其他"></a>10.3.3、其他</h4><p>启动后进入 redis 容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis bash</span><br></pre></td></tr></table></figure>

<p>查看 redis 的日志</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加 -f 代表实时监听日志动态</span></span><br><span class="line">docker logs [-f] redis</span><br></pre></td></tr></table></figure>

<p>输入 <code>redis-cli</code> 连接 redis，如果是连接其他服务器的 redis，则需要加参数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -h IP地址 -p 6379</span><br></pre></td></tr></table></figure>

<h3 id="10-4、ElasticSearch安装"><a href="#10-4、ElasticSearch安装" class="headerlink" title="10.4、ElasticSearch安装"></a>10.4、ElasticSearch安装</h3><h4 id="10-4-1、安装"><a href="#10-4-1、安装" class="headerlink" title="10.4.1、安装"></a>10.4.1、安装</h4><p>ElasticSearch 版本网址：<a target="_blank" rel="noopener" href="https://registry.hub.docker.com/_/elasticsearch">https://registry.hub.docker.com/_&#x2F;elasticsearch(opens new window)</a></p>
<p>这里下载的版本是 7.14.2</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:7.14.2</span><br></pre></td></tr></table></figure>

<h4 id="10-4-2、配置"><a href="#10-4-2、配置" class="headerlink" title="10.4.2、配置"></a>10.4.2、配置</h4><p>如果启动报错</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">max virtual memory areas vm.max_map_count [65530] is too low，increase to at least [262144]</span><br></pre></td></tr></table></figure>

<p>则需要进行配置，没有出现错误可以跳过</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改配置 sysctl.conf</span></span><br><span class="line">vim /etc/stsctl.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入配置信息</span></span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用配置</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h4 id="10-4-3、启动"><a href="#10-4-3、启动" class="headerlink" title="10.4.3、启动"></a>10.4.3、启动</h4><p>三种启动方式：</p>
<ul>
<li>简单启动</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 elasticsearch:7.14.2</span><br></pre></td></tr></table></figure>

<p>如果报错，请看 <a target="_blank" rel="noopener" href="https://frxcat.fun/project-management/Docker/Docker_Software_installation#%E9%85%8D%E7%BD%AE">配置</a> 进行解决</p>
<p>浏览器访问的是 9200 端口</p>
<ul>
<li>持久化和配置文件启动</li>
</ul>
<p>ES 中所有的数据都在容器中的 <code>/usr/share/elasticsearch/data</code> 目录，配置文件在 <code>/usr/share/elasticsearch/config</code>，所以需要挂载出来</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -v es_data:/usr/share/elasticsearch/data -v es_config:/usr/share/elasticsearch/config elasticsearch:7.14.2</span><br></pre></td></tr></table></figure>

<p>挂载成功后，哪怕容器被删除了，数据还是会存在宿主机的 <code>/.../es_data</code> 目录下</p>
<ul>
<li>ik 分词器启动</li>
</ul>
<blockquote>
<p><strong>方式 1：</strong></p>
</blockquote>
<p>首先下载好 ik 分词器，版本要和 ES 版本一致，放到 Linux 系统中，我们知道，ES 的插件目录是 <code>/usr/share/elasticsearch/plugins</code> 下，所以需要挂载出来</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -v es_data:/usr/share/elasticsearch/data -v es_config:/usr/share/elasticsearch/config -v es_plugins:/usr/share/elasticsearch/plugins elasticsearch:7.14.2</span><br></pre></td></tr></table></figure>

<p>此时的 <code>es_plugins</code> 目录下为空，我们把下载好的 ik 分词器放到该目录下，然后重启 ES 即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> &lt;ik 分词器&gt; /var/lib/docker/volumes/es_plugins/_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 es</span></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>方式 2：</strong></p>
</blockquote>
<p>先创建数据卷，把 ik 分词器放到数据卷里</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume create es_plugins</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> &lt;ik 分词器&gt; /var/lib/docker/volumes/es_plugins/_data</span><br></pre></td></tr></table></figure>

<p>再启动容器进行挂载</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -v es_data:/usr/share/elasticsearch/data -v es_config:/usr/share/elasticsearch/config -v es_plugins:/usr/share/elasticsearch/plugins elasticsearch:7.14.2</span><br></pre></td></tr></table></figure>

<h3 id="10-5、Kibana安装"><a href="#10-5、Kibana安装" class="headerlink" title="10.5、Kibana安装"></a>10.5、Kibana安装</h3><p>Kibana 版本网址：<a target="_blank" rel="noopener" href="https://registry.hub.docker.com/_/kibana">https://registry.hub.docker.com/_&#x2F;kibana(opens new window)</a></p>
<p>下载 Kibaba 镜像，版本要和 ElasticSearch 一致。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull kibana:7.14.2</span><br></pre></td></tr></table></figure>

<p>启动</p>
<ul>
<li><p>简单启动</p>
<p>此时没有指定连接 ES</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name kibana -p 5601:5601 kibaba:7.14.2</span><br></pre></td></tr></table></figure>

<ul>
<li>连接 ES 启动</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name kibana -p 5601:5601 -e ELASTICSEARCH_URL=http://IP地址:9200 kibaba:7.14.2</span><br></pre></td></tr></table></figure>

<ul>
<li>先简单启动，后在配置文件再连接 ES，重启生效</li>
</ul>
<p>首先知道配置文件的路径是 <code>/usr/share/kibana/config</code>，将它挂载出来</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name kibana -p 5601:5601 -v kibana_conf:/usr/share/kibana/config kibana:7.14.2</span><br></pre></td></tr></table></figure>

<p>启动后进入宿主机的 kibana_conf 目录或者 容器的 <code>/usr/share/kibana/config</code> 目录，这里演示前者</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/kibana_conf/_data</span><br><span class="line"></span><br><span class="line">vim kibana.yml</span><br></pre></td></tr></table></figure>

<p>修改为 ES 的 IP 地址</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141618939.webp" alt="image"></p>
<h1 id="二、高级篇"><a href="#二、高级篇" class="headerlink" title="二、高级篇"></a>二、高级篇</h1><h2 id="1、Docker复杂安装"><a href="#1、Docker复杂安装" class="headerlink" title="1、Docker复杂安装"></a>1、Docker复杂安装</h2><h3 id="1-1、Mysql主从复制"><a href="#1-1、Mysql主从复制" class="headerlink" title="1.1、Mysql主从复制"></a>1.1、Mysql主从复制</h3><h4 id="1-1-1、数据库主从复制原理"><a href="#1-1-1、数据库主从复制原理" class="headerlink" title="1.1.1、数据库主从复制原理"></a>1.1.1、数据库主从复制原理</h4><p>主从复制原理，简言之，分三步曲进行：</p>
<p>主数据库有个 bin log 二进制文件，记录了所有增删改 SQL 语句。(binlog线程)<br>从数据库把主数据库的 bin log 文件的 SQL 语句复制到自己的中继日志 relay log(io线程)<br>从数据库的 relay log 重做日志文件，再执行一次这些sql语句。(sql执行线程)<br>详细的主从复制过程如图：</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141618342.png" alt="img"></p>
<p>上图主从复制过程分了五个步骤进行：</p>
<ul>
<li>主库的更新SQL(update、insert、delete)被写到binlog</li>
<li>从库发起连接，连接到主库。</li>
<li>此时主库创建一个 binlog dump thread，把 bin log 的内容发送到从库。</li>
<li>从库启动之后，创建一个 I&#x2F;O 线程，读取主库传过来的 bin log 内容并写到 relay log</li>
<li>从库还会创建一个SQL线程，从 relay log 里面读取内容，从 ExecMasterLog_Pos 位置开始执行读取到的更新事件，将更新内容写入到 slave 的db</li>
</ul>
<h4 id="1-1-2、主从搭建步骤"><a href="#1-1-2、主从搭建步骤" class="headerlink" title="1.1.2、主从搭建步骤"></a>1.1.2、主从搭建步骤</h4><p><strong>数据库主从</strong>：一台是主数据库，同时对外提供读写操作。一台是<strong>从数据库，对外提供读的操作。</strong>数据从主库同步到从库。<img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141618795.png" alt="img"><br>从库和备库，就是slave库功能不同因此叫法不一样而已。一般slave库都会对外提供读的功能的，因此，大家日常听得最多的就是<strong>主从</strong>。注意关闭防火墙<code>sytemctl disable firewalld</code></p>
<ul>
<li>新建主服务器容器实例3307</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 3307:3306 --name mysql-master \</span><br><span class="line">-v /mydata/mysql-master/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-master/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-master/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root  \</span><br><span class="line">-d mysql:5.7</span><br><span class="line">[root@hua conf]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS         PORTS                                                  NAMES</span><br><span class="line">2e4da9502453   mysql:5.7   &quot;docker-entrypoint.s…&quot;   10 minutes ago   Up 3 minutes   33060/tcp, 0.0.0.0:3307-&gt;3306/tcp, :::3307-&gt;3306/tcp   mysql-master</span><br></pre></td></tr></table></figure>

<ul>
<li>进入&#x2F;mydata&#x2F;mysql-master&#x2F;conf目录下新建my.cnf</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua conf]# vim my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置server_id，同一局域网中需要唯一</span></span></span><br><span class="line">server_id=101 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 指定不需要同步的数据库名称</span></span></span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 开启二进制日志功能</span></span></span><br><span class="line">log-bin=mall-mysql-bin  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置二进制日志使用内存大小（事务）</span></span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置使用的二进制日志格式（mixed,statement,row）</span></span></span><br><span class="line">binlog_format=mixed  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span></span><br><span class="line">expire_logs_days=7  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span></span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure>

<ul>
<li>修改完配置后重启master实例</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua conf]# docker restart mysql-master</span><br></pre></td></tr></table></figure>

<ul>
<li>进入mysql-master容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua conf]# docker exec -it mysql-master /bin/bash</span><br><span class="line">root@2e4da9502453:/# mysql -uroot -p</span><br><span class="line">Enter password:root</span><br></pre></td></tr></table></figure>

<ul>
<li>master容器实例内创建数据同步用户</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">CREATE USER <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>新建从服务器容器实例3308</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 3308:3306 --name mysql-slave \</span><br><span class="line">-v /mydata/mysql-slave/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-slave/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-slave/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root  \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>

<ul>
<li>·进入&#x2F;mydata&#x2F;mysql-slave&#x2F;conf目录下新建my.cnf</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua conf]# vim my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置server_id，同一局域网中需要唯一</span></span></span><br><span class="line">server_id=102</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 指定不需要同步的数据库名称</span></span></span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span></span></span><br><span class="line">log-bin=mall-mysql-slave1-bin  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置二进制日志使用内存大小（事务）</span></span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置使用的二进制日志格式（mixed,statement,row）</span></span></span><br><span class="line">binlog_format=mixed  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span></span><br><span class="line">expire_logs_days=7  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span></span><br><span class="line">slave_skip_errors=1062  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># relay_log配置中继日志</span></span></span><br><span class="line">relay_log=mall-mysql-relay-bin  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span></span><br><span class="line">log_slave_updates=1  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># slave设置为只读（具有super权限的用户除外）</span></span></span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure>

<ul>
<li>修改完配置后重启slave实例</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart mysql-slave</span><br></pre></td></tr></table></figure>

<ul>
<li>在<strong>主数据库中查看主从同步状态</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show master status;</span></span><br><span class="line">+-----------------------+----------+--------------+------------------+---------------                   ----+</span><br><span class="line">| File                  | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_                   Set |</span><br><span class="line">+-----------------------+----------+--------------+------------------+---------------                   ----+</span><br><span class="line">| mall-mysql-bin.000001 |     617 |              | mysql            |                                      |</span><br><span class="line">+-----------------------+----------+--------------+------------------+---------------                   ----+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>进入mysql-slave容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua ~]# docker exec -it mysql-slave /bin/bash</span><br><span class="line">root@4557df93e926:/# mysql -uroot -p</span><br><span class="line">Enter password:root</span><br></pre></td></tr></table></figure>

<ul>
<li>在从数据库中配置主从复制</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;宿主机ip&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=617, master_connect_retry=30;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;192.168.182.129&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=617, master_connect_retry=30;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主从复制命令参数说明</p>
<p>master_host：主数据库的IP地址；</p>
<p>master_port：主数据库的运行端口；</p>
<p>master_user：在主数据库创建的用于同步数据的用户账号；</p>
<p>master_password：在主数据库创建的用于同步数据的用户密码；</p>
<p>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</p>
<p>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</p>
<p>master_connect_retry：连接失败重试的时间间隔，单位为秒。</p>
</blockquote>
<ul>
<li>在从数据库中查看主从同步状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show slave status \G;</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141618596.png" alt="image-20221013213057313"></p>
<ul>
<li>在从数据库中开启主从同步</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141618403.png" alt="image-20221013213224880"></p>
<ul>
<li>主从复制测试</li>
</ul>
<p>主机新建库-使用库-新建表-插入数据，ok</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create database db01;</span></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">use db01;</span></span><br><span class="line">Database changed</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create table user(<span class="built_in">id</span> int ,name varchar(20));</span></span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">insert into user values(1,<span class="string">&#x27;zhang&#x27;</span>),(2,<span class="string">&#x27;san&#x27;</span>);</span></span><br><span class="line">Query OK, 2 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">select * from user;</span></span><br><span class="line">+------+-------+</span><br><span class="line">| id   | name  |</span><br><span class="line">+------+-------+</span><br><span class="line">|    1 | zhang |</span><br><span class="line">|    2 | san   |</span><br><span class="line">+------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从机使用库-查看记录，ok</p>
<h3 id="1-2、安装Redis集群"><a href="#1-2、安装Redis集群" class="headerlink" title="1.2、安装Redis集群"></a>1.2、安装Redis集群</h3><h4 id="1-2-1、cluster-集群-模式-docker版-哈希槽分区进行亿级数据存储"><a href="#1-2-1、cluster-集群-模式-docker版-哈希槽分区进行亿级数据存储" class="headerlink" title="1.2.1、cluster(集群)模式-docker版 哈希槽分区进行亿级数据存储"></a>1.2.1、cluster(集群)模式-docker版 哈希槽分区进行亿级数据存储</h4><p>问题：1~2亿条数据需要缓存，请问如何设计这个存储案例</p>
<p>单机单台100%不可能，肯定是分布式存储，用redis如何落地</p>
<h5 id="哈希取余分区"><a href="#哈希取余分区" class="headerlink" title="哈希取余分区"></a>哈希取余分区</h5><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141618047.png" alt="image-20221015103628343"></p>
<blockquote>
<p>2亿条记录就是2亿个k,v，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：<code>hash(key) % N</code>个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。</p>
</blockquote>
<p><strong>优点：</strong></p>
<p>简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。</p>
<p><strong>缺点：</strong></p>
<p>原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)&#x2F;3会变成Hash(key) &#x2F;?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。</p>
<p>某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</p>
<h5 id="一致性哈希算法分区"><a href="#一致性哈希算法分区" class="headerlink" title="一致性哈希算法分区"></a>一致性哈希算法分区</h5><p><strong>是什么</strong></p>
<p>一致性哈希算法在1997年由麻省理工学院中提出的，设计目标是为了解决分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数不OK了。</p>
<p><strong>能干嘛</strong></p>
<p>提出一致性Hash解决方案。 目的是当服务器个数发生变动时， 尽量减少影响客户端到服务器的映射关系。</p>
<h6 id="3大步骤"><a href="#3大步骤" class="headerlink" title="3大步骤"></a><strong>3大步骤</strong></h6><ul>
<li>算法构建一致性哈希环</li>
</ul>
<p>一致性哈希环</p>
<p>  一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 &#x3D; 2^32),这样让它逻辑上形成了一个环形空间。</p>
<p>它也是按照使用取模的方法，前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性Hash算法是对2^32取模，简单来说，<strong>一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，</strong>如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下图：<strong>整个空间按顺时针方向组织</strong>，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141618712.png" alt="image-20221015124718040"></p>
<ul>
<li>服务器IP节点映射</li>
</ul>
<p>节点映射</p>
<p><strong>将集群中各个IP节点映射到环上的某一个位置。</strong></p>
<p>将各个服务器使用Hash进行一个哈希，具体可以<strong>选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置</strong>。假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算(hash(ip))，使用IP地址哈希后在环空间的位置如下： </p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141618912.png" alt="image-20221015124806345"></p>
<ul>
<li>key落到服务器的落键规则</li>
</ul>
<p>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，<strong>从此位置沿环顺时针“行走”</strong>，<strong>第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</strong></p>
<p>如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141618277.png" alt="image-20221015124902869"></p>
<p><strong>优点</strong></p>
<ul>
<li>一致性哈希算法的容错性</li>
</ul>
<p><strong>容错性</strong></p>
<p>假设Node C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，<strong>如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响</strong>。简单说，就是C挂了，受到影响的只是B、C之间的数据，并且这些数据会转移到D进行存储。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141618606.jpg" alt="graphic"></p>
<ul>
<li>一致性哈希算法的<strong>扩展性</strong></li>
</ul>
<p> 扩展性</p>
<p>数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，</p>
<p>不会导致hash取余全部数据重新洗牌。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141618720.jpg" alt="graphic"></p>
<p> 缺点</p>
<ul>
<li>一致性哈希算法的数据倾斜问题</li>
</ul>
<p>Hash环的数据倾斜问题</p>
<p>一致性Hash算法在服务<strong>节点太少时</strong>，容易因为节点分布不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上）问题，</p>
<p>例如系统中只有两台服务器：</p>
<p> <img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141619108.jpg" alt="graphic"></p>
<h6 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h6><p>为了在节点数目发生改变时尽可能少的迁移数据。将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到临近的存储节点存放。而当有节点加入或退出时仅影响该节点在Hash环上顺时针相邻的后续节点。 </p>
<p><strong>优点</strong></p>
<p>加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</p>
<p><strong>缺点</strong> </p>
<p>数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</p>
<h5 id="哈希槽分区"><a href="#哈希槽分区" class="headerlink" title="哈希槽分区"></a>哈希槽分区</h5><p>哈希槽实质就是一个数组，数组[0,2^14 -1]形成hash slot空间。</p>
<p><strong>能干什么</strong></p>
<p><strong>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。</strong></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141619477.jpg" alt="graphic"></p>
<p>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。</p>
<p>哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。</p>
<p><strong>多少个hash槽</strong></p>
<p>一个集群只能有16384个槽，编号0-16383（0-2^14-1）。<strong>这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点</strong>。集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取余，余数是几key就落入对应的槽里。slot &#x3D; CRC16(key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p>
<p> <strong>哈希槽计算</strong></p>
<p>Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。如下代码，key之A 、B在Node2， key之C落在Node3上。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141619269.jpeg" alt="graphic"><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141619073.jpg" alt="graphic"></p>
<h4 id="1-2-2、3主3从redis集群扩缩容配置案例架构说明"><a href="#1-2-2、3主3从redis集群扩缩容配置案例架构说明" class="headerlink" title="1.2.2、3主3从redis集群扩缩容配置案例架构说明"></a>1.2.2、3主3从redis集群扩缩容配置案例架构说明</h4><h5 id="3主3从redis集群配置"><a href="#3主3从redis集群配置" class="headerlink" title="3主3从redis集群配置"></a>3主3从redis集群配置</h5><ul>
<li>关闭防火墙+启动docker后台服务</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">docker start docker</span><br></pre></td></tr></table></figure>

<ul>
<li>新建6个docker容器redis实例</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis-node-1 --net host --privileged=true -v /data/redis/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-2 --net host --privileged=true -v /data/redis/share/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-3 --net host --privileged=true -v /data/redis/share/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-4 --net host --privileged=true -v /data/redis/share/redis-node-4:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-5 --net host --privileged=true -v /data/redis/share/redis-node-5:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6385</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-6 --net host --privileged=true -v /data/redis/share/redis-node-6:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386</span><br></pre></td></tr></table></figure>

<p><strong>如果运行成功，效果如下：</strong></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141619527.png" alt="image-20221015134934504"></p>
<blockquote>
<p>#创建并运行docker容器实例</p>
<p>docker run</p>
<p>#容器名字</p>
<p>–name redis-node-6</p>
<p>#使用宿主机的IP和端口，默认</p>
<p>–net host</p>
<p>#获取宿主机root用户权限</p>
<p>–privileged&#x3D;true</p>
<p>#容器卷，宿主机地址:docker内部地址</p>
<p>-v &#x2F;data&#x2F;redis&#x2F;share&#x2F;redis-node-6:&#x2F;data</p>
<p>#redis镜像和版本号</p>
<p>redis:6.0.8</p>
<p>#开启redis集群</p>
<p>–cluster-enabled yes</p>
<p>#开启持久化</p>
<p>–appendonly yes</p>
<p>#redis端口号</p>
<p>–port 6386</p>
</blockquote>
<ul>
<li>进入容器redis-node-1并为6台机器构建集群关系</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua ~]# docker exec -it redis-node-1 /bin/bash</span><br><span class="line">root@hua:/data# redis-cli --cluster create 192.168.182.129:6381 192.168.182.129:6382 192.168.182.129:6383 192.168.182.129:6384 192.168.182.129:6385 192.168.182.129:6386 --cluster-replicas 1</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 192.168.182.129:6385 to 192.168.182.129:6381</span><br><span class="line">Adding replica 192.168.182.129:6386 to 192.168.182.129:6382</span><br><span class="line">Adding replica 192.168.182.129:6384 to 192.168.182.129:6383</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span></span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: ca047127cc88177ace8529eec236c99735aa29cf 192.168.182.129:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 84da5624cbdaa8ea4b25be089b89aecc377c3d90 192.168.182.129:6382</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00 192.168.182.129:6383</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 59f62200185f23135a791505f2122da5c38b417a 192.168.182.129:6384</span><br><span class="line">   replicates 1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00</span><br><span class="line">S: f39c163fabdcc288c01202609aeb082427e257a7 192.168.182.129:6385</span><br><span class="line">   replicates ca047127cc88177ace8529eec236c99735aa29cf</span><br><span class="line">S: 36b3aeacc83ab768c73471fec37adfdb6c3fb4a5 192.168.182.129:6386</span><br><span class="line">   replicates 84da5624cbdaa8ea4b25be089b89aecc377c3d90</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Sending CLUSTER MEET messages to <span class="built_in">join</span> the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><strong>–cluster-replicas 1 表示为每个master创建一个slave节点</strong></p>
<ul>
<li><p>一切OK的话，3主3从搞定</p>
</li>
<li><p>链接进入6381作为切入点，查看集群状态</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@hua:/data# redis-cli -p 6381 -c</span><br><span class="line">127.0.0.1:6381&gt; cluster info</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:170</span><br><span class="line">cluster_stats_messages_pong_sent:173</span><br><span class="line">cluster_stats_messages_sent:343</span><br><span class="line">cluster_stats_messages_ping_received:168</span><br><span class="line">cluster_stats_messages_pong_received:170</span><br><span class="line">cluster_stats_messages_meet_received:5</span><br><span class="line">cluster_stats_messages_received:343</span><br></pre></td></tr></table></figure>

<ul>
<li>链接进入6381作为切入点，查看节点状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt;  cluster nodes</span><br><span class="line"></span><br><span class="line">1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00 192.168.182.129:6383@16383 master - 0 1665810893011 3 connected 10923-16383</span><br><span class="line"></span><br><span class="line">84da5624cbdaa8ea4b25be089b89aecc377c3d90 192.168.182.129:6382@16382 master - 0 1665810891000 2 connected 5461-10922</span><br><span class="line"></span><br><span class="line">ca047127cc88177ace8529eec236c99735aa29cf 192.168.182.129:6381@16381 myself,master - 0 1665810890000 1 connected 0-5460</span><br><span class="line"></span><br><span class="line">59f62200185f23135a791505f2122da5c38b417a 192.168.182.129:6384@16384 slave 1c5a4ebddbd b9305e8fe2b02a43a6a84193d4c00 0 1665810890001 3 connected</span><br><span class="line"></span><br><span class="line">f39c163fabdcc288c01202609aeb082427e257a7 192.168.182.129:6385@16385 slave ca047127cc8                       8177ace8529eec236c99735aa29cf 0 1665810891004 1 connected</span><br><span class="line"></span><br><span class="line">36b3aeacc83ab768c73471fec37adfdb6c3fb4a5 192.168.182.129:6386@16386 slave 84da5624cbd                       aa8ea4b25be089b89aecc377c3d90 0 1665810892008 2 connected</span><br></pre></td></tr></table></figure>

<h5 id="主从容错切换迁移案例"><a href="#主从容错切换迁移案例" class="headerlink" title="主从容错切换迁移案例"></a>主从容错切换迁移案例</h5><p><strong>数据读写存储</strong></p>
<ul>
<li><p>启动6机构成的集群并通过exec进入</p>
</li>
<li><p>对6381新增两个key</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt; set k1 v1</span><br><span class="line">(error) MOVED 12706 192.168.182.129:6383</span><br><span class="line">127.0.0.1:6381&gt; exit</span><br></pre></td></tr></table></figure>

<p>防止路由失效加参数-c并新增两个key</p>
<p><strong>加入参数-c，优化路由</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@hua:/data# redis-cli -p 6381 -c</span><br><span class="line">127.0.0.1:6381&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6381&gt; set k1 v1</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [12706] located at 192.168.182.129:6383</span></span><br><span class="line">OK</span><br><span class="line">192.168.182.129:6383&gt; keys *</span><br><span class="line">1) &quot;k1&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看集群信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@hua:/data# redis-cli --cluster check 192.168.182.129:6381</span><br><span class="line">192.168.182.129:6381 (ca047127...) -&gt; 2 keys | 5461 slots | 1 slaves.</span><br><span class="line">192.168.182.129:6383 (1c5a4ebd...) -&gt; 1 keys | 5461 slots | 1 slaves.</span><br><span class="line">192.168.182.129:6382 (84da5624...) -&gt; 1 keys | 5462 slots | 1 slaves.</span><br><span class="line">[OK] 4 keys in 3 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node 192.168.182.129:6381)</span></span><br><span class="line">M: ca047127cc88177ace8529eec236c99735aa29cf 192.168.182.129:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00 192.168.182.129:6383</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 84da5624cbdaa8ea4b25be089b89aecc377c3d90 192.168.182.129:6382</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 59f62200185f23135a791505f2122da5c38b417a 192.168.182.129:6384</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00</span><br><span class="line">S: f39c163fabdcc288c01202609aeb082427e257a7 192.168.182.129:6385</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates ca047127cc88177ace8529eec236c99735aa29cf</span><br><span class="line">S: 36b3aeacc83ab768c73471fec37adfdb6c3fb4a5 192.168.182.129:6386</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 84da5624cbdaa8ea4b25be089b89aecc377c3d90</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p><strong>容错切换迁移</strong></p>
<ul>
<li>主6381和从机切换，先停止主机6381</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop redis-node-1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>6381主机停了，对应的真实从机上位</p>
</li>
<li><p>查看集群信息</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua ~]# docker stop redis-node-1</span><br><span class="line">redis-node-1</span><br><span class="line">[root@hua ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND                  CREATED             STATUS             PORTS     NAMES</span><br><span class="line">ef5c8dc0e4e3   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-6</span><br><span class="line">fef20b91d661   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-5</span><br><span class="line">7dce83d92716   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-4</span><br><span class="line">720512c556a2   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-3</span><br><span class="line">4c69a4a36031   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-2</span><br><span class="line">[root@hua ~]# docker exec -it redis-node-2 bash</span><br><span class="line">root@hua:/data# redis-cli -p 6382 -c</span><br><span class="line">127.0.0.1:6382&gt; cluster nodes</span><br><span class="line">ca047127cc88177ace8529eec236c99735aa29cf 192.168.182.129:6381@16381 master,fail - 1665813882486 1665813878000 1 disconnected</span><br><span class="line">59f62200185f23135a791505f2122da5c38b417a 192.168.182.129:6384@16384 slave 1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00 0 1665813965945 3 connected</span><br><span class="line">36b3aeacc83ab768c73471fec37adfdb6c3fb4a5 192.168.182.129:6386@16386 slave 84da5624cbdaa8ea4b25be089b89aecc377c3d90 0 1665813963937 2 connected</span><br><span class="line">1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00 192.168.182.129:6383@16383 master - 0 1665813965000 3 connected 10923-16383</span><br><span class="line">84da5624cbdaa8ea4b25be089b89aecc377c3d90 192.168.182.129:6382@16382 myself,master - 0 1665813964000 2 connected 5461-10922</span><br><span class="line">f39c163fabdcc288c01202609aeb082427e257a7 192.168.182.129:6385@16385 master - 0 1665813962000 7 connected 0-5460</span><br><span class="line">127.0.0.1:6382&gt; get k2</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [449] located at 192.168.182.129:6385</span></span><br><span class="line">&quot;v2&quot;</span><br><span class="line">192.168.182.129:6385&gt; exit</span><br></pre></td></tr></table></figure>

<p>6381宕机了，6385上位成为了新的master。</p>
<ul>
<li>先还原之前的3主3从</li>
<li>重启6381</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua ~]# docker start redis-node-1</span><br><span class="line">redis-node-1</span><br><span class="line">[root@hua ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND                  CREATED             STATUS             PORTS     NAMES</span><br><span class="line">ef5c8dc0e4e3   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-6</span><br><span class="line">fef20b91d661   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-5</span><br><span class="line">7dce83d92716   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-4</span><br><span class="line">720512c556a2   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-3</span><br><span class="line">4c69a4a36031   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-2</span><br><span class="line">243752f0641f   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up 9 seconds                 redis-node-1</span><br><span class="line">[root@hua ~]# docker exec -it redis-node-1 bash</span><br><span class="line">root@hua:/data# redis-cli -p 6381 -c</span><br><span class="line">127.0.0.1:6381&gt; cluster nodes</span><br><span class="line">84da5624cbdaa8ea4b25be089b89aecc377c3d90 192.168.182.129:6382@16382 master - 0 1665814203000 2 connected 5461-10922</span><br><span class="line">59f62200185f23135a791505f2122da5c38b417a 192.168.182.129:6384@16384 slave 1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00 0 1665814204000 3 connected</span><br><span class="line">36b3aeacc83ab768c73471fec37adfdb6c3fb4a5 192.168.182.129:6386@16386 slave 84da5624cbdaa8ea4b25be089b89aecc377c3d90 0 1665814206446 2 connected</span><br><span class="line">1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00 192.168.182.129:6383@16383 master - 0 1665814204436 3 connected 10923-16383</span><br><span class="line">ca047127cc88177ace8529eec236c99735aa29cf 192.168.182.129:6381@16381 myself,slave f39c163fabdcc288c01202609aeb082427e257a7 0 1665814203000 7 connected</span><br><span class="line">f39c163fabdcc288c01202609aeb082427e257a7 192.168.182.129:6385@16385 master - 0 1665814205441 7 connected 0-5460</span><br></pre></td></tr></table></figure>

<p><strong>可以看到，重启后的6381变为6385的从机。</strong></p>
<ul>
<li>切换至之前的3主3从，只需将6385主机进行重启，6381又会重新变为主机。</li>
</ul>
<h5 id="主从扩容案例"><a href="#主从扩容案例" class="headerlink" title="主从扩容案例"></a>主从扩容案例</h5><ul>
<li>新建6387、6388两个节点+新建后启动+查看是否8节点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis-node-7 --net host --privileged=true -v /data/redis/share/redis-node-7:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6387</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-8 --net host --privileged=true -v /data/redis/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388</span><br><span class="line"></span><br><span class="line">[root@hua ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND                  CREATED          STATUS                                                                                                      PORTS     NAMES</span><br><span class="line">733b0742469b   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   9 seconds ago    Up 8 seconds                                                                                                          redis-node-8</span><br><span class="line">8cafa60f7a2a   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   29 seconds ago   Up 29 seconds                                                                                                         redis-node-7</span><br><span class="line">ef5c8dc0e4e3   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   2 hours ago      Up 2 hours                                                                                                            redis-node-6</span><br><span class="line">fef20b91d661   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   2 hours ago      Up 33 minutes                                                                                                         redis-node-5</span><br><span class="line">7dce83d92716   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   2 hours ago      Up 2 hours                                                                                                            redis-node-4</span><br><span class="line">720512c556a2   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   2 hours ago      Up 2 hours                                                                                                            redis-node-3</span><br><span class="line">4c69a4a36031   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   2 hours ago      Up 2 hours                                                                                                            redis-node-2</span><br><span class="line">243752f0641f   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   2 hours ago      Up 38 minutes                                                                                                         redis-node-1</span><br></pre></td></tr></table></figure>

<ul>
<li>进入6387容器实例内部</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it redis-node-7 /bin/bash</span><br></pre></td></tr></table></figure>

<ul>
<li>将新增的6387节点(空槽号)作为master节点加入原集群</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将新增的6387作为master节点加入集群</span></span><br><span class="line">edis-cli --cluster add-node 自己实际IP地址:6387 自己实际IP地址:6381</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6387 就是将要作为master新增节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6381 就是原来集群节点里面的领路人，相当于6387拜拜6381的码头从而找到组织加入集群</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141619997.png" alt="image-20221015154912081"></p>
<ul>
<li>重新分派槽号</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新分派槽号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令:redis-cli --cluster reshard IP地址:端口号</span></span><br><span class="line">redis-cli --cluster reshard 192.168.182.129:6381</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141619389.png" alt="image-20221015155045924"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141619478.png" alt="image-20221015155059217"></p>
<ul>
<li>检查集群情况</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141619571.png" alt="image-20221015155243267"></p>
<blockquote>
<p>槽号分派说明</p>
<p>为什么6387是3个新的区间，以前的还是连续？</p>
<p>重新分配成本太高，所以前3家各自匀出来一部分，从6381&#x2F;6382&#x2F;6383三个旧节点分别匀出1364个坑位给新节点6387。</p>
</blockquote>
<ul>
<li>为主节点6387分配从节点6388</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令：redis-cli --cluster add-node ip:新slave端口 ip:新master端口 --cluster-slave --cluster-master-id 新主机节点ID</span></span><br><span class="line"></span><br><span class="line">redis-cli --cluster add-node 192.168.182.129:6388 192.168.182.129:6387 --cluster-slave --cluster-master-id 2551cec91dba763fcf3a7f00727cacff463dec57-------这个是6387的编号，按照自己实际情况</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141619505.png" alt="image-20221015155706840"></p>
<h5 id="主从缩容案例"><a href="#主从缩容案例" class="headerlink" title="主从缩容案例"></a>主从缩容案例</h5><p>目的：6387和6388下线</p>
<p>步骤：先删除从机6388；再重新分配槽点；再删除主机6387；</p>
<ul>
<li><p>检查集群情况获得6388的节点ID</p>
</li>
<li><p>将6388删除 从集群中将4号从节点6388删除</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">命令：redis-cli  --cluster del-node ip:从机端口 从机6388节点ID</span><br><span class="line"></span><br><span class="line">root@hua:/data# redis-cli --cluster del-node 192.168.182.129:6388 ef399e48add1979652435de01c7c0fe7abb4051e</span><br></pre></td></tr></table></figure>

<p> <code>redis-cli  --cluster check 192.168.182.129:6382  </code></p>
<p> 检查一下发现，6388被删除了，只剩下7台机器了。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141619469.png" alt="image-20221015160225738"></p>
<ul>
<li>将6387的槽号清空，重新分配，本例将清出来的槽号都给6381</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard 192.168.182.129:6381</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141619774.jpg" alt="graphic"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141619716.jpg" alt="graphic"></p>
<p><img src="/img/loading.gif" data-original="/2023/04/10/Docker/clip_image012.jpg" alt="graphic"></p>
<ul>
<li>检查集群情况</li>
</ul>
<p> 4096个槽位都指给6381，它变成了8192个槽位，相当于全部都给6381了，不然要输入3次，一锅端。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141619415.png" alt="image-20221015160526037"></p>
<ul>
<li>将6387删除</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令：redis-cli  --cluster del-node ip:端口 6387节点ID</span>     </span><br><span class="line">redis-cli --cluster del-node 192.168.182.129:6387  2551cec91dba763fcf3a7f00727cacff463dec57</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620636.png" alt="image-20221015160654248"></p>
<h2 id="2、DockerFile解析"><a href="#2、DockerFile解析" class="headerlink" title="2、DockerFile解析"></a>2、<strong>DockerFile</strong>解析</h2><h3 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h3><p>·    Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620820.jpg" alt="graphic"></p>
<p>官网</p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>
<p>构建三步骤</p>
<ul>
<li>编写Dockerfile文件</li>
<li>docker build命令构建镜像</li>
<li>docker run依镜像运行容器实例</li>
</ul>
<h3 id="2-2、DockerFile构建过程解析"><a href="#2-2、DockerFile构建过程解析" class="headerlink" title="2.2、DockerFile构建过程解析"></a>2.2、<strong>DockerFile构建过程解析</strong></h3><p>Dockerfile内容基础知识</p>
<ol>
<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li>#表示注释</li>
<li>每条指令都会创建一个新的镜像层并对镜像进行提交</li>
</ol>
<p>Docker执行Dockerfile的大致流程</p>
<ol>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器作出修改</li>
<li>执行类似docker commit的操作提交一个新的镜像层</li>
<li>docker再基于刚提交的镜像运行一个新容器</li>
<li>执行dockerfile中的下一条指令直到所有指令都执行完成</li>
</ol>
<p><strong>小总结</strong></p>
<p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p>
<ul>
<li>Dockerfile是软件的原材料</li>
<li>Docker镜像是软件的交付品</li>
<li>Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例</li>
</ul>
<p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620170.jpg" alt="graphic"></p>
<ol>
<li>Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</li>
<li>Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时会真正开始提供服务;</li>
<li>Docker容器，容器是直接提供服务的。</li>
</ol>
<h3 id="2-3、DockerFile常用保留字指令"><a href="#2-3、DockerFile常用保留字指令" class="headerlink" title="2.3、DockerFile常用保留字指令"></a>2.3、<strong>DockerFile常用保留字指令</strong></h3><p>参考tomcat8的dockerfile入——<a target="_blank" rel="noopener" href="https://github.com/docker-library/tomcat">https://github.com/docker-library/tomcat</a></p>
<ul>
<li><code>FROM</code></li>
</ul>
<p>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from</p>
<ul>
<li><code>MAINTAINER</code></li>
</ul>
<p>镜像维护者的姓名和邮箱地址</p>
<ul>
<li><code>RUN</code></li>
</ul>
<p>容器构建时需要运行的命令</p>
<p>两种格式</p>
<ol>
<li>shell格式</li>
</ol>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620267.jpg" alt="graphic"></p>
<p>例：<code>RUN yum -y install vim</code></p>
<p>​	2. exec格式</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620627.jpg" alt="graphic"></p>
<p><strong>RUN是在 docker build时运行</strong></p>
<ul>
<li><code>EXPOSE</code></li>
</ul>
<p>当前容器对外暴露出的端口</p>
<ul>
<li><code>WORKDIR</code></li>
</ul>
<p>指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p>
<ul>
<li><code>USER</code></li>
</ul>
<p>指定该镜像以什么样的用户去执行，如果都不指定，默认是root</p>
<ul>
<li><code>ENV</code></li>
</ul>
<p>用来在构建镜像过程中设置环境变量</p>
<p>例·：<code>ENV MY_PATH /usr/mytest</code></p>
<p>这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；</p>
<p>也可以在其它指令中直接使用这些环境变量，</p>
<p>比如：<code>WORKDIR $MY_PATH</code></p>
<ul>
<li><code>ADD</code></li>
</ul>
<p>将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</p>
<ul>
<li><code>COPY</code></li>
</ul>
<p>类似ADD，拷贝文件和目录到镜像中。 将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</p>
<p>例：<code>COPY src dest</code></p>
<p><code>COPY [&quot;src&quot;, &quot;dest&quot;]</code></p>
<p>&lt;src源路径&gt;：源文件或者源目录</p>
<p>&lt;dest目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p>
<ul>
<li><code>VOLUME</code></li>
</ul>
<p>容器数据卷，用于数据保存和持久化工作</p>
<ul>
<li><code>CMD</code></li>
</ul>
<p>指定容器启动后的要干的事情</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620565.gif" alt="graphic"></p>
<p><strong>注意</strong></p>
<blockquote>
<p>Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p>
</blockquote>
<p>参考官网Tomcat的dockerfile演示讲解</p>
<p>官网最后一行命令</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620485.jpg" alt="img"></td>
</tr>
</tbody></table>
<p>我们演示自己的覆盖操作</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620273.jpg" alt="img"></td>
</tr>
</tbody></table>
<p><strong>它和前面RUN命令的区别</strong></p>
<p><strong>CMD是在docker run 时运行。</strong></p>
<p><strong>RUN是在 docker build时运行。</strong></p>
<ul>
<li>ENTRYPOINT</li>
</ul>
<p>也是用来指定一个容器启动时要运行的命令，类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖， 而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序</p>
<p>命令格式和案例说明0</p>
<p>命令格式：<img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620662.jpg" alt="graphic"></p>
<p>ENTRYPOINT可以和CMD一起用，一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参。</p>
<p>当指定了ENTRYPOINT后，CMD的含义就发生了变化，不再是直接运行其命令而是将CMD的内容作为参数传递给ENTRYPOINT指令，他两个组合会变成<img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620760.jpg" alt="graphic"></p>
<p>案例如下：假设已通过 Dockerfile 构建了 nginx:test 镜像：</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620497.jpg" alt="graphic"></p>
<table>
<thead>
<tr>
<th>是否传参</th>
<th>按照dockerfile编写执行</th>
<th>传参运行</th>
</tr>
</thead>
<tbody><tr>
<td>Docker命令</td>
<td>docker run   nginx:test</td>
<td>docker run   nginx:test -c &#x2F;etc&#x2F;nginx&#x2F;new.conf</td>
</tr>
<tr>
<td>衍生出的实际命令</td>
<td>nginx -c  &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</td>
<td>nginx -c  &#x2F;etc&#x2F;nginx&#x2F;new.conf</td>
</tr>
</tbody></table>
<p><strong>优点</strong></p>
<p>在执行docker run的时候可以指定 ENTRYPOINT 运行所需的参数。</p>
<p>注意</p>
<blockquote>
<p>如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p>
</blockquote>
<p><strong>小总结</strong></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620989.jpg" alt="graphic"></p>
<h3 id="2-4、案例"><a href="#2-4、案例" class="headerlink" title="2.4、案例"></a>2.4、案例</h3><ul>
<li><p>自定义镜像mycentosjava8</p>
<ul>
<li><p>要求</p>
</li>
<li><p>Centos7镜像具备vim+ifconfig+jdk8</p>
</li>
<li><p>JDK的下载镜像地址</p>
</li>
</ul>
</li>
<li><p>官网</p>
</li>
</ul>
<p> 下载地址：</p>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/downloads/#java8">https://www.oracle.com/java/technologies/downloads/#java8</a></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620753.jpg" alt="graphic"></p>
<p><a target="_blank" rel="noopener" href="https://mirrors.yangxingzhen.com/jdk/">https://mirrors.yangxingzhen.com/jdk/</a></p>
<ul>
<li>编写<ul>
<li>准备编写Dockerfile文件</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620636.jpg" alt="graphic"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER zzyy&lt;zzyybs@126.com&gt;</span><br><span class="line"> </span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"> </span><br><span class="line">#安装vim编辑器</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">#安装ifconfig命令查看网络IP</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line">#安装java8及lib库</span><br><span class="line">RUN yum -y install glibc.i686</span><br><span class="line">RUN mkdir /usr/local/java</span><br><span class="line">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/</span><br><span class="line">#配置java环境变量</span><br><span class="line">ENV JAVA_HOME /usr/local/java/jdk1.8.0_171</span><br><span class="line">ENV JRE_HOME $JAVA_HOME/jre</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"> </span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;success--------------ok&quot;</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<ul>
<li>构建</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t 新镜像名字:TAG .</span><br><span class="line"></span><br><span class="line">docker build -t centosjava8:1.5 .</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620527.jpg" alt="graphic"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141620474.jpg" alt="graphic"></p>
<p><strong>注意，上面TAG后面有个空格，有个点</strong></p>
<ul>
<li>运行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it 新镜像名字:TAG</span><br><span class="line"></span><br><span class="line">docker run -it centosjava8:1.5 /bin/bash</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621926.jpg" alt="graphic"></p>
<ul>
<li>再体会下UnionFS（联合文件系统）</li>
</ul>
<p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对<strong>文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。<strong>镜像可以通过分层来进行继承</strong>，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621163.jpg" alt="graphic"> </p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<h2 id="3、Docker微服务实战"><a href="#3、Docker微服务实战" class="headerlink" title="3、Docker微服务实战"></a>3、Docker微服务实战</h2><h3 id="3-1、通过IDEA新建一个普通微服务模块"><a href="#3-1、通过IDEA新建一个普通微服务模块" class="headerlink" title="3.1、通过IDEA新建一个普通微服务模块"></a>3.1、通过IDEA新建一个普通微服务模块</h3><ul>
<li>建Module</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621213.png" alt="image-20221016133208866"></p>
<ul>
<li>改POM</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;DockerBoot&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;DockerBoot&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;DockerBoot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;<span class="number">1.8</span>&lt;/java.version&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-<span class="number">8</span>&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;spring-boot.version&gt;<span class="number">2.3</span><span class="number">.7</span>.RELEASE&lt;/spring-boot.version&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">1.8</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">1.8</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;junit.version&gt;<span class="number">4.12</span>&lt;/junit.version&gt;</span><br><span class="line">        &lt;log4j.version&gt;<span class="number">1.2</span><span class="number">.17</span>&lt;/log4j.version&gt;</span><br><span class="line">        &lt;lombok.version&gt;<span class="number">1.16</span><span class="number">.18</span>&lt;/lombok.version&gt;</span><br><span class="line">        &lt;mysql.version&gt;<span class="number">5.1</span><span class="number">.47</span>&lt;/mysql.version&gt;</span><br><span class="line">        &lt;druid.version&gt;<span class="number">1.1</span><span class="number">.16</span>&lt;/druid.version&gt;</span><br><span class="line">        &lt;mapper.version&gt;<span class="number">4.1</span><span class="number">.5</span>&lt;/mapper.version&gt;</span><br><span class="line">        &lt;mybatis.spring.boot.version&gt;<span class="number">1.3</span><span class="number">.0</span>&lt;/mybatis.spring.boot.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--SpringBoot通用依赖模块--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--test--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">3.8</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;<span class="number">1.8</span>&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;<span class="number">1.8</span>&lt;/target&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-<span class="number">8</span>&lt;/encoding&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">2.3</span><span class="number">.7</span>.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;mainClass&gt;com.example.dockerboot.DockerBootApplication&lt;/mainClass&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;repackage&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>写YML</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6001</span></span><br></pre></td></tr></table></figure>

<ul>
<li>主启动类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.dockerboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DockerBootApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DockerBootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>业务类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.dockerboot.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/16 13:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/order/docker&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">helloDocker</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello docker&quot;</span>+<span class="string">&quot;\t&quot;</span>+port+<span class="string">&quot;\t&quot;</span>+ UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value =&quot;/order/index&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;服务端口号: &quot;</span>+<span class="string">&quot;\t&quot;</span>+port+<span class="string">&quot;\t&quot;</span>+UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2、通过dockerfile发布微服务部署到docker容器"><a href="#3-2、通过dockerfile发布微服务部署到docker容器" class="headerlink" title="3.2、通过dockerfile发布微服务部署到docker容器"></a>3.2、通过dockerfile发布微服务部署到docker容器</h3><ul>
<li>打包之后上传到mydocker文件下</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621768.png" alt="image-20221016133559133"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621027.png" alt="image-20221016133623282"></p>
<ul>
<li>将微服务jar包和Dockerfile文件放到到同一个目录下&#x2F;mydocker，然后构建镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua mydocker]# vim Dockerfile</span><br><span class="line">[root@hua mydocker]# docker build -t zzyy_docker:1.6 .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基础镜像使用java</span></span><br><span class="line">FROM java:8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">作者</span></span><br><span class="line">MAINTAINER zzyy</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span></span><br><span class="line">VOLUME /tmp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将jar包添加到容器中并更名为zzyy_docker.jar</span></span><br><span class="line">ADD DockerBoot-0.0.1-SNAPSHOT.jar zzyy_docker.jar</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行jar包</span></span><br><span class="line">RUN bash -c &#x27;touch /zzyy_docker.jar&#x27;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">暴露6001端口作为微服务</span></span><br><span class="line">EXPOSE 6001</span><br></pre></td></tr></table></figure>

<ul>
<li>运行容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6001:6001 zzyy_docker:1.6</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621897.png" alt="image-20221016134034413"></p>
<ul>
<li>测试——<a target="_blank" rel="noopener" href="http://192.168.182.129:6001/order/docker">192.168.182.129:6001&#x2F;order&#x2F;docker</a></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621540.png" alt="image-20221016134105082"></p>
<h2 id="4、Docker网络"><a href="#4、Docker网络" class="headerlink" title="4、Docker网络"></a>4、Docker网络</h2><h3 id="4-1、概述"><a href="#4-1、概述" class="headerlink" title="4.1、概述"></a>4.1、概述</h3><ol>
<li>docker不启动，默认网络情况</li>
</ol>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621797.jpg" alt="graphic"></p>
<ul>
<li>ens33</li>
<li>lo</li>
<li>virbr0</li>
</ul>
<p>在CentOS7的安装过程中如果有选择相关虚拟化的的服务安装系统后，启动网卡时会发现有一个以网桥连接的私网地址的virbr0网卡(virbr0网卡：它还有一个固定的默认IP地址192.168.122.1)，是做虚拟机网桥的使用的，其作用是为连接其上的虚机网卡提供 NAT访问外网的功能。</p>
<p>我们之前学习Linux安装，勾选安装系统的时候附带了libvirt服务才会生成的一个东西，如果不需要可以直接将libvirtd服务卸载，<code>yum remove libvirt-libs.x86_64</code></p>
<p>​	2. docker启动后，网络情况</p>
<p><strong>会产生一个名为docker0的虚拟网桥</strong></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621241.jpg" alt="graphic"></p>
<p>​	3. 查看docker网络模式命令</p>
<p>默认创建3大网络模式</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621243.jpg" alt="graphic"></p>
<h3 id="4-2、常用基本命令"><a href="#4-2、常用基本命令" class="headerlink" title="4.2、常用基本命令"></a>4.2、常用基本命令</h3><ul>
<li>All命令</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621348.jpg" alt="graphic"></p>
<ul>
<li>查看网络</li>
</ul>
<p><code>docker network ls</code></p>
<ul>
<li>查看网络源数据</li>
</ul>
<p><code>docker network inspect XXX网络名字</code></p>
<ul>
<li>删除网络</li>
</ul>
<p><code>docker network rm XXX网络名字</code></p>
<ul>
<li>案例</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621415.jpg" alt="graphic"></p>
<h3 id="4-3、能干嘛"><a href="#4-3、能干嘛" class="headerlink" title="4.3、能干嘛"></a>4.3、能干嘛</h3><ul>
<li>容器间的互联和通信以及端口映射</li>
<li>容器IP变动时候可以通过服务名直接网络通信而不受到影响</li>
</ul>
<h3 id="4-4、网络模式"><a href="#4-4、网络模式" class="headerlink" title="4.4、网络模式"></a>4.4、网络模式</h3><ol>
<li>总体介绍</li>
</ol>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621495.jpg" alt="graphic"></p>
<ul>
<li><p>bridge模式：使用–network bridge指定，默认使用docker0</p>
</li>
<li><p>host模式：使用–network host指定</p>
</li>
<li><p>none模式：使用–network none指定</p>
</li>
<li><p>container模式：使用–network container:NAME或者容器ID指定</p>
</li>
<li><p>容器实例内默认网络IP生产规则</p>
</li>
</ul>
<p>​	2. 说明</p>
<ul>
<li>先启动两个ubuntu容器实例</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621750.jpg" alt="graphic"></p>
<ul>
<li><code>docker inspect 容器ID or 容器名字</code></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621537.jpg" alt="graphic"></p>
<ul>
<li>关闭u2实例，新建u3，查看ip变化</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141621302.jpg" alt="graphic"></p>
<p>​	3. 结论</p>
<p>docker容器内部的ip是有可能会发生改变的</p>
<p><strong>案例说明</strong></p>
<h4 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h4><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在内核层连通了其他的物理或虚拟网卡，这就<strong>将所有容器和本地主机都放到同一个物理网络。</strong>Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，<strong>让主机和容器之间可以通过网桥相互通信。</strong></p>
<p># 查看 bridge 网络的详细信息，并通过 grep 获取名称项</p>
<p><code>docker network inspect bridge | grep name</code></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622475.jpg" alt="graphic"></p>
<p><code>ifconfig</code></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622485.jpg" alt="graphic"></p>
<h5 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a><strong>案例说明</strong></h5><ol>
<li>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</li>
<li>docker run 的时候，没有指定network的话默认使用的网桥模式就是bridge，使用的就是docker0。在宿主机ifconfig,就可以看到docker0和自己create的network(后面讲)eth0，eth1，eth2……代表网卡一，网卡二，网卡三……，lo代表127.0.0.1，即localhost，inet addr用来表示网卡的IP地址</li>
<li>网桥docker0创建一对对等虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。<ol>
<li>整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair）；</li>
<li>每个容器实例内部也有一块网卡，每个接口叫eth0；</li>
<li>docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。</li>
</ol>
</li>
</ol>
<p> 通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622133.jpg" alt="graphic"></p>
<p><strong>代码</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8080  --name tomcat81 billygoo/tomcat8-jdk8</span><br><span class="line"></span><br><span class="line">docker run -d -p 8082:8080  --name tomcat82 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>

<ul>
<li>两两匹配验证</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622336.jpg" alt="graphic"></p>
<h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><h5 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h5><p>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。</p>
<h5 id="案例说明-1"><a href="#案例说明-1" class="headerlink" title="案例说明"></a>案例说明</h5><p>容器将不会获得一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622579.jpg" alt="graphic"></p>
<p><strong>代码</strong></p>
<ul>
<li>警告<code>docker run -d -p 8083:8080 --network host --name tomcat83 billygoo/tomcat8-jdk8</code></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622536.jpg" alt="graphic"></p>
<ul>
<li>问题：</li>
</ul>
<p>docke启动时总是遇见标题中的警告</p>
<ul>
<li>原因：</li>
</ul>
<p>docker启动时指定–network&#x3D;host或-net&#x3D;host，如果还指定了-p映射端口，那这个时候就会有此警告，并且通过-p设置的参数将不会起到任何作用，端口号会以主机端口号为主，重复时则递增。</p>
<ul>
<li>解决:</li>
</ul>
<p>解决的办法就是使用docker的其他网络模式，例如–network&#x3D;bridge，这样就可以解决问题，或者直接无视</p>
<ul>
<li>正确命令<code>docker run -d --network host --name tomcat83 billygoo/tomcat8-jdk8</code><ul>
<li>无之前的配对显示了，看容器实例内部</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622631.jpg" alt="graphic"></p>
<ul>
<li>没有设置-p的端口映射了，如何访问启动的tomcat83？？</li>
</ul>
<p><code>http://宿主机IP:8080/</code></p>
<p>在CentOS里面用默认的火狐浏览器访问容器内的tomcat83看到访问成功，因为此时容器的IP借用主机的，所以容器共享宿主机网络IP，这样的好处是外部主机与容器可以直接通信。</p>
<h4 id="none"><a href="#none" class="headerlink" title="none"></a>none</h4><h5 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h5><p>在none模式下，并不为Docker容器进行任何网络配置。 </p>
<p>也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo</p>
<p>需要我们自己为Docker容器添加网卡、配置IP等。</p>
<ul>
<li>禁用网络功能，只有lo标识(就是127.0.0.1表示本地回环)</li>
</ul>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h5><p><code>docker run -d -p 8084:8080 --network none --name tomcat84 billygoo/tomcat8-jdk8</code></p>
<p> 进入容器内部查看</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622903.jpg" alt="graphic"></p>
<p>在容器外部查看</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622602.jpg" alt="graphic"></p>
<p><code>docker run -d -p 8084:8080 --network none --name tomcat84 billygoo/tomcat8-jdk8</code></p>
<h4 id="container"><a href="#container" class="headerlink" title="container"></a>container</h4><h5 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h5><p>container⽹络模式 </p>
<p>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622838.jpg" alt="graphic"></p>
<h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><ul>
<li>错误演示</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8085:8080 --name tomcat85 billygoo/tomcat8-jdk8</span><br><span class="line"></span><br><span class="line">docker run -d -p 8086:8080 --network container:tomcat85 --name tomcat86 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622390.jpg" alt="graphic"></p>
<blockquote>
<p>相当于tomcat86和tomcat85公用同一个ip同一个端口，导致端口冲突</p>
<p>本案例用tomcat演示不合适。。。演示坑。。。。。。o(╥﹏╥)o</p>
</blockquote>
<p>换一个镜像给大家演示，</p>
<ul>
<li>案例2——正确演示</li>
</ul>
<p>Alpine操作系统是一个面向安全的轻型 Linux发行版。</p>
<p>Alpine Linux 是一款独立的、非商业的通用 Linux 发行版，专为追求安全性、简单性和资源效率的用户而设计。 可能很多人没听说过这个 Linux 发行版本，但是经常用 Docker 的朋友可能都用过，因为他小，简单，安全而著称，所以作为基础镜像是非常好的一个选择，可谓是麻雀虽小但五脏俱全，镜像非常小巧，不到 6M的大小，所以特别适合容器打包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name alpine1 alpine /bin/sh</span><br><span class="line"></span><br><span class="line">docker run -it --network container:alpine1 --name alpine2 alpine /bin/sh</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果，验证共用搭桥</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622962.jpg" alt="graphic"></p>
<ul>
<li>假如此时关闭alpine1，再看看alpine2</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622245.jpg" alt="graphic"></p>
<p>15: eth0@if16: 消失了。。。。。。关闭alpine1，再看看alpine2</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622976.jpg" alt="graphic"></p>
<h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><ul>
<li>过时的link</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622807.jpg" alt="graphic"></p>
<h5 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h5><p><strong>before</strong></p>
<ul>
<li>案例</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8080  --name tomcat81 billygoo/tomcat8-jdk8</span><br><span class="line"></span><br><span class="line">docker run -d -p 8082:8080  --name tomcat82 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>

<p>上述成功启动并用docker exec进入各自容器实例内部</p>
<ul>
<li>问题</li>
</ul>
<p>按照IP地址ping是OK的</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622269.jpg" alt="graphic"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622104.jpg" alt="graphic"></p>
<p>按照服务名ping结果???</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622734.jpg" alt="graphic"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141622617.jpg" alt="graphic"></p>
<p><strong>after</strong></p>
<p>案例</p>
<p>自定义桥接网络,自定义网络默认使用的是桥接网络bridge</p>
<ul>
<li>新建自定义网络</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141623513.jpg" alt="graphic"></p>
<ul>
<li>新建容器加入上一步新建的自定义网络</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8080 --network zzyy_network --name tomcat81 billygoo/tomcat8-jdk8</span><br><span class="line"></span><br><span class="line">docker run -d -p 8082:8080 --network zzyy_network --name tomcat82 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure>

<ul>
<li>互相ping测试</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141623319.jpg" alt="graphic"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141623043.jpg" alt="graphic"></p>
<ul>
<li>问题结论</li>
</ul>
<p>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p>
<p>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p>
<p>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p>
<h3 id="4-5、Docker平台架构图解"><a href="#4-5、Docker平台架构图解" class="headerlink" title="4.5、Docker平台架构图解"></a>4.5、Docker平台架构图解</h3><ul>
<li>整体说明</li>
</ul>
<p>从其架构和运行流程来看，Docker 是一个 C&#x2F;S 模式的架构，后端是一个松耦合架构，众多模块各司其职。 </p>
<p>Docker 运行的基本流程为：</p>
<ol>
<li>用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。</li>
<li>Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。</li>
<li>Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</li>
<li>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver将下载镜像以Graph的形式存储。</li>
<li>当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</li>
<li>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。</li>
<li>Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。</li>
</ol>
<ul>
<li>整体架构</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141623879.jpg" alt="graphic"></p>
<h2 id="5、Docker-compose容器编排"><a href="#5、Docker-compose容器编排" class="headerlink" title="5、Docker-compose容器编排"></a>5、Docker-compose容器编排</h2><h3 id="5-1、是什么"><a href="#5-1、是什么" class="headerlink" title="5.1、是什么"></a>5.1、是什么</h3><p>Compose 是 Docker 公司推出的一个工具软件，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件docker-compose.yml，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动&#x2F;关闭这些容器。</p>
<p>Docker-Compose是Docker官方的开源项目， 负责实现对Docker容器集群的快速编排。</p>
<h3 id="5-2、能干嘛"><a href="#5-2、能干嘛" class="headerlink" title="5.2、能干嘛"></a>5.2、能干嘛</h3><p>docker建议我们每一个容器中只运行一个服务,因为docker容器本身占用资源极少,所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？</p>
<p>如果我需要同时部署好多个服务,难道要每个服务单独写Dockerfile然后在构建镜像,构建容器,这样累都累死了,所以docker官方给我们提供了docker-compose多服务部署的工具。</p>
<p>例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysql服务容器，redis服务器，注册中心eureka，甚至还包括负载均衡容器等等。。。。。。</p>
<p><strong>Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</strong> </p>
<p>可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p>
<h3 id="5-3、下载安装"><a href="#5-3、下载安装" class="headerlink" title="5.3、下载安装"></a>5.3、下载安装</h3><ul>
<li>官网</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p>
<ul>
<li>官网安装</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></p>
<ul>
<li>安装步骤</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua ~]# curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_">  % </span><span class="language-bash">Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:--  0:00:16 --:--:--     0</span><br><span class="line">100 12.1M  100 12.1M    0     0   610k      0  0:00:20  0:00:20 --:--:-- 3260k</span><br><span class="line">[root@hua ~]# chmod +x /usr/local/bin/docker-compose</span><br><span class="line">[root@hua ~]# docker-compose --version</span><br><span class="line">docker-compose version 1.29.2, build 5becea4c</span><br></pre></td></tr></table></figure>

<p><strong>卸载</strong></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141623313.png" alt="image-20221017220946523"></p>
<h3 id="5-4、Compose核心概念"><a href="#5-4、Compose核心概念" class="headerlink" title="5.4、Compose核心概念"></a>5.4、Compose核心概念</h3><p><strong>一文件</strong></p>
<p><code>docker-compose.yml</code></p>
<p><strong>两要素</strong></p>
<ul>
<li>服务（service）</li>
</ul>
<p>一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器。</p>
<ul>
<li>工程（project）</li>
</ul>
<p>由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</p>
<h4 id="Compose使用的三个步骤"><a href="#Compose使用的三个步骤" class="headerlink" title="Compose使用的三个步骤"></a>Compose使用的三个步骤</h4><ul>
<li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件。</li>
<li>使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li>
<li>最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线。</li>
</ul>
<h3 id="5-5、常用命令"><a href="#5-5、常用命令" class="headerlink" title="5.5、常用命令"></a>5.5、常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看帮助</span></span><br><span class="line">docker-compose -h</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动所有docker-compose服务</span></span><br><span class="line">docker-compose up </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动所有docker-compose服务并后台运行</span></span><br><span class="line">docker-compose up -d  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止并删除容器、网络、卷、镜像。</span></span><br><span class="line">docker-compose down                         </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器实例内部  docker-compose <span class="built_in">exec</span> docker-compose.yml文件中写的服务<span class="built_in">id</span> /bin/bash</span></span><br><span class="line">docker-compose exec  yml里面的服务id  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">展示当前docker-compose编排过的运行的所有容器</span></span><br><span class="line">docker-compose ps   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">展示当前docker-compose编排过的容器进程</span></span><br><span class="line">docker-compose top        </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器输出日志</span></span><br><span class="line">docker-compose logs  yml里面的服务id    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查配置</span></span><br><span class="line">docker-compose config     </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查配置，有问题才有输出</span></span><br><span class="line">docker-compose config -q  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启服务</span></span><br><span class="line">docker-compose restart  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动服务</span></span><br><span class="line">docker-compose start   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止服务</span></span><br><span class="line">docker-compose stop      </span><br></pre></td></tr></table></figure>

<h3 id="5-6、Compose编排微服务"><a href="#5-6、Compose编排微服务" class="headerlink" title="5.6、Compose编排微服务"></a>5.6、Compose编排微服务</h3><h4 id="微服务测试"><a href="#微服务测试" class="headerlink" title="微服务测试"></a>微服务测试</h4><p>测试项目地址——<a target="_blank" rel="noopener" href="https://gitee.com/tingting-hua/DockerBoot">TINGTING-HUA&#x2F;DockerBoot (gitee.com)</a></p>
<ul>
<li>SQL建表建库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `sex` tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;性别 0=女 1=男 &#x27;</span>,</span><br><span class="line">  `deleted` tinyint(<span class="number">4</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标志，默认0不删除，1删除&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>改pom</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;DockerBoot&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;DockerBoot&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;DockerBoot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;<span class="number">1.8</span>&lt;/java.version&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-<span class="number">8</span>&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;spring-boot.version&gt;<span class="number">2.3</span><span class="number">.7</span>.RELEASE&lt;/spring-boot.version&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">1.8</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">1.8</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;junit.version&gt;<span class="number">4.12</span>&lt;/junit.version&gt;</span><br><span class="line">        &lt;log4j.version&gt;<span class="number">1.2</span><span class="number">.17</span>&lt;/log4j.version&gt;</span><br><span class="line">        &lt;lombok.version&gt;<span class="number">1.16</span><span class="number">.18</span>&lt;/lombok.version&gt;</span><br><span class="line">        &lt;mysql.version&gt;<span class="number">5.1</span><span class="number">.47</span>&lt;/mysql.version&gt;</span><br><span class="line">        &lt;druid.version&gt;<span class="number">1.1</span><span class="number">.16</span>&lt;/druid.version&gt;</span><br><span class="line">        &lt;mapper.version&gt;<span class="number">4.1</span><span class="number">.5</span>&lt;/mapper.version&gt;</span><br><span class="line">        &lt;mybatis.spring.boot.version&gt;<span class="number">1.3</span><span class="number">.0</span>&lt;/mybatis.spring.boot.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--guava Google 开源的 Guava 中自带的布隆过滤器--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">23.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- redisson --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.13</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--SpringBoot通用依赖模块--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--swagger2--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--SpringBoot与Redis整合依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--springCache--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--springCache连接池依赖包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- jedis --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--Mysql数据库驱动--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.1</span><span class="number">.47</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--SpringBoot集成druid连接池--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.1</span><span class="number">.10</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--mybatis-plus启动器--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.5</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 添加springboot对amqp的支持 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.10</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--通用基础配置junit/devtools/test/log4j/lombok/hutool--&gt;</span><br><span class="line">        &lt;!--hutool--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--persistence--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.persistence&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;persistence-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--通用Mapper--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mapper&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;mapper.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">3.8</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;<span class="number">1.8</span>&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;<span class="number">1.8</span>&lt;/target&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-<span class="number">8</span>&lt;/encoding&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">2.3</span><span class="number">.7</span>.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;mainClass&gt;com.example.dockerboot.DockerBootApplication&lt;/mainClass&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;repackage&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>写yml</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.port=6001</span><br><span class="line">  # ========================alibaba.druid????=====================</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://192.168.182.129:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.druid.test-while-idle=false</span><br><span class="line">  # ========================redis????=====================</span><br><span class="line">spring.redis.database=0</span><br><span class="line">spring.redis.host=192.168.182.129</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">spring.redis.password=</span><br><span class="line">spring.redis.lettuce.pool.max-active=8</span><br><span class="line">spring.redis.lettuce.pool.max-wait=-1ms</span><br><span class="line">spring.redis.lettuce.pool.max-idle=8</span><br><span class="line">spring.redis.lettuce.pool.min-idle=0</span><br><span class="line">  # ========================mybatis????===================</span><br><span class="line">mybatis.mapper-locations=classpath:mapper/*.xml</span><br><span class="line">mybatis.type-aliases-package=com.example.dockerboot.pojo</span><br><span class="line">  # ========================swagger=====================</span><br><span class="line">spring.swagger2.enabled=true</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Mybatis一键生成</li>
<li>主启动</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.dockerboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScans;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.dockerboot.mapper&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DockerBootApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DockerBootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>…………….</p>
<ul>
<li><p>mvn package命令将微服务形成新的jar包 并上传到Linux服务器&#x2F;mydocker目录下</p>
</li>
<li><p>编写Dockerfile</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基础镜像使用java</span><br><span class="line">FROM java:8</span><br><span class="line"># 作者</span><br><span class="line">MAINTAINER zzyy</span><br><span class="line"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span><br><span class="line">VOLUME /tmp</span><br><span class="line"># 将jar包添加到容器中并更名为zzyy_docker.jar</span><br><span class="line">ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar</span><br><span class="line"># 运行jar包</span><br><span class="line">RUN bash -c &#x27;touch /zzyy_docker.jar&#x27;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;]</span><br><span class="line">#暴露6001端口作为微服务</span><br><span class="line">EXPOSE 6001</span><br></pre></td></tr></table></figure>

<p> <img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141623324.png" alt="image-20221017221724609"></p>
<ul>
<li>构建镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t zzyy_docker:1.6 .</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141623397.png" alt="image-20221017221909721"></p>
<h4 id="不用Compose"><a href="#不用Compose" class="headerlink" title="不用Compose"></a>不用<strong>Compose</strong></h4><ul>
<li>新建mysql容器实例</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p  3306:3306 --name mysql57 --privileged=true -v  /zzyyuse/mysql/conf:/etc/mysql/conf.d -v /zzyyuse/mysql/logs:/logs -v  /zzyyuse/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7  </span><br></pre></td></tr></table></figure>

<ul>
<li>进入mysql容器实例并新建库db2021+新建表t_user</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql57 /bin/bash</span><br><span class="line"></span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line">create database db2021;</span><br><span class="line"></span><br><span class="line">use db2021;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `t_user` (</span><br><span class="line">  `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户名&#x27;,</span><br><span class="line">  `password` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;,</span><br><span class="line">  `sex` TINYINT(4) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;性别 0=女 1=男 &#x27;,</span><br><span class="line">  `deleted` TINYINT(4) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志，默认0不删除，1删除&#x27;,</span><br><span class="line">  `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">  `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>单独的redis容器实例</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis608 --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d redis:6.0.8 redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>微服务工程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6001:6001 zzyy_docker:1.6</span><br></pre></td></tr></table></figure>

<ul>
<li>上面三个容器实例依次顺序启动成功</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141623326.png" alt="image-20221017222310328"></p>
<ul>
<li>swagger测试</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://192.168.182.129:6001/swagger-ui.html#/">http://192.168.182.129:6001/swagger-ui.html#/</a></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141623094.png" alt="image-20221017222427440"></p>
<ul>
<li>添加数据</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141623668.png" alt="image-20221017222600311"></p>
<p>MySQL中数据</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141623699.png" alt="image-20221017222629010"></p>
<p>Redis中数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua ~]# docker exec -it redis608 bash</span><br><span class="line">root@1ed8f848268b:/data# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;user:3&quot;</span><br><span class="line">2) &quot;user:2&quot;</span><br><span class="line">3) &quot;user:1&quot;</span><br><span class="line">127.0.0.1:6379&gt; get user:3</span><br><span class="line">&quot;&#123;\&quot;@class\&quot;:\&quot;com.example.dockerboot.pojo.User\&quot;,\&quot;id\&quot;:[\&quot;java.lang.Long\&quot;,3],\&quot;username\&quot;:\&quot;zzyy3\&quot;,\&quot;password\&quot;:\&quot;1b3f46\&quot;,\&quot;sex\&quot;:0,\&quot;deleted\&quot;:0,\&quot;updateTime\&quot;:[\&quot;java.util.Date\&quot;,1666013136000],\&quot;createTime\&quot;:[\&quot;java.util.Date\&quot;,1666013136000]&#125;&quot;</span><br><span class="line">127.0.0.1:6379&gt; get user:2</span><br><span class="line">&quot;&#123;\&quot;@class\&quot;:\&quot;com.example.dockerboot.pojo.User\&quot;,\&quot;id\&quot;:[\&quot;java.lang.Long\&quot;,2],\&quot;username\&quot;:\&quot;zzyy2\&quot;,\&quot;password\&quot;:\&quot;ec0d4a\&quot;,\&quot;sex\&quot;:0,\&quot;deleted\&quot;:0,\&quot;updateTime\&quot;:[\&quot;java.util.Date\&quot;,1666013136000],\&quot;createTime\&quot;:[\&quot;java.util.Date\&quot;,1666013136000]&#125;&quot;</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line">&quot;&#123;\&quot;@class\&quot;:\&quot;com.example.dockerboot.pojo.User\&quot;,\&quot;id\&quot;:[\&quot;java.lang.Long\&quot;,1],\&quot;username\&quot;:\&quot;zzyy1\&quot;,\&quot;password\&quot;:\&quot;9ea40c\&quot;,\&quot;sex\&quot;:1,\&quot;deleted\&quot;:0,\&quot;updateTime\&quot;:[\&quot;java.util.Date\&quot;,1666013135000],\&quot;createTime\&quot;:[\&quot;java.util.Date\&quot;,1666013135000]&#125;&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p>上面成功了，有哪些问题?</p>
<ul>
<li><p>先后顺序要求固定，先mysql+redis才能微服务访问成功</p>
</li>
<li><p>多个run命令……</p>
</li>
<li><p>容器间的启停或宕机，有可能导致IP地址对应的容器实例变化，映射出错， 要么生产IP写死(可以但是不推荐)，要么通过服务调用</p>
</li>
</ul>
<h4 id="使用Compose"><a href="#使用Compose" class="headerlink" title="使用Compose"></a>使用Compose</h4><ul>
<li>在jar包的相同目录下编写docker-compose.yml文件</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624215.png" alt="image-20221018204058333"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"> # 相当于docker run -d -p 6001:6001 -v /app/microService:/data</span><br><span class="line">--network atguigu_net –name ms01 zzyy_docker:1.6 </span><br><span class="line">services:</span><br><span class="line">  microService:</span><br><span class="line">    image: zzyy_docker:1.6</span><br><span class="line">    container_name: ms01</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6001:6001&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - /app/microService:/data</span><br><span class="line">    networks: </span><br><span class="line">      - atguigu_net </span><br><span class="line">			#依赖于（启动前提）</span><br><span class="line">    depends_on: </span><br><span class="line">      - redis</span><br><span class="line">      - mysql</span><br><span class="line"> </span><br><span class="line">  redis:</span><br><span class="line">    image: redis:6.0.8</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - /app/redis/redis.conf:/etc/redis/redis.conf</span><br><span class="line">      - /app/redis/data:/data</span><br><span class="line">    networks: </span><br><span class="line">      - atguigu_net</span><br><span class="line">    command: redis-server /etc/redis/redis.conf</span><br><span class="line"> </span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: &#x27;123456&#x27;</span><br><span class="line">      MYSQL_ALLOW_EMPTY_PASSWORD: &#x27;no&#x27;</span><br><span class="line">      MYSQL_DATABASE: &#x27;db2021&#x27;</span><br><span class="line">      MYSQL_USER: &#x27;zzyy&#x27;</span><br><span class="line">      MYSQL_PASSWORD: &#x27;zzyy123&#x27;</span><br><span class="line">    ports:</span><br><span class="line">       - &quot;3306:3306&quot;</span><br><span class="line">    volumes:</span><br><span class="line">       - /app/mysql/db:/var/lib/mysql</span><br><span class="line">       - /app/mysql/conf/my.cnf:/etc/my.cnf</span><br><span class="line">       - /app/mysql/init:/docker-entrypoint-initdb.d</span><br><span class="line">    networks:</span><br><span class="line">      - atguigu_net</span><br><span class="line">      #解决外部无法访问</span><br><span class="line">    command: --default-authentication-plugin=mysql_native_password </span><br><span class="line"> # 相当于docker network create atguigu_net</span><br><span class="line">networks: </span><br><span class="line">   atguigu_net: </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>修改微服务工程docker_boot</li>
</ul>
<p>通过服务名访问，与IP无关</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">server.port=6001</span></span><br><span class="line">  <span class="comment"># ========================alibaba.druid????=====================</span></span><br><span class="line"><span class="string">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="string">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#spring.datasource.url=jdbc:mysql://192.168.182.129:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://mysql:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line"></span><br><span class="line"><span class="string">spring.datasource.username=root</span></span><br><span class="line"><span class="string">spring.datasource.password=123456</span></span><br><span class="line"><span class="string">spring.datasource.druid.test-while-idle=false</span></span><br><span class="line">  <span class="comment"># ========================redis????=====================</span></span><br><span class="line"><span class="string">spring.redis.database=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#spring.redis.host=192.168.182.129</span></span><br><span class="line"><span class="string">spring.redis.host=redis</span></span><br><span class="line"></span><br><span class="line"><span class="string">spring.redis.port=6379</span></span><br><span class="line"><span class="string">spring.redis.password=</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.max-active=8</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.max-wait=-1ms</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.max-idle=8</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.min-idle=0</span></span><br><span class="line">  <span class="comment"># ========================mybatis????===================</span></span><br><span class="line"><span class="string">mybatis.mapper-locations=classpath:mapper/*.xml</span></span><br><span class="line"><span class="string">mybatis.type-aliases-package=com.example.dockerboot.pojo</span></span><br><span class="line">  <span class="comment"># ========================swagger=====================</span></span><br><span class="line"><span class="string">spring.swagger2.enabled=true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>mvn package命令将微服务形成新的jar包 并上传到Linux服务器&#x2F;mydocker目录下</li>
<li>编写Dockerfile</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基础镜像使用java</span><br><span class="line">FROM java:8</span><br><span class="line"># 作者</span><br><span class="line">MAINTAINER zzyy</span><br><span class="line"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span><br><span class="line">VOLUME /tmp</span><br><span class="line"># 将jar包添加到容器中并更名为zzyy_docker.jar</span><br><span class="line">ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar</span><br><span class="line"># 运行jar包</span><br><span class="line">RUN bash -c &#x27;touch /zzyy_docker.jar&#x27;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;]</span><br><span class="line">#暴露6001端口作为微服务</span><br><span class="line">EXPOSE 6001</span><br></pre></td></tr></table></figure>

<ul>
<li>重新构建镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t zzyy_docker:1.6 .</span><br></pre></td></tr></table></figure>

<ul>
<li>执行 <code>docker-compose up</code> 或者 执行 <code>docker-compose up -d</code></li>
</ul>
<p>全部都启动起来了（一键启动）</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624247.png" alt="image-20221018204507200"></p>
<blockquote>
<p><strong>Compose</strong>常用命令</p>
<p>docker-compose -h              # 查看帮助</p>
<p>docker-compose up              # 启动所有docker-compose服务</p>
<p>docker-compose up -d            # 启动所有docker-compose服务并后台运行</p>
<p>docker-compose down             # 停止并删除容器、网络、卷、镜像。</p>
<p>docker-compose exec  yml里面的服务id         # 进入容器实例内部 docker-compose exec docker-compose.yml文件中写的服务id &#x2F;bin&#x2F;bash</p>
<p>docker-compose ps           # 展示当前docker-compose编排过的运行的所有容器</p>
<p>docker-compose top           # 展示当前docker-compose编排过的容器进程</p>
<p>docker-compose logs  yml里面的服务id   # 查看容器输出日志</p>
<p>dokcer-compose config   # 检查配置</p>
<p>dokcer-compose config -q # 检查配置，有问题才有输出</p>
<p>docker-compose restart  # 重启服务</p>
<p>docker-compose start   # 启动服务</p>
<p>docker-compose stop    # 停止服务</p>
</blockquote>
<ul>
<li>进入mysql容器实例并新建库db2021+新建表t_user</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua mydocker]# docker exec -it 2adcd75aadb3 bash</span><br><span class="line">root@2adcd75aadb3:/# mysql -uroot -p</span><br><span class="line">Enter password:</span><br><span class="line">.............</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show databases;</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| db2021             |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">use db2021;</span></span><br><span class="line">Database changed</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">CREATE TABLE `t_user` (</span></span><br><span class="line">    -&gt;   `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt;   `username` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;&#x27;,</span><br><span class="line">    -&gt;   `password` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;&#x27;,</span><br><span class="line">    -&gt;   `sex` TINYINT(4) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27; 0= 1= &#x27;,</span><br><span class="line">    -&gt;   `deleted` TINYINT(4) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;01&#x27;,</span><br><span class="line">    -&gt;   `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT                                                                                            _TIMESTAMP COMMENT &#x27;&#x27;,</span><br><span class="line">    -&gt;   `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;&#x27;,</span><br><span class="line">    -&gt;   PRIMARY KEY (`id`)</span><br><span class="line">    -&gt; ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">select * from t_user;</span></span><br><span class="line">Empty set (0.03 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://192.168.182.129:6001/swagger-ui.html#/">http://192.168.182.129:6001/swagger-ui.html#/</a></p>
<p>添加数据</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624263.png" alt="image-20221018204938439"></p>
<p>添加成功</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624593.png" alt="image-20221018205003523"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624040.png" alt="image-20221018205016204"></p>
<ul>
<li>一键停止</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624703.png" alt="image-20221018205057052"></p>
<h2 id="6、Docker轻量级可视化工具Portainer"><a href="#6、Docker轻量级可视化工具Portainer" class="headerlink" title="6、Docker轻量级可视化工具Portainer"></a>6、Docker轻量级可视化工具Portainer</h2><h3 id="6-1、是什么"><a href="#6-1、是什么" class="headerlink" title="6.1、是什么"></a>6.1、是什么</h3><p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。</p>
<h3 id="6-2、安装"><a href="#6-2、安装" class="headerlink" title="6.2、安装"></a>6.2、安装</h3><ul>
<li>官网</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.portainer.io/">https://www.portainer.io/</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux">https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux</a></p>
<ul>
<li>步骤</li>
</ul>
<p>docker命令安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p  8000:8000 -p 9000:9000 --name portainer   --restart=always    -v /var/run/docker.sock:/var/run/docker.sock    -v portainer_data:/data   portainer/portainer  </span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624102.png" alt="image-20221018220218819"></p>
<h3 id="6-3、使用"><a href="#6-3、使用" class="headerlink" title="6.3、使用"></a>6.3、使用</h3><ul>
<li>第一次登录需创建admin，访问地址：<a target="_blank" rel="noopener" href="http://192.168.182.129:9000/">http://192.168.182.129:9000</a></li>
</ul>
<table>
<thead>
<tr>
<th>用户名，直接用默认admin</th>
</tr>
</thead>
<tbody><tr>
<td>密码记得8位，随便你写</td>
</tr>
</tbody></table>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624276.jpg" alt="graphic"></p>
<ul>
<li>设置admin用户和密码后首次登陆</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624093.jpg" alt="graphic"></p>
<ul>
<li>选择local选项卡后本地docker详细信息展示</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624863.jpg" alt="graphic"></p>
<ul>
<li>上一步的图形展示，能想得起对应命令吗？</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624559.jpg" alt="graphic"></p>
<ul>
<li>登陆并演示介绍常用操作case</li>
</ul>
<h3 id="6-4、汉化"><a href="#6-4、汉化" class="headerlink" title="6.4、汉化"></a>6.4、汉化</h3><ul>
<li>下载汉化包</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1VBmvho7L3H7ILzocNIG_ww</span><br><span class="line"></span><br><span class="line">提取码: hejp</span><br></pre></td></tr></table></figure>

<ul>
<li>解压至Portainer的工作目录</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624851.webp" alt="img"></p>
<ul>
<li>修改docker-compose 配置文件映射工作目录</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">volumes: </span><br><span class="line">    - /var/run/docker.sock:/var/run/docker.sock:rw</span><br><span class="line">    - ./ortainer_data:/data:rw</span><br><span class="line">    # 汉化包</span><br><span class="line">    - ./public:/public:rw</span><br></pre></td></tr></table></figure>

<ul>
<li>重新启动容器</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">docker-compose down &amp;&amp; docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>看到这个界面，汉化成功 </p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624873.webp" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=https://www.portainer.io/">更多功能使用，请查询官网</a></p>
<h2 id="7、Docker容器监控之-CAdvisor-InfluxDB-Granfana"><a href="#7、Docker容器监控之-CAdvisor-InfluxDB-Granfana" class="headerlink" title="7、Docker容器监控之 CAdvisor+InfluxDB+Granfana"></a>7、Docker容器监控之 CAdvisor+InfluxDB+Granfana</h2><h3 id="7-1、原生命令docker-stats"><a href="#7-1、原生命令docker-stats" class="headerlink" title="7.1、原生命令docker stats"></a>7.1、原生命令docker stats</h3><p>操作</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624141.jpg" alt="graphic"></p>
<p><strong>docker stats****命令的结果</strong></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624858.jpg" alt="graphic"></p>
<p>问题</p>
<p>通过docker stats命令可以很方便的看到当前宿主机上所有容器的CPU,内存以及网络流量等数据，一般小公司够用了。。。。</p>
<p>但是，docker stats统计结果只能是当前宿主机的全部容器，数据资料是实时的，没有地方存储、没有健康指标过线预警等功能。</p>
<h3 id="7-2、是什么"><a href="#7-2、是什么" class="headerlink" title="7.2、是什么"></a>7.2、是什么</h3><p>容器监控3剑客</p>
<p>一句话</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141624595.jpg" alt="graphic"></p>
<ul>
<li>CAdvisor监控收集+InfluxDB存储数据+Granfana展示图表</li>
</ul>
<h4 id="CAdvisor监控收集"><a href="#CAdvisor监控收集" class="headerlink" title="CAdvisor监控收集"></a>CAdvisor监控收集</h4><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625902.jpg" alt="graphic"></p>
<h4 id="InfluxDB存储数据"><a href="#InfluxDB存储数据" class="headerlink" title="InfluxDB存储数据"></a>InfluxDB存储数据</h4><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625474.jpg" alt="graphic"></p>
<h4 id="Granfana展示图表"><a href="#Granfana展示图表" class="headerlink" title="Granfana展示图表"></a>Granfana展示图表</h4><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625649.jpg" alt="graphic"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625640.jpg" alt="graphic"></p>
<h3 id="7-3、安装"><a href="#7-3、安装" class="headerlink" title="7.3、安装"></a>7.3、安装</h3><h4 id="compose容器编排，一套带走"><a href="#compose容器编排，一套带走" class="headerlink" title="compose容器编排，一套带走"></a>compose容器编排，一套带走</h4><ul>
<li>新建目录</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625291.jpg" alt="graphic"></p>
<ul>
<li>新建3件套组合的 docker-compose.yml</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3.1&#x27;</span><br><span class="line"> </span><br><span class="line">volumes:</span><br><span class="line">  grafana_data: &#123;&#125;</span><br><span class="line"> </span><br><span class="line">services:</span><br><span class="line"> influxdb:</span><br><span class="line">  image: tutum/influxdb:0.9</span><br><span class="line">  restart: always</span><br><span class="line">  environment:</span><br><span class="line">    - PRE_CREATE_DB=cadvisor</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;8083:8083&quot;</span><br><span class="line">    - &quot;8086:8086&quot;</span><br><span class="line">  volumes:</span><br><span class="line">    - ./data/influxdb:/data</span><br><span class="line"> </span><br><span class="line"> cadvisor:</span><br><span class="line">  image: google/cadvisor</span><br><span class="line">  links:</span><br><span class="line">    - influxdb:influxsrv</span><br><span class="line">  command: -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxsrv:8086</span><br><span class="line">  restart: always</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;8080:8080&quot;</span><br><span class="line">  volumes:</span><br><span class="line">    - /:/rootfs:ro</span><br><span class="line">    - /var/run:/var/run:rw</span><br><span class="line">    - /sys:/sys:ro</span><br><span class="line">    - /var/lib/docker/:/var/lib/docker:ro</span><br><span class="line"> </span><br><span class="line"> grafana:</span><br><span class="line">  user: &quot;104&quot;</span><br><span class="line">  image: grafana/grafana</span><br><span class="line">  user: &quot;104&quot;</span><br><span class="line">  restart: always</span><br><span class="line">  links:</span><br><span class="line">    - influxdb:influxsrv</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;3000:3000&quot;</span><br><span class="line">  volumes:</span><br><span class="line">    - grafana_data:/var/lib/grafana</span><br><span class="line">  environment:</span><br><span class="line">    - HTTP_USER=admin</span><br><span class="line">    - HTTP_PASS=admin</span><br><span class="line">    - INFLUXDB_HOST=influxsrv</span><br><span class="line">    - INFLUXDB_PORT=8086</span><br><span class="line">    - INFLUXDB_NAME=cadvisor</span><br><span class="line">    - INFLUXDB_USER=root</span><br><span class="line">    - INFLUXDB_PASS=root</span><br></pre></td></tr></table></figure>

<ul>
<li>启动docker-compose文件</li>
</ul>
<p><code>docker-compose up</code></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625849.jpg" alt="graphic"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625832.jpg" alt="graphic"></p>
<ul>
<li>查看三个服务容器是否启动</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625621.jpg" alt="graphic"></p>
<ul>
<li><p>测试</p>
</li>
<li><p>浏览cAdvisor收集服务，<a target="_blank" rel="noopener" href="http://ip:8080/">http://ip:8080/</a></p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625499.jpg" alt="graphic"></p>
<p>第一次访问慢，请稍等</p>
<p>cadvisor也有基础的图形展现功能，这里主要用它来作数据采集</p>
<ul>
<li>浏览influxdb存储服务，<a target="_blank" rel="noopener" href="http://ip:8083/">http://ip:8083/</a></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625426.png" alt="image-20221019211956869"></p>
<ul>
<li>浏览grafana展现服务，<a target="_blank" rel="noopener" href="http://ip:3000/">http://ip:3000</a></li>
</ul>
<p>ip+3000端口的方式访问,默认帐户密码（admin&#x2F;admin）</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625810.jpg" alt="graphic"></p>
<p><strong>配置步骤</strong></p>
<ul>
<li>配置数据源</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625515.jpg" alt="graphic"></p>
<ul>
<li>选择influxdb数据源</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625471.jpg" alt="graphic"></p>
<ul>
<li>配置细节</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625193.jpg" alt="graphic"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625120.jpg" alt="graphic"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625817.jpg" alt="graphic"></p>
<ul>
<li>配置面板panel</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625817.jpg" alt="graphic"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625800.jpg" alt="graphic"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141625314.png" alt="image-20221019212419722"></p>
<p>选择展示的图形界面</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141626883.jpg" alt="graphic"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141626619.jpg" alt="graphic"></p>
<p>选择展示的数据源</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141626357.jpg" alt="graphic"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141626407.jpg" alt="graphic"></p>
<ul>
<li>到这里cAdvisor+InfluxDB+Grafana容器监控系统就部署完成了</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">HUA</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/10/Docker/">http://example.com/2023/04/10/Docker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">阿华</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/page4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/23/Docker%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E9%83%A8%E7%BD%B2/"><img class="prev-cover" src="/img/loading.gif" data-original="/img/page6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Docker常用容器部署</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/20/Netty/"><img class="next-cover" src="/img/loading.gif" data-original="/img/page6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Netty</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HUA</div><div class="author-info__description">不要放弃</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/TINGTING-GIT" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromld=45&amp;fromSubld=1&amp;subcmd=all&amp;uin=2164277973&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:2164277973@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div></div><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople1.js"></script><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/zdog.dist.js"></script><script id="rendered-js" src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">一、基本篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Docker%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1、Docker简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81Docker%E7%90%86%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1、Docker理念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2、容器与虚拟机比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">传统虚拟机技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">容器虚拟化技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E3%80%81Docker-%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3、Docker 如何工作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E3%80%81Docker%E5%8E%BB%E5%93%AA%E4%B8%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4、Docker去哪下</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Docker%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">2、Docker架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E9%95%9C%E5%83%8F%E3%80%81%E5%AE%B9%E5%99%A8%E5%92%8C%E4%BB%93%E5%BA%93"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1、镜像、容器和仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81DockerHub"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2、DockerHub</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81Doker%E6%9E%B6%E6%9E%84-%E5%85%A5%E9%97%A8%E7%89%88"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3、Doker架构(入门版)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E3%80%81Docker%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%E5%9B%BE%E8%A7%A3-%E6%9E%B6%E6%9E%84%E7%89%88"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4、Docker平台架构图解(架构版)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E3%80%81%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5、小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Docker%E9%9A%94%E7%A6%BB%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">3、Docker隔离原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Docker%E5%AE%89%E8%A3%85"><span class="toc-number">1.4.</span> <span class="toc-text">4、Docker安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1、前提条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2、安装步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1%E3%80%81%E5%8D%B8%E8%BD%BD%E6%97%A7%E7%89%88%E6%9C%AC"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">4.2.1、卸载旧版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2%E3%80%81yum%E5%AE%89%E8%A3%85gcc%E7%9B%B8%E5%85%B3"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">4.2.2、yum安装gcc相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3%E3%80%81%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">4.2.3、安装软件包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4%E3%80%81%E8%AE%BE%E7%BD%AE%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">4.2.4、设置镜像仓库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5%E3%80%81%E6%9B%B4%E6%96%B0yum%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">4.2.5、更新yum软件包索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-6%E3%80%81%E5%AE%89%E8%A3%85Docker-CE"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">4.2.6、安装Docker CE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-7%E3%80%81%E5%AE%89%E8%A3%85%E8%BF%9B%E9%98%B6"><span class="toc-number">1.4.2.7.</span> <span class="toc-text">4.2.7、安装进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A5%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86Docker"><span class="toc-number">1.4.2.7.1.</span> <span class="toc-text">以非root用户管理Docker</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEDocker%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8"><span class="toc-number">1.4.2.7.2.</span> <span class="toc-text">配置Docker开机启动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E3%80%81%E5%90%AF%E5%8A%A8Docker"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3、启动Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E3%80%81%E5%85%B6%E4%BB%96%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4、其他安装方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1%E3%80%81%E4%BB%8E%E5%8C%85%E5%AE%89%E8%A3%85"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">4.4.1、从包安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2%E3%80%81%E4%BE%BF%E5%88%A9%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">4.4.2、便利脚本安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5%E3%80%81%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5、阿里云镜像加速器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1%E3%80%81%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">4.5.1、配置阿里云镜像加速器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2%E3%80%81%E9%95%9C%E5%83%8F%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%8B%89%E5%8F%96"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">4.5.2、镜像查看和拉取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Docker%E4%BC%9A%E6%AF%94VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BF%AB"><span class="toc-number">1.4.6.</span> <span class="toc-text">4.6、为什么Docker会比VM虚拟机快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7%E3%80%81%E5%8D%B8%E8%BD%BDDocker%E5%BC%95%E6%93%8E"><span class="toc-number">1.4.7.</span> <span class="toc-text">4.7、卸载Docker引擎</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.</span> <span class="toc-text">5、Docker常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81%E5%B8%AE%E5%8A%A9%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1、帮助启动类命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2、镜像命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1%E3%80%81%E9%95%9C%E5%83%8F%E6%9C%AC%E6%9C%BA"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">5.2.1、镜像本机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2%E3%80%81%E9%95%9C%E5%83%8F%E6%90%9C%E7%B4%A2"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">5.2.2、镜像搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3%E3%80%81%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">4.5.3、镜像下载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4%E3%80%81%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F-x2F-%E5%AE%B9%E5%99%A8-x2F-%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%89%80%E5%8D%A0%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">5.2.4、查看镜像&#x2F;容器&#x2F;数据卷所占的空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-5%E3%80%81%E9%95%9C%E5%83%8F%E5%88%A0%E9%99%A4"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">5.2.5、镜像删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-6%E3%80%81docker%E8%99%9A%E6%82%AC%E9%95%9C%E5%83%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">5.2.6、docker虚悬镜像是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-7%E3%80%81%E9%95%9C%E5%83%8F%E5%91%BD%E5%90%8D"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">5.2.7、镜像命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-8%E3%80%81%E9%95%9C%E5%83%8F%E6%89%93%E5%8C%85"><span class="toc-number">1.5.2.8.</span> <span class="toc-text">5.2.8、镜像打包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-9%E3%80%81%E9%95%9C%E5%83%8F%E8%BD%BD%E5%85%A5"><span class="toc-number">1.5.2.9.</span> <span class="toc-text">5.2.9、镜像载入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-10%E3%80%81%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF"><span class="toc-number">1.5.2.10.</span> <span class="toc-text">5.2.10、镜像信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E3%80%81%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3、容器命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1%E3%80%81%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">5.3.1、容器启动</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%90%AF%E5%8A%A8"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text">简单启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%AB%AF%E5%8F%A3%E4%B8%8E%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text">宿主机端口与容器端口映射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8"><span class="toc-number">1.5.3.1.3.</span> <span class="toc-text">后台启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">1.5.3.1.4.</span> <span class="toc-text">交互模式启动容器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2%E3%80%81%E5%AE%B9%E5%99%A8%E6%9F%A5%E7%9C%8B"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">5.3.2、容器查看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3%E3%80%81%E5%AE%B9%E5%99%A8%E9%80%80%E5%87%BA"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">5.3.3、容器退出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-4%E3%80%81%E5%AE%B9%E5%99%A8%E5%86%8D%E5%90%AF%E5%8A%A8"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">5.3.4、容器再启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5%E3%80%81%E5%AE%B9%E5%99%A8%E5%81%9C%E6%AD%A2%E5%92%8C%E9%87%8D%E5%90%AF"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">4.3.5、容器停止和重启</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-6%E3%80%81%E5%AE%B9%E5%99%A8%E5%88%A0%E9%99%A4%E5%92%8C%E6%B8%85%E9%99%A4"><span class="toc-number">1.5.3.6.</span> <span class="toc-text">5.3.6、容器删除和清除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-7%E3%80%81%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.5.3.7.</span> <span class="toc-text">5.3.7、查看容器进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-8%E3%80%81%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E7%BB%86%E8%8A%82"><span class="toc-number">1.5.3.8.</span> <span class="toc-text">5.3.8、查看容器细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-9%E3%80%81%E6%9F%A5%E8%AF%A2%E8%BF%90%E8%A1%8C%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.3.9.</span> <span class="toc-text">5.3.9、查询运行日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-10%E3%80%81%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.5.3.10.</span> <span class="toc-text">5.3.10、进入容器进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-11%E3%80%81%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%96%87%E4%BB%B6-gt-%E5%AE%B9%E5%99%A8"><span class="toc-number">1.5.3.11.</span> <span class="toc-text">5.3.11、宿主机文件 &gt; 容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-12%E3%80%81%E5%AE%B9%E5%99%A8%E5%AF%BC%E5%85%A5-x2F-%E5%AF%BC%E5%87%BA"><span class="toc-number">1.5.3.12.</span> <span class="toc-text">5.3.12、容器导入&#x2F;导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-13%E3%80%81%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.3.13.</span> <span class="toc-text">5.3.13、常用命令总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-14%E3%80%81%E6%80%BB%E7%BB%93%E5%9B%BE%E7%89%87"><span class="toc-number">1.5.3.14.</span> <span class="toc-text">5.3.14、总结图片</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4%E5%9B%BE%E7%89%87"><span class="toc-number">1.5.3.14.1.</span> <span class="toc-text">镜像命令图片</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4%E5%9B%BE%E7%89%87"><span class="toc-number">1.5.3.14.2.</span> <span class="toc-text">容器命令图片</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Docker-%E9%95%9C%E5%83%8F%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">6、Docker 镜像原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%95%9C%E5%83%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1、什么是镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81Docker-%E9%95%9C%E5%83%8F%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2、Docker 镜像原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Docker%E9%95%9C%E5%83%8F%E8%A6%81%E9%87%87%E7%94%A8%E8%BF%99%E7%A7%8D%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E5%91%A2"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3、为什么Docker镜像要采用这种分层结构呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4%E3%80%81%E9%87%8D%E7%82%B9%E7%90%86%E8%A7%A3"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4、重点理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5%E3%80%81%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">1.6.5.</span> <span class="toc-text">6.5、核心架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6%E3%80%81Docker%E9%95%9C%E5%83%8Fcommit%E6%93%8D%E4%BD%9C%E6%A1%88%E4%BE%8B"><span class="toc-number">1.6.6.</span> <span class="toc-text">6.6、Docker镜像commit操作案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7%E3%80%81%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.7.</span> <span class="toc-text">6.7、小总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91"><span class="toc-number">1.7.</span> <span class="toc-text">7、本地镜像发布到阿里云</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E3%80%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1、流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E3%80%81%E9%95%9C%E5%83%8F%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2、镜像的生成方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3%E3%80%81%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E6%8E%A8%E9%80%81%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3、将本地镜像推送到阿里云</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">本地镜像原型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4%E3%80%81%E5%B0%86%E9%95%9C%E5%83%8F%E6%8E%A8%E9%80%81%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4、将镜像推送到阿里云</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5%E3%80%81%E5%B0%86%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0"><span class="toc-number">1.7.5.</span> <span class="toc-text">7.5、将阿里云的镜像下载到本地</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E6%8E%A8%E9%80%81%E5%88%B0%E7%A7%81%E6%9C%89%E5%BA%93"><span class="toc-number">1.8.</span> <span class="toc-text">8、将本地镜像推送到私有库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E3%80%81%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E7%A7%81%E6%9C%89%E5%BA%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1、本地镜像发布到私有库流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFDocker-Registry"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2、什么是Docker Registry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3%E3%80%81%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E6%8E%A8%E9%80%81%E5%88%B0%E7%A7%81%E6%9C%89%E5%BA%93"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3、将本地镜像推送到私有库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Docker%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">1.9.</span> <span class="toc-text">9、Docker数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">1.9.1.</span> <span class="toc-text">9.1、什么是数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">1.9.2.</span> <span class="toc-text">9.2、为什么使用数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3%E3%80%81%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%8C%82%E8%BD%BD%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.3.</span> <span class="toc-text">9.3、数据卷挂载操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1%E3%80%81%E5%85%B7%E4%BD%93%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">9.3.1、具体目录挂载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2%E3%80%81%E9%BB%98%E8%AE%A4%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">9.3.2、默认目录挂载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-3%E3%80%81%E5%8C%BF%E5%90%8D%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">9.3.3、匿名目录挂载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-4%E3%80%81%E5%93%AA%E4%B8%AA%E6%8C%82%E8%BD%BD%E6%96%B9%E6%B3%95%E5%A5%BD%EF%BC%9F"><span class="toc-number">1.9.3.4.</span> <span class="toc-text">9.3.4、哪个挂载方法好？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-5%E3%80%81%E8%AF%BB%E5%86%99%E6%9D%83%E9%99%90"><span class="toc-number">1.9.3.5.</span> <span class="toc-text">9.3.5、读写权限</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4%E3%80%81%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">1.9.4.</span> <span class="toc-text">9.4、数据卷操作命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%91%BD%E4%BB%A4"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">9.4.1、数据卷命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2%E3%80%81%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%9F%A5%E7%9C%8B"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">9.4.2、数据卷查看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-3%E3%80%81%E6%95%B0%E6%8D%AE%E5%8D%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">1.9.4.3.</span> <span class="toc-text">9.4.3、数据卷信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-5%E3%80%81%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%88%9B%E5%BB%BA"><span class="toc-number">1.9.4.4.</span> <span class="toc-text">9.4.5、数据卷创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-6%E3%80%81%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%88%A0%E9%99%A4"><span class="toc-number">1.9.4.5.</span> <span class="toc-text">5.4.6、数据卷删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5%E3%80%81%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-number">1.9.5.</span> <span class="toc-text">9.5、数据卷容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-1%E3%80%81%E7%BB%A7%E6%89%BF"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">9.5.1、继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-2%E3%80%81%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">1.9.5.2.</span> <span class="toc-text">9.5.2、数据共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-3%E3%80%81%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD"><span class="toc-number">1.9.5.3.</span> <span class="toc-text">9.5.3、数据备份</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-4%E3%80%81%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="toc-number">1.9.5.4.</span> <span class="toc-text">9.5.4、数据恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6%E3%80%81%E6%8C%82%E8%BD%BD%E7%89%B9%E6%80%A7"><span class="toc-number">1.9.6.</span> <span class="toc-text">9.6、挂载特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81Docker-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85"><span class="toc-number">1.10.</span> <span class="toc-text">10、Docker 软件安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%E3%80%81Tomcat%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8"><span class="toc-number">1.10.1.</span> <span class="toc-text">10.1、Tomcat安装使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1%E3%80%81%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">10.1.1、版本选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2%E3%80%81%E5%AE%89%E8%A3%85%E4%BF%AE%E6%94%B9"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">10.1.2、安装修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-3%E3%80%81%E5%90%AF%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">10.1.3、启动使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-4%E3%80%81%E6%8C%82%E8%BD%BD%E7%89%B9%E6%80%A7"><span class="toc-number">1.10.1.4.</span> <span class="toc-text">10.1.4、挂载特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-5%E3%80%81%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="toc-number">1.10.1.5.</span> <span class="toc-text">10.1.5、相关指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2%E3%80%81MySQL%E5%AE%89%E8%A3%85"><span class="toc-number">1.10.2.</span> <span class="toc-text">10.2、MySQL安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1%E3%80%81%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">10.2.1、安装启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-2%E3%80%81%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">10.2.2、其他命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3%E3%80%81Redis%E5%AE%89%E8%A3%85"><span class="toc-number">1.10.3.</span> <span class="toc-text">10.3、Redis安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1%E3%80%81%E5%AE%89%E8%A3%85"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">10.3.1、安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-2%E3%80%81%E5%90%AF%E5%8A%A8"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">10.3.2、启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-3%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-number">1.10.3.3.</span> <span class="toc-text">10.3.3、其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4%E3%80%81ElasticSearch%E5%AE%89%E8%A3%85"><span class="toc-number">1.10.4.</span> <span class="toc-text">10.4、ElasticSearch安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-1%E3%80%81%E5%AE%89%E8%A3%85"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">10.4.1、安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2%E3%80%81%E9%85%8D%E7%BD%AE"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">10.4.2、配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-3%E3%80%81%E5%90%AF%E5%8A%A8"><span class="toc-number">1.10.4.3.</span> <span class="toc-text">10.4.3、启动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5%E3%80%81Kibana%E5%AE%89%E8%A3%85"><span class="toc-number">1.10.5.</span> <span class="toc-text">10.5、Kibana安装</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%AB%98%E7%BA%A7%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">二、高级篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Docker%E5%A4%8D%E6%9D%82%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.</span> <span class="toc-text">1、Docker复杂安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1、Mysql主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">1.1.1、数据库主从复制原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2%E3%80%81%E4%B8%BB%E4%BB%8E%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">1.1.2、主从搭建步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81%E5%AE%89%E8%A3%85Redis%E9%9B%86%E7%BE%A4"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2、安装Redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1%E3%80%81cluster-%E9%9B%86%E7%BE%A4-%E6%A8%A1%E5%BC%8F-docker%E7%89%88-%E5%93%88%E5%B8%8C%E6%A7%BD%E5%88%86%E5%8C%BA%E8%BF%9B%E8%A1%8C%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">1.2.1、cluster(集群)模式-docker版 哈希槽分区进行亿级数据存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%8F%96%E4%BD%99%E5%88%86%E5%8C%BA"><span class="toc-number">2.1.2.1.1.</span> <span class="toc-text">哈希取余分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%88%86%E5%8C%BA"><span class="toc-number">2.1.2.1.2.</span> <span class="toc-text">一致性哈希算法分区</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E5%A4%A7%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.1.2.1.2.1.</span> <span class="toc-text">3大步骤</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.2.1.2.2.</span> <span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%A7%BD%E5%88%86%E5%8C%BA"><span class="toc-number">2.1.2.1.3.</span> <span class="toc-text">哈希槽分区</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2%E3%80%813%E4%B8%BB3%E4%BB%8Eredis%E9%9B%86%E7%BE%A4%E6%89%A9%E7%BC%A9%E5%AE%B9%E9%85%8D%E7%BD%AE%E6%A1%88%E4%BE%8B%E6%9E%B6%E6%9E%84%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">1.2.2、3主3从redis集群扩缩容配置案例架构说明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E4%B8%BB3%E4%BB%8Eredis%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.2.2.1.</span> <span class="toc-text">3主3从redis集群配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%AE%B9%E9%94%99%E5%88%87%E6%8D%A2%E8%BF%81%E7%A7%BB%E6%A1%88%E4%BE%8B"><span class="toc-number">2.1.2.2.2.</span> <span class="toc-text">主从容错切换迁移案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%89%A9%E5%AE%B9%E6%A1%88%E4%BE%8B"><span class="toc-number">2.1.2.2.3.</span> <span class="toc-text">主从扩容案例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E7%BC%A9%E5%AE%B9%E6%A1%88%E4%BE%8B"><span class="toc-number">2.1.2.2.4.</span> <span class="toc-text">主从缩容案例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81DockerFile%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">2、DockerFile解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81DockerFile%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2、DockerFile构建过程解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81DockerFile%E5%B8%B8%E7%94%A8%E4%BF%9D%E7%95%99%E5%AD%97%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3、DockerFile常用保留字指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E3%80%81%E6%A1%88%E4%BE%8B"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4、案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Docker%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98"><span class="toc-number">2.3.</span> <span class="toc-text">3、Docker微服务实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E9%80%9A%E8%BF%87IDEA%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1、通过IDEA新建一个普通微服务模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E9%80%9A%E8%BF%87dockerfile%E5%8F%91%E5%B8%83%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E5%88%B0docker%E5%AE%B9%E5%99%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2、通过dockerfile发布微服务部署到docker容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Docker%E7%BD%91%E7%BB%9C"><span class="toc-number">2.4.</span> <span class="toc-text">4、Docker网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.2、常用基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E3%80%81%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">2.4.3.</span> <span class="toc-text">4.3、能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E3%80%81%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.4.</span> <span class="toc-text">4.4、网络模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bridge"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">bridge</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.4.4.1.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">2.4.4.1.2.</span> <span class="toc-text">案例说明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#host"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">host</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">2.4.4.2.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E8%AF%B4%E6%98%8E-1"><span class="toc-number">2.4.4.2.2.</span> <span class="toc-text">案例说明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#none"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">none</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">2.4.4.3.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">2.4.4.3.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#container"><span class="toc-number">2.4.4.4.</span> <span class="toc-text">container</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-number">2.4.4.4.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-number">2.4.4.4.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-number">2.4.4.5.</span> <span class="toc-text">自定义网络</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-number">2.4.4.5.1.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5%E3%80%81Docker%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%E5%9B%BE%E8%A7%A3"><span class="toc-number">2.4.5.</span> <span class="toc-text">4.5、Docker平台架构图解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Docker-compose%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92"><span class="toc-number">2.5.</span> <span class="toc-text">5、Docker-compose容器编排</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.5.1.</span> <span class="toc-text">5.1、是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">2.5.2.</span> <span class="toc-text">5.2、能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E3%80%81%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85"><span class="toc-number">2.5.3.</span> <span class="toc-text">5.3、下载安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E3%80%81Compose%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">2.5.4.</span> <span class="toc-text">5.4、Compose核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Compose%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">Compose使用的三个步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5%E3%80%81%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.5.5.</span> <span class="toc-text">5.5、常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6%E3%80%81Compose%E7%BC%96%E6%8E%92%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.5.6.</span> <span class="toc-text">5.6、Compose编排微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B5%8B%E8%AF%95"><span class="toc-number">2.5.6.1.</span> <span class="toc-text">微服务测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E7%94%A8Compose"><span class="toc-number">2.5.6.2.</span> <span class="toc-text">不用Compose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Compose"><span class="toc-number">2.5.6.3.</span> <span class="toc-text">使用Compose</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Docker%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7Portainer"><span class="toc-number">2.6.</span> <span class="toc-text">6、Docker轻量级可视化工具Portainer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.6.1.</span> <span class="toc-text">6.1、是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81%E5%AE%89%E8%A3%85"><span class="toc-number">2.6.2.</span> <span class="toc-text">6.2、安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E3%80%81%E4%BD%BF%E7%94%A8"><span class="toc-number">2.6.3.</span> <span class="toc-text">6.3、使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4%E3%80%81%E6%B1%89%E5%8C%96"><span class="toc-number">2.6.4.</span> <span class="toc-text">6.4、汉化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Docker%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7%E4%B9%8B-CAdvisor-InfluxDB-Granfana"><span class="toc-number">2.7.</span> <span class="toc-text">7、Docker容器监控之 CAdvisor+InfluxDB+Granfana</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E3%80%81%E5%8E%9F%E7%94%9F%E5%91%BD%E4%BB%A4docker-stats"><span class="toc-number">2.7.1.</span> <span class="toc-text">7.1、原生命令docker stats</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.7.2.</span> <span class="toc-text">7.2、是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CAdvisor%E7%9B%91%E6%8E%A7%E6%94%B6%E9%9B%86"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">CAdvisor监控收集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InfluxDB%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">InfluxDB存储数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Granfana%E5%B1%95%E7%A4%BA%E5%9B%BE%E8%A1%A8"><span class="toc-number">2.7.2.3.</span> <span class="toc-text">Granfana展示图表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.7.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3%E3%80%81%E5%AE%89%E8%A3%85"><span class="toc-number">2.7.3.</span> <span class="toc-text">7.3、安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#compose%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%EF%BC%8C%E4%B8%80%E5%A5%97%E5%B8%A6%E8%B5%B0"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">compose容器编排，一套带走</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/20/%E4%BD%8D%E8%BF%90%E7%AE%97/" title="位运算"><img src="/img/loading.gif" data-original="/img/page4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="位运算"/></a><div class="content"><a class="title" href="/2023/11/20/%E4%BD%8D%E8%BF%90%E7%AE%97/" title="位运算">位运算</a><time datetime="2023-11-20T10:17:54.000Z" title="发表于 2023-11-20 18:17:54">2023-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/18/Vue3/" title="Vue3"><img src="/img/loading.gif" data-original="/img/page5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue3"/></a><div class="content"><a class="title" href="/2023/11/18/Vue3/" title="Vue3">Vue3</a><time datetime="2023-11-18T05:59:47.000Z" title="发表于 2023-11-18 13:59:47">2023-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/22/LeetCode/" title="无题"><img src="/img/loading.gif" data-original="/img/page4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/10/22/LeetCode/" title="无题">无题</a><time datetime="2023-10-22T06:30:38.513Z" title="发表于 2023-10-22 14:30:38">2023-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/07/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/" title="无题"><img src="/img/loading.gif" data-original="/img/page5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/10/07/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/" title="无题">无题</a><time datetime="2023-10-07T15:09:36.518Z" title="发表于 2023-10-07 23:09:36">2023-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/06/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程"><img src="/img/loading.gif" data-original="/img/page5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC并发编程"/></a><div class="content"><a class="title" href="/2023/10/06/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程">JUC并发编程</a><time datetime="2023-10-06T06:55:28.000Z" title="发表于 2023-10-06 14:55:28">2023-10-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By HUA</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/tzy13755126023/BLOG_SOURCE/theme_f/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(e){e.imageLazyLoadSetting.processImages=t;var n=e.imageLazyLoadSetting.isSPA,i=e.imageLazyLoadSetting.preloadRatio||1,r=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){n&&(r=o());for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(e.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];e=function(){r=r.filter(function(t){return o!==t})},(t=o).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,t.removeAttribute("data-original"),e&&e()},t.src!==i&&(n.src=i))}()}function a(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",a),e.addEventListener("resize",a),e.addEventListener("orientationchange",a)}(this);</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>