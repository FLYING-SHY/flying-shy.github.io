<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>how2j | 阿华</title><meta name="author" content="HUA"><meta name="copyright" content="HUA"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="Java基础控制流程Java结束外部循环 结束当前循环  break; 只能结束当前循环 &#96;public&#96; &#96;class&#96; &#96;HelloWorld &amp;#123;&#96;&#96;    &#96;&#96;public&#96; &#96;static&#96; &#96;void&#96; &#96;main(String[] args) &amp;#123;&#96;&#96;         &#96; &#96;        &#96;&#96;&#x2F;&#x2F;打印单数    &#96;&#96;        &#96;&#96;for&#96; &#96;(&#96;&#96;int&#96; &#96;">
<meta property="og:type" content="article">
<meta property="og:title" content="how2j">
<meta property="og:url" content="http://example.com/2020/10/23/how2j/index.html">
<meta property="og:site_name" content="阿华">
<meta property="og:description" content="Java基础控制流程Java结束外部循环 结束当前循环  break; 只能结束当前循环 &#96;public&#96; &#96;class&#96; &#96;HelloWorld &amp;#123;&#96;&#96;    &#96;&#96;public&#96; &#96;static&#96; &#96;void&#96; &#96;main(String[] args) &amp;#123;&#96;&#96;         &#96; &#96;        &#96;&#96;&#x2F;&#x2F;打印单数    &#96;&#96;        &#96;&#96;for&#96; &#96;(&#96;&#96;int&#96; &#96;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/page4.jpg">
<meta property="article:published_time" content="2020-10-23T01:47:09.000Z">
<meta property="article:modified_time" content="2023-10-14T09:11:57.948Z">
<meta property="article:author" content="HUA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/page4.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/10/23/how2j/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'how2j',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-14 17:11:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">阿华</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">how2j</h1><div id="post-meta"><div class="meta-firstline"></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">44.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>182分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="how2j"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><h3 id="Java结束外部循环"><a href="#Java结束外部循环" class="headerlink" title="Java结束外部循环"></a>Java结束外部循环</h3><ol>
<li>结束当前循环</li>
</ol>
<p>break; 只能结束当前循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">`<span class="keyword">public</span>` `class` `HelloWorld &#123;``    ``<span class="keyword">public</span>` `<span class="keyword">static</span>` `<span class="keyword">void</span>` `main(String[] args) &#123;``         ` `        ``<span class="comment">//打印单数    ``        ``for` `(``int` `i = ``0``; i &lt; ``10``; i++) &#123;``            ` `            ``for` `(``int` `j = ``0``; j &lt; ``10``; j++) &#123;``                ``System.out.println(i+``&quot;:&quot;``+j);``                ``if``(``0``==j%``2``) ``                    ``break``; ``//如果是双数，结束当前循环``            ``&#125;``            ` `        ``&#125;``        ` `    ``&#125;``&#125;`</span></span><br></pre></td></tr></table></figure>

<ol>
<li>使用boolean变量结束外部循环</li>
</ol>
<p>借助boolean变量结束外部循环<br>需要在内部循环中修改这个变量值<br>每次内部循环结束后，都要在外部循环中判断，这个变量的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">breakout</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//是否终止外部循环的标记</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">				System.out.println(i + <span class="string">&quot;:&quot;</span> + j);</span><br><span class="line">				<span class="keyword">if</span> (<span class="number">0</span> == j % <span class="number">2</span>) &#123;</span><br><span class="line">					breakout = <span class="literal">true</span>; <span class="comment">//终止外部循环的标记设置为true</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (breakout) <span class="comment">//判断是否终止外部循环</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用标签结束外部循环</li>
</ol>
<p>在外部循环的前一行，加上标签<br>在break的时候使用该标签<br>即能达到结束外部循环的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//打印单数     </span></span><br><span class="line">    	outloop: <span class="comment">//outloop这个标示是可以自定义的比如outloop1,ol2,out5</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    		</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            	System.out.println(i+<span class="string">&quot;:&quot;</span>+j);</span><br><span class="line">            	<span class="keyword">if</span>(<span class="number">0</span>==j%<span class="number">2</span>)  </span><br><span class="line">            		<span class="keyword">break</span> outloop; <span class="comment">//如果是双数，结束外部循环</span></span><br><span class="line">    		&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="理解随机数-Math-floor-Math-random-max-min-1-min"><a href="#理解随机数-Math-floor-Math-random-max-min-1-min" class="headerlink" title="理解随机数 Math.floor(Math.random() * (max - min + 1) + min)"></a>理解随机数 Math.floor(Math.random() * (max - min + 1) + min)</h3><p>众所周知 Math.floor(Math.random() * (max - min + 1) + min) ，会得到 [min,max]之间的随机整数</p>
<ol>
<li><p>使用Math.round()四舍五入小数</p>
<p>Math.round(Math.random() * (max - min)+min)</p>
<p>失败：<br><strong>实际上获得的数并不随机，由于Math.round()四舍五入 ，(2<del>2.5) 才是2,而 [2.5</del>3.5) 是3，很明显这对2和99都不公平 ，它两的随机概率只有其他人的一半</strong></p>
</li>
<li><p>使用Math.floor</p>
<p>floor是向下取整！</p>
<p>使用floor 上面的随机小数<strong>是取不到 最大值的</strong>，<br>那么 (min,max+1) ， 扩大区间 +1就好了</p>
</li>
</ol>
<h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><p>把一个数组的值，复制到另一个数组中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.arraycopy(src, srcPos, dest, destPos, length)</span><br></pre></td></tr></table></figure>

<p>src: 源数组<br>srcPos: 从源数组复制数据的起始位置<br>dest: 目标数组<br>destPos: 复制到目标数组的起始位置<br>length: 复制的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a [] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">18</span>,<span class="number">62</span>,<span class="number">68</span>,<span class="number">82</span>,<span class="number">65</span>,<span class="number">9</span>&#125;;</span><br><span class="line">         </span><br><span class="line">        <span class="type">int</span> b[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">//分配了长度是3的空间，但是没有赋值</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//通过数组赋值把，a数组的前3位赋值到b数组</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//方法一： for循环</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//方法二: System.arraycopy(src, srcPos, dest, destPos, length)</span></span><br><span class="line">        <span class="comment">//src: 源数组</span></span><br><span class="line">        <span class="comment">//srcPos: 从源数组复制数据的起始位置</span></span><br><span class="line">        <span class="comment">//dest: 目标数组</span></span><br><span class="line">        <span class="comment">//destPos: 复制到目标数组的启始位置</span></span><br><span class="line">        <span class="comment">//length: 复制的长度       </span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, b, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//把内容打印出来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            System.out.print(b[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//初始化二维数组，</span></span><br><span class="line">       <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">//有两个一维数组，每个一维数组的长度是3</span></span><br><span class="line">       a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">5</span>;  <span class="comment">//可以直接访问一维数组，因为已经分配了空间</span></span><br><span class="line">          </span><br><span class="line">       <span class="comment">//只分配了二维数组</span></span><br><span class="line">       <span class="type">int</span>[][] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][]; <span class="comment">//有两个一维数组，每个一维数组的长度暂未分配</span></span><br><span class="line">       b[<span class="number">0</span>]  =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">//必须事先分配长度，才可以访问</span></span><br><span class="line">       b[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//指定内容的同时，分配空间</span></span><br><span class="line">       <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">               &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,</span><br><span class="line">               &#123;<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">               &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">       &#125;;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><ol>
<li>Arrays.fill(Object[ ] array, Object obj)——用指定元素填充整个数组(替换数组原元素)</li>
<li>Arrays.sort(Object [ ]arr)——对传入数组进行递增排序，字符则按照ASCII进行排序(不区分大小写)</li>
<li>Arrays.sort(Object [ ]arr,int start,int end)——对区间内的元素进行递增排序</li>
<li>Arrays.equal(Object []arr,Object [] nums)——判断两个数组是否相等，实际上比较的是两个数组的哈希值</li>
<li>Array.hashCode(Object []arr)——返回数组的哈希值</li>
<li>Arrays.copyOf(Object [])——拷贝数组，其内部调用了 System.arraycopy() 方法，从下标0开始，如果超过原数组长度，会用null进行填充。</li>
<li>Arrays.copyOfRange(T[] original, int from, int to)——拷贝数组，指定起始位置和结束位置，如果超过原数组长度，会用null进行填充</li>
<li>Arrays.toString(Object []arr)——将数组中的内容全部打印出来</li>
<li>Arrays.binarySearch(Object []arr,T ans)——二分查找法找指定元素的索引值(数组一定是排好序的，否则会出错。找到元素，只会返回最后一个位置)</li>
</ol>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>成员变量有四种修饰符：<strong>private</strong> 私有的，<strong>package</strong>&#x2F;friendly&#x2F;default 不写，<strong>protected</strong> 受保护的，<strong>public</strong> 公共的</p>
<ol>
<li>private 私有的</li>
</ol>
<p><strong>注： 红色字体，表示不可访问</strong></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141706101.png" alt="private 私有的"></p>
<ol>
<li>没有修饰符即代表package&#x2F;friendly&#x2F;default</li>
</ol>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141706282.png" alt="package/friendly/default 不写"></p>
<ol>
<li>protected 受保护的</li>
</ol>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141706995.png" alt="protected 受保护的"></p>
<ol>
<li>public 公共的</li>
</ol>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141706429.png" alt="public 公共的"></p>
<ol>
<li><p>那么什么情况该用什么修饰符呢？<br>从作用域来看，public能够使用所有的情况。 但是大家在工作的时候，又不会真正全部都使用public,那么到底什么情况该用什么修饰符呢？</p>
<ol>
<li>属性通常使用private封装起来</li>
<li>方法一般使用public用于被调用</li>
<li>会被子类继承的方法，通常使用protected</li>
<li>package用的不多，一般新手会用package,因为还不知道有修饰符这个东西</li>
</ol>
<p>再就是<strong>作用范围最小原则</strong><br>简单说，能用private就用private，不行就放大一级，用package,再不行就用protected，最后用public。 这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了</p>
</li>
</ol>
<h3 id="属性初始化"><a href="#属性初始化" class="headerlink" title="属性初始化"></a>属性初始化</h3><p>对象属性初始化有3种</p>
<ol>
<li><p>声明该属性的时候初始化</p>
</li>
<li><p>构造方法中初始化</p>
</li>
<li><p>初始化块</p>
<p>对象属性的初始化有三种方式<br>故意把初始化块，放在构造方法下面，问题：</p>
</li>
</ol>
<p>这三种方式，谁先执行？谁后执行？  属性声明——》构造方法——》初始化块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;some hero&quot;</span>; </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span>&#123;</span><br><span class="line">        name = <span class="string">&quot;one hero&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;the hero&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类属性初始化有2种</p>
<ol>
<li>声明该属性的时候初始化</li>
<li>静态初始化块</li>
</ol>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ol>
<li><p><strong>饿汉式</strong>是立即加载的方式，无论是否会用到这个对象，都会加载。<br>如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GiantDragon</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//私有化构造方法使得该类无法在外部通过new 进行实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GiantDragon</span><span class="params">()</span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GiantDragon</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GiantDragon</span>();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//public static 方法，提供给调用者获取12行定义的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>懒汉式</strong>，是延迟加载的方式，只有使用的时候才会加载。 并且有<a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-synchronized/355.html#step793">线程安全</a>的考量 ，使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="literal">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;&#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance=<span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ol>
<li><p>介绍</p>
<ul>
<li><p>枚举对应英文(enumeration,简写 enum)</p>
</li>
<li><p>枚举是一组常量的集合</p>
</li>
<li><p>枚举属于一种特殊的类，里面只包含一组有限的特定的对象</p>
</li>
<li><p>不需要提供 setXxxx() 方法，因为枚举对象值通常为只读</p>
</li>
<li><p>对枚举对象&#x2F;属性使用 static+final 共同修饰</p>
<blockquote>
<p><strong>static+final</strong> 只有修饰基本数据类型和String类型才不会加载类，修饰对象或者方法还是会加载类</p>
<p>final 修饰对象(引用)只是保证引用的指向不变，但不能保证对象本身不变</p>
</blockquote>
</li>
<li><p>枚举对象名通常使用全部大写，与常量的命名规范一样</p>
</li>
<li><p>枚举对象根据需要，也可以有多个属性</p>
</li>
</ul>
</li>
<li><p>自定义类实现枚举</p>
<ul>
<li>将构造器私有化，目的是防止被new出对象</li>
<li>去掉 setXxxx() 方法，防止属性被修改</li>
<li>在Season内部，直接创建固定对象</li>
<li>对外暴露对象(通过为对象添加 <strong>public static final</strong> 修饰符)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.AUTUMN);</span><br><span class="line">        System.out.println(Season.SUMMER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="comment">//定义了四个对象</span></span><br><span class="line">    <span class="comment">//加final是为了使引用不能被修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用enum关键字实现枚举</p>
<ul>
<li>使用 enum 关键字代替 class</li>
<li>常量对象名(实参列表)</li>
<li>public static final Season2 SPRING &#x3D; new Season2(“春天”, “温暖”); 等价于 SPRING(“春天”, “温暖”);</li>
<li>如果有多个对象，需要使用 ，间隔</li>
<li>如果使用 enum 关键字来实现枚举，要求将定义的常量对象写在最前面</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season2.SPRING);</span><br><span class="line">        System.out.println(Season2.SUMMER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span>  <span class="title class_">Season2</span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>),WINTER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>),AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season2</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>enum的常用方法</p>
<blockquote>
<p>使用关键字enum时，会隐式继承Enum类，这样就可以使用Enum类的相关方法</p>
</blockquote>
<ul>
<li>toString()：Enum类已经重写过了，返回的是当前对象名；子类可以重写该方法，用于返回对象的属性信息</li>
<li>name()：返回当前对象名(常量名)，子类中不能重写</li>
<li>ordinal()：返回当前对象的位置号，默认从0开始</li>
<li>values()：返回当前枚举类中所有的常量对象</li>
<li>valueOf()：将字符串转换成已有的枚举对象，要求字符串必须为已有的常量名，否则报异常！</li>
<li>compareTo()：比较两个枚举常量的大小(编号),返回的结果是两个枚举常量的编号相减得到的数</li>
</ul>
</li>
<li><p>enum的使用细节</p>
<ul>
<li><strong>使用enum关键字创建的枚举类，就不能再继承其它类了</strong>，因为使用enum创建的枚举类会隐式的继<strong>承Enum类</strong>，而Java是单继承机制</li>
<li>枚举类和普通类一样，可以实现接口</li>
</ul>
</li>
</ol>
<h2 id="接口与继承"><a href="#接口与继承" class="headerlink" title="接口与继承"></a>接口与继承</h2><h3 id="编译类型和运行类型"><a href="#编译类型和运行类型" class="headerlink" title="编译类型和运行类型"></a>编译类型和运行类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.testpoly_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPoly_</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、编译类型和运行类型：</span></span><br><span class="line"><span class="comment">     * 例如：Animal dog = new Dog(&quot;小白&quot;);</span></span><br><span class="line"><span class="comment">     * Animal是编译类型（=的左边），Dog是运行类型（=的右边）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 2、编译类型确定即不能再改变，运行类型可以修改</span></span><br><span class="line"><span class="comment">     * 例如：Animal white = new Dog(&quot;小白狗&quot;);</span></span><br><span class="line"><span class="comment">     * white = new Cat(&quot;小白猫&quot;);</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 3、程序的执行结果是根据运行类型决定的，但是编译类型决定可以调用的方法有哪些</span></span><br><span class="line"><span class="comment">     * 例如：Animal white = new Dog(&quot;小白狗&quot;);</span></span><br><span class="line"><span class="comment">     * white对象可以调用的方法有：eat方法（Animal类里的所有方法），不能调用Dog类里的run方法</span></span><br><span class="line"><span class="comment">     * white对象调用的eat方法的执行结果，是Dog类的eat方法执行结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1、多态是两个类存在继承关系；</span></span><br><span class="line"><span class="comment">	 * 2、多态向上转型：父类的引用指向子类的对象；语法：父类 xxx = new 子类();</span></span><br><span class="line"><span class="comment">	 * 3、可以调用父类中的所有方法，前提是有访问权限，不能调用子类的独有方法；</span></span><br><span class="line"><span class="comment">　　  * 程序在编译阶段，已经决定这个对象可以调用的属性、方法</span></span><br><span class="line"><span class="comment">	 * 4、程序运行结果是根据运行类型决定。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPolymorphism</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">white</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小白狗&quot;</span>);</span><br><span class="line">        white.eat();</span><br><span class="line"><span class="comment">//        white.run();  // 错误：没有run方法</span></span><br><span class="line"></span><br><span class="line">        white = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小白猫&quot;</span>);</span><br><span class="line">        white.eat();</span><br><span class="line"><span class="comment">//        cat.jump();   // 错误：没有jump方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;觅食...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;在啃骨头..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;在吃鱼..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat jump...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JAVA中的方法隐藏"><a href="#JAVA中的方法隐藏" class="headerlink" title="JAVA中的方法隐藏"></a>JAVA中的方法隐藏</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//类方法，静态方法</span></span><br><span class="line">    <span class="comment">//通过类就可以直接调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">battleWin</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hero battle win&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">######################################################</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADHero</span> <span class="keyword">extends</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">AD</span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">physicAttack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//隐藏父类的battleWin方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">battleWin</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ad hero battle win&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Hero.battleWin();</span><br><span class="line">        ADHero.battleWin();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">#######################################################</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="comment">// h.battleWin(); //battleWin是一个类方法</span></span><br><span class="line">		  <span class="comment">// h是父类类型的引用</span></span><br><span class="line">		  <span class="comment">// 但是指向一个子类对象</span></span><br><span class="line">		  <span class="comment">// h.battleWin(); 会调用父类的方法？还是子类的方法？</span></span><br><span class="line">    	  <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ADHero</span>();</span><br><span class="line">          h.battleWin();</span><br><span class="line">          ADHero.battleWin();</span><br><span class="line">         </span><br><span class="line">          <span class="comment">//当继承的方法为静态方法时，父类指向子类，JVM使用的是静态绑定</span></span><br><span class="line">          <span class="comment">//当继承的方法不是静态方法时，父类指向子类，JVM使用的是动态绑定</span></span><br><span class="line">          <span class="comment">//想要继承的方法为静态的方法时，想要调用子类的重写方法，直接子类名称.静态方法</span></span><br><span class="line">          <span class="comment">//*当出现private,final,static,以及构造器的时候，JVM会调用静态绑定</span></span><br><span class="line">       </span><br><span class="line">          <span class="comment">//总结</span></span><br><span class="line">          <span class="comment">/*if(父类指向子类，调用的方法为静态方法)&#123;</span></span><br><span class="line"><span class="comment">              打印父类方法</span></span><br><span class="line"><span class="comment">          &#125;else(父类指向子类，调用的方法不是静态方法)&#123;</span></span><br><span class="line"><span class="comment">              打印子类方法</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="JAVA中的super关键字"><a href="#JAVA中的super关键字" class="headerlink" title="JAVA中的super关键字"></a>JAVA中的super关键字</h3><p>其<strong>父类的构造方法也会被调用</strong><br>并且是父类构造方法<strong>先调用</strong><br>子类构造方法会默认调用父类的 无参的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> property.Item;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hero的构造方法 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">####################################################</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADHero</span> <span class="keyword">extends</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">AD</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ADHero</span><span class="params">()</span>&#123;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">&quot;AD Hero的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ADHero</span>();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">########输出#########</span><br><span class="line">Hero的构造方法</span><br><span class="line">AD Hero的构造方法</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//    故意不提供无参的构造方法</span></span><br><span class="line"><span class="comment">//    public Hero()&#123;</span></span><br><span class="line"><span class="comment">//     </span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#################################################</span><br><span class="line"> <span class="number">2</span>   </span><br><span class="line"> <span class="number">3</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADHero</span> <span class="keyword">extends</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">AD</span>&#123;</span><br><span class="line">       <span class="comment">// 创建子类对象时，会先调用其父类的构造方法，而此时父类没有无参构造，所以需要用super关键字去调用父类的有参构造方法</span></span><br><span class="line"> <span class="number">4</span>     <span class="keyword">public</span> <span class="title function_">ADHero</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="number">5</span>         <span class="built_in">super</span>(<span class="string">&quot;&quot;</span>);<span class="comment">//super(&quot;&quot;)调用的是父类的有参构造方法Hero(String name);</span></span><br><span class="line"> <span class="number">6</span>     &#125;</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="meta">@Override</span></span><br><span class="line"> <span class="number">9</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">physicAttack</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">10</span>         System.out.println(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line"><span class="number">11</span>     &#125;</span><br><span class="line"><span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="JAVA中的超类Object"><a href="#JAVA中的超类Object" class="headerlink" title="JAVA中的超类Object"></a>JAVA中的超类Object</h3><p>Object类是所有类的父类（toString()，finalize()，equals()，hashCode()，getClass()）</p>
<p>例：  当<strong>一个对象没有任何引用指向的</strong>时候，它就满足垃圾回收的条件</p>
<p>当它被垃圾回收的时候，它的finalize() 方法就会被调用。</p>
<p>finalize() 不是开发人员主动调用的方法，而是由虚拟机JVM调用的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这个英雄正在被回收&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//只有一引用</span></span><br><span class="line">        Hero h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//不断生成新的对象</span></span><br><span class="line">            <span class="comment">//每创建一个对象，前一个对象，就没有引用指向了</span></span><br><span class="line">            <span class="comment">//那些对象，就满足垃圾回收的条件</span></span><br><span class="line">            <span class="comment">//当，垃圾堆积的比较多的时候，就会触发垃圾回收</span></span><br><span class="line">            <span class="comment">//一旦这个对象被回收，它的finalize()方法就会被调用</span></span><br><span class="line">            h = <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JAVA抽象类"><a href="#JAVA抽象类" class="headerlink" title="JAVA抽象类"></a>JAVA抽象类</h3><ul>
<li>在类中声明一个方法，这个方法没有实现体，是一个“空”方法</li>
<li>这样的方法就叫抽象方法，使用修饰符“abstract”</li>
<li>当一个类有抽象方法的时候，该类必须被声明为抽象类  </li>
<li>抽象类可以没有抽象方法<ul>
<li>Hero类可以在不提供抽象方法的前提下，声明为抽象类</li>
<li><strong>一旦一个类被声明为抽象类，就不能够被直接实例化</strong></li>
</ul>
</li>
<li>抽象类和接口的区别<ul>
<li>区别1：<br>子类只能继承一个抽象类，不能继承多个<br>子类可以实现<strong>多个</strong>接口</li>
<li>区别2：<br>抽象类可以定义：public,protected,package,private；静态和非静态属性；final和非final属性<br>但是接口中声明的属性，只能是public；静态；final的</li>
</ul>
</li>
</ul>
<h3 id="JAVA内部类"><a href="#JAVA内部类" class="headerlink" title="JAVA内部类"></a>JAVA内部类</h3><ol>
<li><p>非静态内部类</p>
<p>语法: <strong>new 外部类().new 内部类()</strong><br>作为Hero的非静态内部类，是可以直接访问外部类的<strong>private</strong>实例属性name的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">float</span> hp; <span class="comment">// 血量</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">float</span> armor; <span class="comment">// 护甲</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> moveSpeed; <span class="comment">// 移动速度</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 非静态内部类，只有一个外部类对象存在的时候，才有意义</span></span><br><span class="line">    <span class="comment">// 战斗成绩只有在一个英雄对象存在的时候才有意义</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BattleScore</span> &#123;</span><br><span class="line">        <span class="type">int</span> kill;</span><br><span class="line">        <span class="type">int</span> die;</span><br><span class="line">        <span class="type">int</span> assit;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">legendary</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (kill &gt;= <span class="number">8</span>)</span><br><span class="line">                System.out.println(name + <span class="string">&quot;超神！&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(name + <span class="string">&quot;尚未超神！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">garen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        garen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        <span class="comment">// 实例化内部类</span></span><br><span class="line">        <span class="comment">// BattleScore对象只有在一个英雄对象存在的时候才有意义</span></span><br><span class="line">        <span class="comment">// 所以其实例化必须建立在一个外部类对象的基础之上</span></span><br><span class="line">        <span class="type">BattleScore</span> <span class="variable">score</span> <span class="operator">=</span> garen.<span class="keyword">new</span> <span class="title class_">BattleScore</span>();</span><br><span class="line">        score.kill = <span class="number">9</span>;</span><br><span class="line">        score.legendary();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态内部类</p>
<p>语法：<strong>new 外部类.静态内部类();</strong><br>因为没有一个外部类的实例，所以在静态内部类里面<strong>不可以访问外部类的实例属性和方法</strong><br>除了可以访问外部类的<strong>私有静态成员外</strong>，静态内部类和普通类没什么大的区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">battleWin</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;battle win&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//敌方的水晶</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnemyCrystal</span>&#123;</span><br><span class="line">        <span class="type">int</span> hp=<span class="number">5000</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//如果水晶的血量为0，则宣布胜利</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkIfVictory</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hp==<span class="number">0</span>)&#123;</span><br><span class="line">                Hero.battleWin();</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">//静态内部类不能直接访问外部类的对象属性</span></span><br><span class="line">                System.out.println(name + <span class="string">&quot; win this game&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//实例化静态内部类</span></span><br><span class="line">        Hero.<span class="type">EnemyCrystal</span> <span class="variable">crystal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>.EnemyCrystal();</span><br><span class="line">        crystal.checkIfVictory();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名类</p>
<p>匿名类指的是在<strong>声明一个类的同时实例化它</strong>，使代码更加简洁精练<br>通常情况下，要使用一个接口或者抽象类，都必须创建一个子类</p>
<p>有的时候，为了快速使用，直接实例化一个抽象类，并“<strong>当场</strong>”实现其抽象方法。<br>既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。<br>这样的类，叫做匿名类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    String name; <span class="comment">//姓名</span></span><br><span class="line">          </span><br><span class="line">    <span class="type">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">          </span><br><span class="line">    <span class="type">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">          </span><br><span class="line">    <span class="type">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        ADHero adh=<span class="keyword">new</span> <span class="title class_">ADHero</span>();</span><br><span class="line">        <span class="comment">//通过打印adh，可以看到adh这个对象属于ADHero类</span></span><br><span class="line">        adh.attack();</span><br><span class="line">        System.out.println(adh);</span><br><span class="line">          </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>()&#123;</span><br><span class="line">            <span class="comment">//当场实现attack方法</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;新的进攻手段&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.attack();</span><br><span class="line">        <span class="comment">//通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名</span></span><br><span class="line">          </span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地类</p>
<p>本地类可以理解为有名字的匿名类<br>内部类与匿名类不一样的是，内部类必须声明在成员的位置，即与属性和方法平等的位置。<br>本地类和匿名类一样，直接声明在代码块里面，可以是主方法，for循环里等等地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    String name; <span class="comment">//姓名</span></span><br><span class="line">          </span><br><span class="line">    <span class="type">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">          </span><br><span class="line">    <span class="type">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">          </span><br><span class="line">    <span class="type">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//与匿名类的区别在于，本地类有了自定义的类名</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">SomeHero</span> <span class="keyword">extends</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println( name+ <span class="string">&quot; 新的进攻手段&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="type">SomeHero</span> <span class="variable">h</span>  <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">SomeHero</span>();</span><br><span class="line">        h.name =<span class="string">&quot;地卜师&quot;</span>;</span><br><span class="line">        h.attack();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在匿名类中使用外部的局部变量</p>
<p>在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final</p>
<p>为什么要声明为final，其机制比较复杂，请参考第二个Hero代码中的解释</p>
<p><strong>注：</strong>在jdk8中，已经不需要强制修饰成final了，如果没有写final，不会报错，因为编译器<strong>偷偷的</strong>帮你加上了看不见的final  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//在匿名类中使用外部的局部变量damage 必须修饰为final</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">damage</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//这里使用本地类AnonymousHero来模拟匿名类的隐藏属性机制</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//事实上的匿名类，会在匿名类里声明一个damage属性，并且使用构造方法初始化该属性的值</span></span><br><span class="line">        <span class="comment">//在attack中使用的damage，真正使用的是这个内部damage，而非外部damage</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//假设外部属性不需要声明为final</span></span><br><span class="line">        <span class="comment">//那么在attack中修改damage的值，就会被暗示为修改了外部变量damage的值</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//但是他们俩是不同的变量，是不可能修改外部变量damage的</span></span><br><span class="line">        <span class="comment">//所以为了避免产生误导，外部的damage必须声明为final,&quot;看上去&quot;就不能修改了</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">AnonymousHero</span> <span class="keyword">extends</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">            <span class="type">int</span> damage;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">AnonymousHero</span><span class="params">(<span class="type">int</span> damage)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.damage = damage;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">                damage = <span class="number">10</span>;</span><br><span class="line">                System.out.printf(<span class="string">&quot;新的进攻手段，造成%d点伤害&quot;</span>,<span class="built_in">this</span>.damage );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonymousHero</span>(damage);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>  默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法</p>
<p>Mortal 这个接口，增加了一个<strong>默认方法</strong> revive，这个方法有实现体，并且被声明为了<strong>default</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mortal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">die</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">revive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本英雄复活了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141707423.png" alt="解释UML-类图"></p>
<p>带箭头的实线，表示 Spider，Cat, Fish都继承于Animal这个父类.</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141707171.png" alt="解释UML-继承关系"></p>
<p>表示 Fish实现了 Pet这个接口</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141707544.png" alt="解释UML-实现关系"></p>
<h2 id="数字与字符串"><a href="#数字与字符串" class="headerlink" title="数字与字符串"></a>数字与字符串</h2><h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h3><ol>
<li><p>数字转字符串</p>
<p>方法1： 使用String类的静态方法valueOf<br>方法2： 先把基本类型装箱为对象，然后调用对象的toString</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//方法1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//方法2</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> it.toString();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串转数字</p>
<p>调用Integer的静态方法parseInt</p>
</li>
</ol>
<h3 id="Math类常用方法"><a href="#Math类常用方法" class="headerlink" title="Math类常用方法"></a>Math类常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">5.4f</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">5.5f</span>;</span><br><span class="line">        <span class="comment">//5.4四舍五入即5</span></span><br><span class="line">        System.out.println(Math.round(f1));</span><br><span class="line">        <span class="comment">//5.5四舍五入即6</span></span><br><span class="line">        System.out.println(Math.round(f2));</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//得到一个0-1之间的随机浮点数（取不到1）</span></span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//得到一个0-10之间的随机整数 （取不到10）</span></span><br><span class="line">        System.out.println((<span class="type">int</span>)( Math.random()*<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//开方</span></span><br><span class="line">        System.out.println(Math.sqrt(<span class="number">9</span>));</span><br><span class="line">        <span class="comment">//次方（2的4次方）</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//π</span></span><br><span class="line">        System.out.println(Math.PI);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//自然常数</span></span><br><span class="line">        System.out.println(Math.E);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><ol>
<li><p>如果不使用格式化输出，就需要进行字符串连接，如果变量比较多，拼接就会显得繁琐<br>使用格式化输出，就可以简洁明了</p>
<p>%s 表示字符串<br>%d 表示数字<br>%n 表示换行</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">kill</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        String title=<span class="string">&quot;超神&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//直接使用+进行字符串连接，编码感觉会比较繁琐，并且维护性差,易读性差</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sentence</span> <span class="operator">=</span> name+ <span class="string">&quot; 在进行了连续 &quot;</span> + kill + <span class="string">&quot; 次击杀后，获得了 &quot;</span> + title +<span class="string">&quot; 的称号&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(sentence);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//使用格式化输出</span></span><br><span class="line">        <span class="comment">//%s表示字符串，%d表示数字,%n表示换行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sentenceFormat</span> <span class="operator">=</span><span class="string">&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;</span>;</span><br><span class="line">        System.out.printf(sentenceFormat,name,kill,title);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>printf和format能够达到一模一样的效果，<a target="_blank" rel="noopener" href="https://how2j.cn/k/helloworld/helloworld-eclipse-tips/300.html#step706">如何通过eclipse查看java源代码</a> 可以看到，在printf中直接调用了format</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">kill</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        String title=<span class="string">&quot;超神&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">String</span> <span class="variable">sentenceFormat</span> <span class="operator">=</span><span class="string">&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;</span>;</span><br><span class="line">        <span class="comment">//使用printf格式化输出</span></span><br><span class="line">        System.out.printf(sentenceFormat,name,kill,title);</span><br><span class="line">        <span class="comment">//使用format格式化输出</span></span><br><span class="line">        System.out.format(sentenceFormat,name,kill,title);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> <span class="number">2020</span>;</span><br><span class="line">        <span class="comment">//总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//直接打印数字</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,默认右对齐</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%8d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,左对齐</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%-8d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,不够补0</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%08d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//千位分隔符</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%,8d%n&quot;</span>,year*<span class="number">10000</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//小数点位数</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%.2f%n&quot;</span>,Math.PI);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//不同国家的千位分隔符</span></span><br><span class="line">        System.out.format(Locale.FRANCE,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">        System.out.format(Locale.US,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">        System.out.format(Locale.UK,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><ol>
<li><p>Character常见方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> character;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChar</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         </span><br><span class="line">        System.out.println(Character.isLetter(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是否为字母</span></span><br><span class="line">        System.out.println(Character.isDigit(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//判断是否为数字</span></span><br><span class="line">        System.out.println(Character.isWhitespace(<span class="string">&#x27; &#x27;</span>)); <span class="comment">//是否是空白</span></span><br><span class="line">        System.out.println(Character.isUpperCase(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//是否是大写</span></span><br><span class="line">        System.out.println(Character.isLowerCase(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//是否是小写</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//转换为大写</span></span><br><span class="line">        System.out.println(Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>)); <span class="comment">//转换为小写</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; <span class="comment">//不能够直接把一个字符转换成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> Character.toString(<span class="string">&#x27;a&#x27;</span>); <span class="comment">//转换为字符串</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见转义</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141707099.png" alt="常见转义"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> character;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChar</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用空格无法达到对齐的效果&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;abc def&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ab def&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a def&quot;</span>);</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;使用\\t制表符可以达到对齐的效果&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;abc\tdef&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ab\tdef&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a\tdef&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">&quot;一个\\t制表符长度是8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;12345678def&quot;</span>);</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;换行符 \\n&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;abc\ndef&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;单引号 \\&#x27;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;abc\&#x27;def&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;双引号 \\\&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;abc\&quot;def&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;反斜杠本身 \\&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;abc\\def&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>使用equals进行字符串内容的比较，必须大小写一致<br>equalsIgnoreCase，忽略大小写判断内容是否一致</p>
<table>
<thead>
<tr>
<th>charAt</th>
<th>获取字符</th>
<th><a target="_blank" rel="noopener" href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step712">示例代码</a></th>
</tr>
</thead>
<tbody><tr>
<td>toCharArray</td>
<td>获取对应的字符数组</td>
<td><a target="_blank" rel="noopener" href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step719">示例代码</a></td>
</tr>
<tr>
<td>subString</td>
<td>截取子字符串</td>
<td><a target="_blank" rel="noopener" href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step713">示例代码</a></td>
</tr>
<tr>
<td>split</td>
<td>分隔</td>
<td><a target="_blank" rel="noopener" href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step714">示例代码</a></td>
</tr>
<tr>
<td>trim</td>
<td>去掉首尾空格</td>
<td><a target="_blank" rel="noopener" href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step715">示例代码</a></td>
</tr>
<tr>
<td>toLowerCase toUpperCase</td>
<td>大小写</td>
<td><a target="_blank" rel="noopener" href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step716">示例代码</a></td>
</tr>
<tr>
<td>indexOf lastIndexOf contains</td>
<td>定位</td>
<td><a target="_blank" rel="noopener" href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step717">示例代码</a></td>
</tr>
<tr>
<td>replaceAll replaceFirst</td>
<td>替换</td>
<td><a target="_blank" rel="noopener" href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step718">示例代码</a></td>
</tr>
</tbody></table>
<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><table>
<thead>
<tr>
<th>append delete insert reverse</th>
<th>追加 删除 插入 反转</th>
<th><a target="_blank" rel="noopener" href="https://how2j.cn/k/number-string/number-string-stringbuilder/328.html#step723">示例代码</a></th>
</tr>
</thead>
<tbody><tr>
<td>length capacity</td>
<td>长度 容量</td>
<td><a target="_blank" rel="noopener" href="https://how2j.cn/k/number-string/number-string-stringbuilder/328.html#step724">示例代码</a></td>
</tr>
</tbody></table>
<p>为什么StringBuffer可以变长？<br>和String<strong>内部是一个字符数组</strong>一样，StringBuffer也维护了一个字符数组。 但是，这个字符数组，<strong>留有冗余长度</strong><br>比如说new StringBuffer(“the”)，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。<br>如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，<strong>看上去</strong> 数组长度就变长了 参考<a target="_blank" rel="noopener" href="https://how2j.cn/k/number-string/number-string-mystringbuilder/331.html">MyStringBuffer</a><br>length: “the”的长度 3<br>capacity: 分配的总空间 19</p>
<h1 id="JAVA中级"><a href="#JAVA中级" class="headerlink" title="JAVA中级"></a>JAVA中级</h1><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h3><ol>
<li><p>使用绝对路径或者相对路径创建File对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFile</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 绝对路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOLFolder&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;f1的绝对路径：&quot;</span> + f1.getAbsolutePath());</span><br><span class="line">        <span class="comment">// 相对路径,相对于工作目录，如果在eclipse中，就是项目目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;LOL.exe&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;f2的绝对路径：&quot;</span> + f2.getAbsolutePath());</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 把f1作为父目录创建文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(f1, <span class="string">&quot;LOL.exe&quot;</span>);</span><br><span class="line">  </span><br><span class="line">        System.out.println(<span class="string">&quot;f3的绝对路径：&quot;</span> + f3.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFile</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOLFolder/LOL.exe&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前文件是：&quot;</span> +f);</span><br><span class="line">        <span class="comment">//文件是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断是否存在：&quot;</span>+f.exists());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//是否是文件夹</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断是否是文件夹：&quot;</span>+f.isDirectory());</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//是否是文件（非文件夹）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断是否是文件：&quot;</span>+f.isFile());</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//文件长度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取文件的长度：&quot;</span>+f.length());</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//文件最后修改时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> f.lastModified();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取文件的最后修改时间：&quot;</span>+d);</span><br><span class="line">        <span class="comment">//设置文件修改时间为1970.1.1 08:00:00</span></span><br><span class="line">        f.setLastModified(<span class="number">0</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//文件重命名</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOLFolder/DOTA.exe&quot;</span>);</span><br><span class="line">        f.renameTo(f2);</span><br><span class="line">        System.out.println(<span class="string">&quot;把LOL.exe改名成了DOTA.exe&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">&quot;注意： 需要在D:\\LOLFolder确实存在一个LOL.exe,\r\n才可以看到对应的文件长度、修改时间等信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">############################################################### </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFile</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOLFolder/skin/garen.ski&quot;</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</span></span><br><span class="line">        f.list();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</span></span><br><span class="line">        File[]fs= f.listFiles();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 以字符串形式返回获取所在文件夹</span></span><br><span class="line">        f.getParent();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 以文件形式返回获取所在文件夹</span></span><br><span class="line">        f.getParentFile();</span><br><span class="line">        <span class="comment">// 创建文件夹，如果父文件夹skin不存在，创建就无效</span></span><br><span class="line">        f.mkdir();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 创建文件夹，如果父文件夹skin不存在，就会创建父文件夹</span></span><br><span class="line">        f.mkdirs();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 创建一个空文件,如果父文件夹skin不存在，就会抛出异常</span></span><br><span class="line">        f.createNewFile();</span><br><span class="line">        <span class="comment">// 所以创建一个空文件之前，通常都会创建父目录</span></span><br><span class="line">        f.getParentFile().mkdirs();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 列出所有的盘符c: d: e: 等等</span></span><br><span class="line">        f.listRoots();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 刪除文件</span></span><br><span class="line">        f.delete();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// JVM结束的时候，刪除文件，常用于临时文件的删除</span></span><br><span class="line">        f.deleteOnExit();</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="JAVA的流"><a href="#JAVA的流" class="headerlink" title="JAVA的流"></a>JAVA的流</h3><p>什么是流</p>
<p>当不同的介质之间有数据交互的时候，JAVA就使用流来实现。<br>数据源可以是文件，还可以是数据库，网络甚至是其他的程序</p>
<p>比如读取文件的数据到程序中，站在程序的角度来看，就叫做输入流.</p>
<p>文件输入流，这个流可以用来把数据从硬盘的文件，读取到JVM(内存)，输出流则相反。</p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul>
<li>InputStream是字节输入流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。FileInputStream 是InputStream子类，以FileInputStream 为例进行文件读取</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//准备文件lol.txt其中的内容是AB，对应的ASCII分别是65 66</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//创建基于文件的输入流</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            <span class="comment">//创建字节数组，其长度就是文件的长度</span></span><br><span class="line">            <span class="type">byte</span>[] all =<span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">            <span class="comment">//以字节流的形式读取文件所有内容</span></span><br><span class="line">            fis.read(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">byte</span> b : all) &#123;</span><br><span class="line">                <span class="comment">//打印出来是65 66</span></span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//每次使用完流，都应该进行关闭</span></span><br><span class="line">            fis.close();</span><br><span class="line">              </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>OutputStream是字节输出流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。FileOutputStream 是OutputStream子类，以FileOutputStream 为例向文件写出数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 准备文件lol2.txt其中的内容是空的</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol2.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 准备长度是2的字节数组，用88,89初始化，其对应的字符分别是X,Y</span></span><br><span class="line">            <span class="type">byte</span> data[] = &#123; <span class="number">88</span>, <span class="number">89</span> &#125;;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 创建基于文件的输出流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">            <span class="comment">// 把数据写入到输出流</span></span><br><span class="line">            fos.write(data);</span><br><span class="line">            <span class="comment">// 关闭输出流</span></span><br><span class="line">            fos.close();</span><br><span class="line">             </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关闭流的方式"><a href="#关闭流的方式" class="headerlink" title="关闭流的方式"></a>关闭流的方式</h3><ul>
<li><p>在try中关闭</p>
<p>在try的作用域里关闭文件输入流，在前面的示例中都是使用这种方式，这样做有一个弊端；<br>如果文件不存在，或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患。 <strong>不推荐</strong>使用</p>
</li>
<li><p>在finally中关闭</p>
<p>这是标准的关闭流的方式</p>
<ol>
<li>首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally.</li>
<li>在finally关闭之前，要先判断该引用是否为空</li>
<li>关闭的时候，需要再一次进行try catch处理</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            <span class="type">byte</span>[] all = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">            fis.read(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">byte</span> b : all) &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 在finally 里关闭流</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != fis)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用try()的方式</p>
<p>把流定义在try()里,try,catch或者finally结束的时候，会自动关闭<br>这种编写代码的方式叫做 <strong>try-with-resources</strong>， 这是从JDK7开始支持的技术</p>
<p>所有的流，都实现了一个接口叫做 <strong>AutoCloseable</strong>，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//把流定义在try()里,try,catch或者finally结束的时候，会自动关闭</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f)) &#123;</span><br><span class="line">            <span class="type">byte</span>[] all = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">            fis.read(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">byte</span> b : all) &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul>
<li>Reader字符输入流：FileReader 是Reader子类，以FileReader 为例进行文件读取</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备文件lol.txt其中的内容是AB</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建基于文件的Reader</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(f)) &#123;</span><br><span class="line">            <span class="comment">// 创建字符数组，其长度就是文件的长度</span></span><br><span class="line">            <span class="type">char</span>[] all = <span class="keyword">new</span> <span class="title class_">char</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">            <span class="comment">// 以字符流的形式读取文件所有内容</span></span><br><span class="line">            fr.read(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> b : all) &#123;</span><br><span class="line">                <span class="comment">// 打印出来是A B</span></span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Writer字符输出流：FileWriter 是Writer的子类，以FileWriter 为例把字符串写入到文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备文件lol2.txt</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol2.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建基于文件的Writer</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f)) &#123;</span><br><span class="line">            <span class="comment">// 以字符流的形式把数据写入到文件中</span></span><br><span class="line">            String data=<span class="string">&quot;abcdefg1234567890&quot;</span>;</span><br><span class="line">            <span class="type">char</span>[] cs = data.toCharArray();</span><br><span class="line">            fr.write(cs);</span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>专门用于字符的形式读取和写入数据</li>
</ul>
<h3 id="I-x2F-O中文问题"><a href="#I-x2F-O中文问题" class="headerlink" title="I&#x2F;O中文问题"></a>I&#x2F;O中文问题</h3><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141707402.png" alt="编码概念"></p>
<p>工作后经常接触的编码方式有如下几种：</p>
<ul>
<li><strong>ISO-8859-1 ASCII</strong> 数字和西欧字母</li>
<li><strong>GBK GB2312 BIG5</strong> 中文</li>
<li><strong>UNICODE</strong> (统一码，万国码)</li>
</ul>
<p>其中</p>
<ul>
<li>ISO-8859-1 包含 ASCII</li>
<li>GB2312 是简体中文，BIG5是繁体中文，GBK同时包含简体和繁体以及日文。</li>
<li>UNICODE 包括了所有的文字，无论中文，英文，藏文，法文，世界所有的文字都包含其中</li>
</ul>
<p><strong>UNICODE和UTF</strong></p>
<p>根据前面的学习，我们了解到不同的编码方式对应不同的<strong>棋盘</strong>，而UNICODE因为要存放所有的数据，那么它的棋盘是最大的。<br>不仅如此，棋盘里每个数字都是很长的(4个字节)，因为不仅要表示字母，还要表示汉字等。</p>
<p>如果完全按照UNICODE的方式来存储数据，就会有很大的浪费。<br>比如在ISO-8859-1中，<strong>a</strong> 字符对应的数字是0x61<br>而UNICODE中对应的数字是 0x00000061，倘若一篇文章大部分都是英文字母，那么按照UNICODE的方式进行数据保存就会消耗很多空间</p>
<p>在这种情况下，就出现了UNICODE的各种<strong>减肥</strong>子编码, 比如UTF-8对数字和字母就使用一个字节，而对汉字就使用3个字节，从而达到了<strong>减肥还能保证健康</strong>的效果</p>
<p>UTF-8，UTF-16和UTF-32 针对不同类型的数据有不同的<strong>减肥效果</strong>，一般说来UTF-8是比较常用的方式</p>
<p>UTF-8，UTF-16和UTF-32 彼此的区别在此不作赘述，有兴趣的可以参考 <a target="_blank" rel="noopener" href="http://baike.baidu.com/link?url=ty4mEX5hSfK2xAyPO8N2zgxTibBE59CShSb5yFxbVkBun_QVz65llOPEXOepgPeqe3AQDLt6LLjTayn6tioS4_#4">unicode-百度百科</a></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141707777.png" alt="UNICODE和UTF"></p>
<p><strong>Java采用的是Unicode</strong></p>
<p>写在.java源代码中的汉字，在执行之后，都会变成JVM中的字符。<br>而这些中文字符采用的编码方式，都是使用UNICODE. “中”字对应的UNICODE是<strong>4E2D</strong>,所以在内存中，实际保存的数据就是十六进制的0x4E2D, 也就是十进制的20013。</p>
<p>以字符 <strong>中</strong> 为例，查看其在不同编码方式下的值是多少</p>
<p>也即在不同的<strong>棋盘上的位置</strong></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141707084.png" alt="一个汉字使用不同编码方式的表现"></p>
<p><strong>用FileInputStream 字节流正确读取中文</strong></p>
<p>为了能够正确的读取中文内容</p>
<ol>
<li>必须了解文本是以哪种编码方式保存字符的</li>
<li>使用字节流读取了文本后，再使用对应的<strong>编码方式去识别这些数字</strong>，得到正确的字符<br>如本例，一个文件中的内容是字符<strong>中</strong>，编码方式是GBK，那么读出来的数据一定是D6D0。<br>再使用GBK编码方式识别D6D0，就能正确的得到字符<strong>中</strong></li>
</ol>
<p><strong>注：</strong> 在GBK的棋盘上找到的<strong>中</strong>字后，JVM会自动找到<strong>中</strong>在UNICODE这个棋盘上对应的数字，并且以<a target="_blank" rel="noopener" href="https://how2j.cn/k/io/io-encoding/695.html#step2486">UNICODE上的数字保存在内存中</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:\\project\\j2sc\\test.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f))&#123;</span><br><span class="line">            Byte[] bytes = <span class="keyword">new</span> <span class="title class_">Byte</span>[(<span class="type">int</span>)fis.length()];</span><br><span class="line">            fis.read(f);</span><br><span class="line">            System.out.println(<span class="string">&quot;读出来的数据为：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">byte</span> i : bytes)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b&amp;<span class="number">0x000000ff</span>;<span class="comment">//只取16进制的后俩位</span></span><br><span class="line">                System.out.print(Integer.toHexString(i));<span class="comment">//转换为16进制</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;把这个数字，放在GBK的棋盘上去：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141707926.png" alt="用FileInputStream 字节流正确读取中文"></p>
<p><strong>用FileReader 字符流正确读取中文</strong></p>
<p>FileReader得到的是字符，所以一定是已经把字节<strong>根据某种编码识别成了字符</strong>了<br>而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBK<br>FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替，像这样：<code>new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;))</code>;<br>在本例中，用记事本另存为UTF-8格式，然后用UTF-8就能识别对应的中文了。</p>
<p><strong>解释：</strong> 为什么中字前面有一个?<br>如果是使用记事本另存为UTF-8的格式，那么在第一个字节有一个<strong>标示符</strong>，叫做BOM用来标志这个文件是用UTF-8来编码的。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141707556.png" alt="用FileReader 字符流正确读取中文"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException, FileNotFoundException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\project\\j2se\\src\\test.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;默认编码方式:&quot;</span>+Charset.defaultCharset());</span><br><span class="line">        <span class="comment">//FileReader得到的是字符，所以一定是已经把字节根据某种编码识别成了字符了</span></span><br><span class="line">        <span class="comment">//而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBK</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(f)) &#123;</span><br><span class="line">            <span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">            fr.read(cs);</span><br><span class="line">            System.out.printf(<span class="string">&quot;FileReader会使用默认的编码方式%s,识别出来的字符是：%n&quot;</span>,Charset.defaultCharset());</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(cs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替</span></span><br><span class="line">        <span class="comment">//并且使用new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;)); 这样的形式</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f),Charset.forName(<span class="string">&quot;UTF-8&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">            isr.read(cs);</span><br><span class="line">            System.out.printf(<span class="string">&quot;InputStreamReader 指定编码方式UTF-8,识别出来的字符是：%n&quot;</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(cs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存流"><a href="#缓存流" class="headerlink" title="缓存流"></a>缓存流</h3><p>以介质是硬盘为例，<strong>字节流和字符流的弊端</strong>：<br>在每一次读写的时候，都会访问硬盘。 如果读写的频率比较高的时候，其性能表现不佳。</p>
<p>为了解决以上弊端，采用缓存流。<br>缓存流在读取的时候，<strong>会一次性读较多的数据到缓存中</strong>，以后每一次的读取，都是在缓存中访问，直到缓存中的数据读取完毕，再到硬盘中读取。</p>
<p>就好比吃饭，<strong>不用缓存就是每吃一口都到锅里去铲</strong>。<strong>用缓存就是先把饭盛到碗里</strong>，碗里的吃完了，再到锅里去铲</p>
<p>缓存流在写入数据的时候，会先把数据写入到缓存区，直到缓存区<strong>达到一定的量</strong>，才把这些数据，<strong>一起写入到硬盘中去</strong>。按照这种操作模式，就不会像字节流，字符流那样<strong>每写一个字节都访问硬盘</strong>，从而减少了IO操作。</p>
<ul>
<li>使用缓存流读取数据——缓存字符输入流 BufferedReader 可以一次读取一行数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备文件lol.txt其中的内容是</span></span><br><span class="line">        <span class="comment">// garen kill teemo</span></span><br><span class="line">        <span class="comment">// teemo revive after 1 minutes</span></span><br><span class="line">        <span class="comment">// teemo try to garen, but killed again</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建文件字符流</span></span><br><span class="line">        <span class="comment">// 缓存流必须建立在一个存在的流的基础上</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(f);</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">            )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 一次读一行</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == line)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用缓存流写出数据——PrintWriter 缓存字符输出流， 可以一次写出一行数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向文件lol2.txt中写入三行语句</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol2.txt&quot;</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建文件字符流</span></span><br><span class="line">                <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f);</span><br><span class="line">                <span class="comment">// 缓存流必须建立在一个存在的流的基础上              </span></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(fw);              </span><br><span class="line">        ) &#123;</span><br><span class="line">            pw.println(<span class="string">&quot;garen kill teemo&quot;</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;teemo revive after 1 minutes&quot;</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;teemo try to garen, but killed again&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>flush——有的时候，需要<strong>立即把数据写入到硬盘</strong>，而不是等缓存满了才写出去。 这时候就需要用到flush</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//向文件lol2.txt中写入三行语句</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol2.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//创建文件字符流</span></span><br><span class="line">        <span class="comment">//缓存流必须建立在一个存在的流的基础上</span></span><br><span class="line">        <span class="keyword">try</span>(<span class="type">FileWriter</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f);<span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(fr);) &#123;</span><br><span class="line">            pw.println(<span class="string">&quot;garen kill teemo&quot;</span>);</span><br><span class="line">            <span class="comment">//强制把缓存中的数据写入硬盘，无论缓存是否已满</span></span><br><span class="line">                pw.flush();           </span><br><span class="line">            pw.println(<span class="string">&quot;teemo revive after 1 minutes&quot;</span>);</span><br><span class="line">                pw.flush();</span><br><span class="line">            pw.println(<span class="string">&quot;teemo try to garen, but killed again&quot;</span>);</span><br><span class="line">                pw.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>DataInputStream 数据输入流；DataOutputStream 数据输出流；</p>
<p>使用数据流的<strong>writeUTF()和readUTF()</strong> 可以进行数据的<strong>格式化顺序读写</strong><br>如本例，通过DataOutputStream 向文件顺序写出 布尔值，整数和字符串。 然后再通过DataInputStream 顺序读入这些数据。</p>
<p><strong>注：</strong> 要用DataInputStream 读取一个文件，这个文件必须是由DataOutputStream 写出的，否则会出现EOFException，因为DataOutputStream 在写出的时候会做一些特殊标记，只有DataInputStream 才能成功的读取。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141707369.png" alt="直接进行字符串的读写"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        write();</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">FileInputStream</span> <span class="variable">fis</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">                <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fis);</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="type">boolean</span> b= dis.readBoolean();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">             </span><br><span class="line">            System.out.println(<span class="string">&quot;读取到布尔值:&quot;</span>+b);</span><br><span class="line">            System.out.println(<span class="string">&quot;读取到整数:&quot;</span>+i);</span><br><span class="line">            System.out.println(<span class="string">&quot;读取到字符串:&quot;</span>+str);</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">fos</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">                <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fos);</span><br><span class="line">        )&#123;</span><br><span class="line">            dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">            dos.writeInt(<span class="number">300</span>);</span><br><span class="line">            dos.writeUTF(<span class="string">&quot;123 this is gareen&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><p>对象流指的是可以直接<strong>把一个对象以流的形式</strong>传输给其他的介质，比如硬盘</p>
<p>一个对象以流的形式进行传输，叫做序列化。 该对象所对应的类，必须是实现Serializable接口</p>
<p>例：创建一个Hero对象，设置其名称为garen。把该对象序列化到一个文件garen.lol。然后再通过序列化把该文件转换为一个Hero对象。</p>
<p><strong>注：</strong>把一个对象序列化有一个前提是：这个对象的类，必须实现了Serializable接口。</p>
<p>TestStream.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Hero garen</span></span><br><span class="line">        <span class="comment">//要把Hero对象直接保存在文件上，务必让Hero类实现Serializable接口</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        h.name = <span class="string">&quot;garen&quot;</span>;</span><br><span class="line">        h.hp = <span class="number">616</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//准备一个文件用于保存该对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/garen.lol&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">//创建对象输出流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">            <span class="comment">//创建对象输入流              </span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        ) &#123;</span><br><span class="line">            oos.writeObject(h);</span><br><span class="line">            <span class="type">Hero</span> <span class="variable">h2</span> <span class="operator">=</span> (Hero) ois.readObject();</span><br><span class="line">            System.out.println(h2.name);</span><br><span class="line">            System.out.println(h2.hp);</span><br><span class="line">               </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hero.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="I-x2F-O-System-in"><a href="#I-x2F-O-System-in" class="headerlink" title="I&#x2F;O System.in"></a>I&#x2F;O System.in</h3><p><code>System.out</code> 是常用的在控制台输出数据的。<br><code>System.in</code> 可以从控制台输入数据。</p>
<p><strong>System.in</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 控制台输入</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> System.in;) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 敲入a,然后敲回车可以看到</span></span><br><span class="line">                <span class="comment">// 97 13 10</span></span><br><span class="line">                <span class="comment">// 97是a的ASCII码</span></span><br><span class="line">                <span class="comment">// 13 10分别对应回车换行</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> is.read();</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Scanner读取字符串</strong></p>
<p>使用System.in.read虽然可以读取数据，但是很不方便<br>使用Scanner就可以逐行读取了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         </span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> s.nextLine();</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Scanner从控制台读取整数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(s.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line">            System.out.println(<span class="string">&quot;读取到的数字：&quot;</span>+ i );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>如果要存放多个对象，可以使用数组，但是数组有局限性；比如 声明长度是10的数组；不用的数组就浪费了；超过10的个数，又放不下。</p>
<p>为了解决数组的局限性，引入容器类的概念。 最常见的容器类就是<code>ArrayList</code><br><a target="_blank" rel="noopener" href="https://how2j.cn/k/number-string/number-string-stringbuilder/328.html#step724">容器的容量</a>“capacity”会随着对象的增加，自动增长，只需要不断往容器里增加英雄即可，不用担心会出现数组的边界问题。</p>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">简介</th>
<th align="left">示例代码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">add</td>
<td align="left">增加</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2453">示例代码</a></td>
</tr>
<tr>
<td align="left">contains</td>
<td align="left">判断是否存在</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2454">示例代码</a></td>
</tr>
<tr>
<td align="left">get</td>
<td align="left">获取指定位置的对象</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2455">示例代码</a></td>
</tr>
<tr>
<td align="left">indexOf</td>
<td align="left">获取对象所处的位置</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2456">示例代码</a></td>
</tr>
<tr>
<td align="left">remove</td>
<td align="left">删除</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2457">示例代码</a></td>
</tr>
<tr>
<td align="left">set</td>
<td align="left">替换</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2458">示例代码</a></td>
</tr>
<tr>
<td align="left">size</td>
<td align="left">获取大小</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2459">示例代码</a></td>
</tr>
<tr>
<td align="left">toArray</td>
<td align="left">转换为数组</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2460">示例代码</a></td>
</tr>
<tr>
<td align="left">addAll</td>
<td align="left">把另一个容器所有对象都加进来</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2461">示例代码</a></td>
</tr>
<tr>
<td align="left">clear</td>
<td align="left">清空</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2462">示例代码</a></td>
</tr>
</tbody></table>
<h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p>ArrayList实现了接口List<br>常见的写法会把引用声明为接口List类型<br>注意：是<strong>java.util.List</strong>,而<strong>不是</strong>java.awt.List</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//ArrayList实现了接口List</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//常见的写法会把引用声明为接口List类型</span></span><br><span class="line">        <span class="comment">//注意：是java.util.List,而不是java.awt.List</span></span><br><span class="line">        <span class="comment">//接口引用指向子类对象（多态）</span></span><br><span class="line">         </span><br><span class="line">        <span class="type">List</span> <span class="variable">heros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        heros.add( <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;盖伦&quot;</span>));</span><br><span class="line">        System.out.println(heros.size());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">简介</th>
<th align="left">示例代码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">for</td>
<td align="left">用for循环遍历</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-iterator/688.html#step2469">示例代码</a></td>
</tr>
<tr>
<td align="left">iterator</td>
<td align="left">迭代器遍历</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-iterator/688.html#step806">示例代码</a></td>
</tr>
<tr>
<td align="left">for:</td>
<td align="left">用增强型for循环</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-iterator/688.html#step2470">示例代码</a></td>
</tr>
</tbody></table>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>序列分先进先出FIFO,先进后出FILO<br>FIFO在Java中又叫Queue 队列<br>FILO在Java中又叫Stack 栈</p>
<p>与<a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-method/685.html">ArrayList</a>一样，LinkedList也实现了List接口，诸如add,remove,contains等等方法。 详细使用，请参考 <a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-method/685.html">ArrayList 常用方法</a>，在此不作赘述。</p>
<p>接下来要讲的是LinkedList的一些特别的地方</p>
<h4 id="双向链表-Deque"><a href="#双向链表-Deque" class="headerlink" title="双向链表 - Deque"></a>双向链表 - Deque</h4><p>除了实现了List接口外，LinkedList还实现了<strong>双向链表结构</strong>Deque，可以很方便的在头尾插入删除数据。</p>
<p>什么是链表结构: 与数组结构相比较，数组结构，就好像是电影院，每个位置都有标示，每个位置之间的间隔都是一样的。 而链表就相当于佛珠，每个珠子，只连接前一个和后一个，不用关心除此之外的其他佛珠在哪里。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141707271.png" alt="双向链表 - Deque"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//LinkedList是一个双向链表结构的list</span></span><br><span class="line">        LinkedList&lt;Hero&gt; ll =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Hero&gt;();</span><br><span class="line">        <span class="comment">//所以可以很方便的在头部和尾部插入数据</span></span><br><span class="line">        <span class="comment">//在最后插入新的英雄</span></span><br><span class="line">        ll.addLast(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero1&quot;</span>));</span><br><span class="line">        ll.addLast(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero2&quot;</span>));</span><br><span class="line">        ll.addLast(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero3&quot;</span>));</span><br><span class="line">        System.out.println(ll);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//在最前面插入新的英雄</span></span><br><span class="line">        ll.addFirst(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;heroX&quot;</span>));</span><br><span class="line">        System.out.println(ll);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//查看最前面的英雄</span></span><br><span class="line">        System.out.println(ll.getFirst());</span><br><span class="line">        <span class="comment">//查看最后面的英雄</span></span><br><span class="line">        System.out.println(ll.getLast());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//查看不会导致英雄被删除</span></span><br><span class="line">        System.out.println(ll);</span><br><span class="line">        <span class="comment">//取出最前面的英雄</span></span><br><span class="line">        System.out.println(ll.removeFirst());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//取出最后面的英雄</span></span><br><span class="line">        System.out.println(ll.removeLast());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//取出会导致英雄被删除</span></span><br><span class="line">        System.out.println(ll);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 - Queue"></a>队列 - Queue</h4><p>LinkedList 除了实现了List和Deque外，还实现了<strong>Queue</strong>接口(队列)。</p>
<p>Queue是先进先出队列 <strong>FIFO</strong>，常用方法：</p>
<ul>
<li><strong>offer</strong> 在最后添加元素</li>
<li><strong>poll</strong> 取出第一个元素</li>
<li><strong>peek</strong> 查看第一个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//和ArrayList一样，LinkedList也实现了List接口</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">ll</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Hero&gt;();</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//所不同的是LinkedList还实现了Deque，进而又实现了Queue这个接口</span></span><br><span class="line">        <span class="comment">//Queue代表FIFO 先进先出的队列</span></span><br><span class="line">        Queue&lt;Hero&gt; q= <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Hero&gt;();</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//加在队列的最后面</span></span><br><span class="line">        System.out.print(<span class="string">&quot;初始化队列：\t&quot;</span>);</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;Hero1&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;Hero2&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;Hero3&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;Hero4&quot;</span>));</span><br><span class="line">          </span><br><span class="line">        System.out.println(q);</span><br><span class="line">        System.out.print(<span class="string">&quot;把第一个元素取poll()出来:\t&quot;</span>);</span><br><span class="line">        <span class="comment">//取出第一个Hero，FIFO 先进先出</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        System.out.println(h);</span><br><span class="line">        System.out.print(<span class="string">&quot;取出第一个元素之后的队列:\t&quot;</span>);</span><br><span class="line">        System.out.println(q);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//把第一个拿出来看一看，但是不取出来</span></span><br><span class="line">        h=q.peek();</span><br><span class="line">        System.out.print(<span class="string">&quot;查看peek()第一个元素:\t&quot;</span>);</span><br><span class="line">        System.out.println(h);</span><br><span class="line">        System.out.print(<span class="string">&quot;查看并不会导致第一个元素被取出来:\t&quot;</span>);</span><br><span class="line">        System.out.println(q);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList与LinkedList区别"><a href="#ArrayList与LinkedList区别" class="headerlink" title="ArrayList与LinkedList区别"></a>ArrayList与LinkedList区别</h3><ul>
<li><strong>是否保证线程安全</strong>：都是非同步，线程不安全</li>
<li><strong>底层数据结构</strong>：ArrayList底层数据结构为Object数组，LinkedList底层数据结构为双向链表。</li>
<li>ArrayList支持快速查询。</li>
<li><strong>插入和删除是否受元素位置的影响</strong>：<ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</li>
<li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），时间复杂度为 O(1)。</li>
</ul>
</li>
<li><strong>内存空间占用</strong>：<code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h4><p>二叉树由各种<strong>节点</strong>组成<br>二叉树特点：<br>每个节点都可以有<strong>左子</strong>节点，<strong>右子</strong>节点<br>每一个节点都有一个<strong>值</strong></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708456.png" alt="二叉树概念"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node leftNode;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node rightNode;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">public</span> Object value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树排序-插入数据"><a href="#二叉树排序-插入数据" class="headerlink" title="二叉树排序-插入数据"></a>二叉树排序-插入数据</h4><p>假设通过二叉树对如下10个随机数进行排序<br>67,7,30,73,10,0,78,81,10,74<br>排序的第一个步骤是把数据插入到该二叉树中<br>插入基本逻辑是，<strong>小、相同的放左边</strong>，<strong>大的放右边</strong></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708424.png" alt="二叉树排序-插入数据"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node leftNode;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node rightNode;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">public</span> Object value;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 插入 数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object v)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点没有值，就把数据放在当前节点上</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == value)</span><br><span class="line">            value = v;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 如果当前节点有值，就进行判断，新增的值与当前值的大小关系</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新增的值，比当前值小或者相同</span></span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> ((Integer) v -((Integer)value) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == leftNode)</span><br><span class="line">                    leftNode = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                leftNode.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新增的值，比当前值大</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == rightNode)</span><br><span class="line">                    rightNode = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                rightNode.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span> randoms[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">67</span>, <span class="number">7</span>, <span class="number">30</span>, <span class="number">73</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">81</span>, <span class="number">10</span>, <span class="number">74</span> &#125;;</span><br><span class="line">  </span><br><span class="line">        <span class="type">Node</span> <span class="variable">roots</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> number : randoms) &#123;</span><br><span class="line">            roots.add(number);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树排序-遍历"><a href="#二叉树排序-遍历" class="headerlink" title="二叉树排序-遍历"></a>二叉树排序-遍历</h4><p>通过上一个步骤的插入行为，实际上，数据就已经排好序了。 接下来要做的是看，把<strong>这些已经排好序的数据</strong>，遍历成我们常用的List或者数组的形式</p>
<p>二叉树的遍历分左序，中序，右序<br><strong>左序</strong>即： 中间的数遍历后放在<strong>左边</strong><br><strong>中序</strong>即： 中间的数遍历后放在<strong>中间</strong><br><strong>右序</strong>即： 中间的数遍历后放在<strong>右边</strong><br>如图所见，我们希望遍历后的结果是从小到大的，所以应该采用<strong>中序遍历</strong></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708350.png" alt="二叉树排序-遍历"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node leftNode;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node rightNode;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">public</span> Object value;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 插入 数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object v)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点没有值，就把数据放在当前节点上</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == value)</span><br><span class="line">            value = v;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 如果当前节点有值，就进行判断，新增的值与当前值的大小关系</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新增的值，比当前值小或者相同</span></span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> ((Integer) v -((Integer)value) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == leftNode)</span><br><span class="line">                    leftNode = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                leftNode.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新增的值，比当前值大</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == rightNode)</span><br><span class="line">                    rightNode = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                rightNode.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 中序遍历所有的节点</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Object&gt; values = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 左节点的遍历结果</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != leftNode)</span><br><span class="line">            values.addAll(leftNode.values());</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 当前节点</span></span><br><span class="line">        values.add(value);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 右节点的遍历结果</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != rightNode)</span><br><span class="line">  </span><br><span class="line">            values.addAll(rightNode.values());</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span> randoms[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">67</span>, <span class="number">7</span>, <span class="number">30</span>, <span class="number">73</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">81</span>, <span class="number">10</span>, <span class="number">74</span> &#125;;</span><br><span class="line">  </span><br><span class="line">        <span class="type">Node</span> <span class="variable">roots</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> number : randoms) &#123;</span><br><span class="line">            roots.add(number);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        System.out.println(roots.values());</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote>
<p>HashMap储存数据的方式是—— 键值对</p>
<p>对于HashMap而言，key是唯一的，不可以重复的。<br>所以，以相同的key 把不同的value插入到 Map中会导致旧元素被覆盖，只留下最后插入的元素。<br>不过，同一个对象可以作为值插入到map中，只要对应的key不一样</p>
</blockquote>
<h4 id="hashMap和hashTable的区别"><a href="#hashMap和hashTable的区别" class="headerlink" title="hashMap和hashTable的区别"></a>hashMap和hashTable的区别</h4><ul>
<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><blockquote>
<p>元素不能重复</p>
<p>Set中的元素，没有顺序。严格的说，是没有按照元素的插入顺序排列。HashSet的具体顺序，既不是按照插入顺序，也不是按照hashcode的顺序。</p>
</blockquote>
<table>
<thead>
<tr>
<th><code>HashMap</code></th>
<th><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td>实现了 <code>Map</code> 接口</td>
<td>实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用 <code>put()</code>向 map 中添加元素</td>
<td>调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Set不提供get方法来获取指定位置的元素</span></span><br><span class="line">        <span class="comment">//numbers.get(0)</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//遍历Set可以采用迭代器iterator</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;Integer&gt; iterator = numbers.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer) iterator.next();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//或者采用增强型for循环</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : numbers) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashSet和HashMap的关系"><a href="#HashSet和HashMap的关系" class="headerlink" title="HashSet和HashMap的关系"></a>HashSet和HashMap的关系</h4><blockquote>
<p>通过观察HashSet的源代码<br>可以发现HashSet自身并没有独立的实现，而是在里面封装了一个Map.<br>HashSet是作为Map的key而存在的<br>而value是一个命名为PRESENT的static的Object对象，因为是一个类属性，所以只会有一个。</p>
<p>private static final Object PRESENT &#x3D; new Object();</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//HashSet里封装了一个HashMap</span></span><br><span class="line">    <span class="keyword">private</span>  HashMap&lt;E,Object&gt; map;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//HashSet的构造方法初始化这个HashMap</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//向HashSet中增加元素，其实就是把该元素作为key，增加到Map中</span></span><br><span class="line">    <span class="comment">//value是PRESENT，静态，final的对象，所有的HashSet都使用这么同一个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//HashSet的size就是map的size</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//清空Set就是清空Map</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//迭代Set,就是把Map的键拿出来迭代</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><blockquote>
<p>Collection是 Set List Queue和 Deque的接口<br>Queue: 先进先出队列<br>Deque: 双向链表</p>
<p><strong>注：</strong>Collection和Map之间没有关系，Collection是放一个一个对象的，Map 是放键值对的<br><strong>注：</strong>Deque 继承 Queue,间接的继承了 Collection</p>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708324.png" alt="Collection"></p>
<h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>Collections是一个类，容器的工具类,就如同Arrays是数组的工具类。</p>
<table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">简介</th>
<th align="left">示例代码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">reverse</td>
<td align="left">反转</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-collections/369.html#step2498">示例代码</a></td>
</tr>
<tr>
<td align="left">shuffle</td>
<td align="left">混淆</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-collections/369.html#step2501">示例代码</a></td>
</tr>
<tr>
<td align="left">sort</td>
<td align="left">排序</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-collections/369.html#step2499">示例代码</a></td>
</tr>
<tr>
<td align="left">swap</td>
<td align="left">交换</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-collections/369.html#step2500">示例代码</a></td>
</tr>
<tr>
<td align="left">rotate</td>
<td align="left">滚动</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-collections/369.html#step2497">示例代码</a></td>
</tr>
<tr>
<td align="left">synchronizedList</td>
<td align="left">线程安全化</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-collections/369.html#step2502">示例代码</a></td>
</tr>
</tbody></table>
<ul>
<li><strong>shuffle</strong> 混淆List中数据的顺序</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708032.png" alt="混淆"></p>
<ul>
<li><strong>rotate</strong> 把List中的数据，向右滚动指定单位的长度</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708456.png" alt="滚动"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化集合numbers</span></span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">&quot;集合中的数据:&quot;</span>);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">        Collections.rotate(numbers,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;把集合向右滚动2个单位，标的数据后，集合中的数据:&quot;</span>);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>synchronizedList</strong> 把非线程安全的List转换为线程安全的List。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;把非线程安全的List转换为线程安全的List&quot;</span>);</span><br><span class="line">        List&lt;Integer&gt; synchronizedNumbers = (List&lt;Integer&gt;) Collections.synchronizedList(numbers);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h3><h4 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h4><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>
<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708560.png" alt="jdk1.8 之前的内部结构-HashMap"></p>
<h4 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h4><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708868.png" alt="jdk1.8之后的内部结构-HashMap"></p>
<blockquote>
<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
</blockquote>
<p>我们来结合源码分析一下 <code>HashMap</code> 链表到红黑树的转换。</p>
<p><strong>1、 <code>putVal</code> 方法中执行链表转红黑树的判断逻辑。</strong></p>
<p>链表的长度大于 8 的时候，就执行 <code>treeifyBin</code> （转换红黑树）的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">    <span class="comment">// 遍历到链表最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            <span class="comment">// 红黑树转换（并不会直接转换成红黑树）</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    p = e;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>2、<code>treeifyBin</code> 方法中判断是否真的转换为红黑树。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 判断当前数组的长度是否小于 64</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">// 如果当前数组的长度小于 64，那么会选择先进行数组扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 否则才将列表转换为红黑树</span></span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树。</p>
<h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><h4 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h4><p>例：假设Hero有三个属性 name,hp,damage<br>一个集合中放存放10个Hero,通过Collections.sort对这10个进行排序<br>那么<strong>到底是hp小的放前面？还是damage小的放前面？</strong>Collections.sort也无法确定<br>所以要指定到底按照哪种属性进行排序<br>这里就需要提供一个Comparator给定如何进行两个对象之间的<strong>大小</strong>比较</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708012.png" alt="Comparator"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero [name=&quot;</span> + name + <span class="string">&quot;, hp=&quot;</span> + hp + <span class="string">&quot;, damage=&quot;</span> + damage + <span class="string">&quot;]\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name, <span class="type">int</span> hp, <span class="type">int</span> damage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.hp = hp;</span><br><span class="line">        <span class="built_in">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Hero&gt;();</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//通过随机值实例化hero的hp和damage</span></span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span>+ i, r.nextInt(<span class="number">100</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化后的集合：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//直接调用sort会出现编译错误，因为Hero有各种属性</span></span><br><span class="line">        <span class="comment">//到底按照哪种属性进行比较，Collections也不知道，不确定，所以没法排</span></span><br><span class="line">        <span class="comment">//Collections.sort(heros);</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//引入Comparator，指定比较的算法</span></span><br><span class="line">        Comparator&lt;Hero&gt; c = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Hero&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Hero h1, Hero h2)</span> &#123;</span><br><span class="line">                <span class="comment">//按照hp进行排序</span></span><br><span class="line">                <span class="keyword">if</span>(h1.hp&gt;=h2.hp)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//正数表示h1比h2要大</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Collections.sort(heros,c);</span><br><span class="line">        System.out.println(<span class="string">&quot;按照血量排序后的集合：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h4><p>例：使Hero类实现Comparable接口<br>在类里面提供比较算法<br>Collections.sort就有足够的信息进行排序了，也无需额外提供比较器Comparator<br><strong>注：</strong> 如果返回-1, 就表示当前的更小，否则就是更大</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708190.png" alt="Comparable"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Hero&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span>&#123;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name =name;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//初始化name,hp,damage的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name,<span class="type">float</span> hp, <span class="type">int</span> damage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name =name;</span><br><span class="line">        <span class="built_in">this</span>.hp = hp;</span><br><span class="line">        <span class="built_in">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Hero anotherHero)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(damage&lt;anotherHero.damage)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero [name=&quot;</span> + name + <span class="string">&quot;, hp=&quot;</span> + hp + <span class="string">&quot;, damage=&quot;</span> + damage + <span class="string">&quot;]\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Hero&gt;();</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//通过随机值实例化hero的hp和damage</span></span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span>+ i, r.nextInt(<span class="number">100</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;初始化后的集合&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//Hero类实现了接口Comparable，即自带比较信息。</span></span><br><span class="line">        <span class="comment">//Collections直接进行排序，无需额外的Comparator</span></span><br><span class="line">        Collections.sort(heros);</span><br><span class="line">        System.out.println(<span class="string">&quot;按照伤害高低排序后的集合&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>JDK8之后，引入了对集合的聚合操作，可以非常容易的遍历，筛选，比较集合中的元素。</p>
<p>像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span>heros</span><br><span class="line">          .stream()</span><br><span class="line">          .sorted((h1,h2)-&gt;h1.hp&gt;h2.hp?-<span class="number">1</span>:<span class="number">1</span>)</span><br><span class="line">          .skip(<span class="number">2</span>)</span><br><span class="line">          .map(h-&gt;h.getName())</span><br><span class="line">          .findFirst()</span><br><span class="line">          .get();</span><br></pre></td></tr></table></figure>

<p>但是要用好聚合，必须先掌握Lambda表达式。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708429.png" alt="聚合操作 "></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAggregate</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Hero&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;初始化集合后的数据 (最后一个数据重复)：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//传统方式</span></span><br><span class="line">        Collections.sort(heros,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Hero&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Hero o1, Hero o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">int</span>) (o2.hp-o1.hp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">hero</span> <span class="operator">=</span> heros.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;通过传统方式找出来的hp第三高的英雄名称是:&quot;</span> + hero.name);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//聚合方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span>heros</span><br><span class="line">            .stream()</span><br><span class="line">            .sorted((h1,h2)-&gt;h1.hp&gt;h2.hp?-<span class="number">1</span>:<span class="number">1</span>)</span><br><span class="line">            .skip(<span class="number">2</span>)</span><br><span class="line">            .map(h-&gt;h.getName())</span><br><span class="line">            .findFirst()</span><br><span class="line">            .get();</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;通过聚合操作找出来的hp第三高的英雄名称是:&quot;</span> + name);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><h4 id="extends"><a href="#extends" class="headerlink" title="? extends"></a>? extends</h4><p><code>ArrayList heroList&lt;? extends Hero&gt;</code>表示这是一个Hero泛型或者其子类泛型<br>heroList 的泛型可能是Hero<br>heroList 的泛型可能是APHero<br>heroList 的泛型可能是ADHero<br>所以 可以确凿的是，<strong>从heroList取出来的对象，一定是可以转型成Hero的</strong></p>
<p>但是，不能往里面放东西，因为<br>放APHero就不满足<ADHero><br>放ADHero又不满足<APHero></APHero></ADHero></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708728.png" alt="? extends"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGeneric</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        ArrayList&lt;APHero&gt; apHeroList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;APHero&gt;();</span><br><span class="line">        apHeroList.add(<span class="keyword">new</span> <span class="title class_">APHero</span>());</span><br><span class="line">         </span><br><span class="line">        ArrayList&lt;? <span class="keyword">extends</span> <span class="title class_">Hero</span>&gt; heroList = apHeroList;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//? extends Hero 表示这是一个Hero泛型的子类泛型</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//heroList 的泛型可以是Hero</span></span><br><span class="line">        <span class="comment">//heroList 的泛型可以使APHero</span></span><br><span class="line">        <span class="comment">//heroList 的泛型可以使ADHero</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的</span></span><br><span class="line">          </span><br><span class="line">        Hero h= heroList.get(<span class="number">0</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//但是，不能往里面放东西</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> <span class="title class_">ADHero</span>()); <span class="comment">//编译错误，因为heroList的泛型 有可能是APHero</span></span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="super"><a href="#super" class="headerlink" title="? super"></a>? super</h4><p><code>ArrayList heroList&lt;? super Hero&gt; </code>表示这是一个Hero泛型或者其父类泛型<br>heroList的泛型可能是Hero<br>heroList的泛型可能是Object</p>
<p><strong>可以往里面插入Hero以及Hero的子类</strong><br>但是取出来有风险，因为不确定取出来是Hero还是Object</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708302.png" alt="? super"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGeneric</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        ArrayList&lt;? <span class="built_in">super</span> Hero&gt; heroList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//? super Hero 表示 heroList的泛型是Hero或者其父类泛型</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//heroList 的泛型可以是Hero</span></span><br><span class="line">        <span class="comment">//heroList 的泛型可以是Object</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//所以就可以插入Hero</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> <span class="title class_">Hero</span>());</span><br><span class="line">        <span class="comment">//也可以插入Hero的子类</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> <span class="title class_">APHero</span>());</span><br><span class="line">        heroList.add(<span class="keyword">new</span> <span class="title class_">ADHero</span>());</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//但是，不能从里面取数据出来,因为其泛型可能是Object,而Object强转Hero会失败</span></span><br><span class="line">        Hero h= heroList.get(<span class="number">0</span>);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符?"></a>泛型通配符?</h4><p>泛型通配符? 代表任意泛型<br>既然?代表任意泛型，那么换句话说，这个容器什么泛型都有可能</p>
<p>所以只能以Object的形式取出来<br>并且不能往里面放对象，因为不知道到底是一个什么泛型的容器</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708441.png" alt="泛型通配符?"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGeneric</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        ArrayList&lt;APHero&gt; apHeroList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;APHero&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//?泛型通配符，表示任意泛型</span></span><br><span class="line">        ArrayList&lt;?&gt; generalList = apHeroList;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//?的缺陷1： 既然?代表任意泛型，那么换句话说，你就不知道这个容器里面是什么类型</span></span><br><span class="line">        <span class="comment">//所以只能以Object的形式取出来</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> generalList.get(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//?的缺陷2： 既然?代表任意泛型，那么既有可能是Hero,也有可能是Item</span></span><br><span class="line">        <span class="comment">//所以，放哪种对象进去，都有风险，结果就什么什么类型的对象，都不能放进去</span></span><br><span class="line">        generalList.add(<span class="keyword">new</span> <span class="title class_">Item</span>()); <span class="comment">//编译错误 因为?代表任意泛型，很有可能不是Item</span></span><br><span class="line">        generalList.add(<span class="keyword">new</span> <span class="title class_">Hero</span>()); <span class="comment">//编译错误 因为?代表任意泛型，很有可能不是Hero</span></span><br><span class="line">        generalList.add(<span class="keyword">new</span> <span class="title class_">APHero</span>()); <span class="comment">//编译错误  因为?代表任意泛型，很有可能不是APHero</span></span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>如果希望只取出，不插入，就使用? extends Hero（只读不写）</strong><br><strong>如果希望只插入，不取出，就使用? super Hero（只写不读）</strong><br><strong>如果希望，又能插入，又能取出，就不要用通配符？，? extends</strong></p>
<h3 id="泛型转型"><a href="#泛型转型" class="headerlink" title="泛型转型"></a>泛型转型</h3><p><strong>子类泛型转父类泛型和父类泛型转父类泛型都不可以</strong></p>
<p>例：<br>hs的泛型是父类Hero<br>adhs 的泛型是子类ADHero</p>
<p>那么 把adhs转换为hs能成功吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGeneric</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Hero&gt; hs =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ADHero&gt; adhs =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//子类泛型转父类泛型</span></span><br><span class="line">        hs = adhs;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设可以转型成功<br>引用hs指向了ADHero泛型的容器<br>作为Hero泛型的引用hs, 看上去是可以往里面加一个APHero的。<br>但是hs这个引用，实际上是指向的一个ADHero泛型的容器<br>如果能加进去，就变成了ADHero泛型的容器里放进了APHero，这就矛盾了</p>
<p>所以子类泛型<strong>不可以</strong>转换为父类泛型</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141708800.png" alt="假设可以转型成功"></p>
<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><h3 id="匿名类方式"><a href="#匿名类方式" class="headerlink" title="匿名类方式"></a>匿名类方式</h3><p>首先准备一个接口HeroChecker，提供一个test(Hero)方法<br>然后通过匿名类的方式，实现这个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">HeroChecker</span> <span class="variable">checker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroChecker</span>() &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Hero h)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>与<a target="_blank" rel="noopener" href="https://how2j.cn/k/interface-inheritance/interface-inheritance-inner-class/322.html#step687">匿名类</a> 概念相比较，<br>Lambda 其实就是<strong>匿名方法</strong>，这是一种<strong>把方法作为参数</strong>进行传递的编程思想。</p>
<p>虽然代码是这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter(heros, h -&gt; h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>但是，Java会在背后，悄悄的，把这些都还原成<a target="_blank" rel="noopener" href="https://how2j.cn/k/lambda/lambda-lamdba-tutorials/697.html#step2552">匿名类方式</a>。<br>引入Lambda表达式，会使得代码更加紧凑，而不是各种接口和匿名类到处飞。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>lambda 表达式的语法格式如下：</p>
<p>(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }</p>
<p>以下是lambda表达式的重要特征:</p>
<ul>
<li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li>
<li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li>
<li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</li>
</ul>
<h3 id="Lambda-表达式实例"><a href="#Lambda-表达式实例" class="headerlink" title="Lambda 表达式实例"></a>Lambda 表达式实例</h3><p>Lambda 表达式的简单例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 类型声明</span></span><br><span class="line">      <span class="type">MathOperation</span> <span class="variable">addition</span> <span class="operator">=</span> (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; a + b;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 不用类型声明</span></span><br><span class="line">      <span class="type">MathOperation</span> <span class="variable">subtraction</span> <span class="operator">=</span> (a, b) -&gt; a - b;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 大括号中的返回语句</span></span><br><span class="line">      <span class="type">MathOperation</span> <span class="variable">multiplication</span> <span class="operator">=</span> (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 没有大括号及返回语句</span></span><br><span class="line">      <span class="type">MathOperation</span> <span class="variable">division</span> <span class="operator">=</span> (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; a / b;</span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, addition));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, subtraction));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 x 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, multiplication));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 / 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, division));</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 不用括号</span></span><br><span class="line">      <span class="type">GreetingService</span> <span class="variable">greetService1</span> <span class="operator">=</span> message -&gt;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 用括号</span></span><br><span class="line">      <span class="type">GreetingService</span> <span class="variable">greetService2</span> <span class="operator">=</span> (message) -&gt;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">        </span><br><span class="line">      greetService1.sayMessage(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">      greetService2.sayMessage(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">interface</span> <span class="title class_">MathOperation</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="title function_">operation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">interface</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">(String message)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, MathOperation mathOperation)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mathOperation.operation(a, b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line"><span class="number">10</span> + <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"><span class="number">10</span> - <span class="number">5</span> = <span class="number">5</span></span><br><span class="line"><span class="number">10</span> x <span class="number">5</span> = <span class="number">50</span></span><br><span class="line"><span class="number">10</span> / <span class="number">5</span> = <span class="number">2</span></span><br><span class="line">Hello Runoob</span><br><span class="line">Hello Google</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 Lambda 表达式需要注意以下两点：</p>
<ul>
<li>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。</li>
<li>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</li>
</ul>
</blockquote>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p>
<p>在 Java8Tester.java 文件输入以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">salutation</span> <span class="operator">=</span> <span class="string">&quot;Hello! &quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">GreetingService</span> <span class="variable">greetService1</span> <span class="operator">=</span> message -&gt; </span><br><span class="line">      System.out.println(salutation + message);</span><br><span class="line">      greetService1.sayMessage(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">interface</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">(String message)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));</span><br><span class="line">s.convert(<span class="number">2</span>);</span><br><span class="line">num = <span class="number">5</span>;  </span><br><span class="line"><span class="comment">//报错信息：Local variable num defined in an enclosing scope must be final or effectively </span></span><br><span class="line"> <span class="keyword">final</span></span><br></pre></td></tr></table></figure>

<p><strong>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length());  <span class="comment">//编译会出错 </span></span><br></pre></td></tr></table></figure>

<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。</p>
<ul>
<li><p>方法引用通过方法的名字来指向一个方法。</p>
</li>
<li><p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>
</li>
<li><p>方法引用使用一对冒号 <code>::</code></p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141709629.png" alt="在这里插入图片描述"></p>
<h4 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">//Supplier是jdk1.8的接口，这里和lamda一起使用了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> Supplier&lt;Car&gt; supplier)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">collide</span><span class="params">(<span class="keyword">final</span> Car car)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Collided &quot;</span> + car.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="keyword">final</span> Car another)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Following the &quot;</span> + another.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">repair</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Repaired &quot;</span> + <span class="built_in">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>构造器引用：</strong>它的语法是<code>Class::new</code>，或者更一般的Class&lt; T &gt;::new实例如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> Car.create( Car::<span class="keyword">new</span> ); </span><br><span class="line"><span class="keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>静态方法引用：</strong>它的语法是<code>Class::static_method</code>，实例如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意事项：</span></span><br><span class="line"><span class="comment">// 1.collide方法是静态的</span></span><br><span class="line"><span class="comment">// 2.参数列表与 collide(T o1) 参数列表保持一致</span></span><br><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特定类的任意对象的方法引用(对象方法引用)：</strong>它的语法是Class::method实例如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意事项：</span></span><br><span class="line"><span class="comment">// 1.repair方法是非静态的，方法由对象调用</span></span><br><span class="line"><span class="comment">// 2.参数列表与 repair参数列表保持一致</span></span><br><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特定对象的方法引用(实例方法引用)：</strong>它的语法是instance::method实例如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意事项：</span></span><br><span class="line"><span class="comment">// 1.follow方法是非静态的</span></span><br><span class="line"><span class="comment">// 2.follow(T o1) 参数列表中的第一个参数在follow方法中被省略（参数 o1 默认为调用者本身）</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Car</span> <span class="variable">police</span> <span class="operator">=</span> Car.create( Car::<span class="keyword">new</span> ); </span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure>

<h3 id="聚合操作-1"><a href="#聚合操作-1" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>遍历数据的传统方式就是使用for循环，然后条件判断，最后打印出满足条件的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Hero h : heros) &#123;</span><br><span class="line">   <span class="keyword">if</span> (h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>)</span><br><span class="line">	     System.out.println(h.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用聚合操作方式，<strong>画风</strong>就发生了变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">heros</span><br><span class="line">	.stream()</span><br><span class="line">	.filter(h -&gt; h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>)</span><br><span class="line">	.forEach(h -&gt; System.out.println(h.name));</span><br></pre></td></tr></table></figure>

<h4 id="Stream和管道的概念"><a href="#Stream和管道的概念" class="headerlink" title="Stream和管道的概念"></a>Stream和管道的概念</h4><p>要了解聚合操作，首先要建立<strong>Stream</strong>和<strong>管道</strong>的概念<br><strong>Stream</strong> 和Collection结构化的数据不一样，Stream是一系列的元素，就像是生产线上的罐头一样，一串串的出来。<br><strong>管道</strong>指的是一系列的聚合操作。</p>
<p>管道又分3个部分</p>
<ul>
<li><strong>管道源</strong>：在这个例子里，源是一个List</li>
<li><strong>中间操作</strong>： 每个中间操作，又会返回一个Stream，比如.filter()又返回一个Stream, 中间操作是“懒”操作，并不会真正进行遍历。</li>
<li><strong>结束操作</strong>：当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。 结束操作不会返回Stream，但是会返回int、float、String、 Collection或者像forEach，什么都不返回, 结束操作才进行真正的遍历行为，在遍历的时候，才会去进行中间操作的相关判断</li>
</ul>
<p><strong>注：</strong> 这个Stream和I&#x2F;O章节的InputStream,OutputStream是不一样的概念。</p>
<h4 id="管道源"><a href="#管道源" class="headerlink" title="管道源"></a>管道源</h4><p>把Collection切换成管道源很简单，调用stream()就行了。<code>heros.stream()</code></p>
<p>但是数组却没有stream()方法，需要使用<code>Arrays.stream(hs)</code>或者<code>Stream.of(hs)</code></p>
<h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><p>每个中间操作，又会返回一个Stream，比如.filter()又返回一个Stream, 中间操作是“懒”操作，并不会真正进行遍历。</p>
<p>中间操作比较多，主要分两类</p>
<p>对元素进行筛选 和 转换为其他形式的流</p>
<p><strong>对元素进行筛选：</strong></p>
<ul>
<li><code>filter</code> 匹配</li>
<li><code>distinct</code> 去除重复(根据equals判断)</li>
<li><code>sorted</code> 自然排序</li>
<li><code>sorted(Comparator&lt;T&gt;)</code> 指定排序</li>
<li><code>limit</code> 保留</li>
<li><code>skip </code>忽略</li>
</ul>
<p><strong>转换为其他形式的流</strong></p>
<ul>
<li><code>mapToDouble</code> 转换为double的流</li>
<li><code>map</code> 转换为任意类型的流</li>
</ul>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Hero&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span>&#123;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getHp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHp</span><span class="params">(<span class="type">float</span> hp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDamage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> damage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDamage</span><span class="params">(<span class="type">int</span> damage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name =name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化name,hp,damage的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name,<span class="type">float</span> hp, <span class="type">int</span> damage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name =name;</span><br><span class="line">        <span class="built_in">this</span>.hp = hp;</span><br><span class="line">        <span class="built_in">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Hero anotherHero)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(damage&lt;anotherHero.damage)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero [name=&quot;</span> + name + <span class="string">&quot;, hp=&quot;</span> + hp + <span class="string">&quot;, damage=&quot;</span> + damage + <span class="string">&quot;]\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAggregate</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Hero&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//制造一个重复数据</span></span><br><span class="line">        heros.add(heros.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化集合后的数据 (最后一个数据重复)：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(<span class="string">&quot;满足条件hp&gt;100&amp;&amp;damage&lt;50的数据&quot;</span>);</span><br><span class="line">          </span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(h-&gt;h.hp&gt;<span class="number">100</span>&amp;&amp;h.damage&lt;<span class="number">50</span>)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;去除重复的数据，去除标准是看equals&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .distinct()</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">        System.out.println(<span class="string">&quot;按照血量排序&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .sorted((h1,h2)-&gt;h1.hp&gt;=h2.hp?<span class="number">1</span>:-<span class="number">1</span>)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;保留3个&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .limit(<span class="number">3</span>)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;忽略前3个&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .skip(<span class="number">3</span>)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;转换为double的Stream&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .mapToDouble(Hero::getHp)</span><br><span class="line">            .forEach(h-&gt;System.out.println(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;转换任意类型的Stream&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .map((h)-&gt; h.name + <span class="string">&quot; - &quot;</span> + h.hp + <span class="string">&quot; - &quot;</span> + h.damage)</span><br><span class="line">            .forEach(h-&gt;System.out.println(h));</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结束操作"><a href="#结束操作" class="headerlink" title="结束操作"></a>结束操作</h4><p>当进行结束操作后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。 结束操作不会返回Stream，但是会返回int、float、String、 Collection或者像forEach，什么都不返回,。</p>
<p>结束操作才真正进行遍历行为，前面的中间操作也在这个时候，才真正的执行。</p>
<p>常见结束操作如下：</p>
<ul>
<li><strong>forEach()</strong> 遍历每个元素</li>
<li><strong>toArray()</strong> 转换为数组</li>
<li><strong>min(Comparator<T>)</T></strong> 取最小的元素</li>
<li><strong>max(Comparator<T>)</T></strong> 取最大的元素</li>
<li><strong>count()</strong> 总数</li>
<li><strong>findFirst()</strong> 第一个元素</li>
</ul>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAggregate</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Hero&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;遍历集合中的每个数据&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">        System.out.println(<span class="string">&quot;返回一个数组&quot;</span>);</span><br><span class="line">        Object[] hs= heros</span><br><span class="line">            .stream()</span><br><span class="line">            .toArray();</span><br><span class="line">        System.out.println(Arrays.toString(hs));</span><br><span class="line">        System.out.println(<span class="string">&quot;返回伤害最低的那个英雄&quot;</span>);</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">minDamageHero</span> <span class="operator">=</span></span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .min((h1,h2)-&gt;h1.damage-h2.damage)</span><br><span class="line">            .get();</span><br><span class="line">        System.out.print(minDamageHero);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回伤害最高的那个英雄&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">mxnDamageHero</span> <span class="operator">=</span></span><br><span class="line">                heros</span><br><span class="line">                .stream()</span><br><span class="line">                .max((h1,h2)-&gt;h1.damage-h2.damage)</span><br><span class="line">                .get();</span><br><span class="line">        System.out.print(mxnDamageHero);     </span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">&quot;流中数据的总数&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> heros</span><br><span class="line">                .stream()</span><br><span class="line">                .count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;第一个英雄&quot;</span>);</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">firstHero</span> <span class="operator">=</span></span><br><span class="line">                heros</span><br><span class="line">                .stream()</span><br><span class="line">                .findFirst()</span><br><span class="line">                .get();</span><br><span class="line">         </span><br><span class="line">        System.out.println(firstHero);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程即在同一时间，可以做多件事情。</p>
<p>创建多线程有3种方式，分别是继承线程类，实现Runnable接口，匿名类。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141709310.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p>
<p>首先要理解进程(Processor)和线程(Thread)的区别<br><strong>进程：</strong>启动一个LOL.exe就叫一个进程。 接着又启动一个DOTA.exe，这叫两个进程。<br><strong>线程：</strong>线程是在进程内部同时做的事情，比如在LOL里，有很多事情要同时做，比如”盖伦” 击杀“提莫”，<strong>同时</strong>“赏金猎人”又在击杀“盲僧”，这就是由多线程来实现的。</p>
<h3 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h3><h4 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h4><p>使用多线程，就可以做到盖伦在攻击提莫的<strong>同时</strong>，赏金猎人也在攻击盲僧<br>设计一个类KillThread <strong>继承Thread</strong>，<strong>并且重写run方法</strong><br>启动线程办法： 实例化一个KillThread对象，并且调用其<strong>start</strong>方法<br>就可以观察到 赏金猎人攻击盲僧的<strong>同时</strong>，盖伦也在攻击提莫</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KillThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> Hero h1;</span><br><span class="line">    <span class="keyword">private</span> Hero h2;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KillThread</span><span class="params">(Hero h1, Hero h2)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.h1 = h1;</span><br><span class="line">        <span class="built_in">this</span>.h2 = h2;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!h2.isDead())&#123;</span><br><span class="line">            h1.attackHero(h2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">        gareen.damage = <span class="number">50</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">300</span>;</span><br><span class="line">        teemo.damage = <span class="number">30</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">500</span>;</span><br><span class="line">        bh.damage = <span class="number">65</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">455</span>;</span><br><span class="line">        leesin.damage = <span class="number">80</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">KillThread</span> <span class="variable">killThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KillThread</span>(gareen,teemo);</span><br><span class="line">        killThread1.start();</span><br><span class="line">        <span class="type">KillThread</span> <span class="variable">killThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KillThread</span>(bh,leesin);</span><br><span class="line">        killThread2.start();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141709543.png" alt="创建多线程-继承线程类"></p>
<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><p>创建类Battle，实现Runnable接口<br>启动的时候，首先创建一个Battle对象，然后再根据该battle对象创建一个线程对象，并启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Battle</span> <span class="variable">battle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Battle</span>(gareen,teemo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(battle1).start();</span><br></pre></td></tr></table></figure>

<p> battle1 对象实现了Runnable接口，所以有run方法，但是直接调用run方法，并不会启动一个新的线程。<br>必须，借助一个线程对象的start()方法，才会启动一个新的线程。<br>所以，在创建Thread对象的时候，把battle1作为构造方法的参数传递进去，这个线程启动的时候，就会去执行battle1.run()方法了。</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Battle</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> Hero h1;</span><br><span class="line">    <span class="keyword">private</span> Hero h2;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Battle</span><span class="params">(Hero h1, Hero h2)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.h1 = h1;</span><br><span class="line">        <span class="built_in">this</span>.h2 = h2;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!h2.isDead())&#123;</span><br><span class="line">            h1.attackHero(h2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">        gareen.damage = <span class="number">50</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">300</span>;</span><br><span class="line">        teemo.damage = <span class="number">30</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">500</span>;</span><br><span class="line">        bh.damage = <span class="number">65</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">455</span>;</span><br><span class="line">        leesin.damage = <span class="number">80</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Battle</span> <span class="variable">battle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Battle</span>(gareen,teemo);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(battle1).start();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Battle</span> <span class="variable">battle2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Battle</span>(bh,leesin);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(battle2).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h4><p>使用<a target="_blank" rel="noopener" href="https://how2j.cn/k/interface-inheritance/interface-inheritance-inner-class/322.html#step687">匿名类</a>，继承Thread,重写run方法，直接在run方法中写业务代码<br>匿名类的一个好处是可以很方便的访问外部的局部变量。<br>前提是外部的局部变量需要被声明为final。(JDK7以后就不需要了)</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">        gareen.damage = <span class="number">50</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">300</span>;</span><br><span class="line">        teemo.damage = <span class="number">30</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">500</span>;</span><br><span class="line">        bh.damage = <span class="number">65</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">455</span>;</span><br><span class="line">        leesin.damage = <span class="number">80</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//匿名类</span></span><br><span class="line">        Thread t1= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//匿名类中用到外部的局部变量teemo，必须把teemo声明为final</span></span><br><span class="line">                <span class="comment">//但是在JDK7以后，就不是必须加final的了</span></span><br><span class="line">                <span class="keyword">while</span>(!teemo.isDead())&#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">         </span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// lambda形式</span></span><br><span class="line">        Thread t2= <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(!leesin.isDead())&#123;</span><br><span class="line">                bh.attackHero(leesin);      </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见线程方法"><a href="#常见线程方法" class="headerlink" title="常见线程方法"></a>常见线程方法</h3><table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">简介</th>
<th align="left">示例代码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sleep</td>
<td align="left">当前线程暂停</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-methods/354.html#step781">示例代码</a></td>
</tr>
<tr>
<td align="left">join</td>
<td align="left">加入到当前线程中</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-methods/354.html#step782">示例代码</a></td>
</tr>
<tr>
<td align="left">setPriority</td>
<td align="left">线程优先级</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-methods/354.html#step783">示例代码</a></td>
</tr>
<tr>
<td align="left">yield</td>
<td align="left">临时暂停</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-methods/354.html#step784">示例代码</a></td>
</tr>
<tr>
<td align="left">setDaemon</td>
<td align="left">守护线程</td>
<td align="left"><a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-methods/354.html#step2403">示例代码</a></td>
</tr>
</tbody></table>
<h4 id="join-加入到当前线程中"><a href="#join-加入到当前线程中" class="headerlink" title="join 加入到当前线程中"></a>join 加入到当前线程中</h4><p>首先解释一下<strong>主线程</strong>的概念<br>所有进程，至少会有一个线程即主线程，即main方法开始执行，就会有一个<strong>看不见</strong>的主线程存在。<br>在42行执行t.join，即表明<strong>在主线程中加入该线程</strong>。<br>主线程会等待该线程结束完毕， 才会往下运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">        gareen.damage = <span class="number">50</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">300</span>;</span><br><span class="line">        teemo.damage = <span class="number">30</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">500</span>;</span><br><span class="line">        bh.damage = <span class="number">65</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">455</span>;</span><br><span class="line">        leesin.damage = <span class="number">80</span>;</span><br><span class="line">          </span><br><span class="line">        Thread t1= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!teemo.isDead())&#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        t1.start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//代码执行到这里，一直是main线程在运行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//t1线程加入到main线程中来，只有t1线程运行结束，才会继续往下走</span></span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Thread t2= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!leesin.isDead())&#123;</span><br><span class="line">                    bh.attackHero(leesin);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//会观察到盖伦把提莫杀掉后，才运行t2线程</span></span><br><span class="line">        t2.start();</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="setPriority-线程优先级"><a href="#setPriority-线程优先级" class="headerlink" title="setPriority 线程优先级"></a>setPriority 线程优先级</h4><p>当线程处于竞争关系的时候，优先级高的线程会有更大的几率获得CPU资源<br>为了演示该效果，要把暂停时间去掉，多条线程各自会尽力去占有CPU资源<br>同时把英雄的血量增加100倍，攻击减低到1，才有足够的时间观察到优先级的演示<br>如图可见，线程1的优先级是MAX_PRIORITY，所以它争取到了更多的CPU资源执行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackHero</span><span class="params">(Hero h)</span> &#123;</span><br><span class="line">        <span class="comment">//把暂停时间去掉，多条线程各自会尽力去占有CPU资源</span></span><br><span class="line">        <span class="comment">//线程的优先级效果才可以看得出来</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//           </span></span><br><span class="line"><span class="comment">//            Thread.sleep(0);</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            // TODO Auto-generated catch block</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        h.hp-=damage;</span><br><span class="line">        System.out.format(<span class="string">&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;</span>,name,h.name,h.name,h.hp);</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span>(h.isDead())</span><br><span class="line">            System.out.println(h.name +<span class="string">&quot;死了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>&gt;=hp?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">6160</span>;</span><br><span class="line">        gareen.damage = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">3000</span>;</span><br><span class="line">        teemo.damage = <span class="number">1</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">5000</span>;</span><br><span class="line">        bh.damage = <span class="number">1</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">4505</span>;</span><br><span class="line">        leesin.damage = <span class="number">1</span>;</span><br><span class="line">          </span><br><span class="line">        Thread t1= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">while</span>(!teemo.isDead())&#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        Thread t2= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!leesin.isDead())&#123;</span><br><span class="line">                    bh.attackHero(leesin);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">         </span><br><span class="line">        t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="setDaemon-守护线程"><a href="#setDaemon-守护线程" class="headerlink" title="setDaemon 守护线程"></a>setDaemon 守护线程</h4><p>守护线程的概念是： 当一个进程里，所有的线程都是守护线程的时候，结束当前进程。</p>
<p>就好像一个公司有销售部，生产部这些和业务挂钩的部门。<br>除此之外，还有后勤，行政等这些支持部门。</p>
<p>如果一家公司销售部，生产部都解散了，那么只剩下后勤和行政，那么这家公司也可以解散了。</p>
<p>守护线程就相当于那些支持部门，如果一个进程只剩下守护线程，那么进程就会自动结束。</p>
<p>守护线程通常会被用来做日志，性能统计等工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        Thread t1= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">seconds</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;已经玩了LOL %d 秒%n&quot;</span>, seconds++);</span><br><span class="line">                     </span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141709506.png" alt="JMM(Java 内存模型)"></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141709636.png" alt="JMM(Java 内存模型)强制在主存中进行读取"></p>
<p><code>volatile</code> 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p>
<h4 id="如何禁止指令重排序？"><a href="#如何禁止指令重排序？" class="headerlink" title="如何禁止指令重排序？"></a>如何禁止指令重排序？</h4><p><strong>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p>
<p>在 Java 中，<code>Unsafe</code> 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>理论上来说，你通过这个三个方法也可以实现和<code>volatile</code>禁止重排序一样的效果，只是会麻烦一些。</p>
<p>下面我以一个常见的面试题为例讲解一下 <code>volatile</code> 关键字禁止指令重排序的效果。</p>
<p><strong>双重校验锁实现对象单例（线程安全）</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p>
<h4 id="volatile-可以保证原子性么"><a href="#volatile-可以保证原子性么" class="headerlink" title="volatile 可以保证原子性么"></a>volatile 可以保证原子性么</h4><p><strong><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p>
<p>我们通过下面的代码即可证明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatoleAtomicityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatoleAtomicityDemo</span> <span class="variable">volatoleAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatoleAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatoleAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待1.5秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>正常情况下，运行上面的代码理应输出 <code>2500</code>。但你真正运行了上面的代码之后，你会发现每次输出结果都小于 <code>2500</code>。</p>
<p>为什么会出现这种情况呢？不是说好了，<code>volatile</code> 可以保证变量的可见性嘛！</p>
<p>也就是说，如果 <code>volatile</code> 能保证 <code>inc++</code> 操作的原子性的话。每个线程中对 <code>inc</code> 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5*500&#x3D;2500。</p>
<p>但是<code>inc++</code>不是原子操作，实际上，<code>inc++</code> 其实是一个复合操作，包括三步：</p>
<ol>
<li>读取 inc 的值。</li>
<li>对 inc 加 1。</li>
<li>将 inc 的值写回内存。</li>
</ol>
<p><code>volatile</code> 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现：</p>
<ol>
<li>线程 1 对 <code>inc</code> 进行读取操作之后，还未对其进行修改。线程 2 又读取了 <code>inc</code>的值并对其进行修改（+1），再将<code>inc</code> 的值写回内存。</li>
<li>线程 2 操作完毕后，线程 1 对 <code>inc</code>的值进行修改（+1），再将<code>inc</code> 的值写回内存。</li>
</ol>
<p>这也就导致两个线程分别对 <code>inc</code> 进行了一次自增操作后，<code>inc</code> 实际上只增加了 1。</p>
<p>其实，如果想要保证上面的代码运行正确也非常简单，利用 <code>synchronized</code> 、<code>Lock</code>或者<code>AtomicInteger</code>都可以。</p>
<p>使用 <code>synchronized</code> 改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc++;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>使用 <code>AtomicInteger</code> 改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">AtomicInteger</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc.getAndIncrement();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>使用 <code>ReentrantLock</code> 改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>多线程的同步问题指的是多个线程同时修改一个数据的时候，可能导致的问题，多线程的问题，又叫<strong>Concurrency</strong> 问题。</p>
<h4 id="synchronized-同步对象概念"><a href="#synchronized-同步对象概念" class="headerlink" title="synchronized 同步对象概念"></a>synchronized 同步对象概念</h4><p>解决上述问题之前，先理解<strong>synchronized</strong>关键字的意义<br>如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">someObject</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (someObject)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//此处的代码只有占有了someObject后才可以执行</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized表示当前线程，独占 对象 someObject</strong><br>当前线程<strong>独占</strong> 了对象someObject，如果有<strong>其他线程****试图占有对象</strong>someObject，<strong>就会等待</strong>，直到当前线程释放对someObject的占用。<br>someObject 又叫同步对象，所有的对象，都可以作为同步对象<br>为了达到同步的效果，必须使用同一个同步对象</p>
<p><strong>释放同步对象</strong>的方式： synchronized 块自然结束，或者有异常抛出</p>
<h4 id="synchronized-和-volatile-的区别？"><a href="#synchronized-和-volatile-的区别？" class="headerlink" title="synchronized 和 volatile 的区别？"></a>synchronized 和 volatile 的区别？</h4><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li>
<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h4 id="使用synchronized-解决同步问题"><a href="#使用synchronized-解决同步问题" class="headerlink" title="使用synchronized 解决同步问题"></a>使用synchronized 解决同步问题</h4><p>所有需要修改hp的地方，有要<strong>建立在占有someObject的基础上</strong>。<br>而对象 someObject在同一时间，只能被一个线程占有。 间接地，<strong>导致同一时间，hp只能被一个线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">someObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">10000</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">  </span><br><span class="line">        Thread[] addThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[n];</span><br><span class="line">        Thread[] reduceThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[n];</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                     </span><br><span class="line">                    <span class="comment">//任何线程要修改hp的值，必须先占用someObject</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (someObject) &#123;</span><br><span class="line">                        gareen.recover();</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            addThreads[i] = t;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    <span class="comment">//任何线程要修改hp的值，必须先占用someObject</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (someObject) &#123;</span><br><span class="line">                        gareen.hurt();</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            reduceThreads[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待所有增加线程结束</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : addThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待所有减少线程结束</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : reduceThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        System.out.printf(<span class="string">&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n&quot;</span>, n,n,gareen.hp);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用hero对象作为同步对象（同步代码块）"><a href="#使用hero对象作为同步对象（同步代码块）" class="headerlink" title="使用hero对象作为同步对象（同步代码块）"></a>使用hero对象作为同步对象（同步代码块）</h4><p>既然任意对象都可以用来作为同步对象，而所有的线程访问的都是同一个hero对象，<strong>索性就使用gareen来作为同步对象</strong><br>进一步的，对于Hero的hurt方法，加上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表示当前对象为同步对象，即也是gareen为同步对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//回血</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">()</span>&#123;</span><br><span class="line">        hp=hp+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//掉血</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hurt</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//使用this作为同步对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            hp=hp-<span class="number">1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>&gt;=hp?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">10000</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">  </span><br><span class="line">        Thread[] addThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[n];</span><br><span class="line">        Thread[] reduceThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[n];</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                     </span><br><span class="line">                    <span class="comment">//使用gareen作为synchronized</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (gareen) &#123;</span><br><span class="line">                        gareen.recover();</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            addThreads[i] = t;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    <span class="comment">//使用gareen作为synchronized</span></span><br><span class="line">                    <span class="comment">//在方法hurt中有synchronized(this)</span></span><br><span class="line">                    gareen.hurt();</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            reduceThreads[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (Thread t : addThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : reduceThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        System.out.printf(<span class="string">&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n&quot;</span>, n,n,gareen.hp);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><p>在recover前，直接加上synchronized ，其所对应的同步对象，就是this<br>和hurt方法达到的效果是一样<br>外部线程访问gareen的方法，就不需要额外使用synchronized 了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//回血</span></span><br><span class="line">    <span class="comment">//直接在方法前加上修饰符synchronized</span></span><br><span class="line">    <span class="comment">//其所对应的同步对象，就是this</span></span><br><span class="line">    <span class="comment">//和hurt方法达到的效果一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">()</span>&#123;</span><br><span class="line">        hp=hp+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//掉血</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hurt</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//使用this作为同步对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            hp=hp-<span class="number">1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackHero</span><span class="params">(Hero h)</span> &#123;</span><br><span class="line">        h.hp-=damage;</span><br><span class="line">        System.out.format(<span class="string">&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;</span>,name,h.name,h.name,h.hp);</span><br><span class="line">        <span class="keyword">if</span>(h.isDead())</span><br><span class="line">            System.out.println(h.name +<span class="string">&quot;死了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>&gt;=hp?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">10000</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">  </span><br><span class="line">        Thread[] addThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[n];</span><br><span class="line">        Thread[] reduceThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[n];</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                     </span><br><span class="line">                    <span class="comment">//recover自带synchronized</span></span><br><span class="line">                    gareen.recover();</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            addThreads[i] = t;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    <span class="comment">//hurt自带synchronized</span></span><br><span class="line">                    gareen.hurt();</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            reduceThreads[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (Thread t : addThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : reduceThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        System.out.printf(<span class="string">&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n&quot;</span>, n,n,gareen.hp);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修饰类-线程安全的类"><a href="#修饰类-线程安全的类" class="headerlink" title="修饰类 线程安全的类"></a>修饰类 线程安全的类</h4><p>如果一个类，其<strong>方法都是有synchronized修饰的</strong>，那么该类就叫做<strong>线程安全的类</strong></p>
<p>同一时间，只有一个线程能够进入 <strong>这种类的一个实例</strong> 的去修改数据，进而保证了这个实例中的数据的安全(不会同时被多线程修改而变成脏数据)</p>
<p>比如StringBuffer和StringBuilder的区别<br>StringBuffer的方法都是有synchronized修饰的，StringBuffer就叫做线程安全的类<br>而StringBuilder就不是线程安全的类</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141709309.png" alt="线程安全的类"></p>
<h4 id="把非线程安全的集合转换为线程安全"><a href="#把非线程安全的集合转换为线程安全" class="headerlink" title="把非线程安全的集合转换为线程安全"></a>把非线程安全的集合转换为线程安全</h4><p>ArrayList是非线程安全的，换句话说，多个线程可以同时进入<strong>一个ArrayList对象</strong>的add方法</p>
<p>借助Collections.synchronizedList，可以把ArrayList转换为线程安全的List。</p>
<p>与此类似的，还有HashSet,LinkedList,HashMap等等非线程安全的类，都通过<a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-collections/369.html">工具类Collections</a>转换为线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list2 = Collections.synchronizedList(list1);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>例：</p>
<ol>
<li>线程1 首先占有对象1，接着试图占有对象2</li>
<li>线程2 首先占有对象2，接着试图占有对象1</li>
<li>线程1 等待线程2释放对象2</li>
<li>与此同时，线程2等待线程1释放对象1<br>就会。。。一直等待下去，直到天荒地老，海枯石烂，山无棱 ，天地合。。。</li>
</ol>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141709468.png" alt="演示死锁"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">ahri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        ahri.name = <span class="string">&quot;九尾妖狐&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">annie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        annie.name = <span class="string">&quot;安妮&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//占有九尾妖狐</span></span><br><span class="line">                <span class="keyword">synchronized</span> (ahri) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1 已占有九尾妖狐&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//停顿1000毫秒，另一个线程有足够的时间占有安妮</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    System.out.println(<span class="string">&quot;t1 试图占有安妮&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1 等待中 。。。。&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (annie) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  </span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//占有安妮</span></span><br><span class="line">                <span class="keyword">synchronized</span> (annie) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2 已占有安妮&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">//停顿1000毫秒，另一个线程有足够的时间占有暂用九尾妖狐</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2 试图占有九尾妖狐&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2 等待中 。。。。&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (ahri) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  </span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="交互——wait、notify"><a href="#交互——wait、notify" class="headerlink" title="交互——wait、notify"></a>交互——wait、notify</h3><p>例：</p>
<p>线程之间有<strong>交互通知</strong>的需求，考虑如下情况：<br>有两个线程，处理同一个英雄。<br>一个加血，一个减血。</p>
<p>减血的线程，发现血量&#x3D;1，就停止减血，直到加血的线程为英雄加了血，才可以继续减血</p>
<h4 id="使用wait和notify进行线程交互"><a href="#使用wait和notify进行线程交互" class="headerlink" title="使用wait和notify进行线程交互"></a>使用wait和notify进行线程交互</h4><p>在Hero类中：hurt()减血方法：当hp&#x3D;1的时候，执行this.wait().<br>this.wait()<strong>表示 让占有this的线程等待，并临时释放占有</strong><br>进入hurt方法的线程必然是减血线程，this.wait()会让减血线程临时释放对this的占有。 <strong>这样加血线程，就有机会进入recover()加血方法了</strong>。<br>recover() 加血方法：增加了血量，执行this.notify();<br>this.notify() 表示通知那些<strong>等待在this的线程</strong>，可以苏醒过来了。 等待在this的线程，恰恰就是减血线程。 一旦recover()结束， 加血线程释放了this，减血线程，就可以重新占有this，并执行后面的减血工作。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141709520.png" alt="使用wait和notify进行线程交互"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">()</span> &#123;</span><br><span class="line">        hp = hp + <span class="number">1</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s 回血1点,增加血后，%s的血量是%.0f%n&quot;</span>, name, name, hp);</span><br><span class="line">        <span class="comment">// 通知那些等待在this对象上的线程，可以醒过来了，如第20行，等待着的减血线程，苏醒过来</span></span><br><span class="line">        <span class="built_in">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">hurt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hp == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 让占有this的减血线程，暂时释放对this的占有，并等待</span></span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        hp = hp - <span class="number">1</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s 减血1点,减少血后，%s的血量是%.0f%n&quot;</span>, name, name, hp);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackHero</span><span class="params">(Hero h)</span> &#123;</span><br><span class="line">        h.hp -= damage;</span><br><span class="line">        System.out.format(<span class="string">&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;</span>, name, h.name, h.name, h.hp);</span><br><span class="line">        <span class="keyword">if</span> (h.isDead())</span><br><span class="line">            System.out.println(h.name + <span class="string">&quot;死了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &gt;= hp ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">             </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                       </span><br><span class="line">                    <span class="comment">//无需循环判断</span></span><br><span class="line"><span class="comment">//                    while(gareen.hp==1)&#123;</span></span><br><span class="line"><span class="comment">//                        continue;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                       </span><br><span class="line">                    gareen.hurt();</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">   </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    gareen.recover();</span><br><span class="line">   </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关于wait、notify和notifyAll"><a href="#关于wait、notify和notifyAll" class="headerlink" title="关于wait、notify和notifyAll"></a>关于wait、notify和notifyAll</h4><p>留意wait()和notify() 这两个方法是什么对象上的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">hurt</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  。。。</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.wait();</span><br><span class="line"></span><br><span class="line">  。。。</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">   。。。</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.notify();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要强调的是，wait方法和notify方法，并<strong>不是Thread线程上的方法</strong>，它们是Object上的方法。</p>
<p>因为所有的Object都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法。</p>
<p>wait()的意思是： 让占用了这个同步对象的<strong>线程</strong>，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，<strong>一定是在synchronized块里，否则就会出错</strong>。</p>
<p>notify() 的意思是，通知<strong>一个</strong>等待在这个同步对象上的线程，<strong>你</strong>可以苏醒过来了，有机会重新占用当前对象了。</p>
<p>notifyAll() 的意思是，通知<strong>所有的</strong>等待在这个同步对象上的线程，<strong>你们</strong>可以苏醒过来了，有机会重新占用当前对象了。</p>
<h4 id="sleep-方法和-wait-方法对比"><a href="#sleep-方法和-wait-方法对比" class="headerlink" title="sleep() 方法和 wait() 方法对比"></a>sleep() 方法和 wait() 方法对比</h4><p><strong>共同点</strong> ：两者都可以暂停线程的执行。</p>
<p><strong>区别</strong> ：</p>
<ul>
<li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li>
<li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li>
</ul>
<h4 id="为什么-wait-方法不定义在-Thread-中？"><a href="#为什么-wait-方法不定义在-Thread-中？" class="headerlink" title="为什么 wait() 方法不定义在 Thread 中？"></a>为什么 wait() 方法不定义在 Thread 中？</h4><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p>
<p>类似的问题：<strong>为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</strong></p>
<p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>每一个线程的启动和结束都是比较消耗时间和占用资源的。</p>
<p>如果在系统中用到了很多的线程，大量的启动和结束动作会导致系统的性能变卡，响应变慢。</p>
<p>为了解决这个问题，引入线程池这种设计思想。</p>
<p>线程池的模式很像<a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-wait-notify/358.html#step2591">生产者消费者模式</a>，消费的对象是一个一个的能够运行的<strong>任务</strong>。</p>
<h4 id="线程池设计思路"><a href="#线程池设计思路" class="headerlink" title="线程池设计思路"></a>线程池设计思路</h4><p>线程池的思路和<a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-wait-notify/358.html#step2591">生产者消费者模型</a>是很接近的。</p>
<ol>
<li><p>准备一个任务容器</p>
</li>
<li><p>一次性启动10个 消费者线程</p>
</li>
<li><p>刚开始任务容器是空的，所以线程都<strong>wait</strong>在上面。</p>
</li>
<li><p>直到一个外部线程往这个任务容器中扔了一个“任务”，就会有一个消费者线程被唤醒notify</p>
</li>
<li><p>这个消费者线程取出“任务”，并且<strong>执行这个任务</strong>，执行完毕后，继续等待下一次任务的到来。</p>
</li>
<li><p>如果短时间内，有较多的任务加入，那么就会有多个线程被<strong>唤醒</strong>，去执行这些任务。</p>
</li>
</ol>
<p>在整个过程中，都不需要创建新的线程，而是<strong>循环使用这些已经存在的线程</strong>。</p>
<h4 id="开发一个自定义线程池"><a href="#开发一个自定义线程池" class="headerlink" title="开发一个自定义线程池"></a>开发一个自定义线程池</h4><p>这是一个自定义的线程池，虽然不够完善和健壮，但是已经足以说明线程池的工作原理</p>
<p>创造一个情景，每个任务执行的时间都是1秒<br>刚开始是间隔1秒钟向线程池中添加任务</p>
<p>然后间隔时间越来越短，执行任务的线程还没有来得及结束，新的任务又来了。<br>就会观察到线程池里的其他线程被唤醒来执行这些任务</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141709845.png" alt="image-20220920114116086"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 线程池大小</span></span><br><span class="line">    <span class="type">int</span> threadPoolSize;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 任务容器</span></span><br><span class="line">    LinkedList&lt;Runnable&gt; tasks = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Runnable&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 试图消费任务的线程</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        threadPoolSize = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 启动10个任务消费者线程</span></span><br><span class="line">        <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadPoolSize; i++) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TaskConsumeThread</span>(<span class="string">&quot;任务消费者线程 &quot;</span> + i).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">            tasks.add(r);</span><br><span class="line">            <span class="comment">// 唤醒等待的任务消费者线程</span></span><br><span class="line">            tasks.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TaskConsumeThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TaskConsumeThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        Runnable task;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;启动： &quot;</span> + <span class="built_in">this</span>.getName());</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (tasks.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            tasks.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    task = tasks.removeLast();</span><br><span class="line">                    <span class="comment">// 允许添加任务的线程可以继续添加任务</span></span><br><span class="line">                    tasks.notifyAll();</span><br><span class="line">  </span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot; 获取到任务，并执行&quot;</span>);</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadPool pool= <span class="keyword">new</span> <span class="title class_">ThreadPool</span>();</span><br><span class="line">        <span class="type">int</span> sleep=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            pool.add(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">//System.out.println(&quot;执行任务&quot;);</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(sleep);</span><br><span class="line">                sleep = sleep&gt;<span class="number">100</span>?sleep-<span class="number">100</span>:sleep;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用java自带线程池"><a href="#使用java自带线程池" class="headerlink" title="使用java自带线程池"></a>使用java自带线程池</h4><p>java提供自带的线程池，而不需要自己去开发一个自定义线程池了。</p>
<p>线程池类<strong>ThreadPoolExecutor</strong>在包<strong>java.util.concurrent</strong>下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPool= <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">15</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<p><strong>第一个</strong>参数10 表示这个线程池<strong>初始化了10个</strong>线程在里面工作<br><strong>第二个</strong>参数15 表示如果10个线程不够用了，就会自动增加到<strong>最多15个线程</strong><br><strong>第三个</strong>参数60 结合第四个参数TimeUnit.SECONDS，表示经过<strong>60秒</strong>，多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个<br><strong>第四个</strong>参数TimeUnit.SECONDS 如上<br><strong>第五个</strong>参数 new LinkedBlockingQueue() 用来放任务的集合</p>
<p><strong>execute</strong>方法用于添加新的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">           </span><br><span class="line">        ThreadPoolExecutor threadPool= <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">15</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">           </span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                System.out.println(<span class="string">&quot;任务1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">               </span><br><span class="line">        &#125;);</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lock对象"><a href="#Lock对象" class="headerlink" title="Lock对象"></a>Lock对象</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Lock是一个接口，为了使用一个Lock对象，需要用到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>

<p>与 <strong>synchronized (someObject)</strong> 类似的，<strong>lock()<strong>方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。<br>与 <strong>synchronized</strong> 不同的是，一旦synchronized 块结束，就会自动释放对</strong>someObject</strong>的占用。 lock却必须调用<strong>unlock</strong>方法进行手动释放，为了保证释放的执行，往往会把unlock() 放在finally中进行。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141709607.png" alt="使用Lock对象实现同步效果"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">now</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s %s %s %n&quot;</span>, now() , Thread.currentThread().getName() , msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line"> </span><br><span class="line">                    lock.lock();</span><br><span class="line"> </span><br><span class="line">                    log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"> </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先让t1飞2秒</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line"> </span><br><span class="line">                    lock.lock();</span><br><span class="line"> </span><br><span class="line">                    log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"> </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="trylock方法"><a href="#trylock方法" class="headerlink" title="trylock方法"></a>trylock方法</h4><p>synchronized 是<strong>不占用到手不罢休</strong>的，会一直试图占用下去。与 synchronized 的<strong>钻牛角尖</strong>不一样，Lock接口还提供了一个trylock方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.tryLock(<span class="number">1</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>trylock会在指定时间范围内<strong>试图占用</strong>，占成功了，就啪啪啪。 如果时间到了，还占用不成功，扭头就走~</p>
<p>注意： 因为使用trylock有可能成功，有可能失败，所以后面unlock释放锁的时候，需要判断是否占用成功了，如果没占用成功也unlock,就会抛出异常。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141710988.png" alt="image-20220927095221974"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">now</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s %s %s %n&quot;</span>, now() , Thread.currentThread().getName() , msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line">                    <span class="comment">// 模拟在规定时间未占用</span></span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    <span class="comment">// 获取对象时间设置为1秒</span></span><br><span class="line">                    locked = lock.tryLock(<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line">                    <span class="keyword">if</span>(locked)&#123;</span><br><span class="line">                        log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                        log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        log(<span class="string">&quot;经过1秒钟的努力，还没有占有对象，放弃占有&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(locked)&#123;</span><br><span class="line">                        log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先让t1飞2秒</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    locked = lock.tryLock(<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line">                    <span class="keyword">if</span>(locked)&#123;</span><br><span class="line">                        log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                        log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        log(<span class="string">&quot;经过1秒钟的努力，还没有占有对象，放弃占有&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(locked)&#123;</span><br><span class="line">                        log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程交互"><a href="#线程交互" class="headerlink" title="线程交互"></a>线程交互</h4><p>使用synchronized方式进行线程交互，用到的是同步对象的<strong>wait,notify和notifyAll方法</strong></p>
<p>Lock也提供了类似的解决办法，首先通过lock对象得到一个Condition对象，然后分别调用这个Condition对象的：<strong>await</strong>, <strong>signal</strong>,<strong>signalAll</strong> 方法</p>
<p><strong>注意</strong>： 不是Condition对象的wait,nofity,notifyAll方法,是await,signal,signalAll</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141710550.png" alt="线程交互"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">now</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s %s %s %n&quot;</span>, now() , Thread.currentThread().getName() , msg);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">         </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line">  </span><br><span class="line">                    lock.lock();</span><br><span class="line">  </span><br><span class="line">                    log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    log(<span class="string">&quot;临时释放对象 lock， 并等待&quot;</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                    log(<span class="string">&quot;重新占有对象 lock，并进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先让t1飞2秒</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line">  </span><br><span class="line">                    lock.lock();</span><br><span class="line">  </span><br><span class="line">                    log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    log(<span class="string">&quot;唤醒等待中的线程&quot;</span>);</span><br><span class="line">                    condition.signal();</span><br><span class="line">  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Lock和synchronized的区别"><a href="#Lock和synchronized的区别" class="headerlink" title="Lock和synchronized的区别"></a>Lock和synchronized的区别</h4><ol>
<li><strong>两者都是可重入锁</strong></li>
</ol>
<p><strong>“可重入锁” 指的是自己可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>
<ol start="2">
<li><p><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong>，Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。</p>
</li>
<li><p>Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。</p>
</li>
<li><p>synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。</p>
</li>
<li><p><strong>ReentrantLock 比 synchronized 增加了一些高级功能</strong></p>
<p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
</li>
</ol>
<h3 id="原子访问"><a href="#原子访问" class="headerlink" title="原子访问"></a>原子访问</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p>
<p>所谓的<strong>原子性操作</strong>即不可中断的操作，比如赋值操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">count += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>原子性操作本身是线程安全的</strong></p>
<p>但是 count++ 这个行为，至少需要三条 CPU 指令:</p>
<ol>
<li>首先，需要把变量 count 从内存加载到 CPU 的寄存器；</li>
<li>之后，在寄存器中执行 +1 操作；</li>
<li>最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li>
</ol>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141710313.png" alt="img"></p>
<p>这三个步骤，每一步都是一个原子操作，但是合在一起，就不是原子操作。就<strong>不是线程安全</strong>的。</p>
<p>换句话说，一个线程在步骤1 取icount的值结束后，还没有来得及进行步骤2，另一个线程也可以取 count的值了。</p>
<p>这也是<a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-synchronized/355.html#step787">分析同步问题产生的原因</a> 中的原理。i++ ，i–， i &#x3D; i+1 这些都是非原子性操作。只有int i &#x3D; 1,这个赋值操作是原子性的。</p>
<h4 id="AtomicInteger（原子类）"><a href="#AtomicInteger（原子类）" class="headerlink" title="AtomicInteger（原子类）"></a>AtomicInteger（原子类）</h4><p>JDK6 以后，新增加了一个包<strong>java.util.concurrent.atomic</strong>，里面有各种原子类，比如<strong>AtomicInteger</strong>。<br>而AtomicInteger提供了各种自增，自减等方法，这些方法都是原子性的。 换句话说，自增方法 <strong>incrementAndGet</strong> 是线程安全的，同一个时间，只有一个线程可以调用这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicI</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> atomicI.decrementAndGet();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> atomicI.incrementAndGet();</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> atomicI.addAndGet(<span class="number">3</span>);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>分别使用基本变量的非原子性的**++<strong>运算符和 原子性的</strong>AtomicInteger对象的 incrementAndGet** 来进行多线程测试。<br>测试结果如图所示</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141710520.png" alt="同步测试"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicValue</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">        Thread[] ts1 = <span class="keyword">new</span> <span class="title class_">Thread</span>[number];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    value++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts1[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//等待这些线程全部结束</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : ts1) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.printf(<span class="string">&quot;%d个线程进行value++后，value的值变成:%d%n&quot;</span>, number,value);</span><br><span class="line">        Thread[] ts2 = <span class="keyword">new</span> <span class="title class_">Thread</span>[number];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    atomicValue.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts2[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//等待这些线程全部结束</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : ts2) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d个线程进行atomicValue.incrementAndGet();后，atomicValue的值变成:%d%n&quot;</span>, number,atomicValue.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="使用Statement"><a href="#使用Statement" class="headerlink" title="使用Statement"></a>使用Statement</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">                <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>); <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from hero&quot;</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 执行查询语句，并把结果集返回给ResultSet</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> s.executeQuery(sql);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);<span class="comment">// 可以使用字段名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>);<span class="comment">// 也可以使用字段的顺序</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">hp</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;hp&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">damage</span> <span class="operator">=</span> rs.getInt(<span class="number">4</span>);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t%s\t%f\t%d%n&quot;</span>, id, name, hp, damage);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不一定要在这里关闭ReultSet，因为Statement关闭的时候，会自动关闭ResultSet</span></span><br><span class="line">            <span class="comment">// rs.close();</span></span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用PreparedStatement"><a href="#使用PreparedStatement" class="headerlink" title="使用PreparedStatement"></a>使用PreparedStatement</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into hero values(null,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql);</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// Statement需要进行字符串拼接，可读性和维修性比较差</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql0</span> <span class="operator">=</span> <span class="string">&quot;insert into hero values(null,&quot;</span> + <span class="string">&quot;&#x27;提莫&#x27;&quot;</span> + <span class="string">&quot;,&quot;</span> + <span class="number">313.0f</span> + <span class="string">&quot;,&quot;</span> + <span class="number">50</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            s.execute(sql0);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// PreparedStatement 使用参数设置，可读性好，不易犯错</span></span><br><span class="line">            <span class="comment">// &quot;insert into hero values(null,?,?,?)&quot;;</span></span><br><span class="line">            ps.setString(<span class="number">1</span>, <span class="string">&quot;提莫&quot;</span>);</span><br><span class="line">            ps.setFloat(<span class="number">2</span>, <span class="number">313.0f</span>);</span><br><span class="line">            ps.setInt(<span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line">            ps.execute();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>参数设置</li>
</ul>
<blockquote>
<p><strong>Statement</strong> 需要进行字符串拼接，可读性和维护性比较差</p>
<p>String sql &#x3D; “insert into hero values(null,”+”‘提莫’”+”,”+313.0f+”,”+50+”)”;</p>
<p> <strong>PreparedStatement</strong> 使用参数设置，可读性好，不易犯错</p>
<p>String sql &#x3D; “insert into hero values(null,?,?,?)”;</p>
</blockquote>
<ul>
<li>性能表现</li>
</ul>
<p>PreparedStatement有预编译机制，性能比Statement更快</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// Statement执行10次，需要10次把SQL语句传输到数据库端</span></span><br><span class="line">            <span class="comment">// 数据库要对每一次来的SQL语句进行编译处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">sql0</span> <span class="operator">=</span> <span class="string">&quot;insert into hero values(null,&quot;</span> + <span class="string">&quot;&#x27;提莫&#x27;&quot;</span> + <span class="string">&quot;,&quot;</span></span><br><span class="line">                        + <span class="number">313.0f</span> + <span class="string">&quot;,&quot;</span> + <span class="number">50</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                s.execute(sql0);</span><br><span class="line">            &#125;</span><br><span class="line">            s.close();</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// PreparedStatement 执行10次，只需要1次把SQL语句传输到数据库端</span></span><br><span class="line">            <span class="comment">// 数据库对带?的SQL进行预编译</span></span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 每次执行，只需要传输参数到数据库端</span></span><br><span class="line">            <span class="comment">// 1. 网络传输量比Statement更小</span></span><br><span class="line">            <span class="comment">// 2. 数据库不需要再进行编译，响应更快</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                ps.setString(<span class="number">1</span>, <span class="string">&quot;提莫&quot;</span>);</span><br><span class="line">                ps.setFloat(<span class="number">2</span>, <span class="number">313.0f</span>);</span><br><span class="line">                ps.setInt(<span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line">                ps.execute();</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>防止SQL注入式攻击</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from hero where name = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">                <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql);</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 假设name是用户提交来的数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&#x27;盖伦&#x27; OR 1=1&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql0</span> <span class="operator">=</span> <span class="string">&quot;select * from hero where name = &quot;</span> + name;</span><br><span class="line">            <span class="comment">// 拼接出来的SQL语句就是</span></span><br><span class="line">            <span class="comment">// select * from hero where name = &#x27;盖伦&#x27; OR 1=1</span></span><br><span class="line">            <span class="comment">// 因为有OR 1=1，所以恒成立</span></span><br><span class="line">            <span class="comment">// 那么就会把所有的英雄都查出来，而不只是盖伦</span></span><br><span class="line">            <span class="comment">// 如果Hero表里的数据是海量的，比如几百万条，把这个表里的数据全部查出来</span></span><br><span class="line">            <span class="comment">// 会让数据库负载变高，CPU100%，内存消耗光，响应变得极其缓慢</span></span><br><span class="line">            System.out.println(sql0);</span><br><span class="line">  </span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs0</span> <span class="operator">=</span> s.executeQuery(sql0);</span><br><span class="line">            <span class="keyword">while</span> (rs0.next()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">heroName</span> <span class="operator">=</span> rs0.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                System.out.println(heroName);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            s.execute(sql0);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 使用预编译Statement就可以杜绝SQL注入</span></span><br><span class="line">  </span><br><span class="line">            ps.setString(<span class="number">1</span>, name);</span><br><span class="line">  </span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line">            <span class="comment">// 查不出数据出来</span></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">heroName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                System.out.println(heroName);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="execute与executeUpdate的区别"><a href="#execute与executeUpdate的区别" class="headerlink" title="execute与executeUpdate的区别"></a>execute与executeUpdate的区别</h3><p><strong>execute</strong>与<strong>executeUpdate</strong>的相同点：都可以执行增加，删除，修改。</p>
<p>不同1：<br>execute<strong>可以执行查询语句</strong>，然后通过getResultSet，把结果集取出来；<br>executeUpdate<strong>不能执行查询语句；</strong><br>不同2:<br>execute<strong>返回boolean类型</strong>，true表示执行的是查询语句，false表示执行的是insert,delete,update等等；<br>executeUpdate<strong>返回的是int</strong>，表示有多少条数据受到了影响；</p>
<h3 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h3><h4 id="获取自增长id"><a href="#获取自增长id" class="headerlink" title="获取自增长id"></a>获取自增长id</h4><p>通过<strong>Statement</strong>的<strong>getGeneratedKeys</strong>获取该id;</p>
<blockquote>
<p><strong>注：</strong> 第20行的代码，后面加了个<strong>Statement.RETURN_GENERATED_KEYS</strong>参数，以确保会返回自增长ID。 通常情况下不需要加这个，有的时候需要加，所以先加上，保险一些</p>
<p><code>PreparedStatement ps = c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into hero values(null,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">                <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);          </span><br><span class="line">                ) &#123;</span><br><span class="line">  </span><br><span class="line">            ps.setString(<span class="number">1</span>, <span class="string">&quot;盖伦&quot;</span>);</span><br><span class="line">            ps.setFloat(<span class="number">2</span>, <span class="number">616</span>);</span><br><span class="line">            ps.setInt(<span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line">   </span><br><span class="line">            <span class="comment">// 执行插入语句</span></span><br><span class="line">            ps.execute();</span><br><span class="line">   </span><br><span class="line">            <span class="comment">// 在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id</span></span><br><span class="line">            <span class="comment">// JDBC通过getGeneratedKeys获取该id</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.getGeneratedKeys();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">                System.out.println(id);</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取表的元数据"><a href="#获取表的元数据" class="headerlink" title="获取表的元数据"></a>获取表的元数据</h4><p>元数据概念：<br>和数据库服务器相关的数据，比如数据库版本，有哪些表，表有哪些字段，字段类型是什么等等。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141710208.png" alt="获取表的元数据"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);) &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 查看数据库层面的元数据</span></span><br><span class="line">            <span class="comment">// 即数据库服务器版本，驱动版本，都有哪些数据库等等</span></span><br><span class="line">  </span><br><span class="line">            <span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> c.getMetaData();</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取数据库服务器产品名称</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库产品名称:\t&quot;</span>+dbmd.getDatabaseProductName());</span><br><span class="line">            <span class="comment">// 获取数据库服务器产品版本号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库产品版本:\t&quot;</span>+dbmd.getDatabaseProductVersion());</span><br><span class="line">            <span class="comment">// 获取数据库服务器用作类别和表名之间的分隔符 如test.user</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库和表分隔符:\t&quot;</span>+dbmd.getCatalogSeparator());</span><br><span class="line">            <span class="comment">// 获取驱动版本</span></span><br><span class="line">            System.out.println(<span class="string">&quot;驱动版本:\t&quot;</span>+dbmd.getDriverVersion());</span><br><span class="line">  </span><br><span class="line">            System.out.println(<span class="string">&quot;可用的数据库列表：&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取数据库名称</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> dbmd.getCatalogs();</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库名称:\t&quot;</span>+rs.getString(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h3><p>在Mysql中，只有当表的类型是INNODB的时候，才支持事务，所以需要把表的类型设置为INNODB,否则无法观察到事务.</p>
<p>修改表的类型为INNODB的SQL：<code>alter table hero ENGINE  = innodb;</code></p>
<p>查看表的类型的SQL：<code>show table status from how2java; </code></p>
<p>不过有个前提，就是当前的MYSQL服务器本身要支持INNODB,如果不支持，请看 <a target="_blank" rel="noopener" href="https://how2j.cn/k/mysql/mysql-innodb/1064.html">开启MYSQL INNODB的办法</a></p>
<h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>在事务中的多个操作，<strong>要么都成功，要么都失败</strong><br>通过 c.setAutoCommit(false);<strong>关闭自动提交</strong><br>使用 c.commit();进行<strong>手动提交</strong><br>在22行-35行之间的数据库操作，就处于同一个事务当中，要么都成功，要么都失败<br>所以，虽然第一条SQL语句是可以执行的，但是第二条SQL语句有错误，其结果就是两条SQL语句<strong>都没有被提交</strong>。 除非两条SQL语句都是正确的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();) &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 有事务的前提下</span></span><br><span class="line">            <span class="comment">// 在事务中的多个操作，要么都成功，要么都失败</span></span><br><span class="line">  </span><br><span class="line">            c.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 加血的SQL</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update hero set hp = hp +1 where id = 22&quot;</span>;</span><br><span class="line">            s.execute(sql1);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 减血的SQL</span></span><br><span class="line">            <span class="comment">// 不小心写错写成了 updata(而非update)</span></span><br><span class="line">  </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;updata hero set hp = hp -1 where id = 22&quot;</span>;</span><br><span class="line">            s.execute(sql2);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 手动提交</span></span><br><span class="line">            c.commit();</span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><h4 id="数据库连接池原理-传统方式"><a href="#数据库连接池原理-传统方式" class="headerlink" title="数据库连接池原理-传统方式"></a>数据库连接池原理-传统方式</h4><p>当有多个线程，每个线程都需要连接数据库执行SQL语句的话，那么每个线程都会创建一个连接，并且在使用完毕后，关闭连接。</p>
<p>创建连接和关闭连接的过程也是比较消耗时间的，当多线程并发的时候，系统就会变得很卡顿。</p>
<p>同时，一个数据库同时支持的连接总数也是有限的，如果多线程并发量很大，那么数据库连接的总数就会被消耗光，后续线程发起的数据库连接就会失败。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141710361.png" alt="数据库连接池原理-传统方式"></p>
<h4 id="数据库连接池原理-使用池"><a href="#数据库连接池原理-使用池" class="headerlink" title="数据库连接池原理-使用池"></a>数据库连接池原理-使用池</h4><p>与传统方式不同，连接池在使用之前，就会创建好一定数量的连接。<br>如果有任何线程需要使用连接，那么就从连接池里面<strong>借用</strong>，<strong>而不是自己重新创建</strong>.<br>使用完毕后，又把这个连接<strong>归还</strong>给连接池供下一次或者其他线程使用。<br>倘若发生多线程并发情况，连接池里的连接被<strong>借用光</strong>了，那么其他线程就会临时等待，直到有连接被<strong>归还</strong>回来，再继续使用。<br>整个过程，这些连接都<strong>不会被关闭</strong>，而是不断的被循环使用，从而节约了启动和关闭连接的时间。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141710427.png" alt="数据库连接池原理-使用池"></p>
<h4 id="ConnectionPool构造方法和初始化"><a href="#ConnectionPool构造方法和初始化" class="headerlink" title="ConnectionPool构造方法和初始化"></a>ConnectionPool构造方法和初始化</h4><ol>
<li><p>ConnectionPool() 构造方法约定了这个连接池一共有多少连接</p>
</li>
<li><p>在init() 初始化方法中，创建了size条连接。 注意，这里不能使用try-with-resource这种自动关闭连接的方式，因为连接恰恰需要保持不关闭状态，供后续循环使用</p>
</li>
<li><p>getConnection， 判断是否为空，如果是空的就wait等待，否则就借用一条连接出去</p>
</li>
<li><p>returnConnection， 在使用完毕后，归还这个连接到连接池，并且在归还完毕后，调用notifyAll，通知那些等待的线程，有新的连接可以借用了。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;</span><br><span class="line">  </span><br><span class="line">    List&lt;Connection&gt; cs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Connection&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConnectionPool</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//这里恰恰不能使用try-with-resource的方式，因为这些连接都需要是&quot;活&quot;的，不要被自动关闭了</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager</span><br><span class="line">                        .getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">  </span><br><span class="line">                cs.add(c);</span><br><span class="line">  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (cs.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> cs.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">returnConnection</span><span class="params">(Connection c)</span> &#123;</span><br><span class="line">        cs.add(c);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><p>首先初始化一个有3条连接的数据库连接池<br>然后创建100个线程，每个线程都会从连接池中<strong>借用连接</strong>，并且在借用之后，归还连接。 拿到连接之后，执行一个耗时1秒的SQL语句。</p>
<p>运行程序，就可以观察到如图所示的效果;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConnectionPool</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConnectionPool</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionPool</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">WorkingThread</span>(<span class="string">&quot;working thread&quot;</span> + i, cp).start();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkingThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ConnectionPool cp;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WorkingThread</span><span class="params">(String name, ConnectionPool cp)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.cp = cp;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> cp.getConnection();</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getName()+ <span class="string">&quot;:\t 获取了一根连接，并开始工作&quot;</span>  );</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> c.createStatement())&#123;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//模拟时耗１秒的数据库ＳＱＬ语句</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            st.execute(<span class="string">&quot;select * from hero&quot;</span>);</span><br><span class="line">   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException | InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        cp.returnConnection(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h2><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="IP地址-端口"><a href="#IP地址-端口" class="headerlink" title="IP地址 端口"></a>IP地址 端口</h3><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>在网络中每台计算机都必须有一个的IP地址；<br>32位，4个字节，常用点分十进制的格式表示，例如：192.168.1.100<br>127.0.0.1 是固定ip地址，代表当前计算机，相当于面向对象里的 “<strong>this</strong>“</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141710765.png" alt="IP地址"></p>
<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>两台计算机进行连接，总有一台服务器，一台客户端。<br>服务器和客户端之间的通信通过端口进行。如图：</p>
<p>ip地址是 192.168.1.100的服务器通过端口 8080<br>与ip地址是192.168.1.189的客户端 的1087端口通信</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141710214.png" alt="端口"></p>
<h4 id="获取本机IP"><a href="#获取本机IP" class="headerlink" title="获取本机IP"></a>获取本机IP</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSocket</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">host</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span>host.getHostAddress();</span><br><span class="line">        System.out.println(<span class="string">&quot;本机ip地址：&quot;</span> + ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用java-执行ping命令"><a href="#使用java-执行ping命令" class="headerlink" title="使用java 执行ping命令"></a>使用java 执行ping命令</h4><p>借助 Runtime.getRuntime().exec() 可以运行一个windows的exe程序<br>如图，使用java运行 <strong>ping 192.168.2.106</strong>，返回这样的字符串</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141710047.png" alt="使用java 执行ping命令"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSocket</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;ping &quot;</span> + <span class="string">&quot;192.168.2.106&quot;</span>);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(p.getInputStream()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.length() != <span class="number">0</span>)</span><br><span class="line">                sb.append(line + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;本次指令返回的消息是：&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>使用 Socket(套接字)进行不同的程序之间的通信;</p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><ol>
<li>服务端开启8888端口，并监听着，时刻等待着客户端的连接请求</li>
<li>客户端知道服务端的ip地址和监听端口号，发出请求到服务端，客户端的端口地址是系统分配的，通常都会大于1024</li>
</ol>
<p>一旦建立了连接，服务端会得到一个新的Socket对象，该对象负责与客户端进行通信。</p>
<p><strong>注意：</strong> 在开发调试的过程中，如果修改过了服务器Server代码，要关闭启动的Server,否则新的Server不能启动，因为8888端口被占用了</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141710939.png" alt="建立连接 "></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//服务端打开端口8888</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">               </span><br><span class="line">            <span class="comment">//在8888端口上监听，看是否有连接请求过来</span></span><br><span class="line">            System.out.println(<span class="string">&quot;监听在端口号:8888&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span>  ss.accept();</span><br><span class="line">               </span><br><span class="line">            System.out.println(<span class="string">&quot;有连接过来&quot;</span> + s);</span><br><span class="line">             </span><br><span class="line">            s.close();</span><br><span class="line">            ss.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//连接到本机的8888端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            s.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="收发数字"><a href="#收发数字" class="headerlink" title="收发数字"></a>收发数字</h4><p>一旦建立了连接，服务端和客户端就可以通过Socket进行通信了</p>
<ol>
<li>客户端打开输出流，并发送数字 110</li>
<li>服务端打开输入流，接受数字 110，并打印</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;监听在端口号:8888&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//打开输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//读取客户端发送的数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">msg</span> <span class="operator">=</span> is.read();</span><br><span class="line">            <span class="comment">//打印出来</span></span><br><span class="line">            System.out.println(msg);</span><br><span class="line">            is.close();</span><br><span class="line"> </span><br><span class="line">            s.close();</span><br><span class="line">            ss.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 打开输出流</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 发送数字110到服务端</span></span><br><span class="line">            os.write(<span class="number">110</span>);</span><br><span class="line">            os.close();</span><br><span class="line"> </span><br><span class="line">            s.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="收发字符串"><a href="#收发字符串" class="headerlink" title="收发字符串"></a>收发字符串</h4><p>直接使用字节流收发字符串比较麻烦，使用<a target="_blank" rel="noopener" href="https://how2j.cn/k/io/io-datastream/350.html#step771">数据流</a>对字节流进行封装，这样收发字符串就容易了</p>
<ol>
<li>把输出流封装在DataOutputStream中，使用writeUTF发送字符串 “Legendary!”</li>
<li>把输入流封装在DataInputStream，使用readUTF读取字符串,并打印</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;监听在端口号:8888&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"> </span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//把输入流封装在DataInputStream</span></span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="comment">//使用readUTF读取字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">            dis.close();</span><br><span class="line">            s.close();</span><br><span class="line">            ss.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————————————————</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//把输出流封装在DataOutputStream中</span></span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line">            <span class="comment">//使用writeUTF发送字符串</span></span><br><span class="line">            dos.writeUTF(<span class="string">&quot;Legendary!&quot;</span>);</span><br><span class="line">            dos.close();</span><br><span class="line">            s.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程聊天"><a href="#多线程聊天" class="headerlink" title="多线程聊天"></a>多线程聊天</h3><p>如果使用单线程开发Socket应用，那么同一时间，要么收消息，要么发消息，不能同时进行。</p>
<p>为了实现<strong>同时收发消息</strong>，就需要用到多线程；</p>
<h4 id="同时收发消息"><a href="#同时收发消息" class="headerlink" title="同时收发消息"></a>同时收发消息</h4><p>在<a target="_blank" rel="noopener" href="https://how2j.cn/k/socket/socket-socket/400.html#step2737">练习-服务端和客户端互聊</a> 中，只能一人说一句，说了之后，必须等待另一个人的回复，才能说下一句。</p>
<p>这是因为接受和发送都在主线程中，不能同时进行。 为了实现同时收发消息，基本设计思路是把收发分别放在不同的线程中进行</p>
<ol>
<li>SendThread 发送消息线程</li>
<li>RecieveThread 接受消息线程</li>
<li>Server一旦接受到连接，就启动收发两个线程</li>
<li>Client 一旦建立了连接，就启动收发两个线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 发送线程</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Socket s;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SendThread</span><span class="params">(Socket s)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">                dos.writeUTF(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"># 接收线程</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecieveThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Socket s;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RecieveThread</span><span class="params">(Socket s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line"> </span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"># </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;监听在端口号:8888&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//启动发送消息线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SendThread</span>(s).start();</span><br><span class="line">            <span class="comment">//启动接受消息线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RecieveThread</span>(s).start();</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 启动发送消息线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SendThread</span>(s).start();</span><br><span class="line">            <span class="comment">// 启动接受消息线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RecieveThread</span>(s).start();</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JAVA高级"><a href="#JAVA高级" class="headerlink" title="JAVA高级"></a>JAVA高级</h1><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p><strong>Java 反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制。</strong>也就是说，反射本质上是一个“反着来”的过程。我们通过new创建一个类的实例时，实际上是由Java虚拟机根据这个类的Class对象在运行时构建出来的，而反射是通过一个类的Class对象来获取它的定义信息，从而我们可以访问到它的属性、方法，知道这个类的父类、实现了哪些接口等信息。</p>
<p>要想解剖一个类，必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法。所以先要获取到每一个字节码文件对应的Class类型的对象。</p>
<p><strong>反射就是把java类中的各种成分映射成一个个的Java对象</strong>。<br>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把一个个组成部分映射成一个个对象。（其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）</p>
<p>加载的时候：<strong>Class对象的由来是将 .class 文件读入内存，并为之创建一个Class对象。</strong></p>
<pre><code>    Class类

    Class 类的实例表示正在运行的 Java 应用程序中的类和接口。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型）
    Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass 方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。
    我们知道Spring框架可以帮我们创建和管理对象。需要对象时，我们无需自己手动new对象，直接从Spring提供的容器中的Beans获取即可。Beans底层其实就是一个Map&lt;String,Object&gt;，最终通过getBean(“user”)来获取。而这其中最核心的实现就是利用反射技术。   

    Bean
    
    1、Java面向对象，对象有方法和属性，那么就需要对象实例来调用方法和属性（即实例化）；
    2、凡是有方法或属性的类都需要实例化，这样才能具象化去使用这些方法和属性；
    3、规律：凡是子类及带有方法或属性的类都要加上注册Bean到Spring IoC的注解；（@Component , @Repository , @ Controller , @Service , @Configration）
    4、把Bean理解为类的代理或代言人（实际上确实是通过反射、代理来实现的），这样它就能代表类拥有该拥有的东西了
    5、在Spring中，你标识一个@符号，那么Spring就会来看看，并且从这里拿到一个Bean（注册）或者给出一个Bean（使用）
</code></pre>
<p><strong>反射机制有什么用？</strong></p>
<p>通过java语言中的反射机制可以操作字节码文件（可以读和修改<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&spm=1001.2101.3001.7020">字节码</a>文件。）<br>通过反射机制可以操作代码片段。（class文件。）</p>
<p><strong>反射机制的相关类在哪个包下？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.reflect.*;</span><br></pre></td></tr></table></figure>

<p><strong>反射机制相关的重要的类有哪些？</strong></p>
<table>
<thead>
<tr>
<th>类</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>java.lang.Class</td>
<td>java.lang.Class</td>
</tr>
<tr>
<td>java.lang.reflect.Method</td>
<td>代表字节码中的方法字节码。代表类中的方法。</td>
</tr>
<tr>
<td>java.lang.reflect.Constructor</td>
<td>代表字节码中的构造方法字节码。代表类中的构造方法。</td>
</tr>
<tr>
<td>java.lang.reflect.Field</td>
<td>代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注</strong>：<strong>必须先获得Class才能获取Method、Constructor、Field</strong>。</p>
</blockquote>
<p><strong>Class类方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>public T <strong>newInstance</strong>()</td>
<td>创建对象</td>
</tr>
<tr>
<td>public String <strong>getName</strong>()</td>
<td>返回完整类名带包名</td>
</tr>
<tr>
<td>public String <strong>getSimpleName</strong>()</td>
<td>返回类名</td>
</tr>
<tr>
<td>public Field[] <strong>getFields</strong>()</td>
<td>返回类中public修饰的属性</td>
</tr>
<tr>
<td>public Field[] <strong>getDeclaredFields</strong>()</td>
<td>返回类中所有的属性</td>
</tr>
<tr>
<td>public Field <strong>getDeclaredField</strong>(String name)</td>
<td>根据属性名name获取指定的属性</td>
</tr>
<tr>
<td>public native int <strong>getModifiers</strong>()</td>
<td>获取属性的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td>public Method[] <strong>getDeclaredMethods</strong>()</td>
<td>返回类中所有的实例方法</td>
</tr>
<tr>
<td>public Method <strong>getDeclaredMethod</strong>(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>根据方法名name和方法形参获取指定方法</td>
</tr>
<tr>
<td>public Constructor&lt;?&gt;[] <strong>getDeclaredConstructors</strong>()</td>
<td>返回类中所有的构造方法</td>
</tr>
<tr>
<td>public Constructor <strong>getDeclaredConstructor</strong>(Class&lt;?&gt;… parameterTypes)</td>
<td>根据方法形参获取指定的构造方法</td>
</tr>
<tr>
<td>public native Class&lt;? super T&gt; <strong>getSuperclass</strong>()</td>
<td>返回调用类的父类</td>
</tr>
<tr>
<td>public Class&lt;?&gt;[] <strong>getInterfaces</strong>()</td>
<td>返回调用类实现的接口集合</td>
</tr>
</tbody></table>
<h3 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h3><p>类对象概念： 所有的类，都存在一个<strong>类对象</strong>，这个类对象用于提供<strong>类本身</strong>的信息，比如有几种构造方法， 有多少属性，有哪些普通方法。</p>
<h4 id="获取Class的方式"><a href="#获取Class的方式" class="headerlink" title="获取Class的方式"></a>获取Class的方式</h4><p>要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java.lang.Class实例？</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Class.forName(“完整类名带包名”)</td>
<td>静态方法</td>
</tr>
<tr>
<td>对象.getClass()</td>
<td></td>
</tr>
<tr>
<td>任何类型.class</td>
<td></td>
</tr>
</tbody></table>
<p><strong>案例：</strong></p>
<ol>
<li>Class.forName</li>
<li>Hero.class</li>
<li>new Hero().getClass()</li>
</ol>
<p>在一个JVM中，一种类，只会有一个类对象存在。所以以上三种方式取出来的类对象，都是一样的。</p>
<p><strong>注：</strong> 准确的讲是一个ClassLoader下，一种类，只会有一个类对象存在。通常一个JVM下，只会有一个ClassLoader。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        	<span class="comment">// 类路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;charactor.Hero&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class pClass1=Class.forName(className);</span><br><span class="line">                Class pClass2=Hero.class;</span><br><span class="line">                Class pClass3=<span class="keyword">new</span> <span class="title class_">Hero</span>().getClass();</span><br><span class="line">                System.out.println(pClass1==pClass2);</span><br><span class="line">                System.out.println(pClass1==pClass3);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JDBC重点-Class-forName导致类加载"><a href="#JDBC重点-Class-forName导致类加载" class="headerlink" title="JDBC重点(Class.forName导致类加载)"></a>JDBC重点(Class.forName导致类加载)</h4><p>如果你只是希望一个类的<strong>静态代码块</strong>执行，其它代码一律不执行，可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;完整类名&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个方法的执行会导致<strong>类加载</strong>，类加载时，静态代码块执行。其他两种方式不执行。</p>
<p><strong>案例：</strong></p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141711507.png" alt="获取类对象的时候，会导致类属性被初始化"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 实体类</span><br><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> String copyright;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化 copyright&quot;</span>);</span><br><span class="line">        copyright = <span class="string">&quot;版权由Riot Games公司所有&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"># 测试类</span><br><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;charactor.Hero&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class pClass1=Class.forName(className);</span><br><span class="line">                Class pClass2=Hero.class;</span><br><span class="line">                Class pClass3=<span class="keyword">new</span> <span class="title class_">Hero</span>().getClass();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在静态方法上加synchronized，同步对象是什么？"><a href="#在静态方法上加synchronized，同步对象是什么？" class="headerlink" title="在静态方法上加synchronized，同步对象是什么？"></a>在静态方法上加synchronized，同步对象是什么？</h4><p>静态方法被修饰为synchronized的时候，其同步对象就是当前类的类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread t1= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//调用method1</span></span><br><span class="line">                TestReflection.method1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(<span class="string">&quot;第一个线程&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//保证第一个线程先调用method1</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">         </span><br><span class="line">        Thread t2= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//调用method2</span></span><br><span class="line">                TestReflection.method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(<span class="string">&quot;第二个线程&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">synchronized</span> (TestReflection.class) &#123;</span><br><span class="line">            <span class="comment">// 对于method1而言，同步对象是TestReflection.class，只有占用TestReflection.class才可以执行到这里</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入了method1方法&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;运行5秒&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> </span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 对于mehotd2而言，必然有个同步对象，通过观察发现，当某个线程在method1中，占用了TestReflection.class之后</span></span><br><span class="line">        <span class="comment">// 就无法进入method2，推断出，method2的同步对象，就是TestReflection.class</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入了method2方法&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;运行5秒&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//传统的使用new的方式创建对象</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        h1.name = <span class="string">&quot;teemo&quot;</span>;</span><br><span class="line">        System.out.println(h1);</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用反射的方式创建对象</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;charactor.Hero&quot;</span>;</span><br><span class="line">            <span class="comment">//类对象</span></span><br><span class="line">            Class pClass=Class.forName(className);</span><br><span class="line">            <span class="comment">//构造器</span></span><br><span class="line">            Constructor c= pClass.getConstructor();</span><br><span class="line">            <span class="comment">//通过构造器实例化</span></span><br><span class="line">            Hero h2= (Hero) c.newInstance();</span><br><span class="line">            h2.name=<span class="string">&quot;gareen&quot;</span>;</span><br><span class="line">            System.out.println(h2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p><strong>Field类方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>public String <strong>getName</strong>()</td>
<td>返回属性名</td>
</tr>
<tr>
<td>public int <strong>getModifiers</strong>()</td>
<td>获取属性的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td>public Class&lt;?&gt; <strong>getType</strong>()</td>
<td>以Class类型，返回属性类型【一般配合Class类的getSimpleName()方法使用】</td>
</tr>
<tr>
<td>public void <strong>set</strong>(Object obj, Object value)</td>
<td>设置属性值</td>
</tr>
<tr>
<td>public Object <strong>get</strong>(Object obj)</td>
<td>读取属性值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 实体类</span><br><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        name =string;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero [name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackHero</span><span class="params">(Hero h2)</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name+ <span class="string">&quot; 正在攻击 &quot;</span> + h2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"># 测试类访问属性</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">            <span class="comment">//使用传统方式修改name的值为garen</span></span><br><span class="line">            h.name = <span class="string">&quot;garen&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取类Hero的名字叫做name的字段</span></span><br><span class="line">                Field f1= h.getClass().getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="comment">//修改这个字段的值</span></span><br><span class="line">                f1.set(h, <span class="string">&quot;teemo&quot;</span>);</span><br><span class="line">                <span class="comment">//打印被修改后的值</span></span><br><span class="line">                System.out.println(h.name);</span><br><span class="line">                 </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注：</strong> Field类中set()、get()使用注意事项：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">属性.set(对象, 值);</span><br><span class="line"></span><br><span class="line">属性.get(对象);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="getField和getDeclaredField的区别"><a href="#getField和getDeclaredField的区别" class="headerlink" title="getField和getDeclaredField的区别"></a>getField和getDeclaredField的区别</h4><p>这两个方法都是用于获取字段<br><code>getField</code> <strong>只能获取</strong>public的，包括<strong>从父类继承</strong>来的字段。<br><code>getDeclaredField</code> 可以获取本类所有的字段，<strong>包括private</strong>的，但是<strong>不能获取继承</strong>来的字段。 (<strong>注</strong>： 这里只能获取到private的<strong>字段</strong>，但并不能访问该private字段的<strong>值</strong>,除非加上**<code>setAccessible(true)</code>**</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>public void <strong>setAccessible</strong>(boolean flag)</td>
<td>默认false，设置为true为打破封装</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以访问私有的属性吗？</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> studentClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 打破封装（反射机制的缺点：打破封装，可能会给不法分子留下机会！！！）</span></span><br><span class="line"><span class="comment">// 这样设置完之后，在外部也是可以访问private的。</span></span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 给name属性赋值</span></span><br><span class="line">nameField.set(nameField.getConstructor().newInstance(), <span class="string">&quot;xiaowu&quot;</span>);</span><br><span class="line"><span class="comment">// 获取name属性的值</span></span><br><span class="line">System.out.println(nameField.get(obj));</span><br></pre></td></tr></table></figure>

<h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>public String <strong>getName</strong>()</td>
<td>返回方法名</td>
</tr>
<tr>
<td>public int <strong>getModifiers</strong>()</td>
<td>获取方法的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td>public Class&lt;?&gt; <strong>getReturnType</strong>()</td>
<td>以Class类型，返回方法类型【一般配合Class类的getSimpleName()方法使用】</td>
</tr>
<tr>
<td>public Class&lt;?&gt;[] <strong>getParameterTypes</strong>()</td>
<td>返回方法的修饰符列表（一个方法的参数可能会有多个。）【结果集一般配合Class类的getSimpleName()方法使用】</td>
</tr>
<tr>
<td>public Object <strong>invoke</strong>(Object obj, Object… args)</td>
<td>调用方法</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注：</strong> Method类中invoke()使用注意事项：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法.invoke(对象, 实参);</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>案例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 实体类</span><br><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        name =string;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero [name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackHero</span><span class="params">(Hero h2)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"># 测试类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取这个名字叫做setName，参数类型是String的方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> h.getClass().getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">            <span class="comment">// 对h对象，调用这个方法</span></span><br><span class="line">            m.invoke(h, <span class="string">&quot;盖伦&quot;</span>);</span><br><span class="line">            <span class="comment">// 使用传统的方式，调用getName方法</span></span><br><span class="line">            System.out.println(h.getName());</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>public String <strong>getName</strong>()</td>
<td>返回构造方法名</td>
</tr>
<tr>
<td>public int <strong>getModifiers</strong>()</td>
<td>获取构造方法的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td>
</tr>
<tr>
<td>public Class&lt;?&gt;[] <strong>getParameterTypes</strong>()</td>
<td>返回构造方法的修饰符列表（一个方法的参数可能会有多个。）【结果集一般配合Class类的getSimpleName()方法使用】</td>
</tr>
<tr>
<td>public T <strong>newInstance</strong>(Object … initargs)</td>
<td>创建对象【参数为创建对象的数据】</td>
</tr>
</tbody></table>
<p><strong>案例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">反编译一个类的Constructor构造方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest11</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.Vip&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public class UserService &#123;</span></span><br><span class="line">        s.append(Modifier.toString(vipClass.getModifiers()));</span><br><span class="line">        s.append(<span class="string">&quot; class &quot;</span>);</span><br><span class="line">        s.append(vipClass.getSimpleName());</span><br><span class="line">        s.append(<span class="string">&quot;&#123;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Constructor[] constructors = vipClass.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors)&#123;</span><br><span class="line">            <span class="comment">//public Vip(int no, String name, String birth, boolean sex) &#123;</span></span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            s.append(Modifier.toString(c.getModifiers()));</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">//            s.append(c.getName());//包名+类名</span></span><br><span class="line">            s.append(vipClass.getSimpleName());<span class="comment">//类名</span></span><br><span class="line">            s.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            Class[] parameterTypes = c.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++)&#123;</span><br><span class="line">                s.append(parameterTypes[i].getSimpleName());</span><br><span class="line">                <span class="keyword">if</span> (i != parameterTypes.length - <span class="number">1</span> ) s.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.append(<span class="string">&quot;)&#123;&#125;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="基本内置注解"><a href="#基本内置注解" class="headerlink" title="基本内置注解"></a>基本内置注解</h3><ul>
<li><p>@Override 用在方法上，表示这个方法重写了父类的方法，如toString()。如果父类没有这个方法，那么就无法编译通过。</p>
</li>
<li><p>@Deprecated 表示这个方法已经过期，不建议开发者使用。(暗示在将来某个不确定的版本，就有可能会取消掉)，被注解为过期，在调用的时候，就会受到提示。</p>
</li>
<li><p>@SuppressWarnings Suppress英文的意思是抑制的意思，这个注解的用处是忽略警告信息。<br>比如大家使用集合的时候，有时候为了偷懒，会不写泛型，像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">heros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure>

<p>那么就会导致编译器出现警告，而加上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unused&quot; &#125;)</span></span><br></pre></td></tr></table></figure>

<p>就对这些警告进行了<strong>抑制</strong>，即忽略掉这些警告信息。</p>
<p>@SuppressWarnings 有常见的值，分别对应如下意思</p>
<ul>
<li>deprecation：使用了不赞成使用的类或方法时的警告(使用@Deprecated使得编译器产生的警告)；</li>
<li>unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 关闭编译器警告</li>
<li>fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;</li>
<li>path：在类路径、源文件路径等中有不存在的路径时的警告;</li>
<li>serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告;</li>
<li>finally：任何 finally 子句不能正常完成时的警告;</li>
<li>rawtypes 泛型类型未指明</li>
<li>unused 引用定义了，但是没有被使用</li>
<li>all：关于以上所有情况的警告。</li>
</ul>
</li>
<li><p>@SafeVarargs 这是1.7 之后新加入的基本注解. 如例所示，当使用可变数量的参数的时候，而参数的类型又是泛型T的话，就会出现警告。 这个时候，就使用@SafeVarargs来去掉这个警告</p>
<p>@SafeVarargs注解只能用在参数长度可变的方法或构造方法上，且方法必须声明为static或final，否则会出现编译错误。一个方法使用@SafeVarargs注解的前提是，开发人员必须确保这个方法的实现中对泛型类型参数的处理不会引发类型安全问题。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getFirstOne</span><span class="params">(T... elements)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elements.length &gt; <span class="number">0</span> ? elements[<span class="number">0</span>] : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@FunctionalInterface这是Java1.8 新增的注解，用于约定函数式接口。<br>函数式接口概念： 如果接口中只有一个抽象方法（可以包含多个默认方法或多个static方法），该接口称为函数式接口。函数式接口其存在的意义，主要是配合Lambda 表达式来使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adAttack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>在本例中，把数据库连接的工具类DBUtil改造成为注解的方式，来举例演示怎么自定义注解以及如何解析这些自定义注解。</p>
<p>首先创建一个注解JDBCConfig：</p>
<ol>
<li><p>创建注解类型的时候即不使用class也不使用interface,而是使用**<code>@interface</code>**</p>
</li>
<li><p>元注解<br><strong><code>@Target(&#123;METHOD,TYPE&#125;)</code></strong> 表示这个注解可以用用在类&#x2F;接口上，还可以用在方法上<br><strong><code>@Retention(RetentionPolicy.RUNTIME)</code></strong> 表示这是一个运行时注解，即运行起来之后，才获取注解中的相关信息，而不像基本注解如<a target="_blank" rel="noopener" href="https://how2j.cn/k/annotation/annotation-system/1060.html#step4028">@Override </a>那种不用运行，在编译时eclipse就可以进行相关工作的编译时注解。<br><strong><code>@Inherited</code></strong> 表示这个注解可以被子类继承<br><strong><code>@Documented</code></strong> 表示当执行javadoc的时候，本注解会生成相关文档</p>
</li>
<li><p>注解元素，这些注解元素就用于存放注解信息，在解析的时候获取出来</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.METHOD;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.TYPE;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Target(&#123;METHOD,TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JDBCConfig &#123;</span><br><span class="line">     String <span class="title function_">ip</span><span class="params">()</span>;</span><br><span class="line">     <span class="type">int</span> <span class="title function_">port</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">3306</span>;</span><br><span class="line">     String <span class="title function_">database</span><span class="params">()</span>;</span><br><span class="line">     String <span class="title function_">encoding</span><span class="params">()</span>;</span><br><span class="line">     String <span class="title function_">loginName</span><span class="params">()</span>;</span><br><span class="line">     String <span class="title function_">password</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> anno.JDBCConfig;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@JDBCConfig(ip = &quot;127.0.0.1&quot;, database = &quot;test&quot;, encoding = &quot;UTF-8&quot;, loginName = &quot;root&quot;, password = &quot;admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtil</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, NoSuchMethodException, SecurityException &#123;</span><br><span class="line">        <span class="comment">// 通过反射，获取这个DBUtil这个类上的注解对象</span></span><br><span class="line">        <span class="type">JDBCConfig</span> <span class="variable">config</span> <span class="operator">=</span> DBUtil.class.getAnnotation(JDBCConfig.class);</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> config.ip();</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> config.port();</span><br><span class="line">        <span class="type">String</span> <span class="variable">database</span> <span class="operator">=</span> config.database();</span><br><span class="line">        <span class="type">String</span> <span class="variable">encoding</span> <span class="operator">=</span> config.encoding();</span><br><span class="line">        <span class="type">String</span> <span class="variable">loginName</span> <span class="operator">=</span> config.loginName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> config.password();</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> String.format(<span class="string">&quot;jdbc:mysql://%s:%d/%s?characterEncoding=%s&quot;</span>, ip, port, database, encoding);</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, loginName, password);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException, SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> getConnection();</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li><p>@Target 表示这个注解能放在什么位置上，是只能放在类上？还是即可以放在方法上，又可以放在属性上。自定义注解@JDBCConfig这个注解上的@Target是：@Target({METHOD,TYPE})，表示他可以用在方法和类型上（类和接口），但是不能放在属性等其他位置。 可以选择的位置列表如</p>
<ul>
<li><code>ElementType.TYPE</code>：能修饰类、接口或枚举类型</li>
<li><code>ElementType.FIELD</code>：能修饰成员变量</li>
<li><code>ElementType.METHOD</code>：能修饰方法</li>
<li><code>ElementType.PARAMETER</code>：能修饰参数</li>
<li><code>ElementType.CONSTRUCTOR</code>：能修饰构造器</li>
<li><code>ElementType.LOCAL_VARIABLE</code>：能修饰局部变量</li>
<li><code>ElementType.ANNOTATION_TYPE</code>：能修饰注解</li>
<li><code>ElementType.PACKAGE</code>：能修饰包</li>
</ul>
</li>
<li><p>@Retention 表示生命周期，<a target="_blank" rel="noopener" href="https://how2j.cn/k/annotation/annotation-customize/1056.html#step4035">自定义注解@JDBCConfig</a> 上的值是 RetentionPolicy.RUNTIME, 表示可以在运行的时候依然可以使用。 @Retention可选的值有3个：</p>
<ul>
<li><strong><code>RetentionPolicy.SOURCE</code>：</strong> 注解只在源代码中存在，编译成class之后，就没了。<a target="_blank" rel="noopener" href="https://how2j.cn/k/annotation/annotation-system/1060.html#step4028">@Override </a>就是这种注解。</li>
<li><strong><code>RetentionPolicy.CLASS</code>：</strong> 注解在java文件编程成.class文件后，依然存在，但是运行起来后就没了。@Retention的默认值，即当没有显式指定@Retention的时候，就会是这种类型。</li>
<li><strong><code>RetentionPolicy.RUNTIME</code>：</strong> 注解在运行起来之后依然存在，程序可以通过反射获取这些信息，<a target="_blank" rel="noopener" href="https://how2j.cn/k/annotation/annotation-customize/1056.html#step4035">自定义注解@JDBCConfig</a> 就是这样。</li>
</ul>
</li>
<li><p>@Inherited 表示该注解具有继承性。如例，设计一个DBUtil的子类，其getConnection2方法，可以获取到父类DBUtil上的注解信息。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtilChild</span> <span class="keyword">extends</span> <span class="title class_">DBUtil</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, NoSuchMethodException, SecurityException &#123;</span><br><span class="line">        <span class="type">JDBCConfig</span> <span class="variable">config</span> <span class="operator">=</span> DBUtilChild.class.getAnnotation(JDBCConfig.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> config.ip();</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> config.port();</span><br><span class="line">        <span class="type">String</span> <span class="variable">database</span> <span class="operator">=</span> config.database();</span><br><span class="line">        <span class="type">String</span> <span class="variable">encoding</span> <span class="operator">=</span> config.encoding();</span><br><span class="line">        <span class="type">String</span> <span class="variable">loginName</span> <span class="operator">=</span> config.loginName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> config.password();</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> String.format(<span class="string">&quot;jdbc:mysql://%s:%d/%s?characterEncoding=%s&quot;</span>, ip, port, database, encoding);</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, loginName, password);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException, SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> getConnection2();</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>@Documented 如图所示， 在用javadoc命令生成API文档后，DBUtil的文档里会出现该注解说明。</p>
</li>
<li><p>@Repeatable (java1.8 新增)，</p>
</li>
<li><p>当没有@Repeatable修饰的时候，注解在同一个位置，只能出现一次，如例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JDBCConfig(ip = &quot;127.0.0.1&quot;, database = &quot;test&quot;, encoding = &quot;UTF-8&quot;, loginName = &quot;root&quot;, password = &quot;admin&quot;)</span></span><br><span class="line"><span class="meta">@JDBCConfig(ip = &quot;127.0.0.1&quot;, database = &quot;test&quot;, encoding = &quot;UTF-8&quot;, loginName = &quot;root&quot;, password = &quot;admin&quot;)</span></span><br></pre></td></tr></table></figure>

<p>重复做两次就会报错了。<br>使用<code>@Repeatable</code>之后，再配合一些其他动作，就可以在同一个地方使用多次了。</p>
</li>
</ul>
<p><strong>案例：</strong></p>
<p>比如在练习<a target="_blank" rel="noopener" href="https://how2j.cn/k/io/io-filecopy-foldercopy/344.html#step2491">练习-查找文件内容</a> 中有一个要求，即查找文件后缀名是.java的文件，我们把部分代码修改为注解，并且使用@Repeatable 这个元注解来表示，文件后缀名的范围可以是java, html, css, js 等等。</p>
<p>为了紧凑起见，把注解作为内部类的形式放在一个文件里。</p>
<ol>
<li>注解FileTypes，其value()返回一个FileType数组。</li>
<li>注解FileType，其@Repeatable的值采用FileTypes。</li>
<li>运用注解：在work方法上重复使用多次@FileType注解。</li>
<li>解析注解： 在work方法内，通过反射获取到本方法上的FileType类型的注解数组，然后遍历本数组。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindFiles</span> &#123;</span><br><span class="line">    <span class="meta">@Target( METHOD)</span></span><br><span class="line">    <span class="meta">@Retention( RetentionPolicy.RUNTIME )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> FileTypes &#123;</span><br><span class="line">        FileType[] value();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Target(  METHOD )</span></span><br><span class="line">    <span class="meta">@Retention( RetentionPolicy.RUNTIME )</span></span><br><span class="line">    <span class="meta">@Repeatable( FileTypes.class )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> FileType &#123;</span><br><span class="line">        String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@FileType( &quot;.java&quot; )</span></span><br><span class="line">    <span class="meta">@FileType( &quot;.html&quot; )</span></span><br><span class="line">    <span class="meta">@FileType( &quot;.css&quot; )</span></span><br><span class="line">    <span class="meta">@FileType( &quot;.js&quot; )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileType[] fileTypes= <span class="built_in">this</span>.getClass().getMethod(<span class="string">&quot;work&quot;</span>).getAnnotationsByType(FileType.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;将从如下后缀名的文件中查找文件内容&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (FileType fileType : fileTypes) &#123;</span><br><span class="line">                System.out.println(fileType.value());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;查找过程略。。。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | SecurityException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FindFiles</span>().work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="仿Hibernate注解"><a href="#仿Hibernate注解" class="headerlink" title="仿Hibernate注解"></a>仿Hibernate注解</h3><p><a target="_blank" rel="noopener" href="https://how2j.cn/k/annotation/annotation-like-hibernate/1058.html">注解系列教材 （五）- 仿Hibernate注解 (how2j.cn)</a></p>
<h1 id="JAVA应用"><a href="#JAVA应用" class="headerlink" title="JAVA应用"></a>JAVA应用</h1><h2 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ol>
<li>基于类的名称获取日志对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(TestLog4j.class);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>进行默认配置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BasicConfigurator.configure();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置日志输出级别</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.setLevel(Level.DEBUG);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>进行不同级别的日志输出</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.trace(<span class="string">&quot;跟踪信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&quot;调试信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">&quot;输出信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">logger.warn(<span class="string">&quot;警告信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">logger.error(<span class="string">&quot;错误信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">logger.fatal(<span class="string">&quot;致命信息&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Thread.sleep(1000); 是为了便于观察前后日志输出的时间差</p>
<h3 id="配置文件设置Log4j"><a href="#配置文件设置Log4j" class="headerlink" title="配置文件设置Log4j"></a>配置文件设置Log4j</h3><p>方式不同，采用指定配置文件</p>
<ul>
<li>log4j.properties</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 设置日志输出的等级为debug,低于debug就不会输出了</span><br><span class="line"># 设置日志输出到两种地方，分别叫做 stdout和 R</span><br><span class="line">log4j.rootLogger=debug, stdout, R</span><br><span class="line">    </span><br><span class="line"># 第一个地方stdout, 输出到控制台</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">    </span><br><span class="line"># 输出格式是 %5p [%t] (%F:%L) - %m%n  </span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] (%F:%L) - %m%n</span><br><span class="line"></span><br><span class="line"># 第二个地方R, 以滚动的方式输出到文件，文件名是example.log,文件最大100k, 最多滚动<span class="number">5</span>个文件</span><br><span class="line">log4j.appender.R=org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.R.File=example.log</span><br><span class="line">log4j.appender.R.MaxFileSize=100KB</span><br><span class="line">log4j.appender.R.MaxBackupIndex=<span class="number">5</span></span><br><span class="line">    </span><br><span class="line"># 输出格式是 %p %t %c - %m%n</span><br><span class="line">log4j.appender.R.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n</span><br></pre></td></tr></table></figure>

<blockquote>
<p>log4j日志输出格式一览：<br>    <code>%c</code> 输出日志信息所属的类的全名<br>    <code>%d </code>输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy-MM-dd HH:mm:ss }，输出类似：2002-10-18- 22：10：28<br>    <code>%f </code>输出日志信息所属的类的类名<br>    <code>%l</code> 输出日志事件的发生位置，即输出日志信息的语句处于它所在的类的第几行<br>    <code>%m</code> 输出代码中指定的信息，如log(message)中的message<br>    <code>%n</code> 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”<br>    <code>%p</code> 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL。如果是调用debug()输出的，则为DEBUG，依此类推<br>    <code>%r </code>输出自应用启动到输出该日志信息所耗费的毫秒数<br>    <code>%t</code> 输出产生该日志事件的线程名</p>
<p>所以：<br><code>%5p [%t] (%F:%L) - %m%n </code>就表示<br>宽度是5的优先等级 线程名称 (文件名:行号) - 信息 回车换行</p>
</blockquote>
<ul>
<li>测试类TestLog4j<ul>
<li>然后修改TestLog4j，并运行。 有两个效果<ol>
<li>输出在控制台，并且格式有所变化，如图所示，会显示是哪个类的哪一行输出的信息</li>
<li>不仅仅在控制台有输出，在把日志输出到了 E:\project\log4j\example.log 这个位置</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141711516.png" alt="TestLog4j"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> log4j;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.PropertyConfigurator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLog4j</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(TestLog4j.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// Log4j的配置方式按照log4j.properties中的设置进行</span></span><br><span class="line">        PropertyConfigurator.configure(<span class="string">&quot;e:\\project\\log4j\\src\\log4j.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;跟踪信息&quot;</span>);</span><br><span class="line">            logger.debug(<span class="string">&quot;调试信息&quot;</span>);</span><br><span class="line">            logger.info(<span class="string">&quot;输出信息&quot;</span>);</span><br><span class="line">            logger.warn(<span class="string">&quot;警告信息&quot;</span>);</span><br><span class="line">            logger.error(<span class="string">&quot;错误信息&quot;</span>);</span><br><span class="line">            logger.fatal(<span class="string">&quot;致命信息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="xml形式配置Log4j"><a href="#xml形式配置Log4j" class="headerlink" title="xml形式配置Log4j"></a>xml形式配置Log4j</h3><ul>
<li>log4j.xml</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE log4j:configuration PUBLIC <span class="string">&quot;-//log4j/log4j Configuration//EN&quot;</span> <span class="string">&quot;log4j.dtd&quot;</span>&gt;</span><br><span class="line">  </span><br><span class="line">&lt;log4j:configuration xmlns:log4j=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span><br><span class="line">      </span><br><span class="line">    &lt;appender name=<span class="string">&quot;STDOUT&quot;</span> class=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span><br><span class="line">       &lt;layout class=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span><br><span class="line">          &lt;param name=<span class="string">&quot;ConversionPattern&quot;</span> value=<span class="string">&quot;%d %-5p %c.%M:%L - %m%n&quot;</span>/&gt;</span><br><span class="line">       &lt;/layout&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;!-- specify the logging level <span class="keyword">for</span> loggers from other libraries --&gt;</span><br><span class="line">    &lt;logger name=<span class="string">&quot;com.opensymphony&quot;</span>&gt;</span><br><span class="line">        &lt;level value=<span class="string">&quot;ERROR&quot;</span> /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;logger name=<span class="string">&quot;org.apache&quot;</span>&gt;</span><br><span class="line">         &lt;level value=<span class="string">&quot;ERROR&quot;</span> /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;logger name=<span class="string">&quot;org.hibernate&quot;</span>&gt;</span><br><span class="line">         &lt;level value=<span class="string">&quot;ERROR&quot;</span> /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    </span><br><span class="line">   &lt;!-- <span class="keyword">for</span> all other loggers log only debug and above log messages --&gt;</span><br><span class="line">     &lt;root&gt;</span><br><span class="line">        &lt;priority value=<span class="string">&quot;ERROR&quot;</span>/&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span><br><span class="line">     &lt;/root&gt;</span><br><span class="line">      </span><br><span class="line">&lt;/log4j:configuration&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> log4j;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.PropertyConfigurator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLog4j</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(TestLog4j.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        PropertyConfigurator.configure(<span class="string">&quot;e:\\project\\log4j\\src\\log4j.xml&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;跟踪信息&quot;</span>);</span><br><span class="line">            logger.debug(<span class="string">&quot;调试信息&quot;</span>);</span><br><span class="line">            logger.info(<span class="string">&quot;输出信息&quot;</span>);</span><br><span class="line">            logger.warn(<span class="string">&quot;警告信息&quot;</span>);</span><br><span class="line">            logger.error(<span class="string">&quot;错误信息&quot;</span>);</span><br><span class="line">            logger.fatal(<span class="string">&quot;致命信息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="junit白盒测试"><a href="#junit白盒测试" class="headerlink" title="junit白盒测试"></a>junit白盒测试</h2><h3 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h3><p>@Before @After 也是常见的测试框架注解，分别用来在测试开始之前做的事情，和结束之后做的事情。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141711480.png" alt="before &amp; after"></p>
<p>关于 Assert的用法，除了举例里的判断数字是否相等，还可以判断boolean, 是否是null ，是否是相同对象等等常见逻辑。<br><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141711795.png" alt="Assert"></p>
<h2 id="hutool"><a href="#hutool" class="headerlink" title="hutool"></a>hutool</h2><h2 id="jsoup——html解析"><a href="#jsoup——html解析" class="headerlink" title="jsoup——html解析"></a>jsoup——html解析</h2><p>更多关于 jsoup的资料请查阅 jsoup 官方网站： <a target="_blank" rel="noopener" href="https://jsoup.org/">https://jsoup.org/</a></p>
<h3 id="HTML-amp-xml"><a href="#HTML-amp-xml" class="headerlink" title="HTML&amp;xml"></a>HTML&amp;xml</h3><ul>
<li>xml 是<strong>可扩展标记语言</strong>的缩写： Extensible Markup Language。</li>
</ul>
<p>比如做 web 应用开发，需要配置 web.xml，就是个典型的 xml文件。<br>它里面就有这些元素： web-app, servlet, servlet-name, servlet-class 这些。</p>
<p><strong>注：</strong> 什么是元素？ 像这样的格式就是一个元素 ： &lt;元素名称&gt; 元素内容 &lt;&#x2F;元素名称&gt;。 比如： <servlet-name>HelloServlet</servlet-name> 就是 servlet-name 元素。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>html</strong> 是 <strong>HyperText Markup Language</strong>的缩写,<strong>超文本标记语言</strong>。</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>html 可以简单看成是 xml 的一个子集。 html 用的都是一些预先定义的元素，如 <html>, <a>, <body>, <table> 。 而 xml 什么元素都可以自定义： 如 <a> , <b>, <aabb> 。</aabb></b></a></table><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/tzy13755126023/BLOG_SOURCE/theme_f/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></a></html></p>
<h3 id="jsoup"><a href="#jsoup" class="headerlink" title="jsoup"></a>jsoup</h3><h4 id="xml解析"><a href="#xml解析" class="headerlink" title="xml解析"></a>xml解析</h4><p>既然 html 是 xml 的子集，那么解析起来就和 xml一样了，下面我们就来谈 xml的解析就可以了。</p>
<ol>
<li>把文本解析成 Document 对象， Document 对象就代表整个 xml 文档。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(html);</span><br></pre></td></tr></table></figure>

<p>​	2. 获取所有的 p 元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Elements as= doc.getElementsByTag(<span class="string">&quot;p&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​	3. 遍历 所有的 p 元素 （这里其实只有一个）， 打印其内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Element e : as) &#123;</span><br><span class="line">	System.out.println(e.text());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141711643.png" alt="示例"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.how2j.jsoup;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello HTML&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(html);</span><br><span class="line">         </span><br><span class="line">        Elements as= doc.getElementsByTag(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element e : as) &#123;</span><br><span class="line">            System.out.println(e.text());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取文档"><a href="#获取文档" class="headerlink" title="获取文档"></a>获取文档</h4><p>获取Document对象的方式有多种，常见的就是基于字符串，文件，网页地址。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141711549.png" alt="代码演示"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.how2j.jsoup;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">html1</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello HTML&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc1</span> <span class="operator">=</span> Jsoup.parse(html1);</span><br><span class="line">        System.out.println(<span class="string">&quot;基于字符串方式得到的 Document:\r\n&quot;</span>+ doc1);</span><br><span class="line">         </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f.exists()) &#123;</span><br><span class="line">            <span class="type">Document</span> <span class="variable">doc2</span> <span class="operator">=</span> Jsoup.parse(f,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;基于文件方式得到的 Document:\r\n&quot;</span>+ doc2);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://www.baidu.com&quot;</span>;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc3</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">URL</span>(url),<span class="number">5000</span>); <span class="comment">//超过5秒就报错</span></span><br><span class="line">        System.out.println(<span class="string">&quot;基于URL方式得到的 Document:\r\n&quot;</span>+ doc3);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141711929.png" alt="准备 html 内容"></p>
<p>获取元素比较常见的几种方式： 通过id, 标签或者类名称获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.how2j.jsoup;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!f.exists())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(f,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//通过id获取</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">e</span> <span class="operator">=</span> doc.getElementById(<span class="string">&quot;productName&quot;</span>);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//通过标签获取</span></span><br><span class="line">        Elements es;</span><br><span class="line">        es = doc.getElementsByTag(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        show(es);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//通过类名称获取</span></span><br><span class="line">        es = doc.getElementsByClass(<span class="string">&quot;RightBox&quot;</span>);</span><br><span class="line">        show(es);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//通过属性获取</span></span><br><span class="line">        es = doc.getElementsByAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        show(es);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Elements es)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Element e : es) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取内容和文本"><a href="#获取内容和文本" class="headerlink" title="获取内容和文本"></a>获取内容和文本</h4><p><code>c.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;c1 c2&quot;</span>&gt;</span>let us<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;how2j.cn&quot;</span>&gt;</span>study java<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.how2j.jsoup;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;c.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!f.exists())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(f,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Element</span> <span class="variable">e</span> <span class="operator">=</span>doc.getElementById(<span class="string">&quot;d1&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//获取属性</span></span><br><span class="line">        System.out.println(e.attr(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//获取所有属性</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(e.attributes());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//获取id</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(e.id());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//获取类名称</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(e.className());</span><br><span class="line">        <span class="comment">//获取所有类名称</span></span><br><span class="line">        System.out.println(e.classNames());</span><br><span class="line">        <span class="comment">//获取文本</span></span><br><span class="line">        System.out.println(e.text());</span><br><span class="line">        <span class="comment">//获取html</span></span><br><span class="line">        System.out.println(e.html());</span><br><span class="line">        <span class="comment">//获取外html</span></span><br><span class="line">        System.out.println(e.outerHtml());</span><br><span class="line">        <span class="comment">//获取标签信息</span></span><br><span class="line">        System.out.println(e.tagName());</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择器语法"><a href="#选择器语法" class="headerlink" title="选择器语法"></a>选择器语法</h4><p>在选择元素的时候，除了使用方法名如 getElementById 这样的外，还可以用 选择器语法来选择。 操作起来就像 jquery了，比如getElementById 就可以写成是 select(“#id”)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.how2j.jsoup;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Document doc;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!f.exists())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        doc = Jsoup.parse(f,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//像 jquery 那样的选择器语法</span></span><br><span class="line">        show(<span class="string">&quot;选择所有的超链&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;根据id进行选择&quot;</span>, <span class="string">&quot;#logocover&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;根据class进行选择&quot;</span>, <span class="string">&quot;.clearfloat&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;根据属性进行选择&quot;</span>, <span class="string">&quot;[href]&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;有属性以tar开头&quot;</span>, <span class="string">&quot;[^tar]&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;根据属性值选择&quot;</span>, <span class="string">&quot;[type=&#x27;application/javascript&#x27;]&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;属性值以什么开头&quot;</span>, <span class="string">&quot;[href^=&#x27;http://www.oracle.com&#x27;]&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;属性值以什么结尾&quot;</span>, <span class="string">&quot;[href$=&#x27;index.html&#x27;]&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;属性值包含什么&quot;</span>, <span class="string">&quot;[href*=&#x27;download&#x27;]&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String text, String selector)</span> &#123;</span><br><span class="line">        show(text,selector,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String text, String selector, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="type">Elements</span> <span class="variable">es</span> <span class="operator">=</span>doc.select(selector);</span><br><span class="line">        <span class="keyword">if</span>(es.size()&gt;<span class="number">1</span>)</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;%s - 使用的选择器是: \&quot;%s\&quot; \t (最多显示 %d 条 )&quot;</span>, text,selector,limit));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;%s - 使用的选择器是: \&quot;%s\&quot;&quot;</span>, text,selector));</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Element e : es) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i++&lt;limit)</span><br><span class="line">                System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改属性和内容"><a href="#修改属性和内容" class="headerlink" title="修改属性和内容"></a>修改属性和内容</h4><p>jsoup 除了可以解析 html&#x2F;xml 外，还可以进行修改行为。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141711516.png" alt="Test.java"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.how2j.jsoup;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Document doc;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!f.exists())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        doc = Jsoup.parse(f,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        System.out.println(doc);</span><br><span class="line">         </span><br><span class="line">        <span class="type">Element</span> <span class="variable">e</span> <span class="operator">=</span> doc.select(<span class="string">&quot;p&quot;</span>).first();</span><br><span class="line">        e.attr(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;class1&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        e.appendText(<span class="string">&quot; Hello JSoup&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(doc);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><p><a target="_blank" rel="noopener" href="https://projectlombok.org/features/all">https://projectlombok.org/features/all</a></p>
<ul>
<li><code>@Data</code> 注解会为类的所有属性自动生成setter&#x2F;getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。</li>
<li><code>@AllArgsConstructor @NoArgsConstructor</code>：分别提供全参构造方法和无参构造方法</li>
<li><code>@Getter/@Setter</code> ：如果觉得@Data太过粗暴不够精细，可以使用@Getter&#x2F;@Setter注解，此注解在属性上，可以为相应的属性自动生成Getter&#x2F;Setter方法</li>
<li><code>@ToString</code>类使用@ToString注解，Lombok会生成一个toString()方法，默认情况下，会输出类名、所有属性（会按照属性定义顺序），用逗号来分割。通过exclude属性指定忽略字段不输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 忽略 id 字段不输出</span><br><span class="line"><span class="meta">@ToString(exclude = &#123;&quot;id&quot;&#125;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Builder</code>实例化和设置属性值的风格变了。。。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//传统方式</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        h1.setId(<span class="number">1</span>);</span><br><span class="line">        h1.setName(<span class="string">&quot;garren&quot;</span>);</span><br><span class="line">        System.out.println(h1);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//builder 方式</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h2</span> <span class="operator">=</span>Hero.builder().id(<span class="number">1</span>).name(<span class="string">&quot;gareen&quot;</span>).build();</span><br><span class="line">        System.out.println(h2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="J2EE-企业级应用开发"><a href="#J2EE-企业级应用开发" class="headerlink" title="J2EE-企业级应用开发"></a>J2EE-企业级应用开发</h1><h2 id="TOMCAT"><a href="#TOMCAT" class="headerlink" title="TOMCAT"></a>TOMCAT</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>不使用tomcat访问html</li>
</ul>
<p>不使用tomcat也可以打开html页面，但是可以在浏览器的地址里看到 <strong>file:d:&#x2F;test.html</strong> 这样的格式，是通过打开本地文件的形式打开的</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141711470.png" alt="不使用tomcat访问html"></p>
<p>但是我们平时上网看到的html网址一般都是:<br><a target="_blank" rel="noopener" href="http://12306.com/index.html">http://12306.com/index.html</a> 这样的形式，这是因为有web服务器的存在。</p>
<ul>
<li>使用tomcat后，访问html</li>
</ul>
<p>使用tomcat后，可以这样 <strong>127.0.0.1:8080&#x2F;test.html</strong> 像访问一个网站似的，访问一个html文件了。</p>
<p>这是因为tomcat本身是一个web 服务器，test.html部署在了这个web服务器上，所以就可以这样访问了。</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141711938.png" alt="使用tomcat后，访问html"></p>
<ul>
<li>启动Tomcat</li>
</ul>
<p>首先右边下载 tomcat.rar</p>
<p>解压在d:盘，随便你解压在哪里，一般解压在一个好找的地方，因为后续的学习需要频繁的启动它</p>
<p>然后运行批处理文件： <strong>D:&#x2F;tomcat&#x2F;bin&#x2F;startup.bat</strong></p>
<p>最后如果你看到Server startup in xxx ms，就表明启动成功了。</p>
<p><strong>注</strong> Tomcat启动之后，不要关闭。。。。 关闭了就不能访问了。。。。</p>
<p>为了正常运行，请务必确认当前java环境是JDK1.8.<br>在命令行中输入<strong>java -version</strong>进行校验<br>参考JDK下载以及配置办法： <a target="_blank" rel="noopener" href="https://how2j.cn/k/helloworld/helloworld-jdk/141.html">JDK1.8以及更高版本下载和环境变量配置</a><br>JDK9 不够稳定，特别是Tomcat7 <strong>无法在JDK9 中运行</strong>，请勿使用JDK9运行本Tomcat7，请切换至JDK8，谢谢</p>
<ul>
<li>如何部署网页</li>
</ul>
<p>部署一个功能完备的web应用 有很多种方式，但是如果只是部署一个test.html，很简单</p>
<p>把test.html 复制到 <strong>D:\tomcat\webapps\ROOT</strong> 目录下</p>
<p>就可以通过 <a target="_blank" rel="noopener" href="http://127.0.0.1:8080/test.html">http://127.0.0.1:8080/test.html</a> 访问了</p>
<p><img src="/img/loading.gif" data-original="https://huaflying.oss-cn-hangzhou.aliyuncs.com/JavaStudy/202310141711404.png" alt="如何部署网页"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">HUA</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2020/10/23/how2j/">http://example.com/2020/10/23/how2j/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">阿华</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/page4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><img class="prev-cover" src="/img/loading.gif" data-original="/img/page5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HUA</div><div class="author-info__description">不要放弃</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/TINGTING-GIT" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromld=45&amp;fromSubld=1&amp;subcmd=all&amp;uin=2164277973&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:2164277973@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div></div><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople1.js"></script><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/zdog.dist.js"></script><script id="rendered-js" src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">控制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%BB%93%E6%9D%9F%E5%A4%96%E9%83%A8%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">Java结束外部循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E9%9A%8F%E6%9C%BA%E6%95%B0-Math-floor-Math-random-max-min-1-min"><span class="toc-number">1.2.1.</span> <span class="toc-text">理解随机数 Math.floor(Math.random() * (max - min + 1) + min)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">复制数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">初始化二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">1.2.4.</span> <span class="toc-text">Arrays类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.3.1.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">属性初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.3.4.</span> <span class="toc-text">枚举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">1.4.</span> <span class="toc-text">接口与继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E8%A1%8C%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">编译类型和运行类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E9%9A%90%E8%97%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">JAVA中的方法隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E4%B8%AD%E7%9A%84super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.4.3.</span> <span class="toc-text">JAVA中的super关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E4%B8%AD%E7%9A%84%E8%B6%85%E7%B1%BBObject"><span class="toc-number">1.4.4.</span> <span class="toc-text">JAVA中的超类Object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.4.5.</span> <span class="toc-text">JAVA抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.4.6.</span> <span class="toc-text">JAVA内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.7.</span> <span class="toc-text">默认方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UML"><span class="toc-number">1.5.</span> <span class="toc-text">UML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.6.</span> <span class="toc-text">数字与字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.1.</span> <span class="toc-text">字符串转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">Math类常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">1.6.3.</span> <span class="toc-text">格式化输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6"><span class="toc-number">1.6.4.</span> <span class="toc-text">字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.6.5.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer"><span class="toc-number">1.6.6.</span> <span class="toc-text">StringBuffer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E4%B8%AD%E7%BA%A7"><span class="toc-number">2.</span> <span class="toc-text">JAVA中级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">2.1.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.1.</span> <span class="toc-text">文件对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E7%9A%84%E6%B5%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">JAVA的流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">2.1.3.</span> <span class="toc-text">字节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%B5%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.4.</span> <span class="toc-text">关闭流的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">2.1.5.</span> <span class="toc-text">字符流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.6.</span> <span class="toc-text">I&#x2F;O中文问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B5%81"><span class="toc-number">2.1.7.</span> <span class="toc-text">缓存流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">2.1.8.</span> <span class="toc-text">数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-number">2.1.9.</span> <span class="toc-text">对象流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O-System-in"><span class="toc-number">2.1.10.</span> <span class="toc-text">I&#x2F;O System.in</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">2.2.</span> <span class="toc-text">集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">2.2.1.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">List接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList"><span class="toc-number">2.2.2.</span> <span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-Deque"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">双向链表 - Deque</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97-Queue"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">队列 - Queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E4%B8%8ELinkedList%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.3.</span> <span class="toc-text">ArrayList与LinkedList区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.2.4.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">二叉树概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%92%E5%BA%8F-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">二叉树排序-插入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%92%E5%BA%8F-%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">二叉树排序-遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">2.2.5.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hashMap%E5%92%8ChashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">hashMap和hashTable的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet"><span class="toc-number">2.2.6.</span> <span class="toc-text">HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-1"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet%E5%92%8CHashMap%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">HashSet和HashMap的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection"><span class="toc-number">2.2.7.</span> <span class="toc-text">Collection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections"><span class="toc-number">2.2.8.</span> <span class="toc-text">Collections</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.9.</span> <span class="toc-text">HashMap 的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8-%E4%B9%8B%E5%89%8D"><span class="toc-number">2.2.9.1.</span> <span class="toc-text">JDK1.8 之前</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8-%E4%B9%8B%E5%90%8E"><span class="toc-number">2.2.9.2.</span> <span class="toc-text">JDK1.8 之后</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">2.2.10.</span> <span class="toc-text">比较器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Comparator"><span class="toc-number">2.2.10.1.</span> <span class="toc-text">Comparator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Comparable"><span class="toc-number">2.2.10.2.</span> <span class="toc-text">Comparable</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.11.</span> <span class="toc-text">聚合操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">2.3.1.</span> <span class="toc-text">通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#extends"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">? extends</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">? super</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">泛型通配符?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">泛型转型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda"><span class="toc-number">2.4.</span> <span class="toc-text">Lambda</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">匿名类方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.2.</span> <span class="toc-text">匿名方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">2.4.3.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.4.4.</span> <span class="toc-text">Lambda 表达式实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.4.5.</span> <span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">2.4.6.</span> <span class="toc-text">方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">案例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C-1"><span class="toc-number">2.4.7.</span> <span class="toc-text">聚合操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream%E5%92%8C%E7%AE%A1%E9%81%93%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.7.1.</span> <span class="toc-text">Stream和管道的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E6%BA%90"><span class="toc-number">2.4.7.2.</span> <span class="toc-text">管道源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.7.3.</span> <span class="toc-text">中间操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.7.4.</span> <span class="toc-text">结束操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.5.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">创建多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">继承Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">实现Runnable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="toc-number">2.5.2.3.</span> <span class="toc-text">匿名类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.3.</span> <span class="toc-text">常见线程方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#join-%E5%8A%A0%E5%85%A5%E5%88%B0%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E4%B8%AD"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">join 加入到当前线程中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setPriority-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">setPriority 线程优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setDaemon-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.5.3.3.</span> <span class="toc-text">setDaemon 守护线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.5.4.</span> <span class="toc-text">volatile 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">如何禁止指令重排序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B9%88"><span class="toc-number">2.5.4.2.</span> <span class="toc-text">volatile 可以保证原子性么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">2.5.5.</span> <span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E5%90%8C%E6%AD%A5%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5"><span class="toc-number">2.5.5.1.</span> <span class="toc-text">synchronized 同步对象概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.5.5.2.</span> <span class="toc-text">synchronized 和 volatile 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8synchronized-%E8%A7%A3%E5%86%B3%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.5.3.</span> <span class="toc-text">使用synchronized 解决同步问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8hero%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%90%8C%E6%AD%A5%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89"><span class="toc-number">2.5.5.4.</span> <span class="toc-text">使用hero对象作为同步对象（同步代码块）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.5.5.</span> <span class="toc-text">修饰方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%B1%BB-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">2.5.5.6.</span> <span class="toc-text">修饰类 线程安全的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">2.5.5.7.</span> <span class="toc-text">把非线程安全的集合转换为线程安全</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">2.5.6.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E2%80%94%E2%80%94wait%E3%80%81notify"><span class="toc-number">2.5.7.</span> <span class="toc-text">交互——wait、notify</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8wait%E5%92%8Cnotify%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E4%BA%A4%E4%BA%92"><span class="toc-number">2.5.7.1.</span> <span class="toc-text">使用wait和notify进行线程交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ewait%E3%80%81notify%E5%92%8CnotifyAll"><span class="toc-number">2.5.7.2.</span> <span class="toc-text">关于wait、notify和notifyAll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep-%E6%96%B9%E6%B3%95%E5%92%8C-wait-%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-number">2.5.7.3.</span> <span class="toc-text">sleep() 方法和 wait() 方法对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-wait-%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%9C%A8-Thread-%E4%B8%AD%EF%BC%9F"><span class="toc-number">2.5.7.4.</span> <span class="toc-text">为什么 wait() 方法不定义在 Thread 中？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.5.8.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">2.5.8.1.</span> <span class="toc-text">线程池设计思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.5.8.2.</span> <span class="toc-text">开发一个自定义线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8java%E8%87%AA%E5%B8%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.5.8.3.</span> <span class="toc-text">使用java自带线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.5.9.</span> <span class="toc-text">Lock对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.5.9.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#trylock%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.9.2.</span> <span class="toc-text">trylock方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BA%A4%E4%BA%92"><span class="toc-number">2.5.9.3.</span> <span class="toc-text">线程交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock%E5%92%8Csynchronized%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.9.4.</span> <span class="toc-text">Lock和synchronized的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E8%AE%BF%E9%97%AE"><span class="toc-number">2.5.10.</span> <span class="toc-text">原子访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">2.5.10.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicInteger%EF%BC%88%E5%8E%9F%E5%AD%90%E7%B1%BB%EF%BC%89"><span class="toc-number">2.5.10.2.</span> <span class="toc-text">AtomicInteger（原子类）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">2.5.10.3.</span> <span class="toc-text">测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC"><span class="toc-number">2.6.</span> <span class="toc-text">JDBC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Statement"><span class="toc-number">2.6.1.</span> <span class="toc-text">使用Statement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8PreparedStatement"><span class="toc-number">2.6.2.</span> <span class="toc-text">使用PreparedStatement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execute%E4%B8%8EexecuteUpdate%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.3.</span> <span class="toc-text">execute与executeUpdate的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C"><span class="toc-number">2.6.4.</span> <span class="toc-text">特殊操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%87%AA%E5%A2%9E%E9%95%BFid"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">获取自增长id</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%A1%A8%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">2.6.4.2.</span> <span class="toc-text">获取表的元数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.6.5.</span> <span class="toc-text">JDBC事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">2.6.5.1.</span> <span class="toc-text">概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">2.6.6.</span> <span class="toc-text">数据库连接池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8E%9F%E7%90%86-%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.6.1.</span> <span class="toc-text">数据库连接池原理-传统方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8E%9F%E7%90%86-%E4%BD%BF%E7%94%A8%E6%B1%A0"><span class="toc-number">2.6.6.2.</span> <span class="toc-text">数据库连接池原理-使用池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConnectionPool%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.6.6.3.</span> <span class="toc-text">ConnectionPool构造方法和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="toc-number">2.6.6.4.</span> <span class="toc-text">测试类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2"><span class="toc-number">2.7.</span> <span class="toc-text">图形界面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">2.8.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80-%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.8.1.</span> <span class="toc-text">IP地址 端口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-number">2.8.1.1.</span> <span class="toc-text">IP地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.8.1.2.</span> <span class="toc-text">端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAIP"><span class="toc-number">2.8.1.3.</span> <span class="toc-text">获取本机IP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8java-%E6%89%A7%E8%A1%8Cping%E5%91%BD%E4%BB%A4"><span class="toc-number">2.8.1.4.</span> <span class="toc-text">使用java 执行ping命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket"><span class="toc-number">2.8.2.</span> <span class="toc-text">Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.8.2.1.</span> <span class="toc-text">建立连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E5%8F%91%E6%95%B0%E5%AD%97"><span class="toc-number">2.8.2.2.</span> <span class="toc-text">收发数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E5%8F%91%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.8.2.3.</span> <span class="toc-text">收发字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%81%8A%E5%A4%A9"><span class="toc-number">2.8.3.</span> <span class="toc-text">多线程聊天</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF"><span class="toc-number">2.8.3.1.</span> <span class="toc-text">同时收发消息</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E9%AB%98%E7%BA%A7"><span class="toc-number">3.</span> <span class="toc-text">JAVA高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.1.</span> <span class="toc-text">获取类对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Class%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">获取Class的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDBC%E9%87%8D%E7%82%B9-Class-forName%E5%AF%BC%E8%87%B4%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">JDBC重点(Class.forName导致类加载)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8A%E5%8A%A0synchronized%EF%BC%8C%E5%90%8C%E6%AD%A5%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">在静态方法上加synchronized，同步对象是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.2.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">3.1.3.</span> <span class="toc-text">访问属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getField%E5%92%8CgetDeclaredField%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">getField和getDeclaredField的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.4.</span> <span class="toc-text">调用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.5.</span> <span class="toc-text">构造方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.2.1.</span> <span class="toc-text">基本内置注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.2.2.</span> <span class="toc-text">自定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.2.3.</span> <span class="toc-text">元注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BFHibernate%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.2.4.</span> <span class="toc-text">仿Hibernate注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E5%BA%94%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">JAVA应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Log4j"><span class="toc-number">4.1.</span> <span class="toc-text">Log4j</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AELog4j"><span class="toc-number">4.1.2.</span> <span class="toc-text">配置文件设置Log4j</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xml%E5%BD%A2%E5%BC%8F%E9%85%8D%E7%BD%AELog4j"><span class="toc-number">4.1.3.</span> <span class="toc-text">xml形式配置Log4j</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#junit%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">4.2.</span> <span class="toc-text">junit白盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B"><span class="toc-number">4.2.1.</span> <span class="toc-text">入门教程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hutool"><span class="toc-number">4.3.</span> <span class="toc-text">hutool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jsoup%E2%80%94%E2%80%94html%E8%A7%A3%E6%9E%90"><span class="toc-number">4.4.</span> <span class="toc-text">jsoup——html解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML-amp-xml"><span class="toc-number">4.4.1.</span> <span class="toc-text">HTML&amp;xml</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsoup"><span class="toc-number">4.4.2.</span> <span class="toc-text">jsoup</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#xml%E8%A7%A3%E6%9E%90"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">xml解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E6%A1%A3"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">获取文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">获取元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9%E5%92%8C%E6%96%87%E6%9C%AC"><span class="toc-number">4.4.2.4.</span> <span class="toc-text">获取内容和文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">4.4.2.5.</span> <span class="toc-text">选择器语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7%E5%92%8C%E5%86%85%E5%AE%B9"><span class="toc-number">4.4.2.6.</span> <span class="toc-text">修改属性和内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lombok"><span class="toc-number">4.5.</span> <span class="toc-text">Lombok</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#J2EE-%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91"><span class="toc-number">5.</span> <span class="toc-text">J2EE-企业级应用开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TOMCAT"><span class="toc-number">5.1.</span> <span class="toc-text">TOMCAT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">简介</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/20/%E4%BD%8D%E8%BF%90%E7%AE%97/" title="位运算"><img src="/img/loading.gif" data-original="/img/page4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="位运算"/></a><div class="content"><a class="title" href="/2023/11/20/%E4%BD%8D%E8%BF%90%E7%AE%97/" title="位运算">位运算</a><time datetime="2023-11-20T10:17:54.000Z" title="发表于 2023-11-20 18:17:54">2023-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/18/Vue3/" title="Vue3"><img src="/img/loading.gif" data-original="/img/page5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue3"/></a><div class="content"><a class="title" href="/2023/11/18/Vue3/" title="Vue3">Vue3</a><time datetime="2023-11-18T05:59:47.000Z" title="发表于 2023-11-18 13:59:47">2023-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/22/LeetCode/" title="无题"><img src="/img/loading.gif" data-original="/img/page4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/10/22/LeetCode/" title="无题">无题</a><time datetime="2023-10-22T06:30:38.513Z" title="发表于 2023-10-22 14:30:38">2023-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/07/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/" title="无题"><img src="/img/loading.gif" data-original="/img/page5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/10/07/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/" title="无题">无题</a><time datetime="2023-10-07T15:09:36.518Z" title="发表于 2023-10-07 23:09:36">2023-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/06/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程"><img src="/img/loading.gif" data-original="/img/page5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC并发编程"/></a><div class="content"><a class="title" href="/2023/10/06/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程">JUC并发编程</a><time datetime="2023-10-06T06:55:28.000Z" title="发表于 2023-10-06 14:55:28">2023-10-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By HUA</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(e){e.imageLazyLoadSetting.processImages=t;var n=e.imageLazyLoadSetting.isSPA,i=e.imageLazyLoadSetting.preloadRatio||1,r=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){n&&(r=o());for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(e.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];e=function(){r=r.filter(function(t){return o!==t})},(t=o).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,t.removeAttribute("data-original"),e&&e()},t.src!==i&&(n.src=i))}()}function a(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",a),e.addEventListener("resize",a),e.addEventListener("orientationchange",a)}(this);</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>