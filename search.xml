<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dubbo</title>
      <link href="/2022/11/20/Dubbo/"/>
      <url>/2022/11/20/Dubbo/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1、分布式基础理论"><a href="#1、分布式基础理论" class="headerlink" title="1、分布式基础理论"></a>1、分布式基础理论</h2><h3 id="1-1）、什么是分布式系统？"><a href="#1-1）、什么是分布式系统？" class="headerlink" title="1.1）、什么是分布式系统？"></a>1.1）、什么是分布式系统？</h3><p>《分布式系统原理与范型》定义：</p><p>“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”</p><p>分布式系统（distributed system）是建立在网络之上的软件系统。</p><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需<strong>一个治理系统</strong>确保架构有条不紊的演进。</p><h3 id="1-2）、发展演变"><a href="#1-2）、发展演变" class="headerlink" title="1.2）、发展演变"></a>1.2）、发展演变</h3><p><img src="/2022/11/20/Dubbo/image-20221023100817684.png" alt="image-20221023100817684"></p><h4 id="单一应用架构"><a href="#单一应用架构" class="headerlink" title="单一应用架构"></a>单一应用架构</h4><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p><p> <img src="/2022/11/20/Dubbo/image-20221023100826774.png" alt="image-20221023100826774"></p><p>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</p><p>缺点： 1、性能扩展比较难</p><p>​    2、协同开发问题</p><p>​    3、不利于升级维护</p><h4 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h4><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p><p> <img src="/2022/11/20/Dubbo/image-20221023100841014.png" alt="image-20221023100841014"></p><p>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</p><p>缺点： 公用模块无法重复利用，开发性的浪费</p><h4 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h4><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的<strong>分布式服务框架</strong>**(RPC)**是关键。</p><p> <img src="/2022/11/20/Dubbo/image-20221023100851589.png" alt="image-20221023100851589"></p><h4 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a>流动计算架构</h4><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心</strong>**(SOA)[ Service Oriented Architecture]**<strong>是关键</strong>。</p><p> <img src="/2022/11/20/Dubbo/image-20221023100900051.png" alt="image-20221023100900051"></p><h3 id="1-3）、RPC"><a href="#1-3）、RPC" class="headerlink" title="1.3）、RPC"></a>1.3）、RPC</h3><h4 id="什么叫RPC"><a href="#什么叫RPC" class="headerlink" title="什么叫RPC"></a>什么叫RPC</h4><p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p><h4 id="RPC基本原理"><a href="#RPC基本原理" class="headerlink" title="RPC基本原理"></a>RPC基本原理</h4><p><img src="/2022/11/20/Dubbo/image-20221023100915730.png" alt="image-20221023100915730"></p><p>RPC两个核心模块：通讯，序列化。</p><p> <img src="/2022/11/20/Dubbo/image-20221023100923832.png" alt="image-20221023100923832"></p><h2 id="2、dubbo核心概念"><a href="#2、dubbo核心概念" class="headerlink" title="2、dubbo核心概念"></a>2、dubbo核心概念</h2><h3 id="2-1）、简介"><a href="#2-1）、简介" class="headerlink" title="2.1）、简介"></a>2.1）、简介</h3><p>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p><p>官网：</p><p><a href="http://dubbo.apache.org/">http://dubbo.apache.org/</a></p><h3 id="2-2）、基本概念"><a href="#2-2）、基本概念" class="headerlink" title="2.2）、基本概念"></a>2.2）、基本概念</h3><p> <img src="/2022/11/20/Dubbo/image-20221023101018991.png" alt="image-20221023101018991"></p><p><strong>服务提供者（Provider****）</strong>：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p><p>​    <strong>服务消费者（Consumer****）</strong>: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p><p>​    <strong>注册中心（Registry****）</strong>：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p><p>​    <strong>监控中心（Monitor****）</strong>：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p><p>Ø 调用关系说明</p><ul><li>l 服务容器负责启动，加载，运行服务提供者。</li><li>l 服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>l 服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>l 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>l 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>l 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul><h2 id="3、dubbo环境搭建"><a href="#3、dubbo环境搭建" class="headerlink" title="3、dubbo环境搭建"></a>3、dubbo环境搭建</h2><h3 id="3-1）、【windows】-安装zookeeper"><a href="#3-1）、【windows】-安装zookeeper" class="headerlink" title="3.1）、【windows】-安装zookeeper"></a>3.1）、【windows】-安装zookeeper</h3><table><thead><tr><th>1、下载zookeeper  网址 <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/</a></th></tr></thead><tbody><tr><td>2、解压zookeeper  解压运行zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件</td></tr><tr><td>3、修改zoo.cfg配置文件  将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可。  注意几个重要位置：  dataDir&#x3D;.&#x2F;  临时数据存储的目录（可写相对路径）  clientPort&#x3D;2181  zookeeper的端口号  修改完成后再次启动zookeeper</td></tr><tr><td>4、使用zkCli.cmd测试  ls &#x2F;：列出zookeeper根下保存的所有节点  create –e &#x2F;atguigu 123：创建一个atguigu节点，值为123  get &#x2F;atguigu：获取&#x2F;atguigu节点的值</td></tr></tbody></table><h3 id="3-2）、【windows】-安装dubbo-admin管理控制台"><a href="#3-2）、【windows】-安装dubbo-admin管理控制台" class="headerlink" title="3.2）、【windows】-安装dubbo-admin管理控制台"></a>3.2）、【windows】-安装dubbo-admin管理控制台</h3><p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p><p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。</p><table><thead><tr><th>1、下载dubbo-admin  <a href="https://github.com/apache/incubator-dubbo-ops">https://github.com/apache/incubator-dubbo-ops</a> <img src="/2022/11/20/Dubbo/image-20221023101114418.png" alt="image-20221023101114418"></th></tr></thead><tbody><tr><td>2、进入目录，修改dubbo-admin配置  修改 src\main\resources\application.properties  指定zookeeper地址</td></tr><tr><td>3、打包dubbo-admin  mvn clean package -Dmaven.test.skip&#x3D;true</td></tr><tr><td>4、运行dubbo-admin  java -jar dubbo-admin-0.0.1-SNAPSHOT.jar  <strong>注意：【有可能控制台看着启动了，但是网页打不开，需要在控制台按下<strong><strong>ctrl+c</strong></strong>即可】</strong>  默认使用root&#x2F;root 登陆     <img src="/2022/11/20/Dubbo/image-20221023101140949.png" alt="image-20221023101140949"></td></tr></tbody></table><h3 id="3-3）、【linux】-安装zookeeper"><a href="#3-3）、【linux】-安装zookeeper" class="headerlink" title="3.3）、【linux】-安装zookeeper"></a>3.3）、【linux】-安装zookeeper</h3><h4 id="1、安装jdk"><a href="#1、安装jdk" class="headerlink" title="1、安装jdk"></a>1、安装jdk</h4><table><thead><tr><th>1、下载jdk  <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a>         不要使用wget命令获取jdk链接，这是默认不同意，导致下载来的jdk压缩内容错误  <img src="/2022/11/20/Dubbo/image-20221023101149191.png" alt="image-20221023101149191"></th></tr></thead><tbody><tr><td>2、上传到服务器并解压         <img src="/2022/11/20/Dubbo/image-20221023101200817.png" alt="image-20221023101200817"></td></tr><tr><td>3、设置环境变量  &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_171                                                      <img src="/2022/11/20/Dubbo/image-20221023101219946.png" alt="image-20221023101219946">文件末尾加入下面配置                                                                                              export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_171                                                    export JRE_HOME&#x3D;${JAVA_HOME}&#x2F;jre                                                                      export CLASSPATH&#x3D;.:${JAVA_HOME}&#x2F;lib:${JRE_HOME}&#x2F;lib                                   export PATH&#x3D;${JAVA_HOME}&#x2F;bin:$PATH                                                                     <img src="/2022/11/20/Dubbo/image-20221023101311082.png" alt="image-20221023101311082"></td></tr><tr><td>4、使环境变量生效&amp;测试JDK                                                                                       <img src="/2022/11/20/Dubbo/image-20221023101322237.png" alt="image-20221023101322237"></td></tr></tbody></table><h4 id="2、安装zookeeper"><a href="#2、安装zookeeper" class="headerlink" title="2、安装zookeeper"></a>2、安装zookeeper</h4><table><thead><tr><th>1、下载zookeeper  网址 <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/</a>    wget <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz</a></th></tr></thead><tbody><tr><td>2、解压                                                                                                                              <img src="/2022/11/20/Dubbo/image-20221023101338069.png" alt="image-20221023101338069"></td></tr><tr><td>3、移动到指定位置并改名为zookeeper                                                                       <img src="/2022/11/20/Dubbo/image-20221023101346259.png" alt="image-20221023101346259"><img src="/2022/11/20/Dubbo/image-20221023101407691.png" alt="image-20221023101407691"></td></tr></tbody></table><h4 id="3、开机启动zookeeper"><a href="#3、开机启动zookeeper" class="headerlink" title="3、开机启动zookeeper"></a>3、开机启动zookeeper</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）-复制如下脚本</span><br><span class="line">#!/bin/bash</span><br><span class="line">#chkconfig:2345 20 90</span><br><span class="line">#description:zookeeper</span><br><span class="line">#processname:zookeeper</span><br><span class="line">ZK_PATH=/usr/local/zookeeper</span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_171</span><br><span class="line">case $1 in</span><br><span class="line">         start) sh  $ZK_PATH/bin/zkServer.sh start;;</span><br><span class="line">         stop)  sh  $ZK_PATH/bin/zkServer.sh stop;;</span><br><span class="line">         status) sh  $ZK_PATH/bin/zkServer.sh status;;</span><br><span class="line">         restart) sh $ZK_PATH/bin/zkServer.sh restart;;</span><br><span class="line">         *)  echo &quot;require start|stop|status|restart&quot;  ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p><img src="/2022/11/20/Dubbo/image-20221023101513741.png" alt="image-20221023101513741"></p><p>2）-把脚本注册为Service</p><p><img src="/2022/11/20/Dubbo/image-20221023101540950.png" alt="image-20221023101540950"></p><p>3）-增加权限</p><p> <img src="/2022/11/20/Dubbo/image-20221023101545866.png" alt="image-20221023101545866"></p><h4 id="4、配置zookeeper"><a href="#4、配置zookeeper" class="headerlink" title="4、配置zookeeper"></a>4、配置zookeeper</h4><table><thead><tr><th>1、初始化zookeeper配置文件  拷贝&#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;conf&#x2F;zoo_sample.cfg    到同一个目录下改个名字叫zoo.cfg                                                                                                                            <img src="/2022/11/20/Dubbo/image-20221023101601428.png" alt="image-20221023101601428"></th></tr></thead><tbody><tr><td>2、启动zookeeper                <img src="/2022/11/20/Dubbo/image-20221023101606935.png" alt="image-20221023101606935"></td></tr></tbody></table><h3 id="3-4）、【linux】-安装dubbo-admin管理控制台"><a href="#3-4）、【linux】-安装dubbo-admin管理控制台" class="headerlink" title="3.4）、【linux】-安装dubbo-admin管理控制台"></a>3.4）、【linux】-安装dubbo-admin管理控制台</h3><h4 id="1、安装Tomcat8（旧版dubbo-admin是war，新版是jar不需要安装Tomcat）"><a href="#1、安装Tomcat8（旧版dubbo-admin是war，新版是jar不需要安装Tomcat）" class="headerlink" title="1、安装Tomcat8（旧版dubbo-admin是war，新版是jar不需要安装Tomcat）"></a>1、安装Tomcat8（旧版dubbo-admin是war，新版是jar不需要安装Tomcat）</h4><table><thead><tr><th>1、下载Tomcat8并解压  <a href="https://tomcat.apache.org/download-80.cgi">https://tomcat.apache.org/download-80.cgi</a>  wget <a href="http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz">http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz</a></th></tr></thead><tbody><tr><td>2、解压移动到指定位置         <img src="/2022/11/20/Dubbo/image-20221023101630866.png" alt="image-20221023101630866"></td></tr></tbody></table><h5 id="3、开机启动tomcat8"><a href="#3、开机启动tomcat8" class="headerlink" title="3、开机启动tomcat8"></a>3、开机启动tomcat8</h5><p><img src="/2022/11/20/Dubbo/image-20221023101758812.png" alt="image-20221023101758812"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制如下脚本</span><br><span class="line">#!/bin/bash</span><br><span class="line">#chkconfig:2345 21 90</span><br><span class="line">#description:apache-tomcat-8</span><br><span class="line">#processname:apache-tomcat-8</span><br><span class="line">CATALANA_HOME=/opt/apache-tomcat-8.5.32</span><br><span class="line">export JAVA_HOME=/opt/java/jdk1.8.0_171</span><br><span class="line">case $1 in</span><br><span class="line">start)</span><br><span class="line">    echo &quot;Starting Tomcat...&quot;  </span><br><span class="line">    $CATALANA_HOME/bin/startup.sh</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">stop)</span><br><span class="line">    echo &quot;Stopping Tomcat...&quot;  </span><br><span class="line">    $CATALANA_HOME/bin/shutdown.sh</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">restart)</span><br><span class="line">    echo &quot;Stopping Tomcat...&quot;  </span><br><span class="line">    $CATALANA_HOME/bin/shutdown.sh</span><br><span class="line">    sleep 2</span><br><span class="line">    echo  </span><br><span class="line">    echo &quot;Starting Tomcat...&quot;  </span><br><span class="line">    $CATALANA_HOME/bin/startup.sh</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    echo &quot;Usage: tomcat &#123;start|stop|restart&#125;&quot;  </span><br><span class="line">    ;; esac</span><br></pre></td></tr></table></figure><h5 id="4、注册服务-amp-添加权限"><a href="#4、注册服务-amp-添加权限" class="headerlink" title="4、注册服务&amp;添加权限"></a>4、注册服务&amp;添加权限</h5><p><img src="/2022/11/20/Dubbo/image-20221023101812739.png" alt="image-20221023101812739"></p><p><img src="/2022/11/20/Dubbo/image-20221023101819504.png" alt="image-20221023101819504"></p><h5 id="5、启动服务-amp-访问tomcat测试"><a href="#5、启动服务-amp-访问tomcat测试" class="headerlink" title="5、启动服务&amp;访问tomcat测试"></a>5、启动服务&amp;访问tomcat测试</h5><p><img src="/2022/11/20/Dubbo/image-20221023101830048.png" alt="image-20221023101830048"></p><p><img src="/2022/11/20/Dubbo/image-20221023101836418.png" alt="image-20221023101836418"></p><h4 id="2、安装dubbo-admin"><a href="#2、安装dubbo-admin" class="headerlink" title="2、安装dubbo-admin"></a>2、安装dubbo-admin</h4><p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p><p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。</p><table><thead><tr><th>1、下载dubbo-admin  <a href="https://github.com/apache/incubator-dubbo-ops">https://github.com/apache/incubator-dubbo-ops</a>      <img src="/2022/11/20/Dubbo/image-20221023101849689.png" alt="image-20221023101849689"></th></tr></thead><tbody><tr><td>2、进入目录，修改dubbo-admin配置  修改 src\main\resources\application.properties  指定zookeeper地址   <img src="/2022/11/20/Dubbo/image-20221023101858105.png" alt="image-20221023101858105"></td></tr><tr><td>3、打包dubbo-admin  mvn clean package -Dmaven.test.skip&#x3D;true</td></tr><tr><td>4、运行dubbo-admin  java -jar dubbo-admin-0.0.1-SNAPSHOT.jar  默认使用root&#x2F;root 登陆         <img src="/2022/11/20/Dubbo/image-20221023101904524.png" alt="image-20221023101904524"></td></tr></tbody></table><h2 id="4、dubbo-helloworld"><a href="#4、dubbo-helloworld" class="headerlink" title="4、dubbo-helloworld"></a>4、dubbo-helloworld</h2><h3 id="4-1）、提出需求"><a href="#4-1）、提出需求" class="headerlink" title="4.1）、提出需求"></a>4.1）、提出需求</h3><p>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；</p><p>我们现在 需要创建两个服务模块进行测试 </p><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>订单服务web模块</td><td>创建订单等</td></tr><tr><td>用户服务service模块</td><td>查询用户地址等</td></tr></tbody></table><p>测试预期结果：</p><p>​    订单服务web模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。</p><h3 id="4-2）、工程架构"><a href="#4-2）、工程架构" class="headerlink" title="4.2）、工程架构"></a>4.2）、工程架构</h3><p>根据 dubbo《服务化最佳实践》</p><h4 id="1、分包"><a href="#1、分包" class="headerlink" title="1、分包"></a>1、分包</h4><p>建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。</p><p>如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com&#x2F;alibaba&#x2F;china&#x2F;xxx&#x2F;dubbo-reference.xml。</p><h4 id="2、粒度"><a href="#2、粒度" class="headerlink" title="2、粒度"></a>2、粒度</h4><p>服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。</p><p>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。</p><p>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p><p><img src="/2022/11/20/Dubbo/image-20221023101927400.png" alt="image-20221023101927400"></p><h3 id="4-3）、创建模块"><a href="#4-3）、创建模块" class="headerlink" title="4.3）、创建模块"></a>4.3）、创建模块</h3><h4 id="1、gmall-interface：公共接口层（model，service，exception…）"><a href="#1、gmall-interface：公共接口层（model，service，exception…）" class="headerlink" title="1、gmall-interface：公共接口层（model，service，exception…）"></a>1、gmall-interface：公共接口层（model，service，exception…）</h4><p> 作用：定义公共接口，也可以导入公共依赖</p><h5 id="1、Bean模型"><a href="#1、Bean模型" class="headerlink" title="1、Bean模型"></a>1、Bean模型</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAddress</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userAddress;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String consignee;</span><br><span class="line">    <span class="keyword">private</span> String phoneNum;</span><br><span class="line">    <span class="keyword">private</span> String isDefault;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Service接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserService</span><br><span class="line"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title function_">getUserAddressList</span><span class="params">(String userId)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/11/20/Dubbo/image-20221023102051278.png" alt="image-20221023102051278"></p><h4 id="2、gmall-user：用户模块（对用户接口的实现）"><a href="#2、gmall-user：用户模块（对用户接口的实现）" class="headerlink" title="2、gmall-user：用户模块（对用户接口的实现）"></a>2、gmall-user：用户模块（对用户接口的实现）</h4><p> 1、pom.xml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.atguigu.dubbo&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title function_">getUserAddressList</span><span class="params">(String userId)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> userAddressDao.getUserAddressById(userId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、gmall-order-web：订单模块（调用用户模块）"><a href="#4、gmall-order-web：订单模块（调用用户模块）" class="headerlink" title="4、gmall-order-web：订单模块（调用用户模块）"></a>4、gmall-order-web：订单模块（调用用户模块）</h4><p> 1、pom.xml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.atguigu.dubbo&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;gmall-interface&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>2、测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化订单，查询用户的所有地址并返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title function_">initOrder</span><span class="params">(String userId)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> userService.getUserAddressList(userId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这样是无法进行调用的。我们gmall-order-web引入了gmall-interface，但是interface的实现是gmall-user，我们并没有引入，而且实际他可能还在别的服务器中。</p><h3 id="4-4）、使用dubbo改造"><a href="#4-4）、使用dubbo改造" class="headerlink" title="4.4）、使用dubbo改造"></a>4.4）、使用dubbo改造</h3><h4 id="1、改造gmall-user作为服务提供者"><a href="#1、改造gmall-user作为服务提供者" class="headerlink" title="1、改造gmall-user作为服务提供者"></a>1、改造gmall-user作为服务提供者</h4><p> <strong>1、引入dubbo</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入dubbo --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">2.6</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</span><br><span class="line">dubbo <span class="number">2.6</span>以前的版本引入zkclient操作zookeeper </span><br><span class="line">dubbo <span class="number">2.6</span>及以后的版本引入curator操作zookeeper</span><br><span class="line">下面两个zk客户端根据dubbo版本<span class="number">2</span>选<span class="number">1</span>即可</span><br><span class="line">--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.101tec&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">0.10</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- curator-framework --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">2.12</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> <strong>2、配置提供者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--当前应用的名字  --&gt;</span><br><span class="line">&lt;dubbo:application name=<span class="string">&quot;gmall-user&quot;</span>&gt;&lt;/dubbo:application&gt;</span><br><span class="line">&lt;!--指定注册中心的地址  --&gt;</span><br><span class="line">    &lt;dubbo:registry address=<span class="string">&quot;zookeeper://118.24.44.169:2181&quot;</span> /&gt;</span><br><span class="line">    &lt;!--使用dubbo协议，将服务暴露在<span class="number">20880</span>端口  --&gt;</span><br><span class="line">    &lt;dubbo:protocol name=<span class="string">&quot;dubbo&quot;</span> port=<span class="string">&quot;20880&quot;</span> /&gt;</span><br><span class="line">    &lt;!-- 指定需要暴露的服务 --&gt;</span><br><span class="line">    &lt;dubbo:service interface=<span class="string">&quot;com.atguigu.gmall.service.UserService&quot;</span> ref=<span class="string">&quot;userServiceImpl&quot;</span> /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3、启动服务"><a href="#3、启动服务" class="headerlink" title="3、启动服务"></a>3、启动服务</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:spring-beans.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.in.read(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、改造gmall-order-web作为服务消费者"><a href="#2、改造gmall-order-web作为服务消费者" class="headerlink" title="2、改造gmall-order-web作为服务消费者"></a>2、改造gmall-order-web作为服务消费者</h4><p> <strong>1、引入dubbo</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入dubbo --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">2.6</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 由于我们使用zookeeper作为注册中心，所以需要引入zkclient和curator操作zookeeper --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.101tec&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">0.10</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- curator-framework --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">2.12</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="2、配置消费者信息"><a href="#2、配置消费者信息" class="headerlink" title="2、配置消费者信息"></a>2、配置消费者信息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 应用名 --&gt;</span><br><span class="line">&lt;dubbo:application name=<span class="string">&quot;gmall-order-web&quot;</span>&gt;&lt;/dubbo:application&gt;</span><br><span class="line">&lt;!-- 指定注册中心地址 --&gt;</span><br><span class="line">&lt;dubbo:registry address=<span class="string">&quot;zookeeper://118.24.44.169:2181&quot;</span> /&gt;</span><br><span class="line">&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span><br><span class="line">&lt;dubbo:reference id=<span class="string">&quot;userService&quot;</span> interface=<span class="string">&quot;com.atguigu.gmall.service.UserService&quot;</span>&gt;&lt;/dubbo:reference&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3、测试调用"><a href="#3、测试调用" class="headerlink" title="3、测试调用"></a>3、测试调用</h4><p>访问gmall-order-web的initOrder请求，会调用UserService获取用户地址；</p><p>调用成功。说明我们order已经可以调用远程的UserService了；</p><h4 id="4、注解版"><a href="#4、注解版" class="headerlink" title="4、注解版"></a>4、注解版</h4><p> <strong>1、服务提供方</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:application name=<span class="string">&quot;gmall-user&quot;</span>&gt;&lt;/dubbo:application&gt;</span><br><span class="line">    &lt;dubbo:registry address=<span class="string">&quot;zookeeper://118.24.44.169:2181&quot;</span> /&gt;</span><br><span class="line">    &lt;dubbo:protocol name=<span class="string">&quot;dubbo&quot;</span> port=<span class="string">&quot;20880&quot;</span> /&gt;</span><br><span class="line">&lt;dubbo:annotation <span class="keyword">package</span>=<span class="string">&quot;com.atguigu.gmall.user.impl&quot;</span>/&gt;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.gmall.user.mapper.UserAddressMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span> <span class="comment">//使用dubbo提供的service注解，注册暴露服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserAddressMapper userAddressMapper;</span><br></pre></td></tr></table></figure><p> <strong>2、服务消费方</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:application name=<span class="string">&quot;gmall-order-web&quot;</span>&gt;&lt;/dubbo:application&gt;</span><br><span class="line">&lt;dubbo:registry address=<span class="string">&quot;zookeeper://118.24.44.169:2181&quot;</span> /&gt;</span><br><span class="line">&lt;dubbo:annotation <span class="keyword">package</span>=<span class="string">&quot;com.atguigu.gmall.order.controller&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Reference</span>  <span class="comment">//使用dubbo提供的reference注解引用远程服务</span></span><br><span class="line">UserService userService;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5、监控中心"><a href="#5、监控中心" class="headerlink" title="5、监控中心"></a>5、监控中心</h2><h3 id="5-1）、dubbo-admin"><a href="#5-1）、dubbo-admin" class="headerlink" title="5.1）、dubbo-admin"></a>5.1）、dubbo-admin</h3><p>图形化的服务管理页面；安装时需要指定注册中心地址，即可从注册中心中获取到所有的提供者&#x2F;消费者进行配置管理</p><h3 id="5-2）、dubbo-monitor-simple"><a href="#5-2）、dubbo-monitor-simple" class="headerlink" title="5.2）、dubbo-monitor-simple"></a>5.2）、dubbo-monitor-simple</h3><p>简单的监控中心；</p><h4 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h4><table><thead><tr><th>1、下载 dubbo-ops  <a href="https://github.com/apache/incubator-dubbo-ops">https://github.com/apache/incubator-dubbo-ops</a></th></tr></thead><tbody><tr><td>2、修改配置指定注册中心地址  进入 dubbo-monitor-simple\src\main\resources\conf  修改 dubbo.properties文件         <img src="/2022/11/20/Dubbo/image-20221023102608370.png" alt="image-20221023102608370"></td></tr><tr><td>3、打包dubbo-monitor-simple                                                                                           <code>mvn clean package  -Dmaven.test.skip=true</code></td></tr><tr><td>4、解压 tar.gz 文件，并运行start.bat     <img src="/2022/11/20/Dubbo/image-20221023102639195.png" alt="image-20221023102639195">    如果缺少servlet-api，自行导入servlet-api再访问监控中心</td></tr><tr><td>5、启动访问8080         <img src="/2022/11/20/Dubbo/image-20221023102644586.png" alt="image-20221023102644586"></td></tr></tbody></table><h4 id="2、监控中心配置"><a href="#2、监控中心配置" class="headerlink" title="2、监控中心配置"></a>2、监控中心配置</h4><p>  所有服务配置连接监控中心，进行监控统计     </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--  监控中心协议，如果为protocol=<span class="string">&quot;registry&quot;</span>，表示从注册中心发现监控中心地址，否则直连监控中心 --&gt;   </span><br><span class="line">&lt;dubbo:monitor  protocol=*<span class="string">&quot;registry&quot;</span>*&gt;&lt;/dubbo:monitor&gt;     </span><br></pre></td></tr></table></figure><p>Simple Monitor 挂掉不会影响到 Consumer 和 Provider 之间的调用，所以用于生产环境不会有风险。</p><p>Simple Monitor 采用磁盘存储统计信息，请注意安装机器的磁盘限制，如果要集群，建议用mount共享磁盘。</p><h2 id="6、整合SpringBoot"><a href="#6、整合SpringBoot" class="headerlink" title="6、整合SpringBoot"></a>6、整合SpringBoot</h2><p> 1、引入<strong>spring-boot-starter</strong>以及dubbo和curator的依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.2</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 注意starter版本适配：</p><p><img src="/2022/11/20/Dubbo/image-20221023112314096.png" alt="image-20221023112314096"></p><h5 id="2、配置application-properties"><a href="#2、配置application-properties" class="headerlink" title="2、配置application.properties"></a>2、配置application.properties</h5><h6 id="提供者配置："><a href="#提供者配置：" class="headerlink" title="提供者配置："></a>提供者配置：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dubbo.application.name=gmall-user</span><br><span class="line">dubbo.registry.protocol=zookeeper</span><br><span class="line">dubbo.registry.address=<span class="number">192.168</span><span class="number">.67</span><span class="number">.159</span>:<span class="number">2181</span></span><br><span class="line">dubbo.scan.base-<span class="keyword">package</span>=com.atguigu.gmall</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">application.name就是服务名，不能跟别的dubbo提供端重复</span><br><span class="line">registry.protocol 是指定注册中心协议</span><br><span class="line">registry.address 是注册中心的地址加端口号</span><br><span class="line">protocol.name 是分布式固定是dubbo,不要改。</span><br><span class="line">base-<span class="keyword">package</span>  注解方式要扫描的包</span><br></pre></td></tr></table></figure><h6 id="消费者配置："><a href="#消费者配置：" class="headerlink" title="消费者配置："></a>消费者配置：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dubbo.application.name=gmall-order-web</span><br><span class="line">dubbo.registry.protocol=zookeeper</span><br><span class="line">dubbo.registry.address=<span class="number">192.168</span><span class="number">.67</span><span class="number">.159</span>:<span class="number">2181</span></span><br><span class="line">dubbo.scan.base-<span class="keyword">package</span>=com.atguigu.gmall</span><br><span class="line">dubbo.protocol.name=dubbo</span><br></pre></td></tr></table></figure><h5 id="3、dubbo注解"><a href="#3、dubbo注解" class="headerlink" title="3、dubbo注解"></a>3、dubbo注解</h5><p>@Service、@Reference</p><p><strong>【如果没有在配置中写dubbo.scan.base-package,还需要使用@EnableDubbo注解】</strong></p><h1 id="二、dubbo配置"><a href="#二、dubbo配置" class="headerlink" title="二、dubbo配置"></a>二、dubbo配置</h1><h2 id="1、配置原则"><a href="#1、配置原则" class="headerlink" title="1、配置原则"></a>1、配置原则</h2><p> <img src="/2022/11/20/Dubbo/image-20221023112420248.png" alt="image-20221023112420248"></p><p>JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。</p><p>XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。</p><p>Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p><h2 id="2、重试次数"><a href="#2、重试次数" class="headerlink" title="2、重试次数"></a>2、重试次数</h2><p>失败自动切换，当出现失败，重试其它服务器，但重试会带来更长延迟。可通过 retries&#x3D;”2” 来设置重试次数(不含第一次)。</p><p>  重试次数配置如下： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service retries=<span class="string">&quot;2&quot;</span> /&gt;</span><br><span class="line">或</span><br><span class="line">&lt;dubbo:reference retries=<span class="string">&quot;2&quot;</span> /&gt;</span><br><span class="line">或</span><br><span class="line">&lt;dubbo:reference&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;findFoo&quot;</span> retries=<span class="string">&quot;2&quot;</span> /&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3、超时时间"><a href="#3、超时时间" class="headerlink" title="3、超时时间"></a>3、超时时间</h2><p>由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。</p><h3 id="1、Dubbo消费端"><a href="#1、Dubbo消费端" class="headerlink" title="1、Dubbo消费端"></a>1、Dubbo消费端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">全局超时配置</span><br><span class="line">&lt;dubbo:consumer timeout=<span class="string">&quot;5000&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">指定接口以及特定方法超时配置</span><br><span class="line">&lt;dubbo:reference interface=<span class="string">&quot;com.foo.BarService&quot;</span> timeout=<span class="string">&quot;2000&quot;</span>&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;sayHello&quot;</span> timeout=<span class="string">&quot;3000&quot;</span> /&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、Dubbo服务端"><a href="#2、Dubbo服务端" class="headerlink" title="2、Dubbo服务端"></a>2、Dubbo服务端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">全局超时配置</span><br><span class="line">&lt;dubbo:provider timeout=<span class="string">&quot;5000&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">指定接口以及特定方法超时配置</span><br><span class="line">&lt;dubbo:provider interface=<span class="string">&quot;com.foo.BarService&quot;</span> timeout=<span class="string">&quot;2000&quot;</span>&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;sayHello&quot;</span> timeout=<span class="string">&quot;3000&quot;</span> /&gt;</span><br><span class="line">&lt;/dubbo:provider&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="3、配置原则"><a href="#3、配置原则" class="headerlink" title="3、配置原则"></a>3、配置原则</h3><p>dubbo推荐在Provider上尽量多配置Consumer端属性：</p><p>​1、作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等  </p><p>​2、在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的  </p><p>配置的覆盖规则：</p><ol><li><p>方法级配置别优于接口级别，即小Scope优先 </p></li><li><p>Consumer端配置 优于 Provider配置 优于 全局配置，</p></li><li><p>最后是Dubbo Hard Code的配置值（见配置文档）</p></li></ol><p> <img src="/2022/11/20/Dubbo/image-20221023112609216.png" alt="image-20221023112609216"></p><h2 id="4、版本号"><a href="#4、版本号" class="headerlink" title="4、版本号"></a>4、版本号</h2><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p><p>可以按照以下的步骤进行版本迁移：</p><ul><li>在低压力时间段，先升级一半提供者为新版本</li><li>再将所有消费者升级为新版本</li><li>然后将剩下的一半提供者升级为新版本</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">老版本服务提供者配置：</span><br><span class="line">&lt;dubbo:service interface=<span class="string">&quot;com.foo.BarService&quot;</span> version=<span class="string">&quot;1.0.0&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">新版本服务提供者配置：</span><br><span class="line">&lt;dubbo:service interface=<span class="string">&quot;com.foo.BarService&quot;</span> version=<span class="string">&quot;2.0.0&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">老版本服务消费者配置：</span><br><span class="line">&lt;dubbo:reference id=<span class="string">&quot;barService&quot;</span> interface=<span class="string">&quot;com.foo.BarService&quot;</span> version=<span class="string">&quot;1.0.0&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">新版本服务消费者配置：</span><br><span class="line">&lt;dubbo:reference id=<span class="string">&quot;barService&quot;</span> interface=<span class="string">&quot;com.foo.BarService&quot;</span> version=<span class="string">&quot;2.0.0&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">如果不需要区分版本，可以按照以下的方式配置：</span><br><span class="line">&lt;dubbo:reference id=<span class="string">&quot;barService&quot;</span> interface=<span class="string">&quot;com.foo.BarService&quot;</span> version=<span class="string">&quot;*&quot;</span> /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三、高可用"><a href="#三、高可用" class="headerlink" title="三、高可用"></a>三、高可用</h1><h2 id="1、zookeeper宕机与dubbo直连"><a href="#1、zookeeper宕机与dubbo直连" class="headerlink" title="1、zookeeper宕机与dubbo直连"></a>1、zookeeper宕机与dubbo直连</h2><p>现象：zookeeper注册中心宕机，还可以消费dubbo暴露的服务。</p><p>原因：</p><p><strong>健壮性</strong>  </p><ul><li>监控中心宕掉不影响使用，只是丢失部分采样数据  </li><li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务  </li><li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台  </li><li><strong>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</strong>  </li><li>服务提供者无状态，任意一台宕掉后，不影响使用  </li><li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li></ul><p>高可用：通过设计，减少系统不能提供服务的时间；</p><h2 id="2、集群下dubbo负载均衡配置"><a href="#2、集群下dubbo负载均衡配置" class="headerlink" title="2、集群下dubbo负载均衡配置"></a>2、集群下dubbo负载均衡配置</h2><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p><p>负载均衡策略</p><p><strong>Random  LoadBalance</strong>  </p><p>随机，按权重设置随机概率。  在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。  </p><p><strong>RoundRobin  LoadBalance</strong>  </p><p>轮循，按公约后的权重设置轮循比率。  存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。 </p><p> <strong>LeastActive  LoadBalance</strong>  </p><p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。  使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。  </p><p><strong>ConsistentHash  LoadBalance</strong>  </p><p>一致性 Hash，相同参数的请求总是发到同一提供者。  当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a>  缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter  key&#x3D;”hash.arguments” value&#x3D;”0,1” &#x2F;&gt;  缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter  key&#x3D;”hash.nodes” value&#x3D;”320” &#x2F;&gt;  </p><h2 id="3、整合hystrix，服务熔断与降级处理"><a href="#3、整合hystrix，服务熔断与降级处理" class="headerlink" title="3、整合hystrix，服务熔断与降级处理"></a>3、整合hystrix，服务熔断与降级处理</h2><h3 id="1、服务降级"><a href="#1、服务降级" class="headerlink" title="1、服务降级"></a>1、服务降级</h3><p><strong>什么是服务降级？</strong></p><p><strong>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</strong></p><p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p><p>向注册中心写入动态配置覆盖规则：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class="line">Registry registry = registryFactory.getRegistry(URL.valueOf(&quot;zookeeper://10.20.153.10:2181&quot;));</span><br><span class="line">registry.register(URL.valueOf(&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null&quot;));</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>mock&#x3D;force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。</li><li>还可以改为 mock&#x3D;fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</li></ul><h3 id="2、集群容错"><a href="#2、集群容错" class="headerlink" title="2、集群容错"></a>2、集群容错</h3><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p><p><strong>集群容错模式</strong></p><ul><li><strong>Failover  Cluster</strong></li></ul><p>失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过  retries&#x3D;”2” 来设置重试次数(不含第一次)。    </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重试次数配置如下：</span><br><span class="line">&lt;dubbo:service retries=&quot;2&quot; /&gt;</span><br><span class="line">或</span><br><span class="line">&lt;dubbo:reference retries=&quot;2&quot; /&gt;</span><br><span class="line">或</span><br><span class="line">&lt;dubbo:reference&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>Failfast  Cluster</strong></li></ul><p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。    </p><ul><li><strong>Failsafe  Cluster</strong></li></ul><p> 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。    </p><ul><li><strong>Failback  Cluster</strong></li></ul><p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。    </p><ul><li><strong>Forking  Cluster</strong></li></ul><p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过  forks&#x3D;”2” 来设置最大并行数。     <strong>Broadcast  Cluster</strong>  广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。    </p><p> <strong>集群模式配置</strong>  按照以下示例在服务提供方和消费方配置集群模式  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service  cluster=&quot;failsafe&quot; /&gt;  或  &lt;dubbo:reference  cluster=&quot;failsafe&quot; /&gt;  </span><br></pre></td></tr></table></figure><h3 id="3、整合hystrix"><a href="#3、整合hystrix" class="headerlink" title="3、整合hystrix"></a>3、整合hystrix</h3><p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能</p><h4 id="1、配置spring-cloud-starter-netflix-hystrix"><a href="#1、配置spring-cloud-starter-netflix-hystrix" class="headerlink" title="1、配置spring-cloud-starter-netflix-hystrix"></a>1、配置spring-cloud-starter-netflix-hystrix</h4><p>spring boot官方提供了对hystrix的集成，直接在pom.xml里加入依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.4</span><span class="number">.4</span>.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后在Application类上增加@EnableHystrix来启用hystrix starter： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderApplication</span> &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2、配置Provider端"><a href="#2、配置Provider端" class="headerlink" title="2、配置Provider端"></a>2、配置Provider端</h4><p>在Dubbo的Provider上增加@HystrixCommand配置，这样子调用就会经过Hystrix代理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(version = &quot;1.0.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="meta">@HystrixCommand(commandProperties = &#123;</span></span><br><span class="line"><span class="meta">     @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">     @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;) &#125;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;async provider received: &quot; + name);</span></span><br><span class="line">        <span class="comment">// return &quot;annotation: hello, &quot; + name;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception to show hystrix enabled.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、配置Consumer端"><a href="#3、配置Consumer端" class="headerlink" title="3、配置Consumer端"></a>3、配置Consumer端</h4><p>对于Consumer端，则可以增加一层method调用，并在method上配置@HystrixCommand。当调用出错时，会走到fallbackMethod &#x3D; “reliable”的调用里。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Reference(version = &quot;1.0.0&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> HelloService demoService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@HystrixCommand(fallbackMethod = &quot;reliable&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">doSayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">reliable</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hystrix fallback value&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="四、dubbo原理"><a href="#四、dubbo原理" class="headerlink" title="四、dubbo原理"></a>四、dubbo原理</h1><h2 id="1、RPC原理"><a href="#1、RPC原理" class="headerlink" title="1、RPC原理"></a>1、RPC原理</h2><p> <img src="/2022/11/20/Dubbo/image-20221023113318585.png" alt="image-20221023113318585"></p><p>  一次完整的RPC调用流程（同步调用，异步另说）如下：  </p><p><strong>1</strong>）服务消费方（client）调用以本地调用方式调用服务；</p><p>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； </p><p>3）client stub找到服务地址，并将消息发送到服务端； </p><p>4）server stub收到消息后进行解码； </p><p>5）server stub根据解码结果调用本地的服务； </p><p>6）本地服务执行并将结果返回给server stub； </p><p>7）server stub将返回结果打包成消息并发送至消费方； </p><p>8）client stub接收到消息，并进行解码； </p><p><strong>9</strong>）服务消费方得到最终结果。</p><p>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</p><h2 id="2、netty通信原理"><a href="#2、netty通信原理" class="headerlink" title="2、netty通信原理"></a>2、netty通信原理</h2><p>Netty是一个异步事件驱动的网络应用程序框架， 用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。</p><p>BIO：(Blocking IO)</p><p> <img src="/2022/11/20/Dubbo/image-20221023113406919.png" alt="image-20221023113406919"></p><p>NIO (Non-Blocking IO)</p><p> <img src="/2022/11/20/Dubbo/image-20221023113415008.png" alt="image-20221023113415008"></p><p>Selector 一般称 为<strong>选择器</strong> ，也可以翻译为 <strong>多路复用器，</strong></p><p>Connect（连接就绪）、Accept（接受就绪）、Read（读就绪）、Write（写就绪）</p><p>Netty基本原理：</p><p> <img src="/2022/11/20/Dubbo/image-20221023113425432.png" alt="image-20221023113425432"></p><h2 id="3、dubbo原理"><a href="#3、dubbo原理" class="headerlink" title="3、dubbo原理"></a>3、dubbo原理</h2><h3 id="1、dubbo原理-框架设计"><a href="#1、dubbo原理-框架设计" class="headerlink" title="1、dubbo原理 -框架设计"></a>1、dubbo原理 -框架设计</h3><p> <img src="/2022/11/20/Dubbo/image-20221023113434307.png" alt="image-20221023113434307"></p><ul><li>l config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li><li>l proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li><li>l registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li><li>l cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li><li>l monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li><li>l protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li><li>l exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li><li>l transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li><li>l serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li></ul><h3 id="2、dubbo原理-启动解析、加载配置信息"><a href="#2、dubbo原理-启动解析、加载配置信息" class="headerlink" title="2、dubbo原理 -启动解析、加载配置信息"></a>2、dubbo原理 -启动解析、加载配置信息</h3><p> <img src="/2022/11/20/Dubbo/image-20221023113451251.png" alt="image-20221023113451251"></p><h3 id="3、dubbo原理-服务暴露"><a href="#3、dubbo原理-服务暴露" class="headerlink" title="3、dubbo原理 -服务暴露"></a>3、dubbo原理 -服务暴露</h3><p> <img src="/2022/11/20/Dubbo/image-20221023113455723.png" alt="image-20221023113455723"></p><h3 id="4、dubbo原理-服务引用"><a href="#4、dubbo原理-服务引用" class="headerlink" title="4、dubbo原理 -服务引用"></a>4、dubbo原理 -服务引用</h3><p> <img src="/2022/11/20/Dubbo/image-20221023113501509.png" alt="image-20221023113501509"></p><h3 id="5、dubbo原理-服务调用"><a href="#5、dubbo原理-服务调用" class="headerlink" title="5、dubbo原理 -服务调用"></a>5、dubbo原理 -服务调用</h3><p> <img src="/2022/11/20/Dubbo/image-20221023113507171.png" alt="image-20221023113507171"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty</title>
      <link href="/2022/10/22/Netty/"/>
      <url>/2022/10/22/Netty/</url>
      
        <content type="html"><![CDATA[<h1 id="第-1-章-Netty-介绍和应用场景"><a href="#第-1-章-Netty-介绍和应用场景" class="headerlink" title="第 1 章 Netty 介绍和应用场景"></a>第 1 章 Netty 介绍和应用场景</h1><h2 id="1-1-本课程学习要求"><a href="#1-1-本课程学习要求" class="headerlink" title="1.1      本课程学习要求"></a>1.1      本课程学习要求</h2><ol><li><p>本课程不适用于 0 基础的学员</p></li><li><p>要求已经掌握了 Java  编程， 主要技术构成： Java OOP 编程、Java  多线程编程、Java IO  编程  、Java 网络编程、常用的 Java 设计模式(比如 观察者模式 ，命令模式，职责链模式  )、常用的数据结构(比如 链表)</p></li><li><p>本课程的 &lt;&lt;Netty 核心源码剖析章节&gt;&gt; 要求学员最好有项目开发和阅读源码的经历</p></li></ol><h2 id="1-2-Netty-的介绍"><a href="#1-2-Netty-的介绍" class="headerlink" title="1.2      Netty 的介绍"></a>1.2      Netty 的介绍</h2><ol><li><p>Netty 是由 JBOSS 提供的一个 <strong>Java</strong> <strong>开源框架</strong>，现为 <strong>Github</strong> <strong>上的独立项目</strong>。</p></li><li><p>Netty 是一个<strong>异步</strong>的、<strong>基于事件驱动</strong>的网络应用框架，用以快速开发高性能、高可靠性的网络 IO 程序。</p></li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="/2022/10/22/Netty/clip_image002.jpg" alt="img"></td></tr></tbody></table><ol start="3"><li><p>Netty 主要针对在 TCP 协议下，面向 Clients 端的高并发应用，或者 Peer-to-Peer 场景下的大量数据持续传输的应用。</p></li><li><p>Netty 本质是一个 NIO 框架，适用于服务器通讯相关的多种应用场景</p></li></ol><p><img src="/2022/10/22/Netty/clip_image004.jpg" alt="img"></p><ol start="5"><li>要透彻理解 Netty ， 需要先学习 NIO ， 这样我们才能阅读 Netty 的源码。</li></ol><h2 id="1-3-Netty-的应用场景"><a href="#1-3-Netty-的应用场景" class="headerlink" title="1.3      Netty 的应用场景"></a>1.3      Netty 的应用场景</h2><h3 id="1-3-1-互联网行业"><a href="#1-3-1-互联网行业" class="headerlink" title="1.3.1 互联网行业"></a>1.3.1 互联网行业</h3><ol><li><p>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。</p></li><li><p>典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信</p></li></ol><h3 id="1-3-2-游戏行业"><a href="#1-3-2-游戏行业" class="headerlink" title="1.3.2 游戏行业"></a>1.3.2 游戏行业</h3><ol><li><p>无论是手游服务端还是大型的网络游戏，Java 语言得到了越来越广泛的应用</p></li><li><p>Netty 作为高性能的基础通信组件，提供了 TCP&#x2F;UDP 和 HTTP 协议栈，方便定制和开发私有协议栈，账号登录服务器</p></li><li><p>地图服务器之间可以方便的通过 Netty 进行高性能的通信</p></li></ol><h3 id="1-3-3-大数据领域"><a href="#1-3-3-大数据领域" class="headerlink" title="1.3.3 大数据领域"></a>1.3.3 大数据领域</h3><ol><li><p>经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨界点通信</p></li><li><p>它的 Netty Service 基于 Netty 框架二次封装实现。</p></li></ol><p><img src="/2022/10/22/Netty/clip_image008.jpg" alt="img"></p><h3 id="1-3-4-其它开源项目使用到Netty"><a href="#1-3-4-其它开源项目使用到Netty" class="headerlink" title="1.3.4 其它开源项目使用到Netty"></a>1.3.4 其它开源项目使用到Netty</h3><p>网址: <a href="https://netty.io/wiki/related-projects.html">https://netty.io/wiki/related-projects.html</a></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="/2022/10/22/Netty/clip_image010.jpg" alt="img"></td></tr></tbody></table><h2 id="1-4-Netty-的学习参考资料"><a href="#1-4-Netty-的学习参考资料" class="headerlink" title="1.4      Netty 的学习参考资料"></a>1.4      Netty 的学习参考资料</h2><p><img src="/2022/10/22/Netty/clip_image011.jpg" alt="img"></p><p><img src="/2022/10/22/Netty/clip_image012.gif" alt="img"></p><h1 id="第-2-章-Java-BIO-编程"><a href="#第-2-章-Java-BIO-编程" class="headerlink" title="第 2 章 Java BIO 编程"></a>第 2 章 Java BIO 编程</h1><h2 id="2-1-I-x2F-O-模型"><a href="#2-1-I-x2F-O-模型" class="headerlink" title="2.1      I&#x2F;O 模型"></a>2.1      I&#x2F;O 模型</h2><h3 id="2-1-1-I-x2F-O-模型基本说明"><a href="#2-1-1-I-x2F-O-模型基本说明" class="headerlink" title="2.1.1  I&#x2F;O 模型基本说明"></a>2.1.1  I&#x2F;O 模型基本说明</h3><ol><li><p>I&#x2F;O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能</p></li><li><p>Java 共支持 3 种网络编程模型&#x2F;IO 模式：BIO、NIO、AIO</p></li><li><p>Java BIO ： 同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</p></li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="/2022/10/22/Netty/clip_image013.jpg" alt="img"></td></tr></tbody></table><ol start="4"><li>Java NIO ： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I&#x2F;O 请求就进行处理</li></ol><p><img src="/2022/10/22/Netty/clip_image015.gif" alt="img"></p><ol start="5"><li>Java AIO(NIO.2) ： 异步非阻塞，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li></ol><h2 id="2-2-BIO、NIO、AIO-适用场景分析"><a href="#2-2-BIO、NIO、AIO-适用场景分析" class="headerlink" title="2.2      BIO、NIO、AIO 适用场景分析"></a>2.2      BIO、NIO、AIO 适用场景分析</h2><ol><li><p>BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。</p></li><li><p>NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4 开始支持。</p></li><li><p>AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作， 编程比较复杂，JDK7 开始支持。</p></li></ol><h2 id="2-3-Java-BIO-基本介绍"><a href="#2-3-Java-BIO-基本介绍" class="headerlink" title="2.3      Java BIO 基本介绍"></a>2.3      Java BIO 基本介绍</h2><ol><li><p>Java *<strong>BIO*</strong> 就是传统的 <strong>java io</strong> <strong>编程</strong>，其相关的类和接口在 java.io</p></li><li><p>BIO(<strong>blocking I&#x2F;O</strong>) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器)。</p></li><li><p>BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解</p></li></ol><h2 id="2-4-Java-BIO-工作机制"><a href="#2-4-Java-BIO-工作机制" class="headerlink" title="2.4      Java BIO 工作机制                     "></a>2.4      Java BIO 工作机制                     <img src="file:///C:/Users/DONGIU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></h2><h4 id="对-BIO-编程流程的梳理"><a href="#对-BIO-编程流程的梳理" class="headerlink" title="对 BIO 编程流程的梳理"></a>对 BIO 编程流程的梳理</h4><ol><li><p>服务器端启动一个 ServerSocket</p></li><li><p>客户端启动 Socket 对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯</p></li><li><p>客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</p></li><li><p>如果有响应，客户端线程会等待请求结束后，在继续执行</p></li></ol><h2 id="2-5-Java-BIO-应用实例"><a href="#2-5-Java-BIO-应用实例" class="headerlink" title="2.5      Java BIO 应用实例"></a>2.5      Java BIO 应用实例</h2><p>实例说明：</p><ol><li><p>使用 BIO 模型编写一个服务器端，监听 6666 端口，当有客户端连接时，就启动一个线程与之通讯。</p></li><li><p>要求使用线程池机制改善，可以连接多个客户端.</p></li><li><p>服务器端可以接收客户端发送的数据(telnet 方式即可)。</p></li><li><p>代码演示</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/22 15:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//思路：</span></span><br><span class="line">        <span class="comment">//1. 创建一个线程池</span></span><br><span class="line">        <span class="comment">//2. 如果有客户端连接，就创建一个线程，与之通讯（单独写一个方法）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插件ServerSocker</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到一个客户端&quot;</span>);</span><br><span class="line">            <span class="comment">//创建一个线程，与之通讯（单独写一个方法）</span></span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    handler(accept);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个handler方法，和客户端通讯</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息id：&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;,名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//通过socket 获取输入流</span></span><br><span class="line">            <span class="type">byte</span>[] aByte = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">//循环读取数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> inputStream.read(aByte);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(aByte,<span class="number">0</span>,read));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和client的连接&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/22/Netty/image-20221022155235856.png" alt="image-20221022155235856"></p><p><img src="/2022/10/22/Netty/image-20221022155412156.png" alt="image-20221022155412156"></p><h2 id="2-6-Java-BIO-问题分析"><a href="#2-6-Java-BIO-问题分析" class="headerlink" title="2.6      Java BIO 问题分析"></a>2.6      Java BIO 问题分析</h2><ol><li><p>每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。</p></li><li><p>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</p></li><li><p>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。</p></li></ol><h1 id="第-3-章-Java-NIO-编程"><a href="#第-3-章-Java-NIO-编程" class="headerlink" title="第 3 章 Java NIO 编程"></a>第 3 章 Java NIO 编程</h1><h2 id="3-1-Java-NIO-基本介绍"><a href="#3-1-Java-NIO-基本介绍" class="headerlink" title="3.1      Java NIO 基本介绍"></a>3.1      Java NIO 基本介绍</h2><ol><li><p>Java NIO 全称 <strong>java non-blocking IO</strong>，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO(即 New IO)，是同步非阻塞的。</p></li><li><p>NIO 相关类都被放在 <strong>java.nio</strong> 包及子包下，并且对原 java.io 包中的很多类进行改写。</p></li><li><p>NIO 有三大核心部分：<strong>Channel(通道</strong>)，<strong>Buffer(缓冲区</strong>), <strong>Selector(选择器)</strong></p></li><li><p><strong>NIO</strong> <strong>是 面向缓冲区</strong> ，<strong>或者面向 块 编程的</strong>。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络</p></li><li><p>Java NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入， 这个线程同时可以去做别的事情。</p></li><li><p>通俗理解：NIO 是可以做到用一个线程来处理多个操作的。假设有 10000 个请求过来,根据实际情况，可以分配50 或者 100 个线程来处理。不像之前的阻塞 IO 那样，非得分配 10000 个。</p></li><li><p>HTTP2.0 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 HTTP1.1 大了好几个数量级</p></li><li><p>案例说明 NIO 的 Buffer</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"><span class="keyword">import</span> java.nio.IntBuffer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//举例说明 Buffer 的使用 (简单说明)</span></span><br><span class="line">        <span class="comment">//创建一个 Buffer, 大小为 5, 即可以存放 5 个 int IntBuffer intBuffer = IntBuffer.allocate(5);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//向 buffer 存放数据</span></span><br><span class="line">        <span class="comment">//intBuffer.put(10);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(11);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(12);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(13);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(14);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intBuffer.capacity(); i++) &#123; </span><br><span class="line">            intBuffer.put( i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何从 buffer 读取数据</span></span><br><span class="line">        <span class="comment">//将 buffer 转换，读写切换(!!!) intBuffer.flip();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (intBuffer.hasRemaining()) &#123; System.out.println(intBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-NIO-和-BIO-的比较"><a href="#3-2-NIO-和-BIO-的比较" class="headerlink" title="3.2      NIO 和 BIO 的比较"></a>3.2      NIO 和 BIO 的比较</h2><ol><li><p>BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I&#x2F;O 的效率比流 I&#x2F;O 高很多</p></li><li><p>BIO 是阻塞的，NIO 则是非阻塞的</p></li><li><p>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求， 数据到达等），因此使用单个线程就可以监听多个客户端通道。</p></li></ol><h2 id="3-3-NIO-三大核心原理示意图"><a href="#3-3-NIO-三大核心原理示意图" class="headerlink" title="3.3      NIO 三大核心原理示意图"></a>3.3      NIO 三大核心原理示意图</h2><p>一张图描述 NIO 的 Selector 、 Channel 和 Buffer 的关系</p><h3 id="3-3-1-Selector-、-Channel-和-Buffer-的关系图-简单版"><a href="#3-3-1-Selector-、-Channel-和-Buffer-的关系图-简单版" class="headerlink" title="3.3.1 Selector 、 Channel 和 Buffer 的关系图(简单版)"></a>3.3.1 Selector 、 Channel 和 Buffer 的关系图(简单版)</h3><p>关系图的说明:</p><p><img src="/2022/10/22/Netty/clip_image026.jpg" alt="img"></p><ol><li><p>每个 channel 都会对应一个 Buffer</p></li><li><p>Selector 对应一个线程， 一个线程对应多个 channel(连接)</p></li><li><p>该图反应了有三个 channel 注册到 该 selector &#x2F;&#x2F;程序</p></li><li><p>程序切换到哪个 channel 是有事件决定的, Event 就是一个重要的概念</p></li><li><p>Selector 会根据不同的事件，在各个通道上切换</p></li><li><p>Buffer 就是一个内存块 ， 底层是有一个数组</p></li><li><p>数据的读取写入是通过 Buffer, 这个和 BIO , BIO 中要么是输入流，或者是输出流, 不能双向，但是 NIO 的 Buffer 是可以读也可以写, 需要 flip 方法切换，channel 是双向的, 可以返回底层操作系统的情况, 比如 Linux ， 底层的操作系统通道就是双向的。</p></li></ol><h2 id="3-4-缓冲区-Buffer"><a href="#3-4-缓冲区-Buffer" class="headerlink" title="3.4      缓冲区(Buffer)"></a>3.4      缓冲区(Buffer)</h2><h3 id="3-4-1-基本介绍"><a href="#3-4-1-基本介绍" class="headerlink" title="3.4.1 基本介绍"></a>3.4.1 基本介绍</h3><p>缓冲区（Buffer）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个**容器对象(含数组)**，该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer，如图:    </p><p><img src="/2022/10/22/Netty/image-20221023120615713.png" alt="image-20221023120615713"></p><h3 id="3-4-2-Buffer-类及其子类"><a href="#3-4-2-Buffer-类及其子类" class="headerlink" title="3.4.2 Buffer 类及其子类"></a>3.4.2 Buffer 类及其子类</h3><ol><li>在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类, 类的层级关系图:</li></ol><p><img src="/2022/10/22/Netty/image-20221023120811236.png" alt="image-20221023120811236"></p><ol start="2"><li>Buffer 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息:</li></ol><p><img src="/2022/10/22/Netty/image-20221023120828836.png" alt="image-20221023120828836"></p><ol start="3"><li>Buffer 类相关方法一览</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    <span class="comment">//JDK1.4时，引入的api</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">( )</span><span class="comment">//返回此缓冲区的容量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">position</span><span class="params">( )</span><span class="comment">//返回此缓冲区的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">position</span> <span class="params">(<span class="type">int</span> newPositio)</span><span class="comment">//设置此缓冲区的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">limit</span><span class="params">( )</span><span class="comment">//返回此缓冲区的限制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">limit</span> <span class="params">(<span class="type">int</span> newLimit)</span><span class="comment">//设置此缓冲区的限制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">mark</span><span class="params">( )</span><span class="comment">//在此缓冲区的位置设置标记</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">reset</span><span class="params">( )</span><span class="comment">//将此缓冲区的位置重置为以前标记的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">clear</span><span class="params">( )</span><span class="comment">//清除此缓冲区, 即将各个标记恢复到初始状态，但是数据并没有真正擦除, 后面操作会覆盖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">( )</span><span class="comment">//反转此缓冲区</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">rewind</span><span class="params">( )</span><span class="comment">//重绕此缓冲区</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">remaining</span><span class="params">( )</span><span class="comment">//返回当前位置与限制之间的元素数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasRemaining</span><span class="params">( )</span><span class="comment">//告知在当前位置和限制之间是否有元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">( )</span>;<span class="comment">//告知此缓冲区是否为只读缓冲区</span></span><br><span class="line">    <span class="comment">//JDK1.6时引入的api</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">hasArray</span><span class="params">()</span>;<span class="comment">//告知此缓冲区是否具有可访问的底层实现数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title function_">array</span><span class="params">()</span>;<span class="comment">//返回此缓冲区的底层实现数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">arrayOffset</span><span class="params">()</span>;<span class="comment">//返回此缓冲区的底层实现数组中第一个缓冲区元素的偏移量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isDirect</span><span class="params">()</span>;<span class="comment">//告知此缓冲区是否为直接缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-3-ByteBuffer"><a href="#3-4-3-ByteBuffer" class="headerlink" title="3.4.3 ByteBuffer"></a>3.4.3 ByteBuffer</h3><p>从前面可以看出对于 Java 中的基本数据类型(boolean 除外)，都有一个 Buffer 类型与之相对应，最常用的自然是 ByteBuffer 类（二进制数据)，该类的主要方法如下：</p><p><img src="/2022/10/22/Netty/image-20221023120930058.png" alt="image-20221023120930058"></p><h2 id="3-5-通道-Channel"><a href="#3-5-通道-Channel" class="headerlink" title="3.5      通道(Channel)"></a>3.5      通道(Channel)</h2><h3 id="3-5-1基本介绍"><a href="#3-5-1基本介绍" class="headerlink" title="3.5.1基本介绍"></a>3.5.1基本介绍</h3><ol><li><p>NIO 的通道类似于流，但有些区别如下：</p><ul><li><p>通道可以同时进行读写，而流只能读或者只能写</p></li><li><p>通道可以实现异步读写数据</p></li><li><p>通道可以从缓冲读数据，也可以写数据到缓冲</p></li></ul></li><li><p>BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel) 是双向的，可以读操作，也可以写操作。</p></li><li><p>Channel 在 NIO 中是一个接口<code>public interface Channel extends Closeable&#123;&#125;</code></p></li><li><p>常 用 的  Channel  类 有 ： <strong>FileChannel</strong> 、 DatagramChannel 、 <strong>ServerSocketChannel</strong>  和 <strong>SocketChannel</strong> 。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</p></li><li><p>FileChannel 用于文件的数据读写， DatagramChannel 用于 UDP 的数据读写， ServerSocketChannel 和SocketChannel 用于 TCP 的数据读写。</p></li><li><p>图示</p></li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="/2022/10/22/Netty/clip_image035.jpg" alt="img"></td></tr></tbody></table><h3 id="3-5-2-FileChannel-类"><a href="#3-5-2-FileChannel-类" class="headerlink" title="3.5.2 FileChannel 类"></a>3.5.2 FileChannel 类</h3><p>FileChannel 主要用来对本地文件进行 IO 操作，常见的方法有</p><ul><li>public int read(ByteBuffer dst) ，从通道读取数据并放到缓冲区中</li><li>public int write(ByteBuffer src) ，把缓冲区的数据写到通道中</li><li>public long transferFrom(ReadableByteChannel src, long position, long count)，从目标通道中复制数据到当前通道</li><li>public long transferTo(long position, long count, WritableByteChannel target)，把数据从当前通道复制给目标通道</li></ul><h3 id="3-5-3-应用实例-1-本地文件写数据"><a href="#3-5-3-应用实例-1-本地文件写数据" class="headerlink" title="3.5.3 应用实例 1-本地文件写数据"></a>3.5.3 应用实例 1-本地文件写数据</h3><p>实例要求:</p><ol><li><p>使用前面学习后的 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 “hello,尚硅谷” 写入到 file01.txt 中</p></li><li><p>文件不存在就创建</p></li><li><p>代码演示</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream; <span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello,尚硅谷&quot;</span>;</span><br><span class="line">        <span class="comment">//创建一个输出流-&gt;channel</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\file01.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过 fileOutputStream  获取 对应的 FileChannel</span></span><br><span class="line">        <span class="comment">//这个 fileChannel 真实 类型是FileChannelImpl </span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个缓冲区 ByteBuffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 str 放 入 byteBuffer </span></span><br><span class="line">        byteBuffer.put(str.getBytes());</span><br><span class="line">        <span class="comment">//对 byteBuffer 进行 flip </span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 byteBuffer 数据写入到 fileChannel </span></span><br><span class="line">        fileChannel.write(byteBuffer); </span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code> byteBuffer.flip();</code>将position的值赋给limit，然后从0开始读</p><p><img src="/2022/10/22/Netty/image-20221023145444226.png" alt="image-20221023145444226"></p><h3 id="3-5-4-应用实例-2-本地文件读数据"><a href="#3-5-4-应用实例-2-本地文件读数据" class="headerlink" title="3.5.4 应用实例 2-本地文件读数据"></a>3.5.4 应用实例 2-本地文件读数据</h3><p>实例要求:</p><ol><li><p>使用前面学习后的 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 file01.txt 中的数据读入到程序，并显示在控制台屏幕</p></li><li><p>假定文件已经存在</p></li><li><p>代码演示</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream; <span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\file01.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过 fileInputStream  获取对应的 FileChannel -&gt; 实际类型FileChannelImpl </span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>) file.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 通道的数据读入到 Buffer </span></span><br><span class="line">        fileChannel.read(byteBuffer);</span><br><span class="line">        <span class="comment">// 将 byteBuffer 的 字 节 数 据 转 成 String </span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array())); </span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-5-应用实例-3-使用一个Buffer-完成文件读取、写入"><a href="#3-5-5-应用实例-3-使用一个Buffer-完成文件读取、写入" class="headerlink" title="3.5.5 应用实例 3-使用一个Buffer 完成文件读取、写入"></a>3.5.5 应用实例 3-使用一个Buffer 完成文件读取、写入</h3><p>实例要求:</p><ol><li><p>使用 FileChannel(通道) 和 方法 read , write，完成文件的拷贝</p></li><li><p>拷贝一个文本文件 1.txt  , 放在项目下即可</p></li><li><p>代码演示</p></li></ol><p><img src="/2022/10/22/Netty/image-20221023121853120.png" alt="image-20221023121853120"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream; <span class="keyword">import</span> java.io.FileOutputStream; <span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;1.txt&quot;</span>); </span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel01</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;2.txt&quot;</span>); </span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel02</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//循环读取</span></span><br><span class="line">            <span class="comment">//这里有一个重要的操作，一定不要忘了</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public final Buffer clear() &#123; </span></span><br><span class="line"><span class="comment">            position = 0;</span></span><br><span class="line"><span class="comment">            limit = capacity; </span></span><br><span class="line"><span class="comment">            mark = -1; </span></span><br><span class="line"><span class="comment">            return this;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            byteBuffer.clear(); <span class="comment">//清空 buffer</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fileChannel01.read(byteBuffer); </span><br><span class="line">            System.out.println(<span class="string">&quot;read =&quot;</span> + read); </span><br><span class="line">            <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123; <span class="comment">//表示读完</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将 buffer 中的数据写入到 fileChannel02 -- 2.txt </span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            fileChannel02.write(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭相关的流</span></span><br><span class="line">        fileInputStream.close(); </span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-5-6-应用实例-4-拷贝文件transferFrom-方法"><a href="#3-5-6-应用实例-4-拷贝文件transferFrom-方法" class="headerlink" title="3.5.6 应用实例 4-拷贝文件transferFrom 方法"></a>3.5.6 应用实例 4-拷贝文件transferFrom 方法</h3><ol><li><p>实例要求:</p></li><li><p>使用 FileChannel(通道) 和 方法 transferFrom ，完成文件的拷贝</p></li><li><p>拷贝一张图片</p></li><li><p>代码演示</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream; <span class="keyword">import</span> java.io.FileOutputStream; <span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建相关流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\a.jpg&quot;</span>); </span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\a2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取各个流对应的 filechannel</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">sourceCh</span> <span class="operator">=</span> fileInputStream.getChannel(); </span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">destCh</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 transferForm 完成拷贝</span></span><br><span class="line">        destCh.transferFrom(sourceCh,<span class="number">0</span>,sourceCh.size());</span><br><span class="line">        <span class="comment">//关闭相关通道和流</span></span><br><span class="line">        sourceCh.close(); </span><br><span class="line">        destCh.close(); </span><br><span class="line">        fileInputStream.close(); </span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-5-7-关于Buffer-和-Channel-的注意事项和细节"><a href="#3-5-7-关于Buffer-和-Channel-的注意事项和细节" class="headerlink" title="3.5.7 关于Buffer 和 Channel 的注意事项和细节"></a>3.5.7 关于Buffer 和 Channel 的注意事项和细节</h3><ol><li>ByteBuffer 支持类型化的 put 和 get, put 放入的是什么数据类型，get 就应该使用相应的数据类型来取出，否则可能有 BufferUnderflowException 异常。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOByteBufferPutGet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个 Buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类型化方式放入数据</span></span><br><span class="line">        buffer.putInt(<span class="number">100</span>); buffer.putLong(<span class="number">9</span>);</span><br><span class="line">        buffer.putChar(<span class="string">&#x27; 尚 &#x27;</span>); buffer.putShort((<span class="type">short</span>) <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//取出buffer.flip();</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(buffer.getInt()); </span><br><span class="line">        System.out.println(buffer.getLong()); </span><br><span class="line">        System.out.println(buffer.getChar()); </span><br><span class="line">        System.out.println(buffer.getShort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>可以将一个普通 Buffer 转成只读 Buffer</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadOnlyBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个 buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123; </span><br><span class="line">            buffer.put((<span class="type">byte</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取buffer.flip();</span></span><br><span class="line">        <span class="comment">//得到一个只读的 Buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">readOnlyBuffer</span> <span class="operator">=</span> buffer.asReadOnlyBuffer(); </span><br><span class="line">        System.out.println(readOnlyBuffer.getClass());</span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="keyword">while</span> (readOnlyBuffer.hasRemaining()) &#123; </span><br><span class="line">            System.out.println(readOnlyBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        readOnlyBuffer.put((<span class="type">byte</span>)<span class="number">100</span>); <span class="comment">//ReadOnlyBufferException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进行修改， 而如何同步到文件由 NIO 来完成。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile; </span><br><span class="line"><span class="keyword">import</span> java.nio.MappedByteBuffer; </span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 说明</span></span><br><span class="line"><span class="comment">* 1. MappedByteBuffer 可让文件直接在内存(堆外内存)修改,  操作系统不需要拷贝* 一次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MappedByteBufferTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对应的通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> randomAccessFile.getChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *参数 1: FileChannel.MapMode.READ_WRITE 使用的读写模式</span></span><br><span class="line"><span class="comment">        *参数 2： 0 ： 可以直接修改的起始位置</span></span><br><span class="line"><span class="comment">        *参数 3:5: 是映射到内存的大小(不是索引位置) ,即将 1.txt 的多少个字节映射到内存</span></span><br><span class="line"><span class="comment">        *可以直接修改的范围就是 0-5</span></span><br><span class="line"><span class="comment">        *实际类型 DirectByteBuffer</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">MappedByteBuffer</span> <span class="variable">mappedByteBuffer</span> <span class="operator">=</span> channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        mappedByteBuffer.put(<span class="number">0</span>, (<span class="type">byte</span>) <span class="string">&#x27;H&#x27;</span>); </span><br><span class="line">        mappedByteBuffer.put(<span class="number">3</span>, (<span class="type">byte</span>) <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">        <span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line">        mappedByteBuffer.put(<span class="number">5</span>, (<span class="type">byte</span>) <span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">       </span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>4. 前面我们讲的读写操作，都是通过一个 Buffer 完成的，NIO 还支持 通过多个 Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering 。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress; <span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel; <span class="keyword">import</span> java.nio.channels.SocketChannel; <span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入[分散]</span></span><br><span class="line"><span class="comment">*Gathering: 从 buffer 读取数据时，可以采用 buffer 数组，依次读[聚集]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScatteringAndGatheringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 ServerSocketChannel  和 SocketChannel 网络</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open(); </span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">7000</span>);</span><br><span class="line">        <span class="comment">//绑定端口到 socket ，并启动</span></span><br><span class="line">        serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line">        <span class="comment">//创建 buffer 数组</span></span><br><span class="line">        ByteBuffer[] byteBuffers = <span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[<span class="number">2</span>];</span><br><span class="line">        byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>); </span><br><span class="line">        byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//等客户端连接(telnet)</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">        <span class="type">int</span> <span class="variable">messageLength</span> <span class="operator">=</span> <span class="number">8</span>;<span class="comment">//假定从客户端接收 8 个字节</span></span><br><span class="line">        <span class="comment">//循环的读取</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">byteRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (byteRead &lt; messageLength ) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> socketChannel.read(byteBuffers); </span><br><span class="line">                    byteRead += l; <span class="comment">//累计读取的字节数</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;byteRead=&quot;</span> + byteRead);</span><br><span class="line">                <span class="comment">// 使 用 流 打 印 , 看 看 当 前 的 这 个 buffer 的 position 和 limit </span></span><br><span class="line">                    Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="string">&quot;postion=&quot;</span> + buffer.position() + <span class="string">&quot;, limit=&quot;</span> +</span><br><span class="line">                buffer.limit()).forEach(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 所 有 的 buffer 进 行 flip </span></span><br><span class="line">                Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());</span><br><span class="line">            <span class="comment">//将数据读出显示到客户端</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">byteWirte</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (byteWirte &lt; messageLength) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> socketChannel.write(byteBuffers); <span class="comment">// byteWirte += l;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将所有的 buffer 进行 clear</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer-&gt; &#123; </span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;byteRead:=&quot;</span> + byteRead + <span class="string">&quot; byteWrite=&quot;</span> + byteWirte + <span class="string">&quot;, messagelength&quot;</span> + messageLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-Selector-选择器"><a href="#3-7-Selector-选择器" class="headerlink" title="3.7    Selector(选择器)"></a>3.7    Selector(选择器)</h2><h3 id="3-7-1-基本介绍"><a href="#3-7-1-基本介绍" class="headerlink" title="3.7.1 基本介绍"></a>3.7.1 基本介绍</h3><ol><li><p>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到 Selector(选择器)</p></li><li><p>Selector 能够检测多个注册的通道上是否有事件发生(注意:多个 Channel 以事件的方式可以注册到同一个Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</p></li><li><p>只有在 连接&#x2F;通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</p></li><li><p>避免了多线程之间的上下文切换导致的开销</p></li></ol><h3 id="3-7-2Selector-示意图和特点说明"><a href="#3-7-2Selector-示意图和特点说明" class="headerlink" title="3.7.2Selector 示意图和特点说明"></a>3.7.2Selector 示意图和特点说明</h3><p><img src="/2022/10/22/Netty/image-20221023171551026.png" alt="image-20221023171551026"></p><p>说明如下：</p><ol><li><p>Netty 的 IO 线程 NioEventLoop 聚合了 Selector(选择器，也叫多路复用器)，可以同时并发处理成百上千个客户端连接。</p></li><li><p>当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</p></li><li><p>线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。</p></li><li><p>由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 I&#x2F;O 阻塞导致的线程挂起。</p></li><li><p>一个 I&#x2F;O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I&#x2F;O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p></li></ol><h3 id="3-7-3-Selector-类相关方法"><a href="#3-7-3-Selector-类相关方法" class="headerlink" title="3.7.3   Selector 类相关方法"></a>3.7.3   Selector 类相关方法</h3><p>Selector 类是一个抽象类, 常用方法和说明如下:</p><p><img src="/2022/10/22/Netty/image-20221023171639122.png" alt="image-20221023171639122"></p><h3 id="3-7-4-注意事项"><a href="#3-7-4-注意事项" class="headerlink" title="3.7.4 注意事项"></a>3.7.4 注意事项</h3><ol><li><p>NIO 中的 ServerSocketChannel 功能类似 ServerSocket，SocketChannel 功能类似 Socket</p></li><li><p>selector 相关方法说明</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selector.select()<span class="comment">//阻塞</span></span><br><span class="line"></span><br><span class="line">selector.select(<span class="number">1000</span>);<span class="comment">//阻塞 1000 毫秒，在 1000 毫秒后返回</span></span><br><span class="line"></span><br><span class="line">selector.wakeup();<span class="comment">//唤醒 selector</span></span><br><span class="line"></span><br><span class="line">selector.selectNow();<span class="comment">//不阻塞，立马返还</span></span><br></pre></td></tr></table></figure><h2 id="3-8-NIO-非阻塞-网络编程原理分析图"><a href="#3-8-NIO-非阻塞-网络编程原理分析图" class="headerlink" title="3.8    NIO 非阻塞 网络编程原理分析图"></a>3.8    NIO 非阻塞 网络编程原理分析图</h2><p>NIO 非阻塞 网络编程相关的(Selector、SelectionKey、ServerScoketChannel 和 SocketChannel) 关系梳理图</p><p><img src="/2022/10/22/Netty/image-20221023171735105.png" alt="image-20221023171735105"></p><p>对上图的说明:</p><ol><li><p>当客户端连接时，会通过 ServerSocketChannel 得到 SocketChannel</p></li><li><p>Selector 进行监听 select 方法, 返回有事件发生的通道的个数.</p></li><li><p>通过 <code>register(Selector sel, int ops)</code>将 socketChannel 注册到 Selector 上, 一个 selector 上可以注册多个 SocketChannel</p></li><li><p>注册后返回一个 SelectionKey, 会和该 Selector 关联(集合)</p></li><li><p>进一步得到各个 SelectionKey (有事件发生)</p></li><li><p>在通过 SelectionKey  反向获取 SocketChannel , 方法 channel()</p></li><li><p>可以通过 得到的 channel  , 完成业务处理</p></li></ol><h2 id="3-9-NIO-非阻塞-网络编程快速入门"><a href="#3-9-NIO-非阻塞-网络编程快速入门" class="headerlink" title="3.9    NIO 非阻塞 网络编程快速入门"></a>3.9    NIO 非阻塞 网络编程快速入门</h2><p>案例要求:</p><ol><li><p>编写一个 NIO 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</p></li><li><p>目的：理解 NIO 非阻塞网络编程机制</p></li><li><p>代码演示</p></li></ol><p>NIOServer（服务端）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/24 20:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建serverSocketChannel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//得到一个Select对象</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">//绑定一个端口6666，在服务端监听</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//把serverSocketChannel 注册到 selector ，关心事件为OP_ACCEPT</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">//循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//这里等待1秒，如果没有事件发生，返回</span></span><br><span class="line">            <span class="keyword">if</span> (selector.select(<span class="number">1000</span>) == <span class="number">0</span>)&#123; <span class="comment">//没有事件发生</span></span><br><span class="line">                System.out.println(<span class="string">&quot;服务器等待了1秒。无连接&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果返回的值&gt;0,就获取到相关的selectionKey集合</span></span><br><span class="line">            <span class="comment">//1. 如果返回的值&gt;0,表示已经获取到关注的事件</span></span><br><span class="line">            <span class="comment">//2. selector.selectedKeys() 返回关注事件的集合</span></span><br><span class="line">            <span class="comment">//3. 通过selectionKeys反向获取通道</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//遍历selectionKeys,使用迭代器遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                <span class="comment">//获取到selectionKey</span></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">//根据key 对应的通道发生的事件做相应的处理</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123; <span class="comment">//如果是 OP_ACCEPT (表示有一个新的客户端连接)</span></span><br><span class="line">                    <span class="comment">//该客户端生成一个SocketChannel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    <span class="comment">//将socketChannel设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接成功,生成了一个socketChannel:&quot;</span> + socketChannel.hashCode());</span><br><span class="line">                    <span class="comment">//将 socketChannel 注册到selector,关注事件为OP_READ,同时关联一个buffer(缓冲区),服务器端的buffer</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (key.isReadable())&#123; <span class="comment">//发生OP_READ事件</span></span><br><span class="line">                    <span class="comment">//通过selectionKey 反向获取到对应的channel(通道)</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">//获取到该channel关联的buffer</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="comment">//将数据读取到buffer中</span></span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端发送的信息:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//手动移除当前的selectionKey,防止重复操作</span></span><br><span class="line">                selectionKeys.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NIOClient（客户端）:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/24 20:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的IP和端口</span></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">socketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span> (!socketChannel.connect(socketAddress))&#123;</span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;因为连接需要时间,客户端不会阻塞,可以做其他工作...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接成功,就发送数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello,尚硅谷&quot;</span>;</span><br><span class="line">        <span class="comment">//wrap 指定buffer的大小为发送数据的大小</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(str.getBytes());</span><br><span class="line">        <span class="comment">//发送数据,将buffer数据写入channel</span></span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/22/Netty/image-20221024210936091.png" alt="image-20221024210936091"></p><h2 id="3-10-SelectionKey"><a href="#3-10-SelectionKey" class="headerlink" title="3.10  SelectionKey"></a>3.10  SelectionKey</h2><p>其中SelectionKey表示当前发生事件的key</p><p>keys表示所有注册的key</p><p><img src="/2022/10/22/Netty/image-20221024212254265.png" alt="image-20221024212254265"></p><ol><li><p>SelectionKey，表示 <strong>Selector</strong> <strong>和网络通道的注册关系</strong>, 共四种:</p><ul><li><p>int OP_ACCEPT：有新的网络连接可以 accept，值为 16 </p></li><li><p>int OP_CONNECT：代表连接已经建立，值为 8</p></li><li><p>int OP_READ：代表读操作，值为 1</p></li><li><p>int OP_WRITE：代表写操作，值为 4</p></li></ul></li></ol><p>源码中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_ACCEPT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>SelectionKey 相关方法</li></ol><p><img src="/2022/10/22/Netty/image-20221023172100987.png" alt="image-20221023172100987"></p><h2 id="3-11-ServerSocketChannel"><a href="#3-11-ServerSocketChannel" class="headerlink" title="3.11  ServerSocketChannel"></a>3.11  ServerSocketChannel</h2><ol><li><p>ServerSocketChannel 在服务器端监听新的客户端 Socket 连接</p></li><li><p>相关方法如下</p></li></ol><p><img src="/2022/10/22/Netty/image-20221023172136796.png" alt="image-20221023172136796"></p><h2 id="3-12-SocketChannel"><a href="#3-12-SocketChannel" class="headerlink" title="3.12  SocketChannel"></a>3.12  SocketChannel</h2><ol><li><p>SocketChannel，网络 IO 通道，具体负责进行读写操作。NIO 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</p></li><li><p>相关方法如下</p></li></ol><p><img src="/2022/10/22/Netty/image-20221023172201508.png" alt="image-20221023172201508"></p><h2 id="3-13-NIO-网络编程应用实例-群聊系统"><a href="#3-13-NIO-网络编程应用实例-群聊系统" class="headerlink" title="3.13  NIO 网络编程应用实例-群聊系统"></a>3.13  NIO 网络编程应用实例-群聊系统</h2><p>实例要求:</p><ol><li><p>编写一个 NIO 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</p></li><li><p>实现多人群聊</p></li><li><p>服务器端：可以监测用户上线，离线，并实现消息转发功能</p></li><li><p>客户端：通过 channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(有服务器转发得到)</p></li><li><p>目的：进一步理解 NIO 非阻塞网络编程机制</p></li><li><p>示意图分析和代码</p></li></ol><p><img src="/2022/10/22/Netty/clip_image066.jpg" alt="img"></p><p> <strong>代码</strong></p><p>服务端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.nio.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/25 20:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器 初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//ServerSocketChannel</span></span><br><span class="line">            listenChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));</span><br><span class="line">            <span class="comment">//设置为非阻塞</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//将该 listenChannel 注册到selector</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                <span class="comment">//有事件处理</span></span><br><span class="line">                <span class="keyword">if</span> (select &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//遍历得到SelectionKey集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        <span class="comment">//监听到Accept</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> listenChannel.accept();</span><br><span class="line">                            socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            <span class="comment">//注册到selector</span></span><br><span class="line">                            socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                            <span class="comment">//提示</span></span><br><span class="line">                            System.out.println(socketChannel.getRemoteAddress() + <span class="string">&quot;上线&quot;</span> );</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//通道发送read事件，即通道是可读的状态</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//当前的key进行移除，防止重复操作</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readData</span><span class="params">(SelectionKey key)</span>&#123;</span><br><span class="line">        <span class="comment">//定义一个SocketChannel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建buffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">//读取到buffer</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">            <span class="comment">//根据read的值做处理</span></span><br><span class="line">            <span class="keyword">if</span> (read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//把缓冲区的数据转为字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端发送的消息：&quot;</span> + s);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//向其他客户端转发消息(去掉自己)</span></span><br><span class="line">                sendInfoToOtherClients(s,channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot;离线。。。&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给其他客户（通道）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInfoToOtherClients</span><span class="params">(String msg,SocketChannel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中。。。&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历所有注册到selector上的socketChannel</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys())&#123;</span><br><span class="line">            <span class="comment">//通过key获取对应的socketChannel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> key.channel();</span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span> (targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != channel)&#123;</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) targetChannel;</span><br><span class="line">                <span class="comment">//将msg存储到buffer中</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将buffer的数据写入通道</span></span><br><span class="line">                socketChannel.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        <span class="type">GroupChatServer</span> <span class="variable">groupChatServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.nio.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectableChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/25 20:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClient</span> &#123;</span><br><span class="line">    <span class="comment">//定义相关属性 服务器ip 服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(HOST,PORT));</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//将channel 注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString();</span><br><span class="line">        System.out.println(username + <span class="string">&quot;is ok ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInfo</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        msg = username + <span class="string">&quot; 说：&quot;</span> + msg;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(msg.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取服务端转发的消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> selector.select(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">//有发生事件的通道</span></span><br><span class="line">            <span class="keyword">if</span> (select &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                    <span class="comment">//获取key</span></span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    <span class="comment">//可以读取的通道</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                        <span class="comment">//得到通道</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">//创建buffer</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取数据到buffer</span></span><br><span class="line">                        channel.read(buffer);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                        System.out.println(s);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//输出当前的SelectionKey，防止重复操作</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*System.out.println(&quot;没有可用的通道。。。&quot;);*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//启动客户端</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">GroupChatClient</span> <span class="variable">groupChatClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatClient</span>();</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="comment">//读取数据</span></span><br><span class="line">                    groupChatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">//发送数据给服务器</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            groupChatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <img src="/2022/10/22/Netty/image-20221025223251654.png" alt="image-20221025223251654"></p><h2 id="3-14-NIO-与零拷贝"><a href="#3-14-NIO-与零拷贝" class="headerlink" title="3.14  NIO 与零拷贝"></a>3.14  NIO 与零拷贝</h2><h3 id="3-14-1-零拷贝基本介绍"><a href="#3-14-1-零拷贝基本介绍" class="headerlink" title="3.14.1   零拷贝基本介绍"></a>3.14.1   零拷贝基本介绍</h3><ol><li><p>零拷贝是网络编程的关键，很多性能优化都离不开。</p></li><li><p>在 Java 程序中，常用的零拷贝有 mmap(内存映射) 和 sendFile。那么，他们在 OS 里，到底是怎么样的一个的设计？我们分析 mmap 和 sendFile 这两个零拷贝</p></li><li><p>另外我们看下 NIO 中如何使用零拷贝</p></li></ol><h3 id="3-14-2-传统IO-数据读写"><a href="#3-14-2-传统IO-数据读写" class="headerlink" title="3.14.2   传统IO 数据读写"></a>3.14.2   传统IO 数据读写</h3><p>Java 传统 IO 和 网络编程的一段代码</p><p><img src="/2022/10/22/Netty/image-20221024222506791.png" alt="image-20221024222506791"></p><h3 id="3-14-3传统IO-模型"><a href="#3-14-3传统IO-模型" class="headerlink" title="3.14.3传统IO 模型"></a>3.14.3传统IO 模型</h3><p>DMA: direct  memory access 直接内存拷贝(不使用 CPU)</p><p><img src="/2022/10/22/Netty/image-20221024222537370.png" alt="image-20221024222537370"></p><h3 id="3-14-4-mmap-优化"><a href="#3-14-4-mmap-优化" class="headerlink" title="3.14.4   mmap 优化"></a>3.14.4   mmap 优化</h3><ol><li><p>mmap 通过内存映射，将<strong>文件映射到内核缓冲区</strong>，同时，<strong>用户空间可以共享内核空间的数据</strong>。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</p></li><li><p>mmap 示意图</p></li></ol><p><img src="/2022/10/22/Netty/clip_image073.jpg" alt="img"></p><h3 id="3-14-5-sendFile-优化"><a href="#3-14-5-sendFile-优化" class="headerlink" title="3.14.5   sendFile 优化"></a>3.14.5   sendFile 优化</h3><ol><li><p>Linux 2.1 版本 提供了 sendFile 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换</p></li><li><p>示意图和小结</p></li></ol><p><img src="/2022/10/22/Netty/clip_image075.jpg" alt="img"></p><ol start="3"><li><p>提示：<strong>零拷贝是从操作系统角度，没有 cpu 拷贝</strong></p></li><li><p>Linux 在 2.4 版本中，做了一些修改，避免了从<strong>内核缓冲区</strong>拷贝到 <strong>Socket buffer</strong> 的操作，直接拷贝到协议栈， 从而再一次减少了数据拷贝。具体如下图和小结：</p></li></ol><p><img src="/2022/10/22/Netty/clip_image077.jpg" alt="img"></p><ol start="5"><li>这里其实有 一次 cpu 拷贝 kernel buffer -&gt; socket buffer 。但是，拷贝的信息很少，比如 lenght , offset , 消耗低，可以忽略</li></ol><h3 id="3-14-6-零拷贝的再次理解"><a href="#3-14-6-零拷贝的再次理解" class="headerlink" title="3.14.6     零拷贝的再次理解"></a>3.14.6     零拷贝的再次理解</h3><ol><li><p>我们说零拷贝，是从<strong>操作系统的角度</strong>来说的。因为内核缓冲区之间，没有数据是重复的（只有 kernel buffer 有一份数据）。</p></li><li><p>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 CPU 缓存伪共享以及无 CPU 校验和计算。</p></li></ol><h3 id="3-14-7-mmap-和-sendFile-的区别"><a href="#3-14-7-mmap-和-sendFile-的区别" class="headerlink" title="3.14.7     mmap 和 sendFile 的区别"></a>3.14.7     mmap 和 sendFile 的区别</h3><ol><li><p>mmap 适合小数据量读写，sendFile 适合大文件传输。</p></li><li><p>mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要 3 次上下文切换，最少 2 次数据拷贝。</p></li><li><p>sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝到 Socket 缓冲区）。</p></li></ol><h3 id="3-14-8-NIO-零拷贝案例"><a href="#3-14-8-NIO-零拷贝案例" class="headerlink" title="3.14.8   NIO 零拷贝案例"></a>3.14.8   NIO 零拷贝案例</h3><p>案例要求：</p><ol><li><p>使用传统的 IO 方法传递一个大文件</p></li><li><p>使用 NIO 零拷贝方式传递(transferTo)一个大文件</p></li><li><p>看看两种传递方式耗时时间分别是多少</p></li></ol><p>零拷贝方式</p><p>NewIOServer.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">7001</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> serverSocketChannel.socket();</span><br><span class="line"></span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">readcount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != readcount) &#123; </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    readcount = socketChannel.read(byteBuffer);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    <span class="comment">// ex.printStackTrace(); break;</span></span><br><span class="line">                &#125;</span><br><span class="line">                byteBuffer.rewind(); <span class="comment">//倒带 position = 0 mark 作废</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                         </span><br></pre></td></tr></table></figure><p> NewIOClient.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open(); </span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>)); </span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;protoc-3.6.1-win32.zip&quot;</span>;</span><br><span class="line">        <span class="comment">//得到一个文件 channel</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">FileInputStream</span>(filename).getChannel();</span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//在 linux 下一个 transferTo 方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//在 windows 下 一次调用 transferTo 只能发送 8m , 就需要分段传输文件, 而且要主要</span></span><br><span class="line">        <span class="comment">//传输时的位置 =》 课后思考...</span></span><br><span class="line">        <span class="comment">//transferTo 底层使用到零拷贝</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">transferCount</span> <span class="operator">=</span> fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line">        System.out.println(<span class="string">&quot; 发送的总的字节数=&quot;</span> + transferCount + <span class="string">&quot; 耗 时 :&quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        <span class="comment">//关闭fileChannel.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-15-Java-AIO-基本介绍"><a href="#3-15-Java-AIO-基本介绍" class="headerlink" title="3.15  Java AIO 基本介绍"></a>3.15  Java AIO 基本介绍</h2><ol><li><p>JDK 7 引入了 Asynchronous I&#x2F;O，即 AIO。在进行 I&#x2F;O 编程中，常用到两种模式：Reactor 和 Proactor。Java 的NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理</p></li><li><p>AIO 即 NIO2.0，叫做异步不阻塞的 IO。AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写， 有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</p></li><li><p>目前 AIO 还没有广泛应用，Netty 也是基于 NIO, 而不是 AIO， 因此我们就不详解AIO 了，有兴趣的同学可以 参 考 &lt;&lt;Java 新 一 代 网 络 编 程 模 型 AIO 原 理 及 Linux 系 统 AIO 介 绍 &gt;&gt;<a href="http://www.52im.net/thread-306-1-1.html"> http://www.52im.net/thread-306-1-1.html</a></p></li></ol><h2 id="3-16-BIO、NIO、AIO-对比表"><a href="#3-16-BIO、NIO、AIO-对比表" class="headerlink" title="3.16  BIO、NIO、AIO 对比表"></a>3.16  BIO、NIO、AIO 对比表</h2><p><img src="/2022/10/22/Netty/image-20221024222901203.png" alt="image-20221024222901203"></p><h1 id="第-4-章-Netty-概述"><a href="#第-4-章-Netty-概述" class="headerlink" title="第 4 章 Netty 概述"></a>第 4 章 Netty 概述</h1><h2 id="4-1原生-NIO-存在的问题"><a href="#4-1原生-NIO-存在的问题" class="headerlink" title="4.1原生 NIO 存在的问题"></a>4.1原生 NIO 存在的问题</h2><ol><li><p>NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</p></li><li><p>需要具备其他的额外技能：要熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。</p></li><li><p>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。</p></li><li><p>JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。直到 JDK 1.7</p></li></ol><p>版本该问题仍旧存在，没有被根本解决。</p><h2 id="4-2-Netty-官网说明"><a href="#4-2-Netty-官网说明" class="headerlink" title="4.2      Netty 官网说明"></a>4.2      Netty 官网说明</h2><p>官网：<a href="https://netty.io/">https://netty.io/</a></p><p>Netty is an asynchronous event-driven network application framework</p><p>for rapid development of maintainable high performance protocol servers &amp; clients</p><p><img src="/2022/10/22/Netty/clip_image083.jpg" alt="img"></p><h2 id="4-3-Netty-的优点"><a href="#4-3-Netty-的优点" class="headerlink" title="4.3      Netty 的优点"></a>4.3      Netty 的优点</h2><p>Netty 对 JDK 自带的 NIO 的 API 进行了封装，解决了上述问题。</p><ol><li><p>设计优雅：适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池。</p></li><li><p>使用方便：详细记录的 Javadoc，用户指南和示例；没有其他依赖项，JDK 5（Netty 3.x）或 6（Netty 4.x）就足够了。</p></li><li><p>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</p></li><li><p>安全：完整的 SSL&#x2F;TLS 和 StartTLS 支持。</p></li><li><p>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复，同时，更多的新功能会被加入。</p></li></ol><h2 id="4-4-Netty-版本说明"><a href="#4-4-Netty-版本说明" class="headerlink" title="4.4      Netty 版本说明"></a>4.4      Netty 版本说明</h2><ol><li>netty 版本分为 netty3.x  和 netty4.x、netty5.x</li><li>因为 Netty5 出现重大 bug，已经被官网废弃了，目前推荐使用的是 Netty4.x 的稳定版本。</li><li>目前在官网可下载的版本 netty3.x netty4.0.x 和 netty4.1.x</li><li>在本套课程中，我们讲解 Netty4.1.x 版本</li></ol><h1 id="第-5-章-Netty-高性能架构设计"><a href="#第-5-章-Netty-高性能架构设计" class="headerlink" title="第 5 章 Netty 高性能架构设计"></a>第 5 章 Netty 高性能架构设计</h1><h2 id="5-1-线程模型基本介绍"><a href="#5-1-线程模型基本介绍" class="headerlink" title="5.1      线程模型基本介绍"></a>5.1      线程模型基本介绍</h2><ol><li><p>不同的线程模式，对程序的性能有很大影响，为了搞清 Netty 线程模式，我们来系统的讲解下 各个线程模式， 最后看看 Netty 线程模型有什么优越性.</p></li><li><p>目前存在的线程模型有： 传统阻塞 I&#x2F;O 服务模型，Reactor 模式</p></li><li><p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现</p></li></ol><p>单 Reactor 单线程； 单 Reactor 多线程； 主从 Reactor 多线程</p><ol start="4"><li>Netty 线程模式(Netty 主要基于主从 Reactor 多线程模型做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor)</li></ol><h2 id="5-2-传统阻塞-I-x2F-O-服务模型"><a href="#5-2-传统阻塞-I-x2F-O-服务模型" class="headerlink" title="5.2      传统阻塞 I&#x2F;O 服务模型"></a>5.2      传统阻塞 I&#x2F;O 服务模型</h2><h3 id="5-2-1-工作原理图"><a href="#5-2-1-工作原理图" class="headerlink" title="5.2.1 工作原理图"></a>5.2.1 工作原理图</h3><p><img src="/2022/10/22/Netty/image-20221026214347530.png" alt="image-20221026214347530"></p><ol><li><p>黄色的框表示对象， 蓝色的框表示线程</p></li><li><p>白色的框表示方法(API)</p></li></ol><h3 id="5-2-2-模型特点"><a href="#5-2-2-模型特点" class="headerlink" title="5.2.2 模型特点"></a>5.2.2 模型特点</h3><ol><li><p>采用阻塞 IO 模式获取输入的数据</p></li><li><p>每个连接都需要独立的线程完成数据的输入，业务处理, 数据返回</p></li></ol><h3 id="5-2-3-问题分析"><a href="#5-2-3-问题分析" class="headerlink" title="5.2.3 问题分析"></a>5.2.3 问题分析</h3><ol><li><p>当并发数很大，就会创建大量的线程，占用很大系统资源</p></li><li><p>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 read 操作，造成线程资源浪费</p></li></ol><h2 id="5-3-Reactor-模式"><a href="#5-3-Reactor-模式" class="headerlink" title="5.3      Reactor 模式"></a>5.3      Reactor 模式</h2><h3 id="5-3-1-针对传统阻塞-I-x2F-O-服务模型的-2-个缺点，解决方案："><a href="#5-3-1-针对传统阻塞-I-x2F-O-服务模型的-2-个缺点，解决方案：" class="headerlink" title="5.3.1 针对传统阻塞 I&#x2F;O 服务模型的 2 个缺点，解决方案："></a>5.3.1 针对传统阻塞 I&#x2F;O 服务模型的 2 个缺点，解决方案：</h3><ol><li>基于 I&#x2F;O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</li></ol><p>Reactor 对应的叫法: 1. 反应器模式 2. 分发者模式(Dispatcher) 3. 通知者模式(notifier)</p><ol start="2"><li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理， 一个线程可以处理多个连接的业务。</li></ol><p><img src="/2022/10/22/Netty/clip_image003.jpg" alt="img"></p><h3 id="5-3-2-I-x2F-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图"><a href="#5-3-2-I-x2F-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图" class="headerlink" title="5.3.2 I&#x2F;O 复用结合线程池，就是 Reactor 模式基本设计思想，如图"></a>5.3.2 I&#x2F;O 复用结合线程池，就是 Reactor 模式基本设计思想，如图</h3><p> <img src="/2022/10/22/Netty/image-20221027195853479.png" alt="image-20221027195853479"></p><p>对上图说明:</p><ol><li><p>Reactor 模式，通过一个或多个输入同时传递给服务处理器的模式(基于事件驱动)。</p></li><li><p>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程， 因此 Reactor 模式也叫 Dispatcher模式。</p></li><li><p>Reactor 模式使用 IO 复用监听事件, 收到事件后，分发给某个线程(进程), 这点就是网络服务器高并发处理关键。</p></li></ol><h3 id="5-3-3-Reactor-模式中-核心组成："><a href="#5-3-3-Reactor-模式中-核心组成：" class="headerlink" title="5.3.3 Reactor 模式中 核心组成："></a>5.3.3 Reactor 模式中 核心组成：</h3><ol><li><p>Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</p></li><li><p>Handlers：处理程序执行 I&#x2F;O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I&#x2F;O 事件，处理程序执行非阻塞操作。</p></li></ol><h3 id="5-3-4-Reactor-模式分类："><a href="#5-3-4-Reactor-模式分类：" class="headerlink" title="5.3.4 Reactor 模式分类："></a>5.3.4 Reactor 模式分类：</h3><p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现</p><ol><li><p>单 Reactor 单线程</p></li><li><p>单 Reactor 多线程</p></li><li><p>主从 Reactor 多线程</p></li></ol><h2 id="5-4-单-Reactor-单线程"><a href="#5-4-单-Reactor-单线程" class="headerlink" title="5.4      单 Reactor 单线程"></a>5.4      单 Reactor 单线程</h2><p>原理图，并使用 NIO 群聊系统验证</p><p><img src="/2022/10/22/Netty/clip_image007.jpg" alt="img"></p><h3 id="5-4-1-方案说明："><a href="#5-4-1-方案说明：" class="headerlink" title="5.4.1 方案说明："></a>5.4.1 方案说明：</h3><ol><li><p>Select 是前面 I&#x2F;O 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求。</p></li><li><p>Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发。</p></li><li><p>如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理。</p></li><li><p>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应。</p></li><li><p>Handler 会完成 Read→业务处理→Send 的完整业务流程</p></li></ol><p>结合实例：服务器端用一个线程通过多路复用搞定所有的 IO 操作（包括连接，读、写等），编码简单，清晰明了， 但是如果客户端连接数量较多，将无法支撑，前面的 NIO 案例就属于这种模型。</p><h3 id="5-4-2-方案优缺点分析："><a href="#5-4-2-方案优缺点分析：" class="headerlink" title="5.4.2 方案优缺点分析："></a>5.4.2 方案优缺点分析：</h3><ol><li><p>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成。</p></li><li><p>缺点：性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈。</p></li><li><p>缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</p></li><li><p>使用场景：客户端的数量有限，业务处理非常快速，比如 Redis 在业务处理的时间复杂度 O(1) 的情况。</p></li></ol><h2 id="5-5-单Reactor-多线程"><a href="#5-5-单Reactor-多线程" class="headerlink" title="5.5      单Reactor 多线程"></a>5.5      单Reactor 多线程</h2><h3 id="5-5-1-原理图"><a href="#5-5-1-原理图" class="headerlink" title="5.5.1 原理图"></a>5.5.1 原理图</h3><p><img src="/2022/10/22/Netty/clip_image009.jpg" alt="img"></p><h3 id="5-5-2-对上图的小结"><a href="#5-5-2-对上图的小结" class="headerlink" title="5.5.2 对上图的小结"></a>5.5.2 对上图的小结</h3><ol><li><p>Reactor 对象通过 select 监控客户端请求事件, 收到事件后，通过 dispatch 进行分发。</p></li><li><p>如果建立连接请求, 则右 Acceptor 通过accept 处理连接请求, 然后创建一个 Handler 对象处理完成连接后的各种事件。</p></li><li><p>如果不是连接请求（读写请求），则由 reactor 分发调用连接对应的 handler 来处理。</p></li><li><p>handler 只负责响应事件，不做具体的业务处理, 通过 read 读取数据后，会分发给后面的 worker 线程池的某个线程处理业务。</p></li><li><p>worker 线程池会分配独立线程完成真正的业务，并将结果返回给 handler。</p></li><li><p>handler 收到响应后，通过 send 将结果返回给 client。</p></li></ol><h3 id="1-5-3-方案优缺点分析："><a href="#1-5-3-方案优缺点分析：" class="headerlink" title="1.5.3 方案优缺点分析："></a>1.5.3 方案优缺点分析：</h3><ol><li><p>优点：可以充分的利用多核 cpu 的处理能力。</p></li><li><p>缺点：多线程数据共享和访问比较复杂， reactor 处理所有的事件的监听和响应，在单线程运行， 在高并发场景容易出现性能瓶颈。</p></li></ol><h2 id="5-6-主从-Reactor-多线程"><a href="#5-6-主从-Reactor-多线程" class="headerlink" title="5.6      主从 Reactor 多线程"></a>5.6      主从 Reactor 多线程</h2><h3 id="5-6-1-工作原理图"><a href="#5-6-1-工作原理图" class="headerlink" title="5.6.1 工作原理图"></a>5.6.1 工作原理图</h3><p>针对单 Reactor 多线程模型中，Reactor 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 Reactor 在多线程中运行。</p><p><img src="/2022/10/22/Netty/clip_image011-166662187911410.jpg" alt="img"></p><h3 id="5-6-2-上图的方案说明"><a href="#5-6-2-上图的方案说明" class="headerlink" title="5.6.2 上图的方案说明"></a>5.6.2 上图的方案说明</h3><ol><li><p>Reactor 主线程 MainReactor 对象通过 select 监听连接事件, 收到事件后，通过 Acceptor 处理连接事件（MainReactor 只进行接收操作，其他操作交予子线程操作）。</p></li><li><p>当 Acceptor  处理连接事件后，MainReactor 将连接分配给 SubReactor。</p></li><li><p>subreactor 将连接加入到连接队列进行监听,并创建 handler 进行各种事件处理。</p></li><li><p>当有新事件发生时， subreactor 就会调用对应的 handler 处理。</p></li><li><p>handler 通过 read 读取数据，分发给后面的 worker 线程处理。</p></li><li><p>worker 线程池分配独立的 worker 线程进行业务处理，并返回结果。</p></li><li><p>handler 收到响应的结果后，再通过 send 将结果返回给 client。</p></li><li><p>Reactor 主线程可以对应多个 Reactor 子线程, 即 MainRecator 可以关联多个 SubReactor。</p></li></ol><h3 id="5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解："><a href="#5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解：" class="headerlink" title="5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解："></a>5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解：</h3><p><img src="/2022/10/22/Netty/image-20221027201345433.png" alt="image-20221027201345433"></p><h3 id="5-6-4-方案优缺点说明："><a href="#5-6-4-方案优缺点说明：" class="headerlink" title="5.6.4 方案优缺点说明："></a>5.6.4 方案优缺点说明：</h3><ol><li><p>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</p></li><li><p>优点：父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</p></li><li><p>缺点：编程复杂度较高</p></li><li><p>结合实例：这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持。</p></li></ol><h2 id="5-7-Reactor-模式小结"><a href="#5-7-Reactor-模式小结" class="headerlink" title="5.7      Reactor 模式小结"></a>5.7      Reactor 模式小结</h2><h3 id="5-7-1-3种模式用生活案例来理解"><a href="#5-7-1-3种模式用生活案例来理解" class="headerlink" title="5.7.1 3种模式用生活案例来理解"></a>5.7.1 3种模式用生活案例来理解</h3><ol><li><p>单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服务。</p></li><li><p>单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待。</p></li><li><p>主从 Reactor 多线程，多个前台接待员，多个服务生。</p></li></ol><h3 id="5-7-2-Reactor-模式具有如下的优点："><a href="#5-7-2-Reactor-模式具有如下的优点：" class="headerlink" title="5.7.2 Reactor 模式具有如下的优点："></a>5.7.2 Reactor 模式具有如下的优点：</h3><ol><li><p>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的</p></li><li><p>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销</p></li><li><p>扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源</p></li><li><p>复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性</p></li></ol><h2 id="5-8-Netty-模型"><a href="#5-8-Netty-模型" class="headerlink" title="5.8      Netty 模型"></a>5.8      Netty 模型</h2><h3 id="5-8-1-工作原理示意图-1-简单版"><a href="#5-8-1-工作原理示意图-1-简单版" class="headerlink" title="5.8.1 工作原理示意图 1-简单版"></a>5.8.1 工作原理示意图 1-简单版</h3><p> Netty 主要基于主从 Reactors 多线程模型（如图）做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor。</p><p><img src="/2022/10/22/Netty/image-20221027201653118.png" alt="image-20221027201653118"></p><h3 id="5-8-2-对上图说明"><a href="#5-8-2-对上图说明" class="headerlink" title="5.8.2 对上图说明"></a>5.8.2 对上图说明</h3><ol><li><p>BossGroup 线程维护 Selector , 只关注 Accecpt。</p></li><li><p>当接收到 Accept 事件，获取到对应的 SocketChannel, 封装成 NIOScoketChannel 并注册到Worker 线程(事件循环), 并进行维护。</p></li><li><p>当 Worker 线程监听到 selector 中通道发生自己感兴趣的事件后，就进行处理(就由 handler)， 注意 handler 已经加入到通道。</p></li></ol><h3 id="5-8-3-工作原理示意图-2-进阶版"><a href="#5-8-3-工作原理示意图-2-进阶版" class="headerlink" title="5.8.3 工作原理示意图 2-进阶版"></a>5.8.3 工作原理示意图 2-进阶版</h3><p><img src="/2022/10/22/Netty/image-20221027201724857.png" alt="image-20221027201724857"></p><h3 id="5-8-4-工作原理示意图-详细版"><a href="#5-8-4-工作原理示意图-详细版" class="headerlink" title="5.8.4 工作原理示意图-详细版"></a>5.8.4 工作原理示意图-详细版</h3><p><img src="/2022/10/22/Netty/clip_image019.jpg" alt="img"></p><h3 id="1-8-5-对上图的说明小结"><a href="#1-8-5-对上图的说明小结" class="headerlink" title="1.8.5 对上图的说明小结"></a>1.8.5 对上图的说明小结</h3><ol><li><p>Netty 抽象出两组线程池 BossGroup 专门负责接收客户端的连接, WorkerGroup 专门负责网络的读写。</p></li><li><p>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup。</p></li><li><p>NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环 ，每一个事件循环是 NioEventLoop。</p></li><li><p>NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个 NioEventLoop 都有一个 selector , 用于监听绑定在其上的 socket 的网络通讯。</p></li><li><p>NioEventLoopGroup 可以有多个线程, 即可以含有多个 NioEventLoop。</p></li><li><p>每个 Boss NioEventLoop 循环执行的步骤有 3 步</p><ul><li>轮询 accept 事件</li><li>处理 accept 事件 , 与 client 建立连接 , 生成 NioScocketChannel , 并将其注册到某个 worker NIOEventLoop 上的 selector</li><li>处理任务队列的任务 ， 即 runAllTasks</li></ul></li><li><p>每个 Worker NIOEventLoop 循环执行的步骤</p><ul><li>轮询 read, write 事件</li><li>处理 i&#x2F;o 事件， 即 read , write 事件，在对应 NioScocketChannel 处理</li><li>处理任务队列的任务 ， 即 runAllTasks</li></ul></li><li><p>每个Worker NIOEventLoop  处理业务时，会使用pipeline(管道), pipeline 中包含了 channel , 即通过pipeline 可以获取到对应通道, 管道中维护了很多的 处理器。</p></li></ol><h3 id="5-8-6-Netty-快速入门实例-TCP-服务"><a href="#5-8-6-Netty-快速入门实例-TCP-服务" class="headerlink" title="5.8.6 Netty 快速入门实例-TCP 服务"></a>5.8.6 Netty 快速入门实例-TCP 服务</h3><p>实例要求：使用 IDEA 创建 Netty 项目</p><ol><li><p>Netty 服务器在 6668 端口监听，客户端能发送消息给服务器 “hello, 服务器~”</p></li><li><p>服务器可以回复消息给客户端 “hello, 客户端~”</p></li><li><p>目的：对 Netty 线程模型 有一个初步认识, 便于理解 Netty 模型理论</p></li><li><p>看老师代码演示</p></li></ol><p>5.1 编写服务端 5.2 编写客户端 5.3 <strong>对</strong> <strong>netty</strong> <strong>程序进行分析，看看</strong> <strong>netty</strong> <strong>模型特</strong>点</p><p>说明: 创建 Maven 项目，并引入 Netty 包</p><ol start="5"><li>代码如下</li></ol><p>服务端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NettyServer.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/27 21:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建BossGroup 和 WorkGroup</span></span><br><span class="line">        <span class="comment">//说明：</span></span><br><span class="line">        <span class="comment">//1. 创建两个线程组 bossGroup workGroup</span></span><br><span class="line">        <span class="comment">//2. boosGroup 只处理连接请求，真正的和客户端业务处理，会交给workGroup处理</span></span><br><span class="line">        <span class="comment">//3. 两个都是无限循环</span></span><br><span class="line">        <span class="comment">//4. bossGroup 和 workGroup 含有的子线程（NioEventLoopGroup） 默认 cpu核数*2</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(bossGroup,workGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//使用NioSocketChannel 作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>) <span class="comment">//设置线程队列的连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="literal">true</span>) <span class="comment">//设置连接保持活动连接状态</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123; <span class="comment">//创建一个通道测试对象</span></span><br><span class="line">                        <span class="comment">// 给pipeline设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">//给 workGroup的NioEventLoop 对应的管道设置处理器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器 is ready ....&quot;</span>);</span><br><span class="line">            <span class="comment">//启动服务器，绑定一个端口并且同步，生成了一个ChannelFuture对象</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">sync</span> <span class="operator">=</span> bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            sync.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自定义NettyServerHandler.java</span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/27 21:50</span></span><br><span class="line"><span class="comment"> * 自定义一个handler 需要继承netty 规定好的某个HandlerAdapter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据（这里我们可以读取客户端发送的消息）</span></span><br><span class="line"><span class="comment">     * 1. ChannelHandlerContext ctx:上下文对象，含有管道pipeline,通道channel,地址</span></span><br><span class="line"><span class="comment">     * 2. Object msg:客户都发送的消息 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;server ctx = &quot;</span> + ctx);</span><br><span class="line">        <span class="comment">//将 msg 转成 ByteBuffer</span></span><br><span class="line">        <span class="comment">//ByteBuf 是netty提供的，不是NIO的ByteBuffer</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送的消息：&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端地址：&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕后操作</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将数据写入到缓冲区并刷新</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello，客户端~&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常，一般需要关闭通道</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NettyClient.java</span><br><span class="line">    </span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/29 13:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是ServerBootstrap 而是BootStrap</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(eventExecutors) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">//设置客户端通道的实现类（反射）</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 is OK....&quot;</span>);</span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端  ChannelFuture涉及到netty的异步模型</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给channelFuture注册监听器,监控我们关心的事件</span></span><br><span class="line">            channelFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">if</span> (channelFuture.isSuccess())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口6668成功&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口6668成功&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自定义NettyClientHandler.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/29 13:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道就绪时就会出发</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;client：&quot;</span> + ctx);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,server!&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时会触发</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息：&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器的地址：&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/10/22/Netty/image-20221030111949451.png" alt="image-20221030111949451"></p><h3 id="5-8-7-任务队列中的-Task-有-3-种典型使用场景"><a href="#5-8-7-任务队列中的-Task-有-3-种典型使用场景" class="headerlink" title="5.8.7 任务队列中的 Task 有 3 种典型使用场景"></a>5.8.7 任务队列中的 Task 有 3 种典型使用场景</h3><ol><li><p>用户程序自定义的普通任务 [举例说明]</p></li><li><p>用户自定义定时任务 </p></li><li><p>非当前 Reactor 线程调用 Channel 的各种方法</p></li></ol><p>例如在推送系统的业务线程里面，根据用户的标识，找到对应的 Channel 引用，然后调用 Write 类方法向该用户推送消息，就会进入到这种场景。最终的 Write 会提交到任务队列中后被异步消费</p><ol start="4"><li>代码演示</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/27 21:50</span></span><br><span class="line"><span class="comment"> * 自定义一个handler 需要继承netty 规定好的某个HandlerAdapter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据（这里我们可以读取客户端发送的消息）</span></span><br><span class="line"><span class="comment">     * 1. ChannelHandlerContext ctx:上下文对象，含有管道pipeline,通道channel,地址</span></span><br><span class="line"><span class="comment">     * 2. Object msg:客户都发送的消息 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;server ctx = &quot;</span> + ctx);</span><br><span class="line">        <span class="comment">//将 msg 转成 ByteBuffer</span></span><br><span class="line">        <span class="comment">//ByteBuf 是netty提供的，不是NIO的ByteBuffer</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送的消息：&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端地址：&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比如我们这里有一个非常耗时的业务-&gt;异步执行-&gt;提交该channel对应的请求</span></span><br><span class="line">        <span class="comment">// 解决方案1. 用户程序自定义的普通方法 -&gt; NIOEventLoop 的taskQueue中</span></span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端,自定义任务!&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解决方案2. 用户自定义定时任务 -&gt; 该任务是提交到scheduleTaskQueue4</span></span><br><span class="line">        ctx.channel().eventLoop().schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端,自定义任务!&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕后操作</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将数据写入到缓冲区并刷新</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello，客户端~&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常，一般需要关闭通道</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/22/Netty/image-20221030112334830.png" alt="image-20221030112334830"></p><h3 id="5-8-8-方案再说明"><a href="#5-8-8-方案再说明" class="headerlink" title="5.8.8 方案再说明"></a>5.8.8 方案再说明</h3><ol><li><p>Netty 抽象出两组线程池，BossGroup 专门负责接收客户端连接，WorkerGroup 专门负责网络读写操作。</p></li><li><p>NioEventLoop 表示一个不断循环执行处理任务的线程，每个 NioEventLoop 都有一个 selector，用于监听绑定在其上的 socket 网络通道。</p></li><li><p>NioEventLoop 内部采用串行化设计，从消息的读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送，始终由 IO 线程 NioEventLoop负责</p></li><li><p>NioEventLoopGroup 下包含多个 NioEventLoop</p><ul><li>每个 NioEventLoop 中包含有一个 Selector，一个 taskQueue</li><li>每个 NioEventLoop 的 Selector 上可以注册监听多个 NioChannel</li><li>每个 NioChannel 只会绑定在唯一的 NioEventLoop 上</li><li>每个 NioChannel 都绑定有一个自己的 ChannelPipeline</li></ul></li></ol><h2 id="5-9-异步模型"><a href="#5-9-异步模型" class="headerlink" title="5.9      异步模型"></a>5.9      异步模型</h2><h3 id="5-9-1-基本介绍"><a href="#5-9-1-基本介绍" class="headerlink" title="5.9.1 基本介绍"></a>5.9.1 基本介绍</h3><ol><li><p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</p></li><li><p>Netty 中的 I&#x2F;O 操作是异步的，包括 Bind、Write、Connect 等操作会简单的返回一个 ChannelFuture。</p></li><li><p>调用者并不能立刻获得结果，而是通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得IO 操作结果。</p></li><li><p>Netty 的异步模型是建立在 future 和 callback 的之上的。callback 就是回调。重点说 Future，它的核心思想是：假设一个方法 fun，计算过程可能非常耗时，等待 fun 返回显然不合适。那么可以在调用 fun 的时候，立马返回一个 Future，后续可以通过 Future 去监控方法 fun 的处理过程(即 ： Future-Listener 机制)。</p></li></ol><h3 id="5-9-2-Future-说明"><a href="#5-9-2-Future-说明" class="headerlink" title="5.9.2 Future 说明"></a>5.9.2 Future 说明</h3><ol><li><p>表示<strong>异步的执行结果</strong>, 可以通过它提供的方法来检测执行是否完成，比如检索计算等等。</p></li><li><p>ChannelFuture 是一个接口 ： <code>public interface ChannelFuture extends Future&lt;Void&gt;</code>我们可以添<strong>加监听器，当监听的事件发生时，就会通知到监听器</strong>。</p></li></ol><h3 id="5-9-3-工作原理示意图"><a href="#5-9-3-工作原理示意图" class="headerlink" title="5.9.3 工作原理示意图"></a>5.9.3 工作原理示意图</h3><p><img src="/2022/10/22/Netty/clip_image029.jpg" alt="img"></p><p><img src="/2022/10/22/Netty/image-20221027202429972.png" alt="image-20221027202429972"></p><p>说明:</p><ol><li><p>在使用 Netty 进行编程时，拦截操作和转换出入站数据只需要您提供 callback 或利用 future 即可。这使得链式操作简单、高效, 并有利于编写可重用的、通用的代码。</p></li><li><p>Netty 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来</p></li></ol><h3 id="5-9-4-Future-Listener-机制"><a href="#5-9-4-Future-Listener-机制" class="headerlink" title="5.9.4 Future-Listener 机制"></a>5.9.4 Future-Listener 机制</h3><ol><li><p>当 Future 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 ChannelFuture 来获取操作执行的状态， 注册监听函数来执行完成后的操作。</p></li><li><p>常见有如下操作</p><ul><li>通过 isDone 方法来判断当前操作是否完成；</li><li>通过 isSuccess 方法来判断已完成的当前操作是否成功；</li><li>通过 getCause 方法来获取已完成的当前操作失败的原因；</li><li>通过 isCancelled 方法来判断已完成的当前操作是否被取消；</li><li>通过 addListener 方法来注册监听器，当操作已完成(isDone 方法返回完成)，将会通知指定的监听器；如果Future 对象已完成，则通知指定的监听器。</li></ul></li></ol><p>​3. 举例说明</p><p>演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/29 13:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是ServerBootstrap 而是BootStrap</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(eventExecutors) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">//设置客户端通道的实现类（反射）</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 is OK....&quot;</span>);</span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端  ChannelFuture涉及到netty的异步模型</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给channelFuture注册监听器,监控我们关心的事件</span></span><br><span class="line">            channelFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">if</span> (channelFuture.isSuccess())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口6668成功&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口6668成功&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-10-快速入门实例-HTTP-服务"><a href="#5-10-快速入门实例-HTTP-服务" class="headerlink" title="5.10   快速入门实例-HTTP 服务"></a>5.10   快速入门实例-HTTP 服务</h2><ol><li><p>实例要求：使用 IDEA 创建 Netty 项目</p></li><li><p>Netty 服务器在 6668 端口监听，浏览器发出请求 “<a href="http://localhost:6668/">http://localhost:6668/</a> “</p></li><li><p>服务器可以回复消息给客户端 “Hello! 我是服务器  “ , 并对特定请求资源进行过滤。</p></li><li><p>目的：Netty 可以做 Http 服务开发，并且理解 Handler 实例和客户端及其请求的关系。</p></li><li><p>代码演示</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestHttpServer.java</span><br><span class="line">    </span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.sctp.nio.NioSctpServerChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/29 15:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHttpServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">TestServerInitializer</span>());</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/29 15:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//向管道加入处理器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到管道</span></span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入一个netty提供的httpServerCodec codec =&gt;[coder decoder]</span></span><br><span class="line">        <span class="comment">//HttpServerCodec 是netty提供编解码器</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyHttpServerCodec&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加一个自定义的handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyTestHttpServerHandler&quot;</span>,<span class="keyword">new</span> <span class="title class_">TestHttpServerHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/29 15:27</span></span><br><span class="line"><span class="comment"> * SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter的子类</span></span><br><span class="line"><span class="comment"> * HttpObject 表示客户端和服务器端相互通讯的数据被封装成 HttpObject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpObject&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端数据</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断msg是不是httpRequest请求</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;msg地址：&quot;</span> + msg.getClass());</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端地址：&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="type">HttpRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> (HttpRequest) msg;</span><br><span class="line">            <span class="comment">//获取uri</span></span><br><span class="line">            <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URI</span>(httpRequest.uri());</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath()))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请求了favicon.ico，不做响应&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回复信息给浏览器[http协议]</span></span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;hello,我是服务器&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">            <span class="comment">//构造一个http的响应</span></span><br><span class="line">            <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, buf);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH,buf.readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将构建好的 response返回</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第-6-章-Netty核心模块组件"><a href="#第-6-章-Netty核心模块组件" class="headerlink" title="第 6 章 Netty核心模块组件"></a>第 6 章 Netty核心模块组件</h1><h2 id="6-1-Bootstrap、ServerBootstrap"><a href="#6-1-Bootstrap、ServerBootstrap" class="headerlink" title="6.1   Bootstrap、ServerBootstrap"></a>6.1   Bootstrap、ServerBootstrap</h2><ol><li><p>Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p></li><li><p>常见的方法有</p></li></ol><ul><li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端， 用来设置两个 EventLoop</li><li><code>public B group(EventLoopGroup group)</code> ，该方法用于客户端，用来设置一个 EventLoop </li><li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li><li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 ServerChannel 添加配置</li><li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li><li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>， 该方法用来设置业务处理类（ 自定义的handler）</li><li><code>public ChannelFuture bind(int inetPort)</code> ，该方法用于服务器端，用来设置占用的端口号</li><li><code>public ChannelFuture connect(String inetHost, int inetPort) </code>，该方法用于客户端，用来连接服务器端</li></ul><h2 id="6-2-Future、ChannelFuture"><a href="#6-2-Future、ChannelFuture" class="headerlink" title="6.2      Future、ChannelFuture"></a>6.2      Future、ChannelFuture</h2><p>Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和ChannelFutures，<strong>他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</strong></p><p>常见的方法有：</p><ul><li><code>Channel channel()</code>，返回当前正在进行 IO 操作的通道</li><li><code>ChannelFuture sync()</code>，等待异步操作执行完毕</li></ul><h2 id="6-3-Channel"><a href="#6-3-Channel" class="headerlink" title="6.3      Channel"></a>6.3      Channel</h2><ol><li><p><strong>Netty 网络通信的组件，能够用于执行网络 I&#x2F;O 操作。</strong></p></li><li><p>通过 Channel 可获得当前网络连接的通道的状态</p></li><li><p>通过 Channel 可获得 网络连接的配置参数 （例如接收缓冲区大小）</p></li><li><p>Channel 提供异步的网络 I&#x2F;O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I&#x2F;O 调用都将立即返回，并且不保证在调用结束时所请求的 I&#x2F;O 操作已完成</p></li><li><p>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I&#x2F;O 操作成功、失败或取消时回调通知调用方</p></li><li><p>支持关联 I&#x2F;O 操作与对应的处理程序</p></li><li><p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，常用的 Channel 类型: NioSocketChannel，异步的客户端 TCP Socket 连接。</p></li></ol><p>NioServerSocketChannel，异步的服务器端 TCP Socket 连接。</p><p>NioDatagramChannel，异步的 UDP 连接。</p><p>NioSctpChannel，异步的客户端 Sctp 连接。</p><p>NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</p><h2 id="6-4-Selector"><a href="#6-4-Selector" class="headerlink" title="6.4      Selector"></a>6.4      Selector</h2><ol><li><p><strong>Netty 基于 Selector 对象实现 I&#x2F;O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。</strong></p></li><li><p>当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的Channel 是否有已就绪的 I&#x2F;O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel。</p></li></ol><h2 id="6-5-ChannelHandler-及其实现类"><a href="#6-5-ChannelHandler-及其实现类" class="headerlink" title="6.5      ChannelHandler 及其实现类"></a>6.5      ChannelHandler 及其实现类</h2><ol><li><p><strong>ChannelHandler 是一个接口，处理 I&#x2F;O 事件或拦截 I&#x2F;O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。</strong></p></li><li><p>ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</p></li><li><p>ChannelHandler 及其实现类一览图(后)</p></li></ol><p> <img src="/2022/10/22/Netty/image-20221030113954905.png" alt="image-20221030113954905"></p><ol start="4"><li>我们经常需要自定义一个 Handler 类去继承 ChannelInboundHandlerAdapter，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法</li></ol><p><img src="/2022/10/22/Netty/clip_image002-16671008194122.jpg" alt="img"></p><h2 id="6-6-Pipeline-和-ChannelPipeline"><a href="#6-6-Pipeline-和-ChannelPipeline" class="headerlink" title="6.6      Pipeline 和 ChannelPipeline"></a>6.6      Pipeline 和 ChannelPipeline</h2><p><strong>ChannelPipeline 是一个重点：</strong></p><ol><li><p>ChannelPipeline 是一个 Handler 的集合，<strong>它负责处理和拦截 inbound 或者 outbound 的事件和操作，相当于一个贯穿 Netty 的链</strong>。(也可以这样理解：ChannelPipeline 是 保存 ChannelHandler 的 List，用于处理或拦截Channel 的入站事件和出站操作)。</p></li><li><p>ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel中各个的 ChannelHandler 如何相互交互。</p></li><li><p>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下</p></li></ol><p><img src="/2022/10/22/Netty/clip_image004.gif" alt="img"></p><ol start="4"><li>常用方法</li></ol><ul><li><code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>，把一个业务处理类（handler）添加到链中的第一个位置</li><li><code>ChannelPipeline addLast(ChannelHandler... handlers)</code>，把一个业务处理类（handler）添加到链中的最后一个位置</li></ul><h2 id="6-7-ChannelHandlerContext"><a href="#6-7-ChannelHandlerContext" class="headerlink" title="6.7      ChannelHandlerContext"></a>6.7      ChannelHandlerContext</h2><ol><li><p><strong>保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象。</strong></p></li><li><p>即 ChannelHandlerContext  中 包 含 一 个 具 体 的事件处理器ChannelHandler，同 时ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler 进行调用。</p></li><li><p>常用方法</p></li></ol><p><img src="/2022/10/22/Netty/clip_image006.gif" alt="img"></p><h2 id="6-8-ChannelOption"><a href="#6-8-ChannelOption" class="headerlink" title="6.8      ChannelOption"></a>6.8      ChannelOption</h2><ol><li><p>Netty 在创建 Channel 实例后,一般都需要设置 ChannelOption 参数。</p></li><li><p>ChannelOption 参数如下:</p></li></ol><p><img src="/2022/10/22/Netty/image-20221030114308015.png" alt="image-20221030114308015"></p><h2 id="6-9-EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#6-9-EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="6.9      EventLoopGroup 和其实现类 NioEventLoopGroup"></a>6.9      EventLoopGroup 和其实现类 NioEventLoopGroup</h2><ol><li><p>EventLoopGroup 是一组 EventLoop 的抽象，Netty 为了更好的利用多核 CPU 资源，一般会有多个 EventLoop同时工作，每个 EventLoop 维护着一个 Selector 实例。</p></li><li><p>EventLoopGroup 提供 next 接口，可以从组里面按照一定规则获取其中一个 EventLoop 来处理任务。在 Netty 服 务 器 端 编 程 中 ， 我 们 一 般 都 需 要 提 供 两 个 EventLoopGroup ， 例 如 ： BossEventLoopGroup 和WorkerEventLoopGroup。</p></li><li><p>通常一个服务端口即一个 ServerSocketChannel 对应一个 Selector 和一个EventLoop 线程。BossEventLoop 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理，如下图所示</p></li></ol><p><img src="/2022/10/22/Netty/clip_image009.gif" alt="img"></p><ol start="4"><li>常用方法</li></ol><ul><li><code>public NioEventLoopGroup()</code>，构造方法</li><li><code>public Future&lt;?&gt; shutdownGracefully()</code>，断开连接，关闭线程</li></ul><h2 id="6-10-Unpooled-类"><a href="#6-10-Unpooled-类" class="headerlink" title="6.10   Unpooled 类"></a>6.10   Unpooled 类</h2><ol><li><p>Netty 提供一个专门用来操作缓冲区(即 Netty 的数据容器)的工具类。</p></li><li><p>常用方法如下所示</p></li></ol><p><img src="/2022/10/22/Netty/image-20221030114407908.png" alt="image-20221030114407908"></p><ol start="3"><li>举例说明 Unpooled 获取 Netty 的数据容器 ByteBuf 的基本使用 【案例演示】</li></ol><p><img src="/2022/10/22/Netty/image-20221030114423892.png" alt="image-20221030114423892"></p><p>案例 1</p><p><img src="/2022/10/22/Netty/image-20221030125618460.png" alt="image-20221030125618460"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 12:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyByteBuf01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个ByteBuf</span></span><br><span class="line">        <span class="comment">//说明：</span></span><br><span class="line">        <span class="comment">// 1. 创建对象，该对象包含一个数组byte[10]</span></span><br><span class="line">        <span class="comment">// 2. 在netty的buffer中，不需要flip进行反转，因为底层维护了readerIndex和writerIndex</span></span><br><span class="line">        <span class="comment">// 3. 通过 readerIndex 和 writerIndex 和 capacity,将buffer分成三个区域：</span></span><br><span class="line">        <span class="comment">//     0 -&gt; readerIndex 已经读取的区域   readerIndex -&gt; writerIndex 可读的区域    writerIndex -&gt; capacity 可写的区域</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buffer.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;capacity：&quot;</span> + buffer.capacity());</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            System.out.println(buffer.getByte(i));</span><br><span class="line">            System.out.println(buffer.readByte()   );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>案例 2</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 12:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NettyByteBuf02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建ByteBuf</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;hello,world!&quot;</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        <span class="comment">//使用相关的方法</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuf.hasArray())&#123;</span><br><span class="line">            <span class="type">byte</span>[] array = byteBuf.array();</span><br><span class="line">            <span class="comment">//将array转成字符串</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(array,Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line">            System.out.println(<span class="string">&quot;byteBuf：&quot;</span> + byteBuf);</span><br><span class="line"></span><br><span class="line">            System.out.println(byteBuf.arrayOffset()); <span class="comment">//0</span></span><br><span class="line">            System.out.println(byteBuf.readerIndex()); <span class="comment">//0</span></span><br><span class="line">            System.out.println(byteBuf.writerIndex()); <span class="comment">//12</span></span><br><span class="line">            System.out.println(byteBuf.capacity());  <span class="comment">//36</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> byteBuf.readableBytes(); <span class="comment">//可读字节数 12</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//输出指定区域的值</span></span><br><span class="line">            System.out.println(byteBuf.getCharSequence(<span class="number">2</span>,<span class="number">4</span>,Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="/2022/10/22/Netty/image-20221030131357338.png" alt="image-20221030131357338"></p><h2 id="6-11-Netty-应用实例-群聊系统"><a href="#6-11-Netty-应用实例-群聊系统" class="headerlink" title="6.11   Netty 应用实例-群聊系统"></a>6.11   Netty 应用实例-群聊系统</h2><p>实例要求:</p><ol><li><p>编写一个 Netty 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</p></li><li><p>实现多人群聊</p></li><li><p>服务器端：可以监测用户上线，离线，并实现消息转发功能</p></li><li><p>客户端：通过 channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(有服务器转发得到)</p></li><li><p>目的：进一步理解 Netty 非阻塞网络编程机制</p></li><li><p>代码演示</p></li></ol><p>代码如下：</p><p><img src="/2022/10/22/Netty/image-20221030144924319.png" alt="image-20221030144924319"></p><p>服务端</p><p>GroupChatServer</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 13:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line">    <span class="comment">//监听端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">(<span class="type">int</span> port)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写run方法，处理客户端的请求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="literal">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//获取到pipeline</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            <span class="comment">//向pipeline加入解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            <span class="comment">//向pipeline加入编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                            <span class="comment">//加入自己的业务处理handler</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">GroupChatServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;netty 服务器启动&quot;</span>);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">//监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>(<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> GroupChatServerHandler</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 13:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个channel组，管理所有的channel</span></span><br><span class="line"><span class="comment">     * GlobalEventExecutor.INSTANCE 是全局的事件执行器，是一个单例</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ChannelGroup</span> <span class="variable">channelGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelGroup</span>(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handlerAdded 表示连接建立，一旦连接，第一个被执行</span></span><br><span class="line"><span class="comment">     * 将当前channel 加入到 channelGroup</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        <span class="comment">//将该客户加入聊天的信息推送给其他在线的客户端</span></span><br><span class="line">        <span class="comment">//writeAndFlush会将 channelGroup 中所有的channel 遍历并发送消息</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端] &quot;</span> + channel.remoteAddress() + <span class="string">&quot; 加入聊天\n&quot;</span>);</span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示channel 处于活动状态，提示xx上线</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot; 上线了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示channel 处于不活动状态，提示xx离线了</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot; 离线了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开连接，将xx客户离开信息推送给其他在线的客户</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 离开了&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;channelGroup size：&quot;</span> + channelGroup.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        <span class="comment">//遍历channelGroup，根据不同的情况，回送不同的消息</span></span><br><span class="line">        channelGroup.forEach(channel1 -&gt; &#123;</span><br><span class="line">            <span class="comment">//给不是当前的channel，转发消息</span></span><br><span class="line">            <span class="keyword">if</span> (channel1 != channel)&#123;</span><br><span class="line">                channel1.writeAndFlush(<span class="string">&quot;[客户]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 发送的消息：&quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                channel1.writeAndFlush(<span class="string">&quot;你已发送消息：&quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生异常时</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端</p><p>GroupChatClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 14:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> PORT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClient</span><span class="params">(String host,<span class="type">int</span> port)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.HOST = host;</span><br><span class="line">        <span class="built_in">this</span>.PORT = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bootstrap.group(eventExecutors)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//得到pipeline</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            <span class="comment">//加入相关的handler</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br><span class="line">                                    .addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">StringEncoder</span>())</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> <span class="title class_">GroupChatClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(HOST, PORT).sync();</span><br><span class="line"></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;--------&quot;</span> + channel.localAddress() + <span class="string">&quot;---------&quot;</span>);</span><br><span class="line">            <span class="comment">//客户端需要输入信息，创建一个扫描器</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="comment">//通过channel发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(s + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GroupChatClient</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>GroupChatClientHandler</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 14:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-12-Netty-心跳检测机制案例"><a href="#6-12-Netty-心跳检测机制案例" class="headerlink" title="6.12   Netty 心跳检测机制案例"></a>6.12   Netty 心跳检测机制案例</h2><p>实例要求:</p><ol><li><p>编写一个 Netty 心跳检测机制案例, 当服务器超过 3 秒没有读时，就提示读空闲</p></li><li><p>当服务器超过 5 秒没有写操作时，就提示写空闲</p></li><li><p>实现当服务器超过 7 秒没有读或者写操作时，就提示读写空闲</p></li><li><p>代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.netty.netty.heartbeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 16:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO)) <span class="comment">//在bossGroup添加一个日志处理器</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            <span class="comment">//加入一个netty 提供的IdleStateHandler：处理空闲状态的处理器</span></span><br><span class="line">                            <span class="comment">// long readerIdleTime：表示多长时间没有读，就会发送一个心跳检测包，检测是否连接</span></span><br><span class="line">                            <span class="comment">// long writerIdleTime：表示多长时间没有写，就会发送一个心跳检测包，检测是否连接</span></span><br><span class="line">                            <span class="comment">// long allIdleTime：表示多长时间没有读写，就会发送一个心跳检测包，检测是否连接</span></span><br><span class="line">                            <span class="comment">//当IdleStateHandler触发后，就会传递给管道的下一个handler去处理，通过调用（触发）下一个handler的userEventTriggered去处理</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line">                            <span class="comment">//加入一个对空闲检测进一步处理的handler（自定义）</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//启动服务器</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hua.netty.netty.heartbeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/30 17:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt 事件</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            <span class="comment">//将evt 向下转型 IdleStateEvent</span></span><br><span class="line">            <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">            <span class="type">String</span> <span class="variable">eventType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state())&#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读空闲&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;写空闲&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读写空闲&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot;--超时时间--&quot;</span> + eventType);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <img src="/2022/10/22/Netty/image-20221030173646593.png" alt="image-20221030173646593"></p><h2 id="6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接"><a href="#6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接" class="headerlink" title="6.13   Netty 通过 WebSocket 编程实现服务器和客户端长连接"></a>6.13   Netty 通过 WebSocket 编程实现服务器和客户端长连接</h2><p>实例要求:</p><ol><li><p>Http 协议是无状态的, 浏览器和服务器间的请求响应一次，下一次会重新创建连接.</p></li><li><p>要求：实现基于 webSocket 的长连接的全双工的交互</p></li><li><p>改变 Http 协议多次请求的约束，实现长连接了， 服务器可以发送消息给浏览器</p></li><li><p>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</p></li><li><p>运行界面</p></li></ol><p><img src="/2022/10/22/Netty/image-20221030114911232.png" alt="image-20221030114911232"></p><p>代码演示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.websocket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.netty.heartbeat.MyServerHandler; <span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture; <span class="keyword">import</span> io.netty.channel.ChannelInitializer; <span class="keyword">import</span> io.netty.channel.ChannelPipeline; <span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup; <span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler; <span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler; <span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler; <span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); <span class="comment">//8 个 NioEventLoop try &#123;</span></span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line">        serverBootstrap.group(bossGroup, workerGroup); </span><br><span class="line">        serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">        serverBootstrap.handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO)); </span><br><span class="line">        serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">                <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                <span class="comment">//因为基于 http 协议，使用 http 的编码和解码器</span></span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">                <span class="comment">//是以块方式写，添加 ChunkedWriteHandler 处理器</span></span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                说明</span></span><br><span class="line"><span class="comment">                1.http 数据在传输过程中是分段, HttpObjectAggregator ，就是可以将多个段聚合</span></span><br><span class="line"><span class="comment">                2.这就就是为什么，当浏览器发送大量数据时，就会发出多次 http 请求</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">8192</span>));</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                说明</span></span><br><span class="line"><span class="comment">                1.对应 websocket ，它的数据是以 帧(frame) 形式传递</span></span><br><span class="line"><span class="comment">                2.可以看到 WebSocketFrame 下面有六个子类</span></span><br><span class="line"><span class="comment">                3.浏览器请求时 ws://localhost:7000/hello  表示请求的 uri</span></span><br><span class="line"><span class="comment">                4.WebSocketServerProtocolHandler 核心功能是将 http 协议升级为 ws 协议 , 保持长连接</span></span><br><span class="line"><span class="comment">                5.是通过一个 状态码 101</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> <span class="title class_">WebSocketServerProtocolHandler</span>(<span class="string">&quot;/hello2&quot;</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//自定义的 handler ，处理业务逻辑</span></span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyTextWebSocketFrameHandler</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动服务器</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">7000</span>).sync(); </span><br><span class="line">        channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully(); </span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.netty.websocket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里 TextWebSocketFrame 类型，表示一个文本帧(frame)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt;&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到消息 &quot;</span> + msg.text());</span><br><span class="line">        <span class="comment">//回复消息</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(<span class="string">&quot; 服 务 器 时 间 &quot;</span> + LocalDateTime.now() + <span class="string">&quot; &quot;</span> + msg.text()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当 web 客户端连接后， 触发方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span></span><br><span class="line">            System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">            System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asShortText());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;handlerRemoved 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常发生 &quot;</span> + cause.getMessage());</span><br><span class="line">            ctx.close(); <span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            <span class="keyword">var</span> socket;</span><br><span class="line">            <span class="comment">//判断当前浏览器是否支持 websocket if(window.WebSocket) &#123;</span></span><br><span class="line">            <span class="comment">//go on</span></span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:7000/hello2&quot;</span>);</span><br><span class="line">            <span class="comment">//相当于 channelReado, ev 收到服务器端回送的消息</span></span><br><span class="line">            socket.onmessage = function (ev) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">rt</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;responseText&quot;</span>); </span><br><span class="line">                rt.value = rt.value + <span class="string">&quot;\n&quot;</span> + ev.data;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//相当于连接开启(感知到连接开启)</span></span><br><span class="line">            socket.onopen = function (ev) &#123;</span><br><span class="line">                <span class="type">var</span> <span class="variable">rt</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;responseText&quot;</span>);</span><br><span class="line">                rt.value = <span class="string">&quot;连接开启了..&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//相当于连接关闭(感知到连接关闭) </span></span><br><span class="line">socket.onclose = function (ev) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">var</span> <span class="variable">rt</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;responseText&quot;</span>); </span><br><span class="line">                rt.value = rt.value + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;连接关闭了..&quot;</span></span><br><span class="line">                alert(<span class="string">&quot;当前浏览器不支持 websocket&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送消息到服务器function send(message) &#123;</span></span><br><span class="line">            <span class="keyword">if</span>(!window.socket) &#123; <span class="comment">//先判断 socket 是否创建好</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket.readyState == WebSocket.OPEN) &#123;</span><br><span class="line">                <span class="comment">//通过 socket 发送消息</span></span><br><span class="line">                socket.send(message)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(<span class="string">&quot;连接没有开启&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;form onsubmit=<span class="string">&quot;return false&quot;</span>&gt;</span><br><span class="line">            &lt;textarea name=<span class="string">&quot;message&quot;</span> style=<span class="string">&quot;height: 300px; width: 300px&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;发生消息&quot;</span> onclick=<span class="string">&quot;send(this.form.message.value)&quot;</span>&gt;</span><br><span class="line">            &lt;textarea id=<span class="string">&quot;responseText&quot;</span> style=<span class="string">&quot;height: 300px; width: 300px&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;清空内容&quot;</span> onclick=<span class="string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文件灰色且有删除线</title>
      <link href="/2022/10/17/IDEA%20%E4%B8%AD%E6%9F%90%E4%B8%AA%E9%A1%B9%E7%9B%AE%20pom%20%E6%96%87%E4%BB%B6%E7%81%B0%E8%89%B2%E4%B8%94%E6%9C%89%E5%88%A0%E9%99%A4%E7%BA%BF/"/>
      <url>/2022/10/17/IDEA%20%E4%B8%AD%E6%9F%90%E4%B8%AA%E9%A1%B9%E7%9B%AE%20pom%20%E6%96%87%E4%BB%B6%E7%81%B0%E8%89%B2%E4%B8%94%E6%9C%89%E5%88%A0%E9%99%A4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA-中某个项目-pom-文件灰色且有删除线"><a href="#IDEA-中某个项目-pom-文件灰色且有删除线" class="headerlink" title="IDEA 中某个项目 pom 文件灰色且有删除线"></a>IDEA 中某个项目 pom 文件灰色且有删除线</h1><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>因为<a href="https://so.csdn.net/so/search?q=maven&spm=1001.2101.3001.7020">maven</a> 将该 pom忽略</p><h1 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h1><p>打开设置 settings –&gt; maven –&gt; Ignored Files 取消相应pom的勾选，然后确定即可</p><p><img src="/2022/10/17/IDEA%20%E4%B8%AD%E6%9F%90%E4%B8%AA%E9%A1%B9%E7%9B%AE%20pom%20%E6%96%87%E4%BB%B6%E7%81%B0%E8%89%B2%E4%B8%94%E6%9C%89%E5%88%A0%E9%99%A4%E7%BA%BF/1659961827087.png" alt="1659961827087"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2022/08/06/Docker/"/>
      <url>/2022/08/06/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基本篇"><a href="#一、基本篇" class="headerlink" title="一、基本篇"></a>一、基本篇</h1><h2 id="1、Docker简介"><a href="#1、Docker简介" class="headerlink" title="1、Docker简介"></a>1、Docker简介</h2><h3 id="1-1、Docker理念"><a href="#1-1、Docker理念" class="headerlink" title="1.1、Docker理念"></a>1.1、Docker理念</h3><p>Docker用Go编程语言编写，并利用Linux内核的多种功能来交付其功能。</p><p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“<strong>一次镜像，处处运行</strong>”。</p><p><img src="/2022/08/06/Docker/240bb37ecf24bb3b47e4f7e2dd72553359f8516d.png" alt="img"></p><p>Linux容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用打成镜像，通过镜像成为运行在Docker容器上面的实例，而 Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</p><p><strong>一句话解决了运行环境和配置问题的软件容器， 方便做持续集成并有助于整体发布的容器虚拟化技术。</strong></p><p><strong>小结：</strong></p><ul><li><strong>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</strong><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul></li><li><strong>Docker如何解决开发、测试、生产环境有差异的问题？</strong><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul></li><li><strong>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</strong><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul></li></ul><h3 id="1-2、容器与虚拟机比较"><a href="#1-2、容器与虚拟机比较" class="headerlink" title="1.2、容器与虚拟机比较"></a>1.2、容器与虚拟机比较</h3><h4 id="传统虚拟机技术"><a href="#传统虚拟机技术" class="headerlink" title="传统虚拟机技术"></a>传统虚拟机技术</h4><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在Windows10系统里面运行Linux系统CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。</p><table><thead><tr><th>Win10</th><th>VMWare</th><th>Centos7</th><th>各种cpu、内存网络额配置+各种软件</th><th>虚拟机实例</th></tr></thead></table><p><img src="/2022/08/06/Docker/159866a75eb41110fda423c1c44a2962046b37cd.png" alt="img"></p><p><img src="/2022/08/06/Docker/bcb7519ab7e62a03724a76ea28ee9e8b3399d980.png" alt="img"></p><p>虚拟机的缺点：</p><ul><li>资源占用多</li><li>冗余步骤多</li><li>启动慢</li></ul><h4 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h4><p>由于前面虚拟机存在某些缺点，Linux发展出了另一种虚拟化技术：<strong>Linux容器(Linux Containers，缩写为 LXC)<strong>Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。 <strong>Linux 容器不是模拟一个完整的操作系统而是对进程进行隔离。</strong>有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。</strong>容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。</strong>系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p><p><img src="/2022/08/06/Docker/a6e6c0245b65806695b53d1f109e7b96a6ffd362.png" alt="img"></p><p><img src="/2022/08/06/Docker/f7b658bc77fa9c9ab33bee02786d408179d386ea.png" alt="img"></p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="/2022/08/06/Docker/image-20220531104245070.png" alt="image-20220531104245070"></p><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p><p><em>容器内的应用进程直接运行于宿主的内核，<strong>容器内没有自己的内核且也没有进行硬件虚拟</strong>。因此容器要比传统虚拟机更为轻便。</em></p><p> 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p><h3 id="1-3、Docker-如何工作？"><a href="#1-3、Docker-如何工作？" class="headerlink" title="1.3、Docker 如何工作？"></a>1.3、Docker 如何工作？</h3><p> Docker 技术使用 Linux 内核和内核功能（例如 Cgroups 和 namespaces）来分隔进程，以便各进程相互独立运行。这种独立性正是采用容器的目的所在；它可以独立运行多种进程、多个应用程序，更加充分地发挥基础设施的作用，同时保持各个独立系统的安全性。</p><p> 容器工具（包括 Docker）可提供基于镜像的部署模式。这使得它能够轻松跨多种环境，与其依赖程序共享应用或服务组。Docker 还可在这一容器环境中自动部署应用程序（或者合并多种流程，以构建单个应用程序）。</p><h3 id="1-4、Docker去哪下"><a href="#1-4、Docker去哪下" class="headerlink" title="1.4、Docker去哪下"></a>1.4、Docker去哪下</h3><ul><li>官网<ul><li><a href="http://www.docker.com/">Docker 官网(opens new window)</a></li></ul></li><li>仓库<ul><li><a href="https://hub.docker.com/">Docker Hub 官网(opens new window)</a></li></ul></li><li>相关官网<ul><li>Docker 官方主页: <a href="https://www.docker.com/">https://www.docker.com(opens new window)</a></li><li>Docker 官方博客: <a href="https://blog.docker.com/">https://blog.docker.com(opens new window)</a></li><li>Docker 官方文档: <a href="https://docs.docker.com/">https://docs.docker.com(opens new window)</a></li><li>Docker 安装文档：<a href="https://docs.docker.com/engine/install">https://docs.docker.com/engine/install(opens new window)</a></li><li>Docker Store: <a href="https://store.docker.com/">https://store.docker.com(opens new window)</a></li><li>Docker Cloud: <a href="https://cloud.docker.com/">https://cloud.docker.com(opens new window)</a></li><li>Docker Hub: <a href="https://hub.docker.com/">https://hub.docker.com(opens new window)</a></li><li>Docker 中文文档：<a href="https://vuepress.mirror.docker-practice.com/">https://vuepress.mirror.docker-practice.com/</a></li></ul></li></ul><h2 id="2、Docker架构"><a href="#2、Docker架构" class="headerlink" title="2、Docker架构"></a>2、Docker架构</h2><h3 id="2-1、镜像、容器和仓库"><a href="#2-1、镜像、容器和仓库" class="headerlink" title="2.1、镜像、容器和仓库"></a>2.1、镜像、容器和仓库</h3><p>Docker中有几个重要的概念：</p><ul><li><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</li></ul><p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，<strong>一个镜像可以创建很多容器</strong>。</p><p>它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。</p><p>相当于容器的“源代码”，<strong>docker镜像文件类似于Java的类模板，而docker容器实例类似于java中new出来的实例对象</strong>。</p><p>容器与镜像的关系类似于面向对象编程中的对象与类：</p><table><thead><tr><th>Docker</th><th>面向对象</th></tr></thead><tbody><tr><td>容器</td><td>对象</td></tr><tr><td>镜像</td><td>类</td></tr></tbody></table><ul><li><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</li></ul><ol><li><strong>从面向对象角度</strong></li></ol><p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，<strong>容器是用镜像创建的运行实例</strong>。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p><ol><li><strong>从镜像容器角度</strong></li></ol><p><strong>可以把容器看做是一个简易版的</strong> <strong>Linux</strong> <strong>环境</strong>（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p><ul><li><strong>仓库(repository)</strong></li></ul><p>仓库（Repository）是集中存放镜像文件的场所。</p><p>类似于Maven仓库，存放各种jar包的地方；github仓库，存放各种git项目的地方；Docker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p><p><strong>最大的公开仓库是 DockerHub</strong>(<a href="https://hub.docker.com/">https://hub.docker.com/ (opens new window)</a>)，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等</p><p><img src="/2022/08/06/Docker/image-20220531104638396.png" alt="image-20220531104638396"></p><p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p><p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p><p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中运行，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p><p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p><h3 id="2-2、DockerHub"><a href="#2-2、DockerHub" class="headerlink" title="2.2、DockerHub"></a>2.2、DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如<code>Redis</code>、<code>MySQL</code>镜像放到网络上，共享使用，就像<code>GitHub</code>的代码共享一样。</p><ul><li><strong>DockerHub</strong>：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</li><li>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</li></ul><p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像</p><p><img src="/2022/08/06/Docker/image-20220531105015867.png" alt="image-20220531105015867"></p><h3 id="2-3、Doker架构-入门版"><a href="#2-3、Doker架构-入门版" class="headerlink" title="2.3、Doker架构(入门版)"></a>2.3、Doker架构(入门版)</h3><p><img src="/2022/08/06/Docker/image-20221008204201004.png" alt="image-20221008204201004"></p><blockquote><p>K8S：CRI（Container Runtime Interface）</p><p>Client： 客户端；操作docker服务器的客户端（命令行或者界面）</p><p>Docker_Host：Docker主机；安装Docker服务的主机</p><p>Docker_Daemon：后台进程；运行在Docker服务器的后台进程</p><p>Containers：容器；在Docker服务器中的容器（一个容器一般是一个应用实例，容器间互相隔离）</p><p>Images：镜像、映像、程序包；Image是只读模板，其中包含创建Docker容器的说明。容器是由Image运行而来，Image固定不变。</p><p>Registries：仓库；存储Docker Image的地方。官方远程仓库地址： <a href="https://hub.docker.com/search">https://hub.docker.com/search</a></p></blockquote><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p><p>Docker是一个CS架构的程序，由两部分组成：</p><ul><li>**服务端(server)**：Docker守护进程，负责处理Docker指令，管理镜像、容器等</li><li>**客户端(client)**：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li></ul><h3 id="2-4、Docker平台架构图解-架构版"><a href="#2-4、Docker平台架构图解-架构版" class="headerlink" title="2.4、Docker平台架构图解(架构版)"></a>2.4、Docker平台架构图解(架构版)</h3><p>Docker 是一个 C&#x2F;S 模式的架构，后端是一个松耦合架构，众多模块各司其职。</p><p><img src="/2022/08/06/Docker/image.6zaea6xum9k0.webp" alt="image"></p><p>Docker运行的基本流程：</p><ol><li>用户是使用Docker Client与 Docker Daemon建立通信，并发送请求给后者。</li><li>Docker Daemon作为Docker架构中的主体部分，首先提供Docker Server的功能使其可以接受Docker Client 的请求。</li><li>Docker Engine执行Docker 内部的一系列工作，每一项工作都是以一个Job的形式的存在。</li><li>Job的运行过程中，当需要容器镜像时，则从Docker Registry 中下载镜像，并通过镜像管理驱动Graph driver将下载镜像以Graph的形式存储。</li><li>当需要为Docker创建网络环境时，通过网络管理驱动Network driver创建并配置Docker容器网络环境。</li><li>当需要限制Docker容器运行资源或执行用户指令等操作时，则通过Exec driver来完成。</li><li>Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。</li></ol><p><img src="/2022/08/06/Docker/image.7hh30r9dad40.webp" alt="image"></p><h3 id="2-5、小结"><a href="#2-5、小结" class="headerlink" title="2.5、小结"></a>2.5、小结</h3><p>镜像：</p><ul><li>将应用程序及其依赖、环境、配置打包在一起</li></ul><p>容器：</p><ul><li>镜像运行起来就是容器，一个镜像可以运行多个容器</li></ul><p>Docker结构：</p><ul><li>服务端：接收命令或远程请求，操作镜像或容器</li><li>客户端：发送命令或者请求到Docker服务端</li></ul><p>DockerHub：</p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul><h2 id="3、Docker隔离原理"><a href="#3、Docker隔离原理" class="headerlink" title="3、Docker隔离原理"></a>3、Docker隔离原理</h2><ul><li><strong>namespace 6 项隔离 （资源隔离）</strong></li></ul><table><thead><tr><th><strong>namespace</strong></th><th><strong>系统调用参数</strong></th><th><strong>隔离内容</strong></th></tr></thead><tbody><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>主机和域名</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>信号量、消息队列和共享内存</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>进程编号</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>网络设备、网络栈、端口等</td></tr><tr><td>Mount</td><td>CLONE_NEWNS</td><td>挂载点(文件系统)</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>用户和用户组</td></tr></tbody></table><ul><li><strong>cgroups 资源限制 （资源限制）</strong></li></ul><p>cgroup提供的主要功能如下：</p><ul><li><ul><li>资源限制：限制任务使用的资源总额，并在超过这个 配额 时发出提示</li><li>优先级分配：分配CPU时间片数量及磁盘IO带宽大小、控制任务运行的优先级</li><li>资源统计：统计系统资源使用量，如CPU使用时长、内存用量等</li><li>任务控制：对任务执行挂起、恢复等操作</li></ul></li></ul><blockquote><p>cgroup资源控制系统，每种子系统独立地控制一种资源。功能如下</p></blockquote><table><thead><tr><th><strong>子系统</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>cpu</td><td>使用调度程序控制任务对CPU的使用</td></tr><tr><td>cpuacct(CPU Accounting)</td><td>自动生成cgroup中任务对CPU资源使用情况的报告</td></tr><tr><td>cpuset</td><td>为cgroup中的任务分配独立的CPU(多处理器系统时)和内存</td></tr><tr><td>devices</td><td>开启或关闭cgroup中任务对设备的访问</td></tr><tr><td>freezer</td><td>挂起或恢复cgroup中的任务</td></tr><tr><td>memory</td><td>设定cgroup中任务对内存使用量的限定，并生成这些任务对内存资源使用情况的报告</td></tr><tr><td>perf_event(Linux CPU性能探测器)</td><td>使cgroup中的任务可以进行统一的性能测试</td></tr><tr><td>net_cls(Docker未使用)</td><td>通过等级识别符标记网络数据包，从而允许Linux流量监控程序(Tra?icController)识别从具体cgroup中生成的数据包</td></tr></tbody></table><h2 id="4、Docker安装"><a href="#4、Docker安装" class="headerlink" title="4、Docker安装"></a>4、Docker安装</h2><blockquote><p>以下以centos为例；</p><p>更多其他安装方式，详细参照文档： <a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p></blockquote><p><img src="/2022/08/06/Docker/image.3b1ygz3skt80.webp" alt="image"></p><h3 id="4-1、前提条件"><a href="#4-1、前提条件" class="headerlink" title="4.1、前提条件"></a>4.1、<strong>前提条件</strong></h3><p>目前，CentOS 仅发行版本中的内核支持 Docker。<strong>Docker 运行在CentOS 7 (64-bit)上，</strong></p><p><strong>要求系统为64位、Linux系统内核版本为 3.8以上，这里选用Centos7.x</strong></p><p><strong>查看自己的内核</strong></p><p>uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua ~]# cat /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.9.2009 (Core)</span><br><span class="line">[root@hua ~]# uname -r</span><br><span class="line">3.10.0-1160.el7.x86_64</span><br><span class="line">[root@hua ~]#</span><br></pre></td></tr></table></figure><p>该 <code>centos-extras</code> 库必须启用。默认情况下启用此存储库，但如果您已禁用它，则需要 <a href="https://wiki.centos.org/AdditionalResources/Repositories">重新启用它 (opens new window)</a>。</p><p><code>overlay2</code> 推荐使用存储驱动。</p><h3 id="4-2、安装步骤"><a href="#4-2、安装步骤" class="headerlink" title="4.2、安装步骤"></a>4.2、安装步骤</h3><h4 id="4-2-1、卸载旧版本"><a href="#4-2-1、卸载旧版本" class="headerlink" title="4.2.1、卸载旧版本"></a>4.2.1、卸载旧版本</h4><p>旧版本的 Docker 被称为 <code>docker</code> 或 <code>docker-engine</code>。如果安装了这些，请卸载它们以及相关的依赖项：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                docker-client \</span><br><span class="line">                docker-client-latest \</span><br><span class="line">                docker-common \</span><br><span class="line">                docker-latest \</span><br><span class="line">                docker-latest-logrotate \</span><br><span class="line">                docker-logrotate \</span><br><span class="line">                docker-engine</span><br></pre></td></tr></table></figure><p>如果 <code>yum</code> 报告没有安装这些软件包，那也没关系，只是说明曾经没安装过，不影响任何东西。</p><p>卸载并不会全部卸载，如图像、容器、卷和网络，将被保留，以及 <code>/var/lib/docker/</code> 的内容</p><p>Docker 引擎包现在被称为 <code>docker-ce</code>。</p><h4 id="4-2-2、yum安装gcc相关"><a href="#4-2-2、yum安装gcc相关" class="headerlink" title="4.2.2、yum安装gcc相关"></a>4.2.2、yum安装gcc相关</h4><p>保证CentOS能够正常上网。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure><h4 id="4-2-3、安装软件包"><a href="#4-2-3、安装软件包" class="headerlink" title="4.2.3、安装软件包"></a>4.2.3、安装软件包</h4><p>首先说明下：Docker 安装路径是 <code>/var/lib/docker</code>，安装 Docker 成功后，在该路径中有一个 image 和 containers 文件夹，分别存放镜像和实例。</p><p>您可以根据需要以不同方式安装 Docker Engine：</p><ul><li>从 Docker 的存储库或者其他镜像库里下载，这是最推荐的方法</li><li>下载 RPM 包并手动安装并完全手动管理升级。这在某些情况下非常有用，例如在无法访问互联网的气隙系统上安装 Docker</li><li>便捷脚本安装 Docker，可以在测试和开发环境中安装</li></ul><p>在新主机上首次安装 Docker Engine 之前，您需要设置 Docker 存储库。之后，您可以从存储库安装和更新 Docker。</p><p>安装 <code>yum-utils</code> 包，它提供 <code>yum-config-manager</code> 实用程序</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure><h4 id="4-2-4、设置镜像仓库"><a href="#4-2-4、设置镜像仓库" class="headerlink" title="4.2.4、设置镜像仓库"></a>4.2.4、<strong>设置镜像仓库</strong></h4><p>设置稳定版本的仓库</p><p>官网（国外）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>阿里云（国内）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>阿里云仓库也是定期从官网仓库进行更新引用，两者仓库量无太大区别，如果配置了阿里云仓库，也要配置阿里云镜像加速，即下载速度源由官网改为阿里云。</p><ul><li>最新版本安装</li><li>特定版本安装</li></ul><h4 id="4-2-5、更新yum软件包索引"><a href="#4-2-5、更新yum软件包索引" class="headerlink" title="4.2.5、更新yum软件包索引"></a>4.2.5、更新yum软件包索引</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><h4 id="4-2-6、安装Docker-CE"><a href="#4-2-6、安装Docker-CE" class="headerlink" title="4.2.6、安装Docker CE"></a>4.2.6、安装Docker CE</h4><p>安装 <strong>最新版本</strong> 的 Docker Engine 和 containerd：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum -y install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>如果希望自己手动确认一些安装条件，则把 <code>-y</code> 去掉。</p><p>如果报如下错误：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">No package docker-ce available.</span><br><span class="line">No package docker-ce-cli available.</span><br><span class="line">No package containerd.io available.</span><br></pre></td></tr></table></figure><p>要么你的 Linux 版本没到达 3.10.+，要么你忽略了上方的设置存储库，请设置官方或者阿里云的存储库，否则无法找到 Docker。</p><p>还有一种可能就是你的 yum 版本太低，请更新它。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新 yum</span></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS 7 更新索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS 8 更新索引</span></span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p>安装 <strong>特定版本</strong> 的 Docker Engine，请在 repo 中列出可用版本，然后选择并安装</p><p>首先列出可以安装的版本：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">docker-ce.x86_643:18.09.1-3.el7docker-ce-stable</span><br><span class="line">docker-ce.x86_643:18.09.0-3.el7docker-ce-stable</span><br><span class="line">docker-ce.x86_6418.06.1.ce-3.el7docker-ce-stable</span><br><span class="line">docker-ce.x86_6418.06.e.ce-3.el7docker-ce-stable</span><br></pre></td></tr></table></figure><p>返回的列表取决于启用的存储库，并且特定于您的 CentOS 版本（e17 就是 CentOS 7.x 版本，如果是 CentOS 8.2，则是 e18）</p><p>通过完全限定的包名称安装特定版本，即包名称 (<code>docker-ce</code>) 加上从第一个冒号 (<code>:</code>)开始的版本字符串（第 2 列），直到第一个连字符，由连字符 (<code>-</code>)分隔。例如：<code>docker-ce-18.09.1</code>。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce-&lt;version&gt; docker-ce-cli-&lt;version&gt; containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line">sudo yum install docker-ce-18.09.1 docker-ce-cli-18.09.1 containerd.io</span><br></pre></td></tr></table></figure><p>此命令会安装 Docker，但不会启动 Docker。它还会创建一个 <code>docker</code> 组，但是，默认情况下它不会向该组添加任何用户。</p><h4 id="4-2-7、安装进阶"><a href="#4-2-7、安装进阶" class="headerlink" title="4.2.7、安装进阶"></a>4.2.7、安装进阶</h4><h5 id="以非root用户管理Docker"><a href="#以非root用户管理Docker" class="headerlink" title="以非root用户管理Docker"></a>以非root用户管理Docker</h5><p>Docker 守护进程绑定到 Unix 套接字而不是 TCP 端口。默认情况下，Unix 套接字归用户所有 <code>root</code>，其他用户只能使用 <code>sudo</code>. Docker 守护进程始终以<code>root</code> 用户身份运行。</p><p>如果您不想在 <code>docker</code> 命令前加上 <code>sudo</code>，请创建一个 <code>docker</code> 用户组并向其中添加用户。当 Docker 守护进程启动时，它会创建一个可由 <code>docker</code> 组成员访问的 Unix 套接字。</p><ol><li>创建 <code>docker</code> 组</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure><p>​2. 将您的用户添加到 <code>docker</code> 组中</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><ol start="3"><li>注销并重新登录，以便重新评估您的组成员身份。</li></ol><p>如果在虚拟机上进行测试，可能需要重新启动虚拟机以使更改生效。</p><p>在桌面 Linux 环境（例如 X Windows）上，完全注销会话，然后重新登录。</p><p>在 Linux 上，您还可以运行以下命令来激活对组的更改：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">newgrp docker </span><br></pre></td></tr></table></figure><ol start="4"><li>验证您可以在<code>docker</code>没有<code>sudo</code>.</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>此命令下载测试映像并在容器中运行它。当容器运行时，它会打印一条消息并退出。</p><p>如果您 <code>sudo</code> 在将用户添加到 <code>docker</code> 组之前最初使用 Docker CLI 命令运行，您可能会看到以下错误，这表明您的 <code>~/.docker/</code> 目录由于 <code>sudo</code> 命令而使用不正确的权限创建。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WARNING: Error loading config file: /home/user/.docker/config.json -</span><br><span class="line"><span class="built_in">stat</span> /home/user/.docker/config.json: permission denied</span><br></pre></td></tr></table></figure><p>要解决此问题，请删除 <code>~/.docker/</code> 目录（它会自动重新创建，但所有自定义设置都将丢失），或使用以下命令更改其所有权和权限：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> <span class="string">&quot;<span class="variable">$USER</span>&quot;</span>:<span class="string">&quot;<span class="variable">$USER</span>&quot;</span> /home/<span class="string">&quot;<span class="variable">$USER</span>&quot;</span>/.docker -R</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rwx <span class="string">&quot;<span class="variable">$HOME</span>/.docker&quot;</span> -R</span><br></pre></td></tr></table></figure><h5 id="配置Docker开机启动"><a href="#配置Docker开机启动" class="headerlink" title="配置Docker开机启动"></a>配置Docker开机启动</h5><p>多数当前的 Linux 发行版（RHEL、CentOS、Fedora、Debian、Ubuntu 16.04 及更高版本）用于 systemd 管理系统启动时启动的服务（就是 <code>systemctl</code> 命令）。在 Debian 和 Ubuntu 上，Docker 服务默认配置为在启动时启动。要在引导时为其他发行版自动启动 Docker 和 Containerd，请使用以下命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可省略 .service</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> containerd.servic</span><br></pre></td></tr></table></figure><p>要禁用此开机启动，请改用为 <code>disable</code>。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可省略 .service</span></span><br><span class="line">sudo systemctl <span class="built_in">disable</span> docker.service</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> containerd.service</span><br></pre></td></tr></table></figure><h3 id="4-3、启动Docker"><a href="#4-3、启动Docker" class="headerlink" title="4.3、启动Docker"></a>4.3、启动Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>测试是否启动成功</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行该命令</span></span><br><span class="line">sudo systemctl status docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行结果，出现 active (running) 代表启动成功</span></span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 五 2021-11-19 15:40:03 CST; 1s ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 29970 (dockerd)</span><br><span class="line">    Tasks: 11</span><br><span class="line">   Memory: 114.0M</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           └─29970 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>其他命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 docker 的状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启 docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 docker 服务开启自启动</span></span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p><strong>验证安装</strong></p><p>查看 Docker 版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p>查看 Docker 信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p><strong>测试运行</strong></p><p>通过运行 <code>hello-world</code> 映像验证 Docker Engine 是否已正确安装</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行该命令</span></span><br><span class="line">docker run hello-world</span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p>此命令下载测试映像并在容器中运行它。当容器运行时，它会打印一条消息并退出。</p><h3 id="4-4、其他安装方式"><a href="#4-4、其他安装方式" class="headerlink" title="4.4、其他安装方式"></a>4.4、其他安装方式</h3><h4 id="4-4-1、从包安装"><a href="#4-4-1、从包安装" class="headerlink" title="4.4.1、从包安装"></a>4.4.1、从包安装</h4><p>如果您无法使用 Docker 的存储库来安装 Docker，您可以下载该<code>.rpm</code>版本的 文件并手动安装。每次要升级 Docker Engine 时都需要下载一个新文件。</p><p>前往 <a href="https://download.docker.com/linux/centos/">https://download.docker.com/linux/centos/ (opens new window) (opens new window)</a>并选择您的 CentOS 版本。然后浏览 <code>x86_64/stable/Packages/</code> 并下载 <code>.rpm</code> 要安装的 Docker 版本的文件。</p><blockquote><p><strong>安装</strong></p></blockquote><p>安装 Docker Engine，将下面的路径更改为您下载 Docker 包的路径。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum install /path/to/package.rpm</span><br></pre></td></tr></table></figure><p>Docker 已安装但未启动。该 <code>docker</code> 组被创建，但没有用户添加到组。</p><blockquote><p><strong>启动 Docker</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>其他命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 docker 的状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="comment"># 重启 docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 设置 docker 服务开启自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><blockquote><p><strong>验证安装</strong></p></blockquote><p>查看 Docker 版本</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p>查看 Docker 信息</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><blockquote><p><strong>测试运行</strong></p></blockquote><p>通过运行 <code>hello-world</code> 映像验证 Docker Engine 是否已正确安装</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>此命令下载测试映像并在容器中运行它。当容器运行时，它会打印一条消息并退出。</p><h4 id="4-4-2、便利脚本安装"><a href="#4-4-2、便利脚本安装" class="headerlink" title="4.4.2、便利脚本安装"></a>4.4.2、便利脚本安装</h4><p>Docker 在 <a href="https://get.docker.com/">get.docker.com (opens new window) (opens new window)</a>上提供了一个方便的脚本，可以快速且非交互式地将 Docker 安装到开发环境中。不建议将便捷脚本用于生产环境，但可以用作示例来创建适合您需求的配置脚本。</p><p>在本地运行之前，请务必检查从 Internet 下载的脚本。在安装之前，让自己熟悉便利脚本的潜在风险和限制：</p><ul><li>脚本需要 <code>root</code> 或 <code>sudo</code> 特权才能运行。</li><li>该脚本会尝试检测您的 Linux 发行版和版本并为您配置包管理系统，并且不允许您自定义大多数安装参数。</li><li>该脚本无需确认即可安装依赖项和建议。这可能会安装大量软件包，具体取决于主机的当前配置。</li><li>默认情况下，该脚本会安装 Docker、containerd 和 runc 的最新稳定版本。使用此脚本配置机器时，可能会导致 Docker 的主要版本意外升级。在部署到生产系统之前，始终在测试环境中测试（主要）升级。</li><li>该脚本并非旨在升级现有的 Docker 安装。使用脚本更新现有安装时，依赖项可能不会更新到预期版本，从而导致使用过时的版本。</li></ul><blockquote><p><strong>安装</strong></p></blockquote><p>此示例从 <a href="https://get.docker.com/">get.docker.com (opens new window) (opens new window)</a>下载脚本并运行它以在 Linux 上安装 Docker 的最新稳定版本，另外可以通过 <code>--mirror</code> 选项使用国内下载源进行安装：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh --mirror</span><br></pre></td></tr></table></figure><blockquote><p><strong>启动 Docker</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>其他命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 docker 的状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="comment"># 重启 docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 设置 docker 服务开启自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><blockquote><p><strong>创建 docker 用户组</strong></p></blockquote><p>便利脚本安装不会自动创建 docker 用户组，请手动安装</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure><blockquote><p><strong>验证测试</strong></p></blockquote><p>查看 Docker 版本</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p>查看 Docker 信息</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><blockquote><p><strong>测试运行</strong></p></blockquote><p>通过运行 <code>hello-world</code> 映像验证 Docker Engine 是否已正确安装</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>此命令下载测试映像并在容器中运行它。当容器运行时，它会打印一条消息并退出。</p><h3 id="4-5、阿里云镜像加速器"><a href="#4-5、阿里云镜像加速器" class="headerlink" title="4.5、阿里云镜像加速器"></a>4.5、阿里云镜像加速器</h3><blockquote><p><strong>Docker 安装好以后，我们就要开始为拉取镜像准备了；国内从 DockerHub 拉取镜像有时会特别慢，此时可以配置镜像加速器。</strong></p></blockquote><p>Docker 官方和国内很多云服务商都提供了国内加速器服务，比如：</p><ul><li>阿里云的加速器：<a href="https://help.aliyun.com/document_detail/60750.html">https://help.aliyun.com/document_detail/60750.html</a></li><li>网易加速器：<a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></li><li>Docker 官方中国加速器：<a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></li><li>ustc 的镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></li><li>daocloud：<a href="https://www.daocloud.io/mirror#accelerator-doc%EF%BC%88%E6%B3%A8%E5%86%8C%E5%90%8E%E4%BD%BF%E7%94%A8%EF%BC%89">https://www.daocloud.io/mirror#accelerator-doc（注册后使用）</a></li></ul><p>对于使用 systemd 的系统（CentOS 7.x 以上），请在 &#x2F;etc&#x2F;docker&#x2F;daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://registry.docker-cn.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方式</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="comment"># 下面是一个步骤，全部复制</span></span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://registry.docker-cn.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>之后重新启动服务</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h4 id="4-5-1、配置阿里云镜像加速器"><a href="#4-5-1、配置阿里云镜像加速器" class="headerlink" title="4.5.1、配置阿里云镜像加速器"></a>4.5.1、配置阿里云镜像加速器</h4><ul><li>访问阿里云登录自己的账号查看 docker 镜像加速服务：<a href="https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors">https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors(opens new window)</a></li></ul><p><img src="/2022/08/06/Docker/image.1zbgqzzakxeo.webp" alt="image"></p><p>操作步骤是统一的，不存在不同用户不同的操作步骤，我已经放到下面代码块：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">阿里云的镜像是从docker hub来的，我们配置了加速，默认是从阿里云（缓存）下载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以后docker下载直接从阿里云拉取相关镜像</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/etc/docker/daemon.json 是Docker的核心配置文件。</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://gib4mdsy.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>之后重新启动服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载配置文件</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启Docker</span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>验证 docker 的镜像加速器是否生效</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# docker info</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">结果</span></span><br><span class="line">Client:</span><br><span class="line"> Context:    default</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> ...</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line"> Labels:</span><br><span class="line"> Experimental: false</span><br><span class="line"> Insecure Registries:</span><br><span class="line">  127.0.0.0/8</span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https://gib4mdsy.mirror.aliyuncs.com/</span><br><span class="line"> Live Restore Enabled: false</span><br></pre></td></tr></table></figure><h4 id="4-5-2、镜像查看和拉取"><a href="#4-5-2、镜像查看和拉取" class="headerlink" title="4.5.2、镜像查看和拉取"></a>4.5.2、镜像查看和拉取</h4><blockquote><p><strong>拉一个 docker 镜像试试吧？</strong></p></blockquote><p>拉取 hello world</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行改命令</span></span><br><span class="line">[root@master ~]<span class="comment"># docker pull hello-world:latest</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">Digest: sha256:2498fce14358aa50ead0cc6c19990fc6ff866ce72aeb5546e1d59caac3d0d60f</span><br><span class="line">Status: Image is up to <span class="built_in">date</span> <span class="keyword">for</span> hello-world:latest</span><br><span class="line">docker.io/library/hello-world:latest</span><br></pre></td></tr></table></figure><p>看本地仓库是否有这个库</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行改命令</span></span><br><span class="line">[root@master ~]<span class="comment"># docker images</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   11 months ago   13.3kB</span><br></pre></td></tr></table></figure><p>运行这个镜像的实例，即容器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># docker run hello-world</span></span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">....</span><br></pre></td></tr></table></figure><blockquote><p>注意, 如果你在没有镜像的时候，直接 <code>docker run hello-world</code> 也是可以的；它会先检查本地是否有这个镜像，没有的话会先从指定仓库中拉取。</p></blockquote><ul><li>run干了什么？</li></ul><p><img src="/2022/08/06/Docker/image.4fq3ksgij3g.webp" alt="image"></p><h3 id="4-6、为什么Docker会比VM虚拟机快"><a href="#4-6、为什么Docker会比VM虚拟机快" class="headerlink" title="4.6、为什么Docker会比VM虚拟机快"></a>4.6、为什么Docker会比VM虚拟机快</h3><ol><li><strong>docker有着比虚拟机更少的抽象层</strong></li></ol><p>由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p><ol><li><strong>docker利用的是宿主机的内核,而不需要加载操作系统OS内核</strong></li></ol><p>当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。</p><p><img src="/2022/08/06/Docker/image.4xh8wae98fk0.webp" alt="image"></p><table><thead><tr><th></th><th>Docker容器</th><th>虚拟机(VM)</th></tr></thead><tbody><tr><td>操作系统</td><td>与宿主机共享OS</td><td>宿主机OS上运行虚拟机OS</td></tr><tr><td>存储大小</td><td>镜像小，便于存储与运输</td><td>镜像庞大(vmdk、vdi等)</td></tr><tr><td>运行性能</td><td>几乎无额外性能损失</td><td>操作系统额外的CPU、内存消耗</td></tr><tr><td>移植性</td><td>轻便、灵活、适应于Linux</td><td>笨重，与虚拟机技术耦合度高</td></tr><tr><td>硬件亲和性</td><td>面向软件开发者</td><td>面向硬件运维者</td></tr><tr><td>部署速度</td><td>快速，秒级</td><td>较慢。10s以上</td></tr></tbody></table><h3 id="4-7、卸载Docker引擎"><a href="#4-7、卸载Docker引擎" class="headerlink" title="4.7、卸载Docker引擎"></a>4.7、卸载Docker引擎</h3><blockquote><p><strong>卸载 Docker Engine、CLI 和 Containerd 包</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><blockquote><p><strong>主机上的映像、容器、卷或自定义配置文件不会自动删除。删除所有镜像、容器和卷</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line">sudo <span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure><p>您必须手动删除任何已编辑的配置文件</p><h2 id="5、Docker常用命令"><a href="#5、Docker常用命令" class="headerlink" title="5、Docker常用命令"></a>5、Docker常用命令</h2><p>所有Docker命令手册:<a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a></p><h3 id="5-1、帮助启动类命令"><a href="#5-1、帮助启动类命令" class="headerlink" title="5.1、帮助启动类命令"></a>5.1、帮助启动类命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动docker：</span> </span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止docker：</span> </span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker：</span> </span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker状态：</span> </span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机启动：</span> </span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker概要信息：</span> </span><br><span class="line">docker info</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker总体帮助文档：</span> </span><br><span class="line">docker --help</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker命令帮助文档：</span> </span><br><span class="line">docker 具体命令 --help</span><br></pre></td></tr></table></figure><h3 id="5-2、镜像命令"><a href="#5-2、镜像命令" class="headerlink" title="5.2、镜像命令"></a>5.2、镜像命令</h3><p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</p><blockquote><p>注意</p><p>镜像的唯一标识是 id 和 tag（版本）。（大部分情况下）能以 id 操作镜像，则也能以 tag 操作镜像，反之亦然。</p><p>下面的例子可能只写一个标识如 id，忽略另一个，但请记住，两者使用任意一个标识都可以。</p></blockquote><p>指令语法标签介绍：</p><ul><li>[xxx]：xxx 是可选的</li><li><xxx>：xxx 是必选的</xxx></li><li>|：或者</li><li>&amp;：和</li></ul><h4 id="5-2-1、镜像本机"><a href="#5-2-1、镜像本机" class="headerlink" title="5.2.1、镜像本机"></a>5.2.1、镜像本机</h4><p>查看本机中所有镜像命令格式：<code>docker images [options] [镜像名]</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地镜像格式</span></span><br><span class="line">docker images [options] [镜像名]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有镜像（包含中间映像层）</span></span><br><span class="line">docker iamges -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示出镜像 id</span></span><br><span class="line">docker iamges -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 专门查询某个镜像</span></span><br><span class="line">docker images &lt;镜像名&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 1：查询全部镜像</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">[root@master ~]<span class="comment"># docker images</span></span><br><span class="line"></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   11 months ago   13.3kB</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 2：查询 hello-world 镜像</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># docker images hello-world</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   11 months ago   13.3kB</span><br></pre></td></tr></table></figure><p>各个选项说明:</p><ul><li>REPOSITORY：镜像的仓库源</li><li>TAG：镜像的标签，同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本。<strong>唯一</strong></li><li>IMAGE ID：镜像 ID。<strong>唯一</strong></li><li>CREATED：镜像的创建时间</li><li>SIZE：镜像的大小</li></ul><h4 id="5-2-2、镜像搜索"><a href="#5-2-2、镜像搜索" class="headerlink" title="5.2.2、镜像搜索"></a>5.2.2、镜像搜索</h4><blockquote><p><strong>Docker Hub 网页搜索镜像</strong></p></blockquote><p><img src="/2022/08/06/Docker/image.2pl4371jjmc0.webp" alt="image"></p><p><img src="/2022/08/06/Docker/image.6yr72dghxoc0.webp" alt="image"></p><p><img src="/2022/08/06/Docker/image.5fb8d91n1o40.webp" alt="image"></p><blockquote><p><strong>命令搜索镜像</strong></p></blockquote><p>去 Docker Hub 上查询镜像命令格式：<code>docker search [options] &lt;镜像名&gt;[:TAG]</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询指定的镜像格式</span></span><br><span class="line">docker search [options] &lt;镜像名&gt;[:TAG]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出收藏数不少于指定值的镜像</span></span><br><span class="line">docker search -s &lt;收藏数/指定值&gt; &lt;镜像名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示完整的镜像信息</span></span><br><span class="line">docker search --no-trunc &lt;镜像名&gt;</span><br></pre></td></tr></table></figure><p>通过命令无法列出版本，只能指定查询某个版本是否存在，所以建议还是去 Docker Hub 查看版本号</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker search &lt;镜像名:版本号&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 1：查询 MySQL</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># docker search mysql</span></span><br><span class="line">NAME                            DESCRIPTION                                     STARS                                                                                                 OFFICIAL   AUTOMATED</span><br><span class="line">mysql                           MySQL is a widely used, open-source relation…   13234                                                                                                 [OK]</span><br><span class="line">mariadb                         MariaDB Server is a high performing open sou…   5062                                                                                                  [OK]</span><br><span class="line">phpmyadmin                      phpMyAdmin - A web interface <span class="keyword">for</span> MySQL and M…   640                                                                                                   [OK]</span><br><span class="line">percona                         Percona Server is a fork of the MySQL relati…   588                                                                                                   [OK]</span><br><span class="line">bitnami/mysql                   Bitnami MySQL Docker Image                      77  </span><br></pre></td></tr></table></figure><ul><li>NAME: 镜像仓库源的名称</li><li>DESCRIPTION: 镜像的描述</li><li>OFFICIAL: 是否为官方发布，OK 代表是官方发布，空白代表是个人发布</li><li>STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思</li><li>AUTOMATED: 是否自动构建</li></ul><h4 id="4-5-3、镜像下载"><a href="#4-5-3、镜像下载" class="headerlink" title="4.5.3、镜像下载"></a>4.5.3、镜像下载</h4><p>从远程仓库下载镜像命令格式：<code>docker pull &lt;镜像名&gt;[:TAG | @DIGEST]</code></p><ul><li>TAG：版本号、标签</li><li>DIGEST：摘要</li></ul><p>推荐通过「版本号」下载镜像，如果不指定版本，默认最新版 <code>latest</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载镜像格式</span></span><br><span class="line">docker pull &lt;镜像名&gt;[:TAG | @DIGEST]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过「版本号」下载镜像</span></span><br><span class="line">docker pull &lt;镜像名:TAG&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过「摘要」下载镜像</span></span><br><span class="line">docker pull &lt;镜像名:@DIGEST&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>查看摘要</strong></p></blockquote><p><img src="/2022/08/06/Docker/image.6r4ofi9v9r80.webp" alt="image"></p><p><img src="/2022/08/06/Docker/image.mo6n44962u8.webp" alt="image"></p><blockquote><p><strong>例子 1：通过「版本」下载 MySQL 的 latest 版本</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker pull mysql:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不指定版本号，默认下载 latest 版本</span></span><br><span class="line">docker pull mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">a10c77af2613: Pull complete </span><br><span class="line">b76a7eb51ffd: Pull complete </span><br><span class="line">258223f927e4: Pull complete </span><br><span class="line">2d2c75386df9: Pull complete </span><br><span class="line">63e92e4046c9: Pull complete </span><br><span class="line">f5845c731544: Pull complete </span><br><span class="line">bd0401123a9b: Pull complete </span><br><span class="line">3ef07ec35f1a: Pull complete </span><br><span class="line">c93a31315089: Pull complete </span><br><span class="line">3349ed800d44: Pull complete </span><br><span class="line">6d01857ca4c1: Pull complete </span><br><span class="line">4cc13890eda8: Pull complete </span><br><span class="line">Digest: sha256:aeecae58035f3868bf4f00e5fc623630d8b438db9d05f4d8c6538deb14d4c31b</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:latest</span><br><span class="line">docker.io/library/mysql:latest</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 2：通过「摘要」下载 MySQL 的 latest 版本</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker pull mysql:sha256:1ea233722275afb6bf54bdb53bcb162bdb9f3ceed69c64836250f72bc641f63a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">a10c77af2613: Pull complete </span><br><span class="line">b76a7eb51ffd: Pull complete </span><br><span class="line">258223f927e4: Pull complete </span><br><span class="line">2d2c75386df9: Pull complete </span><br><span class="line">63e92e4046c9: Pull complete </span><br><span class="line">f5845c731544: Pull complete </span><br><span class="line">bd0401123a9b: Pull complete </span><br><span class="line">3ef07ec35f1a: Pull complete </span><br><span class="line">c93a31315089: Pull complete </span><br><span class="line">3349ed800d44: Pull complete </span><br><span class="line">6d01857ca4c1: Pull complete </span><br><span class="line">4cc13890eda8: Pull complete </span><br><span class="line">Digest: sha256:aeecae58035f3868bf4f00e5fc623630d8b438db9d05f4d8c6538deb14d4c31b</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:latest</span><br><span class="line">docker.io/library/mysql:latest</span><br></pre></td></tr></table></figure><h4 id="5-2-4、查看镜像-x2F-容器-x2F-数据卷所占的空间"><a href="#5-2-4、查看镜像-x2F-容器-x2F-数据卷所占的空间" class="headerlink" title="5.2.4、查看镜像&#x2F;容器&#x2F;数据卷所占的空间"></a>5.2.4、查看镜像&#x2F;容器&#x2F;数据卷所占的空间</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># docker system df</span></span><br><span class="line">TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE</span><br><span class="line">Images          3         1         177MB     177MB (99%)</span><br><span class="line">Containers      2         0         0B        0B</span><br><span class="line">Local Volumes   0         0         0B        0B</span><br><span class="line">Build Cache     0         0         0B        0B</span><br></pre></td></tr></table></figure><ul><li>镜像，容器，本地卷，构建的缓存</li></ul><h4 id="5-2-5、镜像删除"><a href="#5-2-5、镜像删除" class="headerlink" title="5.2.5、镜像删除"></a>5.2.5、镜像删除</h4><p>在本地仓库删除镜像命令格式：</p><ul><li>完整：<code>docker image rm [options] &lt;镜像名&gt;[:TAG | IMAGE ID]</code></li><li>简写： <code>docker rmi [options] &lt;镜像名&gt;[:TAG | IMAGE ID]</code></li></ul><p><code>i</code> 指的是 image</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除镜像 完整格式</span></span><br><span class="line">docker image <span class="built_in">rm</span> [options] &lt;镜像名&gt;[:TAG | IMAGE ID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像 简写格式</span></span><br><span class="line">docker rmi [options] &lt;镜像名&gt;[:TAG | IMAGE ID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除镜像</span></span><br><span class="line">docker image <span class="built_in">rm</span> -f &lt;镜像名&gt;</span><br><span class="line">docker rmi -f &lt;镜像名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过「版本号」删除镜像</span></span><br><span class="line">docker rmi &lt;镜像名&gt;:TAG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过「镜像 id」删除镜像</span></span><br><span class="line">docker rmi &lt;镜像名&gt;:IMAGE ID</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 1：直接删除 hello-world 镜像</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 完整格式</span></span><br><span class="line">docker image <span class="built_in">rm</span> hello-world</span><br><span class="line"><span class="comment"># 简写格式</span></span><br><span class="line">docker rmi hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">Error response from daemon: conflict: unable to remove repository reference <span class="string">&quot;hello-world&quot;</span> (must force) - container 2be48e124757 is using its referenced image feb5d9fea6a5</span><br></pre></td></tr></table></figure><p>返回结果报错了，原因有两点，要么是容器（container）曾经运行过（类似于 Windows 里运行的软件无法删除），要么存在镜像依赖。</p><p>两种解决方案：</p><ul><li>使用强制删除镜像命令</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi -f hello-world</span><br></pre></td></tr></table></figure><p>这将会让它产生的历史容器也被删除。</p><blockquote><p>注意</p><p>正在运行容器的镜像无法删除，先停止运行的容器才可以强制删除对应镜像。</p></blockquote><ul><li>报错的结果已经给了容器的 id，先删除容器 id，再重新删除 hello-world 镜像</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> feb5d9fea6a5</span><br><span class="line">docker rmi hello-world</span><br></pre></td></tr></table></figure><p>删除容器id不需要 <code>i</code></p><blockquote><p><strong>例子 2：通过 hello-world 镜像的唯一标识符(tag、id)进行删除</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># docker images hello-world</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   11 months ago   13.3kB</span><br></pre></td></tr></table></figure><p>删除 hello-world 镜像</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi hello-world:latest</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker rmi hello-world:feb5d9fea6a5</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 3：删除全部镜像</strong></p></blockquote><p>如果不强制删除，需要先删除容器id（如果容器存在）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi -f $(docker images -q)</span><br></pre></td></tr></table></figure><p><code>$()</code> 类似于 Linux 的管道符号 <code>|</code>，先执行括号里的命令，再执行外面的命令。</p><h4 id="5-2-6、docker虚悬镜像是什么？"><a href="#5-2-6、docker虚悬镜像是什么？" class="headerlink" title="5.2.6、docker虚悬镜像是什么？"></a>5.2.6、docker虚悬镜像是什么？</h4><p>仓库名、标签都是<code>&lt;none&gt;</code>的镜像，被称为虚悬镜像。</p><h4 id="5-2-7、镜像命名"><a href="#5-2-7、镜像命名" class="headerlink" title="5.2.7、镜像命名"></a>5.2.7、镜像命名</h4><p>如果你觉得下载的镜像名或者镜像 TAG 太长，可以进行重命名。</p><p>我们可以手动新增镜像的版本，也就是设置 TAG，并改名，格式为：<code>docker tag &lt;ID&gt; | &lt;镜像名:原来 TAG&gt; &lt;镜像名&gt;:&lt;新的 TAG&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手动新增镜像的 TAG</span></span><br><span class="line">docker tag &lt;ID&gt; | &lt;镜像名:原来 TAG&gt; &lt;镜像名&gt;:&lt;新的 TAG&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 1：新增 hello-world 的版本 TAG 为 1.0</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker tag feb5d9fea6a5 hello-world:v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   8 weeks ago   13.3kB</span><br><span class="line">hello-world   v1.0      feb5d9fea6a5   8 weeks ago   13.3kB</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 2：下载的镜像名和版本名太长，可以新增一个短的版本，并修改镜像名，再删除掉长的版本</strong></p></blockquote><p>我刚下载了 Tomcat 镜像，因为版本太长，可以先新增一个短的版本名，再删除掉长的版本名，将 <code>8.5.73-jre8-temurin-focal</code> 改为 <code>8.5.73</code>，顺便把 tomcat 改为 tom</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker images tomcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY    TAG                         IMAGE ID       CREATED        SIZE</span><br><span class="line">tomcat        8.5.73-jre8-temurin-focal   7ec084df520c   24 hours ago   249MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增短版本</span></span><br><span class="line">docker tag 7ec084df520c tom:8.5.73</span><br><span class="line"><span class="comment"># 删除长版本</span></span><br><span class="line">docker rmi tomcat:8.5.73-jre8-temurin-focal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询查看镜像</span></span><br><span class="line">docker images tom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY    TAG                         IMAGE ID       CREATED        SIZE</span><br><span class="line">tom          8.5.73                      7ec084df520c   24 hours ago   249MB</span><br></pre></td></tr></table></figure><h4 id="5-2-8、镜像打包"><a href="#5-2-8、镜像打包" class="headerlink" title="5.2.8、镜像打包"></a>5.2.8、镜像打包</h4><p>利用 <code>save</code> 可以打包镜像，格式有两个，分别为：</p><ul><li><code>docker save &gt; &lt;名称.tar&gt; &lt;镜像 ID&gt;</code></li><li><code>docker save &lt;镜像名&gt;[:TAG | ID] -o &lt;名称.tar&gt;</code></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save &gt; &lt;名称.tar&gt; &lt;镜像 ID&gt;</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker save &lt;镜像名&gt;[:TAG | ID] -o &lt;名称.tar&gt;</span><br></pre></td></tr></table></figure><p><strong>这里的镜像 ID 不能修改为镜像版本 TAG。</strong></p><blockquote><p><strong>例子 1：打包 hello-world 镜像为 myHelloWorld.tar</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">tomcat        8.5.73    7ec084df520c   24 hours ago   249MB</span><br><span class="line">mysql         latest    b05128b000dd   2 days ago     516MB</span><br><span class="line">hello-world   latest    feb5d9fea6a5   8 weeks ago    13.3kB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包命令</span></span><br><span class="line">docker save &gt; myHelloWorld.tar feb5d9fea6a5</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker save hello-world -o myHelloWorld.tar</span><br></pre></td></tr></table></figure><h4 id="5-2-9、镜像载入"><a href="#5-2-9、镜像载入" class="headerlink" title="5.2.9、镜像载入"></a>5.2.9、镜像载入</h4><p>利用 <code>load</code> 可以导入镜像，格式为：<code>docker load -i &lt;名称.tar&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker load -i &lt;名称.tar&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 1：解压 myHelloWorl.tar</strong></p></blockquote><p>进入镜像包目录下执行命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker load -i myHelloWorld.tar</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker load &lt; myHelloWorld.tar</span><br></pre></td></tr></table></figure><p><code>-i</code> 或者 <code>&lt;</code> 表示从文件输入。会成功导入镜像及相关元数据，包括 tag 信息</p><h4 id="5-2-10、镜像信息"><a href="#5-2-10、镜像信息" class="headerlink" title="5.2.10、镜像信息"></a>5.2.10、镜像信息</h4><p>镜像是由一层一层的文件系统组成，在下载镜像的时候就发现，下载了很多文件，那么如何查看这些文件信息呢？</p><p>在 Windows 系统，如果查看文件夹的信息，<strong>右键 -&gt; 属性</strong> 即可查看文件夹里的文件个数、创建时间等信息。镜像也可以查看自己的信息。</p><p>查看镜像信息的命令格式：<code>docker images inspect &lt;镜像名&gt;[:TAG | ID]</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker images inspect &lt;镜像名&gt;[:TAG | ID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以简写</span></span><br><span class="line">docker inspect &lt;镜像名&gt;[:TAG | ID]</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 1：查看 tomcat 的组成文件</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">tomcat        8.5.73    7ec084df520c   24 hours ago   249MB</span><br><span class="line">mysql         latest    b05128b000dd   2 days ago     516MB</span><br><span class="line">hello-world   latest    feb5d9fea6a5   8 weeks ago    13.3kB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 tomcat 的组成文件</span></span><br><span class="line">docker image inspect tomcat:8.5.73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果太长，自行实践</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="5-3、容器命令"><a href="#5-3、容器命令" class="headerlink" title="5.3、容器命令"></a>5.3、容器命令</h3><blockquote><p>切记</p><p>容器的唯一标识是 id 和 names（名字）。（大部分情况下）能以 id 操作容器，则也能以 name 操作容器，反之亦然。</p><p>内容例子可能只写一个标识如 id，忽略另一个，但请记住，两者使用任意一个标识都可以。</p></blockquote><h4 id="5-3-1、容器启动"><a href="#5-3-1、容器启动" class="headerlink" title="5.3.1、容器启动"></a>5.3.1、容器启动</h4><p>启动容器内容比较长，大纲如下：</p><ul><li>概念</li><li>简单启动，不涉及后台启动，端口映射。外界无法访问该容器</li><li>宿主机端口与容器端口映射</li><li>后台启动</li><li>指定名称启动</li></ul><blockquote><p><strong>概念</strong></p></blockquote><p><img src="/2022/08/06/Docker/image.4ecsbpz8cro0.webp" alt="image"></p><p>首先我们要知道，Docker 启动一个容器，这个容器与操作系统是隔离的，比如 Tomcat 容器的端口是 8080，操作系统的 IP 是 <code>http://192.168.199.27</code>，则访问 Tomcat 的界面 <code>http://192.168.199.27:8080</code> 是失败的，这就是容器的隔离效果。你访问的是操作系统的 8080 端口，不是容器的 8080 端口。所以 <strong>我们在启动容器时要将容器的端口和操作系统的端口进行绑定（映射）</strong>，这样，外界访问操作系统的端口，就会转发给容器的端口。</p><p>通过镜像启动一个容器，格式为：<code>docker run [options] &lt;镜像名[:tag | 镜像 id]&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run [options] &lt;镜像名[:tag | 镜像 <span class="built_in">id</span>]&gt;</span><br><span class="line">-p       <span class="comment"># 指定端口号，将容器的端口和操作系统端口进行绑定</span></span><br><span class="line">-d       <span class="comment"># 启动守护式容器，在后台启动容器</span></span><br><span class="line">--name   <span class="comment"># 为容器起一个别名</span></span><br><span class="line">-it      <span class="comment"># 打开窗口以交互模式启动容器，进入容器进程内容会有讲解</span></span><br><span class="line">--restart=always     <span class="comment"># 固定格式，容器一旦关闭就会自启动，一般用于经常发生意外而宕机的容器</span></span><br><span class="line">--<span class="built_in">rm</span>     <span class="comment"># 容器启动成功并进入容器，再退出来后，容器自动停止并删除，一般在测试情况下使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整格式</span></span><br><span class="line">docker run -p 系统端口:容器端口 -p 系统端口:容器端口 ... -d --name 容器别名 镜像名:tag | 镜像 <span class="built_in">id</span></span><br></pre></td></tr></table></figure><p>其中 tag（TAG） 或者容器 id（IMAGE ID）选一个即可。</p><p><strong>options 常用参数说明：</strong></p><table><thead><tr><th align="left">参数</th><th>说明</th></tr></thead><tbody><tr><td align="left">-d</td><td>启动守护式容器，在后台启动容器，并返回容器的id！</td></tr><tr><td align="left">-i</td><td>以交互(interactive)模式运行容器，通过和 -t 一起使用</td></tr><tr><td align="left">-t</td><td>给容器重新分配一个终端(tty)，通常和 -i 一起使用</td></tr><tr><td align="left">-P</td><td>随机端口映射（大写）</td></tr><tr><td align="left">-p</td><td>指定端口映射（小写），将容器的端口和操作系统端口进行绑定（映射），多个 <code>-p</code> 可以指定多个端口号</td></tr><tr><td align="left">–name&#x3D;”x”</td><td>给容器指定一个名字，如果不设置别名，启动容器会自动给该容器取一个名字</td></tr></tbody></table><h5 id="简单启动"><a href="#简单启动" class="headerlink" title="简单启动"></a><strong>简单启动</strong></h5><p>简单启动一个容器，不涉及后台启动，端口映射，外界无法访问该容器。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker images tomcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">tomcat       8.5.73    7ec084df520c   24 hours ago   249MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动命令 1，默认启动 latest 版本</span></span><br><span class="line">docker run tomcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动命令 2，启动 8.5.73 版本</span></span><br><span class="line">docker run hello-world:8.5.73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动命令 3，启动 id 为 7ec084df520c 的镜像</span></span><br><span class="line">docker run hello-world:7ec084df520c</span><br></pre></td></tr></table></figure><h5 id="宿主机端口与容器端口映射"><a href="#宿主机端口与容器端口映射" class="headerlink" title="宿主机端口与容器端口映射"></a><strong>宿主机端口与容器端口映射</strong></h5><p>如果想外界访问容器，比如容器启动了 Tomcat，外界想访问 Tomcat，则需要将 Tomcat 容器和操作系统端口进行绑定（映射），这样，访问操作系统端口就会转发到容器端口。</p><p>用 <code>-p</code> 进行映射。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -p 8080:8080 tomcat:8.5.73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想多个映射</span></span><br><span class="line">docker run -p 8080:8080 -p 8081:8080 tomcat:8.5.73</span><br></pre></td></tr></table></figure><p>8080&#x2F;8080 中前面的 8080 是操作系统的端口，后面的 8080 端口是容器的端口，操作系统的端口只要不占用，随便写，但是容器的端口是固定的。</p><p>此时启动还是前台启动。</p><h5 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a><strong>后台启动</strong></h5><p>前台启动导致无法操作界面，只能看控制台输出发呆，所以需要后台启动</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -p 8080:8080 -d tomcat:8.5.73</span><br></pre></td></tr></table></figure><blockquote><p><strong>指定名称启动</strong></p></blockquote><p><strong>如何精确找到并操作某一个 Docker 容器？</strong></p><ul><li>容器 id</li><li>容器名称</li></ul><p>可以通过 id 操作容器，但是启动容器时会自动生成随机的 id，很难记住，不可能每次想操作容器都要查看一下容器的 id，所以容器的名称非常重要，默认启动容器会自动生成随机的名称，我们也可以指定名称，通过 <code>--name</code> 选项</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动 tomcat</span></span><br><span class="line">docker run -d --name tomcat01 tomcat:8.5.73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器运行状态，后面有讲解</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回容器运行状态</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                                       NAMES</span><br><span class="line">e323fce921be   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   5 seconds ago    Up 4 seconds    8080/tcp                                    tomcat01</span><br></pre></td></tr></table></figure><h5 id="交互模式启动容器"><a href="#交互模式启动容器" class="headerlink" title="交互模式启动容器"></a><strong>交互模式启动容器</strong></h5><p>在启动容器的时候，我们可以启动完成后 <strong>直接进入容器内部</strong>。使用 <code>-it</code> 即可实现，需要指定的容器内部使用窗口如 shell 窗口、bash 窗口。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">[root@master ~]<span class="comment"># docker run -it tomcat:8.5.73 bash</span></span><br><span class="line"><span class="comment"># 此时已经进入了 Tomcat 容器内部，长什么样子呢？和 Windows 下的根目录类似</span></span><br><span class="line">root@8d9ffc09a8e8:/usr/local/tomcat<span class="comment"># ls</span></span><br><span class="line">BUILDING.txt     LICENSE  README.md      RUNNING.txt  conf  logs            temp     webapps.dist</span><br><span class="line">CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin          lib   native-jni-lib  webapps  work</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>交互模式启动容器，不能加入 <code>-d</code>，否则启动后无法进入容器。</p></blockquote><p>上面的例子都是单独针对某个选项而言，实际使用，我们需要将它们组合在一起，如：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d  --name tomcat01 -p 8080:8080 tomcat:8.5.73</span><br></pre></td></tr></table></figure><h4 id="5-3-2、容器查看"><a href="#5-3-2、容器查看" class="headerlink" title="5.3.2、容器查看"></a>5.3.2、容器查看</h4><p>容器查看的格式：<code>docker ps [options]</code></p><p><strong>options 常用参数说明：</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>表示 all，所有的，列出当前所有正在运行的容器 + 历史运行过的容器</td></tr><tr><td>-l</td><td>显示最近创建的容器</td></tr><tr><td>-n&#x3D;?</td><td>显示最近n个创建的容器</td></tr><tr><td>-q</td><td>静默模式，返回正在运行的容器 id。</td></tr></tbody></table><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看正在运行的容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS      NAMES</span><br><span class="line">e323fce921be   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   12 minutes ago   Up 12 minutes   8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有容器，包括历史运行的容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS                        PORTS      NAMES</span><br><span class="line">8d9ffc09a8e8   tomcat:8.5.73   <span class="string">&quot;bash&quot;</span>              10 minutes ago   Exited (0) 9 minutes ago                 nifty_goldstine</span><br><span class="line">e323fce921be   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   12 minutes ago   Up 12 minutes                 8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有容器的 ID，包括历史运行的容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps -aq</span></span><br><span class="line">8d9ffc09a8e8</span><br><span class="line">e323fce921be</span><br></pre></td></tr></table></figure><p>返回结果参数名：</p><ul><li>CONTAINER ID：容器 id（唯一）</li><li>IMAGE：生成容器的镜像名</li><li>COMMAND：容器启动后，内部执行的命令</li><li>CREATED：创建时间</li><li>STATUS：当前状态</li><li>PORTS：容器监听的端口</li><li>NAMES：容器的别名</li></ul><h4 id="5-3-3、容器退出"><a href="#5-3-3、容器退出" class="headerlink" title="5.3.3、容器退出"></a>5.3.3、容器退出</h4><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>exit</td><td>容器停止退出</td></tr><tr><td>ctrl+P+Q</td><td>容器不停止退出</td></tr></tbody></table><h4 id="5-3-4、容器再启动"><a href="#5-3-4、容器再启动" class="headerlink" title="5.3.4、容器再启动"></a>5.3.4、容器再启动</h4><p>容器再启动命令格式：<code>docker start &lt;容器 id | 容器名&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker start &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br></pre></td></tr></table></figure><p>首先查看历史运行的容器 id 或者名称，再启动历史运行的容器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有容器，包括曾经运行的容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED              STATUS                        PORTS      NAMES</span><br><span class="line">5d3f5ce66c6f   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>         About a minute ago   Up About a minute                        nifty_brown</span><br><span class="line">e86b30e440cb   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>         11 minutes ago       Exited (130) 8 minutes ago               hungry_poincare</span><br><span class="line">8d9ffc09a8e8   tomcat:8.5.73   <span class="string">&quot;bash&quot;</span>              50 minutes ago       Exited (0) 48 minutes ago                nifty_goldstine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再启动容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker start 8d9ffc09a8e8</span></span><br></pre></td></tr></table></figure><h4 id="4-3-5、容器停止和重启"><a href="#4-3-5、容器停止和重启" class="headerlink" title="4.3.5、容器停止和重启"></a>4.3.5、容器停止和重启</h4><p>容器正常停止命令格式：<code>docker stop &lt;容器 id | 容器名&gt;</code></p><p>容器立即停止命令格式：<code>docker kill &lt;容器 id | 容器名&gt;</code></p><p>容器重启命令格式：<code>docker restart &lt;容器 id | 容器名&gt;</code></p><p>先正常停止 Tomcat 容器，再启动 Tomcat 容器，然后重启 Tomcat 容器，最后立即停止 Tomcat 容器。（这里演示 id，其实 name 也可以）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看历史运行的容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS                        PORTS      NAMES</span><br><span class="line">5d3f5ce66c6f   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>         6 minutes ago    Up 6 minutes                             nifty_brown</span><br><span class="line">e86b30e440cb   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>         16 minutes ago   Exited (130) 13 minutes ago              hungry_poincare</span><br><span class="line">8d9ffc09a8e8   tomcat:8.5.73   <span class="string">&quot;bash&quot;</span>              55 minutes ago   Up 3 minutes                  8080/tcp   nifty_goldstine</span><br><span class="line">e323fce921be   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   56 minutes ago   Up 7 seconds                  8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常停止容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker stop tomcat01</span></span><br><span class="line">tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Tomcat 容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker start tomcat01</span></span><br><span class="line">tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker restart tomcat01</span></span><br><span class="line">tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立即停止容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker kill tomcat01</span></span><br><span class="line">tomcat01</span><br></pre></td></tr></table></figure><p>如果容器处于特殊状态，立即停止 <code>kill</code> 命令可能造成严重后果。</p><h4 id="5-3-6、容器删除和清除"><a href="#5-3-6、容器删除和清除" class="headerlink" title="5.3.6、容器删除和清除"></a>5.3.6、容器删除和清除</h4><p>容器删除命令格式：<code>docker rm [options] &lt;容器 id | 容器名&gt;</code></p><p>容器清除命令格式：<code>docker container prune</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除命令格式</span></span><br><span class="line">docker <span class="built_in">rm</span> [options] &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除</span></span><br><span class="line">docker <span class="built_in">rm</span> -f &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br></pre></td></tr></table></figure><p>例子：删除Tomcat的历史容器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看历史运行容器</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED             STATUS                           PORTS      NAMES</span><br><span class="line">5d3f5ce66c6f   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>         11 minutes ago      Up 11 minutes                               nifty_brown</span><br><span class="line">e86b30e440cb   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>         21 minutes ago      Exited (130) 18 minutes ago                 hungry_poincare</span><br><span class="line">8d9ffc09a8e8   tomcat:8.5.73   <span class="string">&quot;bash&quot;</span>              About an hour ago   Up 9 minutes                     8080/tcp   nifty_goldstine</span><br><span class="line">42e9b9dfa967   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   About an hour ago   Exited (143) 56 minutes ago                 elegant_hawking</span><br><span class="line">9c5812be9efd   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   About an hour ago   Exited (130) About an hour ago              dazzling_herschel</span><br><span class="line">fb74a2687495   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   About an hour ago   Exited (130) About an hour ago              reverent_curran</span><br><span class="line">f27f7f59368f   feb5d9fea6a5    <span class="string">&quot;/hello&quot;</span>            3 days ago          Exited (0) 3 days ago                       happy_mayer</span><br><span class="line">c7b6f05514ea   feb5d9fea6a5    <span class="string">&quot;/hello&quot;</span>            3 days ago          Exited (0) 3 days ago                       hopeful_lalande</span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">[root@master ~]<span class="comment"># docker rm 42e9b9dfa967 9c5812be9efd fb74a2687495 f27f7f59368f c7b6f05514ea</span></span><br></pre></td></tr></table></figure><blockquote><p>只是演示</p></blockquote><p>有时候删除会报错，原因在于它处于运行状态，Windows 里正在运行的进程也不能删除。</p><p><strong>那么如何删除一个正在运行的容器呢？</strong></p><p>我们可以使用强制删除命令 <code>-f</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND       CREATED             STATUS                        PORTS      NAMES</span><br><span class="line">5d3f5ce66c6f   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>   13 minutes ago      Up 13 minutes                            nifty_brown</span><br><span class="line">e86b30e440cb   ubuntu          <span class="string">&quot;/bin/bash&quot;</span>   23 minutes ago      Exited (130) 20 minutes ago              hungry_poincare</span><br><span class="line">8d9ffc09a8e8   tomcat:8.5.73   <span class="string">&quot;bash&quot;</span>        About an hour ago   Up 11 minutes                 8080/tcp   nifty_goldstine</span><br><span class="line">[root@master ~]<span class="comment"># docker rm -f 8d9ffc09a8e8</span></span><br></pre></td></tr></table></figure><p><strong>如何删除所有的历史容器呢？</strong></p><p>别忘了，之前提到过的 <code>$()</code>，按照数学运算符号优先级来说，括号的执行优先级很高。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -a -q)</span><br></pre></td></tr></table></figure><p>也有专门的清除历史容器命令：<code>docker container prune</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker container prune</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">WARNING! This will remove all stopped containers.</span><br><span class="line"><span class="comment"># 输入 y 确定清除</span></span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N] y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询查看历史容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><p>删除容器并不会删除它的镜像，此时可以理解镜像是安装包，容器是安装后的软件，只要保存好镜像（安装包），容器（软件）删除了可以再通过镜像（安装包） <code>run</code> 出来。</p><h4 id="5-3-7、查看容器进程"><a href="#5-3-7、查看容器进程" class="headerlink" title="5.3.7、查看容器进程"></a>5.3.7、查看容器进程</h4><p>查看容器进程命令格式：<code>docker top &lt;容器 id | 容器名&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker top &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>查看 Tomcat 容器的进程</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">[root@master ~]<span class="comment"># docker ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND             CREATED          STATUS          PORTS      NAMES</span><br><span class="line">0c6e3fc4a28d   tomcat    <span class="string">&quot;catalina.sh run&quot;</span>   11 seconds ago   Up 10 seconds   8080/tcp   tomcat01</span><br><span class="line">5d3f5ce66c6f   ubuntu    <span class="string">&quot;/bin/bash&quot;</span>         46 minutes ago   Up 46 minutes              nifty_brown</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">[root@master ~]<span class="comment"># docker top 0c6e3fc4a28d</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                8573                8554                7                   23:20               ?                   00:00:02            /usr/local/openjdk-11/bin/java -Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=0027 -Dignore.endorsed.dirs= -classpath /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar -Dcatalina.base=/usr/local/tomcat -Dcatalina.home=/usr/local/tomcat -Djava.io.tmpdir=/usr/local/tomcat/temp org.apache.catalina.startup.Bootstrap start</span><br></pre></td></tr></table></figure><p>可以查看容器的一些进程信息，如 UID，已经运行时间等。</p><h4 id="5-3-8、查看容器细节"><a href="#5-3-8、查看容器细节" class="headerlink" title="5.3.8、查看容器细节"></a>5.3.8、查看容器细节</h4><p>这个命令还是很常用的，要求容器必须运行起来。</p><p>查看容器内部细节命令格式：<code>docker inspect &lt;容器 id | 容器名&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker inspect &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>查看 Tomcat 容器的内部细节</strong></p></blockquote><p>首先查看 Tomcat 容器的 id 或者 names（名字）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED             STATUS          PORTS                                       NAMES</span><br><span class="line">1365f332be6b   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   About an hour ago   Up 12 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01</span><br></pre></td></tr></table></figure><p>接着查看 Tomcat 容器的内部细节</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker inspect 1365f332be6b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果（部分内容）</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;70983c5ab3c77ce3bbc8c341e3debc866e5c797bdf6d18cbfb89fa0def4e79cb&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2022-09-08T15:26:42.214308916Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Path&quot;</span>: <span class="string">&quot;catalina.sh&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;run&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;State&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Status&quot;</span>: <span class="string">&quot;running&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Running&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;Paused&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Restarting&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;OOMKilled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Dead&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Pid&quot;</span>: 8842,</span><br><span class="line">            <span class="string">&quot;ExitCode&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;Error&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;StartedAt&quot;</span>: <span class="string">&quot;2022-09-08T15:26:42.504365515Z&quot;</span>,</span><br><span class="line">            <span class="string">&quot;FinishedAt&quot;</span>: <span class="string">&quot;0001-01-01T00:00:00Z&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="string">&quot;Networks&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;bridge&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;IPAMConfig&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;Links&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;Aliases&quot;</span>: null,</span><br><span class="line">                    <span class="string">&quot;NetworkID&quot;</span>: <span class="string">&quot;88ffcfc688e0d2e932751871441b70c7cc7ebf3b44aa4d087879328e97a7587f&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;a18572b17e13c83d569c771694b26c4c0240a4963b9631c381ae26e019a190c5&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.17.0.1&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.17.0.3&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;IPPrefixLen&quot;</span>: 16,</span><br><span class="line">                    <span class="string">&quot;IPv6Gateway&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;GlobalIPv6Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;GlobalIPv6PrefixLen&quot;</span>: 0,</span><br><span class="line">                    <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:11:00:03&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;DriverOpts&quot;</span>: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>只截取一部分内容，可以看出有容器的状态，和操作系统绑定的端口等等信息。</p><h4 id="5-3-9、查询运行日志"><a href="#5-3-9、查询运行日志" class="headerlink" title="5.3.9、查询运行日志"></a>5.3.9、查询运行日志</h4><p>查询容器的 <strong>运行</strong> 日志命令格式：<code>docker logs [options] &lt;容器 id | 容器名&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询容器的运行日志命令格式</span></span><br><span class="line">docker logs [options] &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入时间戳</span></span><br><span class="line">docker logs -t &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听日志的输出，一旦日志更新，显示在控制台上</span></span><br><span class="line">docker logs -f &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示日志的最后多少条数据，取决于数字</span></span><br><span class="line">docker logs --<span class="built_in">tail</span> 数字 &lt;容器 <span class="built_in">id</span> | 容器名&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-t</td><td>显示时间戳</td></tr><tr><td>-f</td><td>监听日志，一旦更新，立即打印在控制台</td></tr><tr><td>–tail N</td><td>显示日志的最后 N 条数据</td></tr></tbody></table><blockquote><p><strong>例子 1：查看容器的日志(显示时间戳)</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED        STATUS         PORTS                                       NAMES</span><br><span class="line">1365f332be6b   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   13 hours ago   Up 5 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器日志(显示时间戳)</span></span><br><span class="line">docker logs -t 1365f332be6b</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 2：实时监听容器的日志</strong></p></blockquote><p>要求：先运行容器才能实时监听容器的日志</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED        STATUS         PORTS                                       NAMES</span><br><span class="line">1365f332be6b   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   13 hours ago   Up 5 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器日志(显示时间戳)</span></span><br><span class="line">docker logs -tf 1365f332be6b</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 3：查看日志的最后 5 行记录</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED        STATUS         PORTS                                       NAMES</span><br><span class="line">1365f332be6b   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   13 hours ago   Up 5 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器日志(显示时间戳)</span></span><br><span class="line">docker logs -t --<span class="built_in">tail</span> 5 1365f332be6b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">2021-11-20T04:11:38.947501511Z 20-Nov-2021 04:11:38.947 INFO [main] org.apache.catalina.startup.Catalina.load Initialization processed <span class="keyword">in</span> 2190 ms</span><br><span class="line">2021-11-20T04:11:39.030048052Z 20-Nov-2021 04:11:39.029 INFO [main] org.apache.catalina.core.StandardService.startInternal Starting service [Catalina]</span><br><span class="line">2021-11-20T04:11:39.030143031Z 20-Nov-2021 04:11:39.029 INFO [main] org.apache.catalina.core.StandardEngine.startInternal Starting Servlet engine: [Apache Tomcat/8.5.73]</span><br><span class="line">2021-11-20T04:11:39.069039566Z 20-Nov-2021 04:11:39.068 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [<span class="string">&quot;http-nio-8080&quot;</span>]</span><br><span class="line">2021-11-20T04:11:39.080909086Z 20-Nov-2021 04:11:39.080 INFO [main] org.apache.catalina.startup.Catalina.start Server startup <span class="keyword">in</span> 133 ms</span><br></pre></td></tr></table></figure><h4 id="5-3-10、进入容器进程"><a href="#5-3-10、进入容器进程" class="headerlink" title="5.3.10、进入容器进程"></a>5.3.10、进入容器进程</h4><p>先启动 Tomcat</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS                        PORTS     NAMES</span><br><span class="line">1365f332be6b   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   39 minutes ago   Exited (143) 34 minutes ago             tomcat01</span><br><span class="line">156e574bee6a   hello-world     <span class="string">&quot;/hello&quot;</span>            3 hours ago      Exited (0) 2 hours ago                  sweet_kare</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Tomcat</span></span><br><span class="line">docker start 1365f332be6b</span><br></pre></td></tr></table></figure><ul><li>第一种命令：<code>docker attach</code></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                                       NAMES</span><br><span class="line">1365f332be6b   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   42 minutes ago   Up 20 seconds   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器内</span></span><br><span class="line">docker attach 1365f332be6b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>可以看出，该命令进入容器后，如果退出容器，容器自动结束运行。</p><ul><li>第二种命令：<code>docker exec</code>，格式为：<code>docker exec [options] &lt;容器 id&gt; &lt;容器使用的终端窗口&gt;</code></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> [options] &lt;容器 <span class="built_in">id</span>&gt; &lt;容器使用的终端窗口&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以交互模式运行容器，通常与 -t 一起使用</span></span><br><span class="line">docker <span class="built_in">exec</span> -i &lt;容器 <span class="built_in">id</span>&gt; &lt;容器使用的终端窗口&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#分配一个伪终端，如 shell窗口、base 窗口</span></span><br><span class="line">docker <span class="built_in">exec</span> -t &lt;容器 <span class="built_in">id</span>&gt; &lt;容器使用的终端窗口&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#建议一起使用</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;容器 <span class="built_in">id</span>&gt; &lt;容器使用的终端窗口&gt;</span><br></pre></td></tr></table></figure><p><code>-i</code>：以交互模式运行容器，通常与 -t 一起使用</p><p><code>-t</code>：分配一个伪终端，如 shell窗口、base 窗口</p><blockquote><p><strong>进入 Tomcat 容器内部</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 1365f332be6b bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器内部，查看容器内部</span></span><br><span class="line">root@1365f332be6b:/usr/local/tomcat<span class="comment"># ls</span></span><br><span class="line">bin  BUILDING.txt  conf  CONTRIBUTING.md  lib  LICENSE  logs  native-jni-lib  NOTICE  README.md  RELEASE-NOTES  RUNNING.txt  temp  webapps  webapps.dist  work</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从容器内部退出</span></span><br><span class="line">root@1365f332be6b:/usr/local/tomcat<span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器是否停止运行</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                                       NAMES</span><br><span class="line">1365f332be6b   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   51 minutes ago   Up 26 seconds   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01</span><br></pre></td></tr></table></figure><ul><li><p>第 6 行是不是很熟悉，就是 Tomcat 的根目录，这就是 Tomcat 容器的根目录。</p><p><code>exit</code> 退出容器后，Docker 不会停止运行容器</p></li></ul><p><strong>区别：</strong></p><p>使用 <code>docker attach</code> 进入容器后，exit 退出来便容器也停止运行了。而 <code>docker exec</code> 则不会这样操作导致停止运行容器。</p><p>推荐使用 <code>docker exec</code> 命令，因为该命令退出容器终端，不会导致容器的停止。</p><h4 id="5-3-11、宿主机文件-gt-容器"><a href="#5-3-11、宿主机文件-gt-容器" class="headerlink" title="5.3.11、宿主机文件 &gt; 容器"></a>5.3.11、宿主机文件 &gt; 容器</h4><p>将宿主机的文件拷贝到容器里命令格式：<code>docker cp &lt;宿主机文件 | 目录&gt; &lt;容器 id:容器路径&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> &lt;宿主机文件 | 目录&gt; &lt;容器 <span class="built_in">id</span>:容器路径&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>将宿主机的 杂文.txt 文件拷贝到 Tomcat 容器里</strong></p></blockquote><p>杂文.txt 文件在 &#x2F;opt 目录下</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">activemq  containerd  dump.rdb  jdk  mysql  README.md  redis  rh  tomcat 杂文.txt</span><br></pre></td></tr></table></figure><p>Tomcat 容器的 id是 1365f332be6b，拷贝到的路径是 &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 杂文.txt 1365f332be6b:/usr/local/tomcat/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 1365f332be6b bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前路径内容</span></span><br><span class="line">oot@1365f332be6b:/usr/local/tomcat<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">bin           conf             lib      logs            NOTICE     RELEASE-NOTES  temp     webapps.dist  杂文.txt</span><br><span class="line">BUILDING.txt  CONTRIBUTING.md  LICENSE  native-jni-lib  README.md  RUNNING.txt    webapps  work</span><br></pre></td></tr></table></figure><h4 id="5-3-12、容器导入-x2F-导出"><a href="#5-3-12、容器导入-x2F-导出" class="headerlink" title="5.3.12、容器导入&#x2F;导出"></a>5.3.12、容器导入&#x2F;导出</h4><ul><li>导入和导出容器</li><li>export 导出容器的内容留作为一个tar归档文件[对应import命令]</li><li>import 从tar包中的内容创建一个新的文件系统再导入为镜像[对应export]</li><li>命令</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">export</span> 容器ID &gt; 文件名.tar</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号</span><br></pre></td></tr></table></figure><ul><li>案例</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND             CREATED             STATUS             PORTS                                         NAMES</span><br><span class="line">70983c5ab3c7   tomcat    <span class="string">&quot;catalina.sh run&quot;</span>   35 minutes ago      Up 18 minutes      0.0.0.0:49154-&gt;8080/tcp, :::49154-&gt;8080/tcp   tomcat01</span><br><span class="line">5d3f5ce66c6f   ubuntu    <span class="string">&quot;/bin/bash&quot;</span>         About an hour ago   Up About an hour                                                 nifty_brown</span><br><span class="line">[root@master ~]<span class="comment"># docker export 70983c5ab3c7 &gt; ABCD.tar</span></span><br><span class="line">[root@master ~]<span class="comment"># ls</span></span><br><span class="line">          anaconda-ks.cfg  BUILDING.txt  initial-setup-ks.cfg  nodes-6379.conf  公共  视频  文档  音乐</span><br><span class="line">ABCD.tar  appendonly.aof   dump.rdb      lua_demo              postfile         模板  图片  下载  桌面</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">docker <span class="built_in">rm</span> -f tomcat01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从tar包中的内容创建一个新的文件系统再导入为镜像</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># cat ABCD.tar | docker import - frx01/tomcat02:8.5.27</span></span><br><span class="line">sha256:bc554c9488cc1b4ff0649eaeb9cd6fa0ffc763f4a48a6796499fc05cb37eaf6b</span><br></pre></td></tr></table></figure><h4 id="5-3-13、常用命令总结"><a href="#5-3-13、常用命令总结" class="headerlink" title="5.3.13、常用命令总结"></a>5.3.13、常用命令总结</h4><p><img src="/2022/08/06/Docker/image.33l1vukec220.webp" alt="image"></p><table><thead><tr><th>命令</th><th>官方说明</th><th>解释</th></tr></thead><tbody><tr><td>attach</td><td>Attach local standard input, output, and error streams to a running container</td><td>当前 shell 下 attach 连接指定运行镜像</td></tr><tr><td>build</td><td>Build an image from a Dockerfile</td><td>通过 Dockerfile 定制镜像</td></tr><tr><td>commit</td><td>Create a new image from a container’s changes</td><td>提交当前容器为新的镜像</td></tr><tr><td>cp</td><td>Copy files&#x2F;folders between a container and the local filesystem</td><td>从容器中拷贝指定文件或者目录到宿主机中</td></tr><tr><td>create</td><td>Create a new container</td><td>创建一个新的容器，同 run，但不启动容器</td></tr><tr><td>diff</td><td>Inspect changes to files or directories on a container’s filesystem</td><td>查看 docker 容器变化</td></tr><tr><td>events</td><td>Get real time events from the server</td><td>从 docker 服务获取容 器实时事件</td></tr><tr><td>exec</td><td>Run a command in a running container</td><td>在已存在的容器上运行命令</td></tr><tr><td>export</td><td>Export a container’s filesystem as a tar archive</td><td>导出容器的内 容流作为一个 tar 归档文件[对应 import ]</td></tr><tr><td>history</td><td>Show the history of an image</td><td>展示一个镜像形成历史</td></tr><tr><td>images</td><td>List images</td><td>列出系统当前镜像</td></tr><tr><td>import</td><td>Import the contents from a tarball to create a filesystem image</td><td>从 tar包中的内容创建一个新的文件系统映像[对应export]</td></tr><tr><td>info</td><td>Display system-wide information</td><td>显示系统相关信息</td></tr><tr><td>inspect</td><td>Return low-level information on Docker objects</td><td>查看容器详细信息</td></tr><tr><td>kill</td><td>Kill one or more running containers</td><td>杀掉 指定 docker 容器</td></tr><tr><td>load</td><td>Load an image from a tar archive or STDIN</td><td>从一个 tar 包中加载一 个镜像[对应 save]</td></tr><tr><td>login</td><td>Log in to a Docker registry</td><td>登陆一个 docker 源服务器</td></tr><tr><td>logout</td><td>Log out from a Docker registry</td><td>从当前 Docker registry 退出</td></tr><tr><td>logs</td><td>Fetch the logs of a container</td><td>输出当前容器日志信息</td></tr><tr><td>pause</td><td>Pause all processes within one or more containers</td><td>暂停容器</td></tr><tr><td>port</td><td>List port mappings or a specific mapping for the container</td><td>查看映射端口对应的容器内部源端口</td></tr><tr><td>ps</td><td>List containers</td><td>列出容器列表</td></tr><tr><td>pull</td><td>Pull an image or a repository from a registry</td><td>从docker镜像源服务器拉取指定镜像或者库镜像</td></tr><tr><td>push</td><td>Push an image or a repository to a registry</td><td>推送指定镜像或者库镜像至docker源服务器</td></tr><tr><td>rename</td><td>Rename a container</td><td>给一个容器改名</td></tr><tr><td>restart</td><td>Restart one or more containers</td><td>重启运行的容器</td></tr><tr><td>rm</td><td>Remove one or more containers</td><td>移除一个或者多个容器</td></tr><tr><td>rmi</td><td>Remove one or more images</td><td>移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</td></tr><tr><td>run</td><td>Run a command in a new container</td><td>创建一个新的容器并运行 一个命令</td></tr><tr><td>save</td><td>Save one or more images to a tar archive (streamed to STDOUT by default)</td><td>保存一个镜像为一个 tar 包[对应 load]</td></tr><tr><td>search</td><td>Search the Docker Hub for images</td><td>在 docker hub 中搜 索镜像</td></tr><tr><td>start</td><td>Start one or more stopped containers</td><td>启动容器</td></tr><tr><td>stats</td><td>Display a live stream of container(s) resource usage statistics</td><td>显示容器资源使用统计信息的实时信息</td></tr><tr><td>stop</td><td>Stop one or more running containers</td><td>停止容器</td></tr><tr><td>tag</td><td>Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</td><td>给源中镜像打标签</td></tr><tr><td>top</td><td>Display the running processes of a container</td><td>查看容器中运行的进程信 息</td></tr><tr><td>unpause</td><td>Unpause all processes within one or more containers</td><td>取消暂停容器</td></tr><tr><td>update</td><td>Update configuration of one or more containers</td><td>更新容器配置</td></tr><tr><td>version</td><td>Show the Docker version information</td><td>查看 docker 版本号</td></tr><tr><td>wait</td><td>Block until one or more containers stop, then print their exit codes</td><td>截取容器停止时的退出状态值</td></tr></tbody></table><h4 id="5-3-14、总结图片"><a href="#5-3-14、总结图片" class="headerlink" title="5.3.14、总结图片"></a>5.3.14、总结图片</h4><h5 id="镜像命令图片"><a href="#镜像命令图片" class="headerlink" title="镜像命令图片"></a>镜像命令图片</h5><p><img src="/2022/08/06/Docker/20211120172455.png" alt="image-20211120172453603"></p><p><img src="/2022/08/06/Docker/20211120172720.png" alt="image-20211120172716950"></p><h5 id="容器命令图片"><a href="#容器命令图片" class="headerlink" title="容器命令图片"></a>容器命令图片</h5><p><img src="/2022/08/06/Docker/20211120172307.png" alt="image-20211120172301522"></p><p><img src="/2022/08/06/Docker/20211120172327.png" alt="image-20211120172319882"></p><p><img src="/2022/08/06/Docker/20211120172738.png" alt="image-20211120172737409"></p><p><img src="/2022/08/06/Docker/20211120172745.png" alt="image-20211120172743635"></p><h2 id="6、Docker-镜像原理"><a href="#6、Docker-镜像原理" class="headerlink" title="6、Docker 镜像原理"></a>6、Docker 镜像原理</h2><h3 id="6-1、什么是镜像"><a href="#6-1、什么是镜像" class="headerlink" title="6.1、什么是镜像"></a>6.1、什么是镜像</h3><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><p><img src="/2022/08/06/Docker/image.2eyaa1qewe80.webp" alt="image"></p><p><strong>镜像就是花卷，多个镜像组成一个完整的镜像</strong></p><ul><li>UnionFS（联合文件系统）</li></ul><p>Union 文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文代系统下。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。Union 文件系统是 Docker 镜像的基础。</p><p>这种文件系统特性就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h3 id="6-2、Docker-镜像原理"><a href="#6-2、Docker-镜像原理" class="headerlink" title="6.2、Docker 镜像原理"></a>6.2、Docker 镜像原理</h3><p><img src="/2022/08/06/Docker/image.44m96fv6jxo0.webp" alt="image"></p><blockquote><p><strong>docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统 UnionFS。</strong></p></blockquote><ul><li>典型的 Linux 文件系统由 <strong>bootfs</strong> 和 <strong>rootfs</strong> 两部分组成</li><li><strong>bootfs（boot file system）</strong>主要包含 <strong>bootloader</strong> 和 <strong>kernel</strong>，<strong>bootloader</strong> 主要是引导加载 <strong>kernel</strong>，<strong>Linux</strong> 刚启动时会加载 <strong>bootfs</strong> 文件系统，<strong>在 Docker 镜像的最底层是 bootfs</strong>。这一层与我们典型的 Linux&#x2F;Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。</li><li><strong>rootfs (root file system)</strong> ，在 bootfs 之上。包含的就是典型 Linux 系统中的 &#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc 等标准目录和文件。rootfs 就是各种不同的操作系统发行版，比如 Ubuntu，Centos 等等</li><li>我们平时安装进虚拟机的 CentOS 都有 1 到几个 GB，为什么 Docker 这里才 200MB？对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用 Host 的 Kemal,自己只需要提供 rootfs 就行了。由此可见不同的 Linux 发行版，他们的 bootfs 是一致的，rootfs 会有差别。<strong>因此不同的发行版可以共用 bootfs</strong></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat              8.5.27              a92c139758db        4 years ago         558MB</span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/image.n12zxx92lls.webp" alt="image"></p><h3 id="6-3、为什么Docker镜像要采用这种分层结构呢"><a href="#6-3、为什么Docker镜像要采用这种分层结构呢" class="headerlink" title="6.3、为什么Docker镜像要采用这种分层结构呢"></a>6.3、为什么Docker镜像要采用这种分层结构呢</h3><p><strong>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</strong></p><p>比如：有多个镜像都是从相同的 base 镜像构建而来的，那么宿主机只需在磁盘中保存一份 base 镜像。同时内存中也只需要加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker 镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。</p><blockquote><p><strong>如何查看镜像分层？</strong></p></blockquote><p>使用 <code>docker inspect</code> 命令，查看容器细节</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos              latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat              8.5.27              a92c139758db        4 years ago         558MB</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker inspect tomcat:8.5.27</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/image.6rx8e7zvbnc0.webp" alt="image"></p><p>所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p><p>举一个简单的例子，假如基于 Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python 包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。</p><p>该镜像当前已经包含 3 个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。</p><p><img src="/2022/08/06/Docker/image.4xklf0i3iy80.webp" alt="image"></p><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含 3 个文件，而镜像包含了来自两个镜像层的 6 个文件。</p><p><img src="/2022/08/06/Docker/image.7hlezkqhyrs0.webp" alt="image"></p><p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。</p><p>Docker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p><p>Linux 上可用的存储引擎有 AUFS、Overlay2、Device Mapper、Btrfs 以及 ZFS。顾名思义，每种存储引擎都基于 Linux 中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p><p>Docker 在 Windows 上仅支持 windowsfilter 一种存储引擎，该引擎基于 NTFS 文件系统之上实现了分层和 COW。</p><p>下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。</p><p><img src="/2022/08/06/Docker/image.2rka9swxxwg.webp" alt="image"></p><h3 id="6-4、重点理解"><a href="#6-4、重点理解" class="headerlink" title="6.4、重点理解"></a>6.4、重点理解</h3><p><strong>Docker镜像层都是只读的，容器层是可写的</strong> 。当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p><p><img src="/2022/08/06/Docker/9db8d8ccaee984b715ac0c26bfa60cd5ac2a55b4.png" alt="img"></p><h3 id="6-5、核心架构图"><a href="#6-5、核心架构图" class="headerlink" title="6.5、核心架构图"></a>6.5、核心架构图</h3><p><img src="/2022/08/06/Docker/image.22vkerqfoi0w.webp" alt="image"></p><h3 id="6-6、Docker镜像commit操作案例"><a href="#6-6、Docker镜像commit操作案例" class="headerlink" title="6.6、Docker镜像commit操作案例"></a>6.6、Docker镜像commit操作案例</h3><ul><li>docker commit提交容器副本使之成为一个新的镜像</li><li>docker commit -m&#x3D;”提交的描述信息” -a&#x3D;”作者” 容器ID 要创建的目标镜像名:[标签名]</li><li>案例演示ubuntu安装vim<ul><li>从Hub上下载ubuntu镜像到本地并成功运行</li><li>原始的默认Ubuntu镜像是不带着vim命令的</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker run -it ubuntu /bin/bash</span></span><br><span class="line">root@e4a6abf80ca5:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@e4a6abf80ca5:/<span class="comment"># vim a.txt</span></span><br><span class="line">bash: vim: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><ul><li>外网连通的情况下，安装vim，docker容器内执行以下两条命令：</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先更新我们的包管理工具</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="comment">#然后安装我们需要的vim</span></span><br><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure><ul><li>安装完成后，commit我们自己的新镜像</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">e4a6abf80ca5        ubuntu              <span class="string">&quot;/bin/bash&quot;</span>         21 minutes ago      Up 21 minutes                           nostalgic_mclaren</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker commit -m=&quot;add vim cmd&quot; -a=&quot;frx&quot; e4a6abf80ca5 frx01/myubuntu:1.3</span></span><br><span class="line">sha256:64df8ffb7faf445aa2c8e0e69e67819c4abe549dae7f6ddea943b1a62588b190</span><br></pre></td></tr></table></figure><ul><li>启动我们的新镜像并和原来的对比</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">frx01/myubuntu      1.3                 64df8ffb7faf        40 seconds ago      179MB</span><br><span class="line">ubuntu              latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos              latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat              8.5.27              a92c139758db        4 years ago         558MB</span><br></pre></td></tr></table></figure><ol><li>官网是默认下载的Ubuntu没有vim命令</li><li>我们自己commit构建的镜像，新增加了vim功能，可以成功使用。</li></ol><h3 id="6-7、小总结"><a href="#6-7、小总结" class="headerlink" title="6.7、小总结"></a>6.7、小总结</h3><p>Docker中的镜像分层，<strong>支持通过扩展现有镜像，创建新的镜像</strong>。类似Java继承于一个Base基础类，自己再按需扩展。</p><p>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p><p><img src="/2022/08/06/Docker/image.55hqvoufnsw0.webp" alt="image"></p><h2 id="7、本地镜像发布到阿里云"><a href="#7、本地镜像发布到阿里云" class="headerlink" title="7、本地镜像发布到阿里云"></a>7、本地镜像发布到阿里云</h2><h3 id="7-1、流程"><a href="#7-1、流程" class="headerlink" title="7.1、流程"></a>7.1、流程</h3><p><img src="/2022/08/06/Docker/image.nzg3lx1r7y8.webp" alt="image"></p><h3 id="7-2、镜像的生成方法"><a href="#7-2、镜像的生成方法" class="headerlink" title="7.2、镜像的生成方法"></a>7.2、镜像的生成方法</h3><ul><li>第一种：基于当前容器创建一个新的镜像，新功能增强<ul><li><a href="https://frxcat.fun/project-management/Docker/Docker_images_principle/#docker%E9%95%9C%E5%83%8Fcommit%E6%93%8D%E4%BD%9C%E6%A1%88%E4%BE%8B">具体步骤</a></li></ul></li><li>第二种：DockerFile章节</li></ul><h3 id="7-3、将本地镜像推送到阿里云"><a href="#7-3、将本地镜像推送到阿里云" class="headerlink" title="7.3、将本地镜像推送到阿里云"></a>7.3、将本地镜像推送到阿里云</h3><h4 id="本地镜像原型"><a href="#本地镜像原型" class="headerlink" title="本地镜像原型"></a>本地镜像原型</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">frx01/myubuntu      1.3                 64df8ffb7faf        3 days ago          179MB</span><br><span class="line">ubuntu              latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos              latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat              8.5.27              a92c139758db        4 years ago         558MB</span><br></pre></td></tr></table></figure><ul><li>阿里云开发者平台:<a href="https://promotion.aliyun.com/ntms/act/kubernetes.html">https://promotion.aliyun.com/ntms/act/kubernetes.html(opens new window)</a></li></ul><p><img src="/2022/08/06/Docker/image.26vtegy9iack.webp" alt="image"></p><ul><li>选择控制台，进入容器镜像服务</li></ul><p><img src="/2022/08/06/Docker/image.3ggtfvzruxk0.webp" alt="image"></p><ul><li>进入个人实例</li></ul><p><img src="/2022/08/06/Docker/image.6x8g7kynigk0.webp" alt="image"></p><ul><li>创建命名空间</li></ul><p><img src="/2022/08/06/Docker/image.x9xgkhb2rgw.webp" alt="image"></p><ul><li>创建镜像仓库</li></ul><p><img src="/2022/08/06/Docker/image.2qchilnl2di0.webp" alt="image"></p><p><img src="/2022/08/06/Docker/image.104ml4c0mzn4.webp" alt="image"></p><ul><li>进入管理页面获得脚本</li></ul><p><img src="/2022/08/06/Docker/image.5a1l9nfogv00.webp" alt="image"></p><h3 id="7-4、将镜像推送到阿里云"><a href="#7-4、将镜像推送到阿里云" class="headerlink" title="7.4、将镜像推送到阿里云"></a>7.4、将镜像推送到阿里云</h3><ul><li>将镜像推送到阿里云registy</li><li>管理页面脚本</li></ul><p><img src="/2022/08/06/Docker/image-20221011222329891.png" alt="image-20221011222329891"></p><ul><li>执行3的命令</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker login --username=shyflying registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">$ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/hylflying/dockertest:[镜像版本号]</span><br><span class="line">$ docker push registry.cn-hangzhou.aliyuncs.com/hylflying/dockertest:[镜像版本号]</span><br></pre></td></tr></table></figure><blockquote><p>密码是自己容器镜像下面的访问凭证设置的密码</p></blockquote><p><img src="/2022/08/06/Docker/image.x8qx98px48w.webp" alt="image"></p><blockquote><p>设置image id和版本号</p></blockquote><ul><li>在阿里云上面查看结果</li></ul><p><img src="/2022/08/06/Docker/image.ogz22mouas0.webp" alt="image"></p><h3 id="7-5、将阿里云的镜像下载到本地"><a href="#7-5、将阿里云的镜像下载到本地" class="headerlink" title="7.5、将阿里云的镜像下载到本地"></a>7.5、将阿里云的镜像下载到本地</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos              latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat              8.5.27              a92c139758db        4 years ago         558MB</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker pull registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3:1.3</span></span><br><span class="line">1.3: Pulling from frx01/myubuntu1.3</span><br><span class="line">7b1a6ab2e44d: Already exists</span><br><span class="line">bc4c9551ae8d: Pull complete</span><br><span class="line">Digest: sha256:76bc84ede8beac0565b660ce31f588d6d2a1bcbc02f34b6c5b0563023f9b537e</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3:1.3</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3   1.3                 64df8ffb7faf        3 days ago          179MB</span><br><span class="line">ubuntu                                                latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos                                                latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat                                                8.5.27              a92c139758db        4 years ago         558MB</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker run -it 64df8ffb7faf /bin/bash</span></span><br><span class="line">root@a7795849ec26:/<span class="comment"># vim a.text</span></span><br></pre></td></tr></table></figure><h2 id="8、将本地镜像推送到私有库"><a href="#8、将本地镜像推送到私有库" class="headerlink" title="8、将本地镜像推送到私有库"></a>8、将本地镜像推送到私有库</h2><h3 id="8-1、本地镜像发布到私有库流程"><a href="#8-1、本地镜像发布到私有库流程" class="headerlink" title="8.1、本地镜像发布到私有库流程"></a>8.1、本地镜像发布到私有库流程</h3><p><img src="/2022/08/06/Docker/640f0a286fccab23687fb43a37a44fc637259dc7-16655749507574.png" alt="img"></p><h3 id="8-2、什么是Docker-Registry"><a href="#8-2、什么是Docker-Registry" class="headerlink" title="8.2、什么是Docker Registry"></a>8.2、什么是Docker Registry</h3><ol><li>官方Docker Hub地址：<a href="https://hub.docker.com/">https://hub.docker.com/ (opens new window)</a>，中国大陆访问太慢了且准备被阿里云取代的趋势，不太主流。</li><li>Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。</li></ol><p> Docker Registry是官方提供的工具，可以用于构建私有镜像仓库。</p><h3 id="8-3、将本地镜像推送到私有库"><a href="#8-3、将本地镜像推送到私有库" class="headerlink" title="8.3、将本地镜像推送到私有库"></a>8.3、将本地镜像推送到私有库</h3><ol><li>下载镜像Docker Registry</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker pull registry</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/registry</span><br><span class="line">79e9f2f55bf5: Pull complete</span><br><span class="line">0d96da54f60b: Pull complete</span><br><span class="line">5b27040df4a2: Pull complete</span><br><span class="line">e2ead8259a04: Pull complete</span><br><span class="line">3790aef225b9: Pull complete</span><br><span class="line">Digest: sha256:169211e20e2f2d5d115674681eb79d21a217b296b43374b8e39f97fcf866b375</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> registry:latest</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3   1.3                 64df8ffb7faf        3 days ago          179MB</span><br><span class="line">registry                                              latest              b8604a3fe854        10 months ago       26.2MB</span><br><span class="line">ubuntu                                                latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos                                                latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat                                                8.5.27              a92c139758db        4 years ago         558MB</span><br></pre></td></tr></table></figure><p>​2. 运行私有库Registry，相当于本地有个私有库Docker Hub</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000  -v /zzyyuse/myregistry/:/tmp/registry --privileged=<span class="literal">true</span> registry</span><br></pre></td></tr></table></figure><p>默认情况，仓库被创建在容器的&#x2F;var&#x2F;lib&#x2F;registry目录下，建议自行用容器卷映射，方便于宿主机联调。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker run -d -p 5000:5000  -v /zzyyuse/myregistry/:/tmp/registry --privileged=true registry</span></span><br><span class="line">ac3ec6f2ef9bfc9e7293e9e962622d043a5696c49e2613d8b4dca7ef2ff75faf</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">ac3ec6f2ef9b        registry            <span class="string">&quot;/entrypoint.sh /etc…&quot;</span>   19 seconds ago      Up 18 seconds       0.0.0.0:5000-&gt;5000/tcp   elated_stallman</span><br></pre></td></tr></table></figure><p>​3. 案例演示创建一个新镜像，<code>ubuntu</code>安装<code>ifconfig</code>命令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker run -it ubuntu /bin/bash</span></span><br><span class="line">root@016aba0aa47c:/<span class="comment"># ifconfig</span></span><br><span class="line">bash: ifconfig: <span class="built_in">command</span> not found</span><br><span class="line">root@016aba0aa47c:/<span class="comment"># apt-get update</span></span><br><span class="line">Get:1 http://security.ubuntu.com/ubuntu focal-security InRelease [114 kB]</span><br><span class="line">Get:2 http://archive.ubuntu.com/ubuntu focal InRelease [265 kB]</span><br><span class="line">......</span><br><span class="line">root@016aba0aa47c:/<span class="comment"># apt-get install net-tools</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  net-tools</span><br><span class="line">0 upgraded, 1 newly installed, 0 to remove and 34 not upgraded.</span><br><span class="line">......</span><br><span class="line">root@016aba0aa47c:/<span class="comment"># ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 8467  bytes 24172245 (24.1 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 7644  bytes 417236 (417.2 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>​4. 安装完成后，commit我们自己的新镜像</p><p>公式：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker commit -m=<span class="string">&quot;提交的描述信息&quot;</span> -a=<span class="string">&quot;作者&quot;</span> 容器ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure><p>命令：在容器外执行，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker commit -m=<span class="string">&quot;ifconfig cmd add&quot;</span> -a=<span class="string">&quot;zzyy&quot;</span> a69d7c825c4f zzyyubuntu:1.2</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">016aba0aa47c        ubuntu              <span class="string">&quot;/bin/bash&quot;</span>              3 minutes ago       Up 3 minutes                                 relaxed_jackson</span><br><span class="line">ac3ec6f2ef9b        registry            <span class="string">&quot;/entrypoint.sh /etc…&quot;</span>   28 minutes ago      Up 28 minutes       0.0.0.0:5000-&gt;5000/tcp   elated_stallman</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker commit -m=&quot;ifconfig cmd add&quot; -a=&quot;zzyy&quot; 016aba0aa47c zzyyubuntu:1.2</span></span><br><span class="line">sha256:6581250435309a04a2ea6bf1f94f12bfeadee801e0a77e59b29cdf8d78b46194</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">zzyyubuntu                                            1.2                 658125043530        7 seconds ago       112MB</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3   1.3                 64df8ffb7faf        3 days ago          179MB</span><br><span class="line">registry                                              latest              b8604a3fe854        10 months ago       26.2MB</span><br><span class="line">ubuntu                                                latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos                                                latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat                                                8.5.27              a92c139758db        4 years ago         558MB</span><br></pre></td></tr></table></figure><p>​5. 启动我们的新镜像和原来的对比</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker run -it zzyyubuntu:1.2 /bin/bash</span></span><br><span class="line">root@3657253e6268:/<span class="comment"># ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.4  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:04  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 6  bytes 516 (516.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>​6. curl验证私服库上有什么镜像</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -XGET http://192.168.182.129:5000/v2/_catalog</span><br></pre></td></tr></table></figure><p>可以看到，目前私服库没有任何镜像上传过。。。。。。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># curl -XGET http://192.168.182.129:5000/v2/_catalog</span></span><br><span class="line">&#123;<span class="string">&quot;repositories&quot;</span>:[]&#125;</span><br></pre></td></tr></table></figure><p>​7. 将新镜像zzyyubuntu:1.2修改符合私服规范的Tag</p><p>按照公式： <code>docker tag 镜像:Tag Host:Port/Repository:Tag</code></p><p>自己host主机IP地址，填写你们自己的，不要粘贴错误，O(∩_∩)O</p><p>使用命令 docker tag 将zzyyubuntu:1.2 这个镜像修改为192.168.182.129:5000&#x2F;zzyyubuntu:1.2</p><p><code>docker tag zzyyubuntu:1.2 192.168.182.129:5000/zzyyubuntu:1.2</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker tag  zzyyubuntu:1.2  192.168.91.166:5000/zzyyubuntu:1.2</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.91.166:5000/zzyyubuntu                        1.2                 658125043530        7 minutes ago       112MB</span><br><span class="line">zzyyubuntu                                            1.2                 658125043530        7 minutes ago       112MB</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3   1.3                 64df8ffb7faf        3 days ago          179MB</span><br><span class="line">registry                                              latest              b8604a3fe854        10 months ago       26.2MB</span><br><span class="line">ubuntu                                                latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos                                                latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat                                                8.5.27              a92c139758db        4 years ago         558MB</span><br></pre></td></tr></table></figure><p>​8. vim命令新增如下红色内容：vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://aa25jngu.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;192.168.182.129:5000&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述理由：docker默认不允许http方式推送镜像，通过配置选项来取消这个限制。&#x3D;&#x3D;&#x3D;&#x3D;&gt; 修改完后如果不生效，建议重启docker</p><p>​9. 推送到私服库</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker push 192.168.182.129:5000/zzyyubuntu:1.2</span></span><br><span class="line">The push refers to repository [192.168.91.166:5000/zzyyubuntu]</span><br><span class="line">fa04f996f230: Pushed</span><br><span class="line">9f54eef41275: Pushed</span><br><span class="line">1.2: digest: sha256:fb2ac08ef38b9ff478d209ce1912294ee3471c9ecc572adeaa9dd6cec4d4529a size: 741</span><br></pre></td></tr></table></figure><p>​10. curl验证私服库上有什么镜像</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># curl -XGET http://192.168.91.166:5000/v2/_catalog</span></span><br><span class="line">&#123;<span class="string">&quot;repositories&quot;</span>:[<span class="string">&quot;zzyyubuntu&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><p>​11. pull到本地并运行</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.182.129:5000/zzyyubuntu                        1.2                 658125043530        19 minutes ago      112MB</span><br><span class="line">zzyyubuntu                                            1.2                 658125043530        19 minutes ago      112MB</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker rmi -f 192.168.182.129:5000/zzyyubuntu:1.2</span></span><br><span class="line">Untagged: 192.168.182.129:5000/zzyyubuntu:1.2</span><br><span class="line">Untagged: 192.168.91.166:5000/zzyyubuntu@sha256:fb2ac08ef38b9ff478d209ce1912294ee3471c9ecc572adeaa9dd6cec4d4529a</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker rmi -f zzyyubuntu:1.2</span></span><br><span class="line">Untagged: zzyyubuntu:1.2</span><br><span class="line">Deleted: sha256:6581250435309a04a2ea6bf1f94f12bfeadee801e0a77e59b29cdf8d78b46194</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3   1.3                 64df8ffb7faf        3 days ago          179MB</span><br><span class="line">registry                                              latest              b8604a3fe854        10 months ago       26.2MB</span><br><span class="line">ubuntu                                                latest              ba6acccedd29        11 months ago       72.8MB</span><br><span class="line">centos                                                latest              5d0da3dc9764        12 months ago       231MB</span><br><span class="line">tomcat                                                8.5.27              a92c139758db        4 years ago         558MB</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker pull 192.168.182.129:5000/zzyyubuntu:1.2</span></span><br><span class="line">1.2: Pulling from zzyyubuntu</span><br><span class="line">7b1a6ab2e44d: Already exists</span><br><span class="line">0c8559be87f8: Already exists</span><br><span class="line">Digest: sha256:fb2ac08ef38b9ff478d209ce1912294ee3471c9ecc572adeaa9dd6cec4d4529a</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> 192.168.91.166:5000/zzyyubuntu:1.2</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.182.129:5000/zzyyubuntu                        1.2                 658125043530        22 minutes ago      112MB</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3   1.3                 64df8ffb7faf        3 days ago          179MB</span><br><span class="line">[root@frx01 ~]<span class="comment"># docker run -it 192.168.182.129:5000/zzyyubuntu:1.2 /bin/bash</span></span><br><span class="line">root@749c02466301:/<span class="comment"># ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 6  bytes 516 (516.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><h2 id="9、Docker数据卷"><a href="#9、Docker数据卷" class="headerlink" title="9、Docker数据卷"></a>9、Docker数据卷</h2><blockquote><p>注</p><p> Docker挂载主机目录访问如果出现<strong>cannot open directory .: Permission</strong> denied解决办法：在挂载目录后多加一个**–privileged&#x3D;true**参数即可 </p><p>如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了，如果要开启，我们一般使用–privileged&#x3D;true命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p></blockquote><h3 id="9-1、什么是数据卷"><a href="#9-1、什么是数据卷" class="headerlink" title="9.1、什么是数据卷"></a>9.1、什么是数据卷</h3><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：卷的设计目的就是<strong>数据的持久化</strong>，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><p><strong>数据卷</strong> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性:</p><ul><li><strong>数据卷</strong> 可以在容器之间共享和享用</li><li>对 <strong>数据卷</strong> 的修改立马生效</li><li>对 <strong>数据卷</strong> 的更新，不会影响镜像</li><li><strong>数据卷</strong> 默认会一直存在，即时容器被删除</li></ul><p>注意</p><p><strong>数据卷</strong> 的使用，类似于 Linux 下对目录或者文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷（仅数据卷为空时复制）</p><h3 id="9-2、为什么使用数据卷"><a href="#9-2、为什么使用数据卷" class="headerlink" title="9.2、为什么使用数据卷"></a>9.2、为什么使用数据卷</h3><ul><li>当创建一个容器的时候，容器运行，数据能不能持久化</li><li>如果能够持久化，数据存储在哪？由于 docker 是隔离的，数据能不能存储在容器外</li><li>如果部署很多容器，每次都需要进入容器中进行配置嘛？能不能外部进行配置</li></ul><p>docker 数据卷呈现给 docker 容器的一个形式就是目录，该目录支持多个容器间共享，修改不会影响到镜像。使用 Docker 的数据卷，类似在系统中使用 mount 挂载一个文件系统。</p><h3 id="9-3、数据卷挂载操作"><a href="#9-3、数据卷挂载操作" class="headerlink" title="9.3、数据卷挂载操作"></a>9.3、数据卷挂载操作</h3><p>三种挂载数据卷格式</p><ul><li>具体目录挂载：<code>docker run [options] -v &lt;宿主机绝对路径:容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</code></li><li>默认目录挂载：<code>docker run [options] -v &lt;任意别名:容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</code></li><li>匿名目录挂载：<code>docker run [options] -v &lt;容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</code></li></ul><p>默认目录挂载和匿名目录挂载的目录默认在 <code>/var/lib/docker/volumes/</code> 目录下。</p><p>宿主机挂载目录里，都会生成 <code>_data</code> 目录，该目录存放容器挂载目录下的数据。</p><h4 id="9-3-1、具体目录挂载"><a href="#9-3-1、具体目录挂载" class="headerlink" title="9.3.1、具体目录挂载"></a>9.3.1、具体目录挂载</h4><p>自定义数据卷目录。</p><p>在用 docker run 命令的时候，使用 -v 标记来创建一个数据卷并挂载到容器里。</p><p>格式：<code>docker run [options] -v &lt;宿主机绝对路径 | 任意别名:容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run [options] -v &lt;宿主机绝对路径 | 任意别名:容器内的路径:[:ro | rw]&gt; &lt;镜像名&gt;</span><br></pre></td></tr></table></figure><p><strong>宿主机路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。</strong></p><p><code>ro</code>：代表 read-only，容器的路径只允许读，不允许写。不影响宿主机的路径可读可写</p><p><code>rw</code>：默认值，代表可读可写</p><blockquote><p><strong>例子 1：具名挂载</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8080 --name tomcat02 -v /opt/aa:/usr/local/tomcat/webapps tomcat:8.5.73</span><br></pre></td></tr></table></figure><p><strong>特点：宿主机的的挂载目录内容覆盖到容器的挂载目录内容</strong></p><p>因为 &#x2F;opt&#x2F;aa 目录为空，所以容器的 webapps 目录被 aa 目录覆盖，也为空。</p><p><strong>验证是否成功挂载</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE                                COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">3302e930a1a8        tomcat:8.5.27                        <span class="string">&quot;catalina.sh run&quot;</span>        42 seconds ago      Up 40 seconds       0.0.0.0:8081-&gt;8080/tcp   tomcat02</span><br><span class="line">749c02466301        192.168.91.166:5000/zzyyubuntu:1.2   <span class="string">&quot;/bin/bash&quot;</span>              3 days ago          Up 3 days                                    pedantic_gagarin</span><br><span class="line">ad5ee6156b1c        registry                             <span class="string">&quot;/entrypoint.sh /etc…&quot;</span>   3 days ago          Up 3 days           0.0.0.0:5000-&gt;5000/tcp   competent_meninsky</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看挂载信息</span></span><br><span class="line">docker inspect 3302e930a1a8</span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/image.4qmas1zt8z20.webp" alt="image"></p><blockquote><p><strong>例子 2：测试容器和宿主机之间数据共享</strong></p></blockquote><p>在 tomcat02 容器里创建 test.txt 文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 tomcat02 容器</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># docker exec -it tomcat02 bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器挂载目录</span></span><br><span class="line">root@3302e930a1a8:/usr/local/tomcat<span class="comment"># cd webapps/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 test.txt 文件</span></span><br><span class="line">root@3302e930a1a8:/usr/local/tomcat/webapps<span class="comment"># touch text.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否创建成功</span></span><br><span class="line">root@3302e930a1a8:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">text.txt</span><br></pre></td></tr></table></figure><p>在宿主机查看文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 宿主机挂载目录</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># cd /opt/aa</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 返回结果</span></span><br><span class="line">text.txt</span><br></pre></td></tr></table></figure><p>说明挂载成功，双方挂载的目录实现共享。</p><blockquote><p><strong>例子 3：容器停止运行，宿主机添加 test2.txt，再启动容器，文件是否同步到容器里？</strong></p></blockquote><p>宿主机添加 test2.txt</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 宿主机挂载目录</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># cd /opt/aa</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 test2.txt 文件 </span></span><br><span class="line">[root@frx01 aa]<span class="comment"># touch text2.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">text2.txt  text.txt</span><br></pre></td></tr></table></figure><p>启动 tomcat02 容器，查看挂载目录是否有 test2.txt</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动 tomcat02 容器</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># docker start tomcat02</span></span><br><span class="line">tomcat02</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 tomcat02 容器</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># docker exec -it tomcat02 bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器挂载目录</span></span><br><span class="line">root@3302e930a1a8:/usr/local/tomcat<span class="comment"># cd webapps/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件</span></span><br><span class="line">root@3302e930a1a8:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">text.txt  text2.txt</span><br></pre></td></tr></table></figure><p>说明数据依旧同步</p><blockquote><p><strong>例子 4：删除容器</strong></p></blockquote><p>我们删除容器，看主机上数据是否会被删除</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># docker ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID        IMAGE                                COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">3302e930a1a8        tomcat:8.5.27                        <span class="string">&quot;catalina.sh run&quot;</span>        16 minutes ago      Up 16 minutes       0.0.0.0:8081-&gt;8080/tcp   tomcat02</span><br><span class="line">749c02466301        192.168.91.166:5000/zzyyubuntu:1.2   <span class="string">&quot;/bin/bash&quot;</span>              3 days ago          Up 3 days                                    pedantic_gagarin</span><br><span class="line">ad5ee6156b1c        registry                             <span class="string">&quot;/entrypoint.sh /etc…&quot;</span>   3 days ago          Up 3 days           0.0.0.0:5000-&gt;5000/tcp   competent_meninsky</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># docker rm -f 3302e930a1a8</span></span><br><span class="line">3302e930a1a8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 aa 目录</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># cd /opt/aa &amp;&amp; ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">text2.txt  text.txt</span><br></pre></td></tr></table></figure><p>说明没有删除。</p><h4 id="9-3-2、默认目录挂载"><a href="#9-3-2、默认目录挂载" class="headerlink" title="9.3.2、默认目录挂载"></a>9.3.2、默认目录挂载</h4><p>数据卷目录路径是固定的。</p><p>格式：<code>docker run [options] -v &lt;任意别名:容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run [options] -v &lt;任意别名:容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</span><br></pre></td></tr></table></figure><p>任意别名是一个数据卷名字，名字可以随便写，Docker 会在 <code>/var/lib/docker/volumes</code> 目录下生成该数据卷，这是 docker 默认的数据卷目录。并且在数据卷里生成 <code>_data</code> 目录用于与容器目录同步数据。</p><p><code>ro</code>：代表 read-only，容器的路径只允许读，不允许写。不影响宿主机的路径可读可写</p><p><code>rw</code>：默认值，代表可读可写</p><blockquote><p><strong>例子 1：</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">[root@frx01 aa]<span class="comment"># docker run -d -p 8080:8081 --name tomcat -v aa:/usr/local/tomcat/webapps tomcat:8.5.27</span></span><br><span class="line"></span><br><span class="line">[root@frx01 aa]<span class="comment"># find / -name aa</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">/var/lib/docker/volumes/aa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入宿主机挂载</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/aa/_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">docs  examples  host-manager  manager  ROOT</span><br></pre></td></tr></table></figure><p>aa 代表一个数据卷名字，可以是任意，这相当于相对路径，它会在 <code>/var/lib/docker/volumes</code> 下创建 aa 目录作为数据卷。</p><p>特点：容器的挂载目录内容覆盖到宿主机的挂载目录内容</p><p>其他例子和 具体目录挂载一样。</p><h4 id="9-3-3、匿名目录挂载"><a href="#9-3-3、匿名目录挂载" class="headerlink" title="9.3.3、匿名目录挂载"></a>9.3.3、匿名目录挂载</h4><p>没指定名字的挂载都是匿名挂载，-v 只写了容器内路径，并没写宿主机路径。</p><p>匿名目录挂载的目录是：<code>/var/lib/docker/volumes/</code>，它会在这个目录生成匿名数据卷目录。</p><p>格式：<code>docker run [options] -v &lt;容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run [options] -v &lt;容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</span><br></pre></td></tr></table></figure><p><code>ro</code>：代表 read-only，容器的路径只允许读，不允许写。不影响宿主机的路径可读可写</p><p><code>rw</code>：默认值，代表可读可写</p><blockquote><p><strong>例子 1：匿名创建 tomcat3 容器，找到匿名的目录位置</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d -P 8080:8081 --name tomcat03 -v /usr/local/tomcat/webapps tomcat:8.5.27</span><br></pre></td></tr></table></figure><p>创建容器时，没有指定宿主机的目录，那么它在哪呢？</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 volumes]<span class="comment"># cd /var/lib/docker/volumes/</span></span><br><span class="line"></span><br><span class="line">[root@frx01 volumes]<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line">75b754f7602e8b946432ad871b0c4b43408dde92f06ce5574ff8352a85c39858</span><br></pre></td></tr></table></figure><p>我们可以得知：没有指定宿主机目录，docker 会自动在 <code>/var/lib/docker/volumes</code> 生成很长的字符串，这是什么呢？</p><p>这里透露 docker 数据卷操作命令：<code>docker volume ls</code>，查看数据卷</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     75b754f7602e8b946432ad871b0c4b43408dde92f06ce5574ff8352a85c39858</span><br></pre></td></tr></table></figure><p>可以看出匿名目录挂载生成的目录名就是 <strong>随机生成的数据卷名字</strong>。</p><h4 id="9-3-4、哪个挂载方法好？"><a href="#9-3-4、哪个挂载方法好？" class="headerlink" title="9.3.4、哪个挂载方法好？"></a>9.3.4、哪个挂载方法好？</h4><p>首先排除掉 <strong>匿名目录挂载</strong>，它的缺点是不好维护，数据卷名随机生成且太长，不清楚目录挂载的是哪个容器。</p><p><strong>默认目录挂载</strong> 指定了一个默认目录，无论挂载目录有多少，都集中在默认目录下管理。但是缺点是 <strong>不能指定文件挂载</strong>，只能指定目录进行挂载。它和具体目录挂载的另一个区别是：第一次启动容器挂载时，<strong>容器的挂载目录内容会覆盖宿主机的挂载目录内容</strong>。</p><p><strong>具体目录挂载</strong> 可以指定宿主机的任意位置，但是一旦挂载目录多了起来，可能目录过于分散导致无法集中管理，但是它更加灵活，而且 <strong>能指定文件挂载</strong>。值得注意的是：第一次启动容器挂载时，必须确保容器的挂载目录数据备份好，因为该挂载方式会将 <strong>宿主机的挂载目录内容覆盖掉容器的挂载目录内容</strong>。所以，有数据则备份，再挂载。</p><p>总之：<strong>匿名目录挂载</strong> 不推荐，根据需求选择 <strong>默认目录挂载</strong> 和 <strong>具体目录挂载</strong>，前者不能挂载文件，挂载在默认目录；后者能挂载文件，且挂载在宿主机任意位置，但是会覆盖容器的挂载目录。我喜欢 <strong>具体目录挂载</strong>。</p><h4 id="9-3-5、读写权限"><a href="#9-3-5、读写权限" class="headerlink" title="9.3.5、读写权限"></a>9.3.5、读写权限</h4><p>三个挂载方式我都提到了读写的权限，这个读写权限仅针对 <strong>容器的挂载目录</strong>，如果不指定权限，默认就是可读可写。</p><p><strong>什么时候用到呢？</strong> 当我们希望只操作宿主机的挂载目录，然后同步给容器的挂载目录，但是不希望容器的挂载目录也能操作，影响宿主机的挂载目录。</p><p>拿默认目录挂载的命令格式来说：<code>docker run [options] -v &lt;任意别名:容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run [options] -v &lt;任意别名:容器内的路径[:ro | rw]&gt; &lt;镜像名&gt;</span><br></pre></td></tr></table></figure><p><code>ro</code>：代表 read-only，容器的路径只允许读，不允许写。不影响宿主机的路径可读可写</p><p><code>rw</code>：默认值，代表可读可写</p><blockquote><p><strong>例子 1：启动 tomcat04 容器，挂载到 kele 数据卷里，并赋予只读权限</strong></p></blockquote><p>为了方便，不指定端口映射，<code>-P</code>（大写）直接让 Docker 随机生成端口映射</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d -P --name tomcat04 -v frx:/usr/local/tomcat/webapps:ro tomcat:8.5.27</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果</span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               75b754f7602e8b946432ad871b0c4b43408dde92f06ce5574ff8352a85c39858</span><br><span class="line"><span class="built_in">local</span>               frx</span><br></pre></td></tr></table></figure><p><strong>宿主机操作</strong>：找到 docker 的数据卷默认目录，进入 kele 目录下的 _data 目录，创建 test.txt 文件，测试读写权限</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 frx 目录下的 _data 目录</span></span><br><span class="line">[root@frx01 _data]<span class="comment"># cd /var/lib/docker/volumes/frx/_data/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 test.txt 文件，测试写权限</span></span><br><span class="line">[root@frx01 _data]<span class="comment"># touch text.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件，测试读权限</span></span><br><span class="line">[root@frx01 _data]<span class="comment"># ls </span></span><br><span class="line">docs  examples  host-manager  manager  ROOT  text.txt</span><br></pre></td></tr></table></figure><p>说明宿主机可读可写。如果不可写会报错。</p><p><strong>容器操作：</strong> 进入 tomcat04 容器的挂载目录，测试读写权限</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 tomcat04 容器</span></span><br><span class="line">[root@frx01 _data]<span class="comment"># docker exec -it tomcat04 bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入挂载目录</span></span><br><span class="line">root@83d20336795b:/usr/local/tomcat<span class="comment"># cd webapps/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件，测试读权限</span></span><br><span class="line">root@83d20336795b:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">ROOT  docs  examples  host-manager  manager  text.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试写权限</span></span><br><span class="line">root@83d20336795b:/usr/local/tomcat/webapps<span class="comment"># touch text2.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果，报错</span></span><br><span class="line"><span class="built_in">touch</span>: cannot <span class="built_in">touch</span> <span class="string">&#x27;text2.txt&#x27;</span>: Read-only file system</span><br></pre></td></tr></table></figure><p>结果告诉我们，无法执行写操作，只能执行读操作。</p><blockquote><p><strong>例子 2：</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 赋予读写权限</span></span><br><span class="line">docker run -d -P --name tomcat04 -v kele:/usr/local/tomcat/webapps:ro tomcat:8.5.27</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不写权限，默认赋予读写权限</span></span><br><span class="line">docker run -d -P --name tomcat04 -v kele:/usr/local/tomcat/webapps tomcat:8.5.27</span><br></pre></td></tr></table></figure><h3 id="9-4、数据卷操作命令"><a href="#9-4、数据卷操作命令" class="headerlink" title="9.4、数据卷操作命令"></a>9.4、数据卷操作命令</h3><p>数据卷在 Docker 称为 volume，所以相关命令都要有 volume。</p><h4 id="9-4-1、数据卷命令"><a href="#9-4-1、数据卷命令" class="headerlink" title="9.4.1、数据卷命令"></a>9.4.1、数据卷命令</h4><p>看注释：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker volume --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">Usage:  docker volume COMMAND</span><br><span class="line">Manage volumes</span><br><span class="line">Commands:</span><br><span class="line"></span><br><span class="line">  create      Create a volume  <span class="comment"># 创建一个数据卷</span></span><br><span class="line">  inspect     Display detailed information on one or more volumes  <span class="comment"># 查看数据卷的详细信息</span></span><br><span class="line">  <span class="built_in">ls</span>          List volumes  <span class="comment"># 查看所有数据卷列表</span></span><br><span class="line">  prune       Remove all unused <span class="built_in">local</span> volumes  <span class="comment"># 删除所有未使用的数据卷</span></span><br><span class="line">  <span class="built_in">rm</span>          Remove one or more volumes   <span class="comment"># 删除指定的数据卷</span></span><br><span class="line">  </span><br><span class="line">Run <span class="string">&#x27;docker volume COMMAND --help&#x27;</span> <span class="keyword">for</span> more information on a <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure><h4 id="9-4-2、数据卷查看"><a href="#9-4-2、数据卷查看" class="headerlink" title="9.4.2、数据卷查看"></a>9.4.2、数据卷查看</h4><p>查看数据卷的命令已经在上面透露过了。</p><p>格式：<code>docker volume ls</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><strong>例子 1：</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 _data]<span class="comment"># docker volume ls</span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               75b754f7602e8b946432ad871b0c4b43408dde92f06ce5574ff8352a85c39858</span><br><span class="line"><span class="built_in">local</span>               aa</span><br><span class="line"><span class="built_in">local</span>               frx</span><br></pre></td></tr></table></figure><h4 id="9-4-3、数据卷信息"><a href="#9-4-3、数据卷信息" class="headerlink" title="9.4.3、数据卷信息"></a>9.4.3、数据卷信息</h4><p>格式：<code>docker volume inspect &lt;数据卷名&gt;</code></p><blockquote><p><strong>例子 1：查看 frx 数据卷的具体信息</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 _data]<span class="comment"># docker volume ls</span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               75b754f7602e8b946432ad871b0c4b43408dde92f06ce5574ff8352a85c39858</span><br><span class="line"><span class="built_in">local</span>               aa</span><br><span class="line"><span class="built_in">local</span>               frx</span><br><span class="line">[root@frx01 _data]<span class="comment"># docker volume inspect frx</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2022-09-18T22:19:07+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/frx/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;frx&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="9-4-5、数据卷创建"><a href="#9-4-5、数据卷创建" class="headerlink" title="9.4.5、数据卷创建"></a>9.4.5、数据卷创建</h4><p>如果不想在启动容器的时候利用 <code>-v</code>「被迫」创建数据卷，这个命令让你收益实用。</p><p>格式：<code>docker volumn create &lt;数据卷名&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volumn create &lt;数据卷名&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 1：创建一个MyVolumn 数据卷</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 _data]<span class="comment"># docker volume create MyVolume</span></span><br><span class="line">MyVolume</span><br><span class="line">[root@frx01 _data]<span class="comment"># docker volume ls</span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               75b754f7602e8b946432ad871b0c4b43408dde92f06ce5574ff8352a85c39858</span><br><span class="line"><span class="built_in">local</span>               aa</span><br><span class="line"><span class="built_in">local</span>               frx</span><br><span class="line"><span class="built_in">local</span>               MyVolume</span><br></pre></td></tr></table></figure><p>创建的数据卷目录依然在 <code>/var/lib/docker/volumes</code> 下</p><h4 id="5-4-6、数据卷删除"><a href="#5-4-6、数据卷删除" class="headerlink" title="5.4.6、数据卷删除"></a>5.4.6、数据卷删除</h4><p>数据卷太多怎么办？可以删除指定名字的数据卷，也可以删除全部未被使用的数据卷。</p><ul><li>删除指定名字的数据卷命令格式：<code>docker rm &lt;数据卷名&gt;</code></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> &lt;数据卷名&gt;</span><br></pre></td></tr></table></figure><ul><li>删除全部未被使用的数据卷命令格式：<code>docker volume prune</code></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 1：删除 620fb …. 的数据卷</strong></p></blockquote><p><strong>例子 1：删除 75b …. 的数据卷</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume rm -f 75b754f7602e8b946432ad871b0c4b43408dde92f06ce5574ff8352a85c39858</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 2：删除所有未使用的数据卷</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">docker volume prune</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">[root@frx01 _data]<span class="comment"># docker volume prune</span></span><br><span class="line">WARNING! This will remove all <span class="built_in">local</span> volumes not used by at least one container.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认 y，取消 N</span></span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N] y</span><br></pre></td></tr></table></figure><h3 id="9-5、数据卷容器"><a href="#9-5、数据卷容器" class="headerlink" title="9.5、数据卷容器"></a>9.5、数据卷容器</h3><h4 id="9-5-1、继承"><a href="#9-5-1、继承" class="headerlink" title="9.5.1、继承"></a>9.5.1、继承</h4><p>容器1完成和宿主机的映射</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=<span class="literal">true</span> -v /mydocker/u:/tmp --name u1 ubuntu</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 _data]<span class="comment"># docker run -it  --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu</span></span><br><span class="line">WARNING: IPv4 forwarding is disabled. Networking will not work.</span><br><span class="line">root@a817d0f97c01:/<span class="comment"># cd /tmp/</span></span><br><span class="line">root@a817d0f97c01:/tmp<span class="comment"># ls -l</span></span><br><span class="line">total 0</span><br><span class="line">root@a817d0f97c01:/tmp<span class="comment"># touch u1_data.txt</span></span><br><span class="line">root@a817d0f97c01:/tmp<span class="comment"># ls -l</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r--. 1 root root 0 Sep 18 14:58 u1_data.txt</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 _data]<span class="comment"># cd /mydocker/u/</span></span><br><span class="line">[root@frx01 u]<span class="comment"># pwd</span></span><br><span class="line">/mydocker/u</span><br><span class="line">[root@frx01 u]<span class="comment"># ls -l</span></span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r--. 1 root root 0 9月  18 22:58 u1_data.txt</span><br></pre></td></tr></table></figure><p>容器2继承容器1的卷规则</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it  --privileged=<span class="literal">true</span> --volumes-from 父类 --name u2 ubuntu</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 u]<span class="comment"># docker run -it  --privileged=true --volumes-from u1 --name u2 ubuntu</span></span><br><span class="line">root@9c23dc4755bd:/<span class="comment"># cd /tmp/</span></span><br><span class="line">root@9c23dc4755bd:/tmp<span class="comment"># ls</span></span><br><span class="line">u1_data.txt</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@frx01 u]<span class="comment"># docker run -it  --privileged=true --volumes-from u1 --name u2 ubuntu</span></span><br><span class="line">root@9c23dc4755bd:/<span class="comment"># cd /tmp/</span></span><br><span class="line">root@9c23dc4755bd:/tmp<span class="comment"># ls</span></span><br><span class="line">u1_data.txt</span><br><span class="line">root@9c23dc4755bd:/tmp<span class="comment"># touch u2_data.txt</span></span><br><span class="line">root@9c23dc4755bd:/tmp<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@frx01 u]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@frx01 u]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">9c23dc4755bd        ubuntu              <span class="string">&quot;bash&quot;</span>              2 minutes ago       Exited (0) 19 seconds ago                       u2</span><br><span class="line">5d80a700eff5        ubuntu              <span class="string">&quot;bash&quot;</span>              2 minutes ago       Exited (0) 2 minutes ago                        u1</span><br><span class="line">[root@frx01 u]<span class="comment"># docker start u1</span></span><br><span class="line">u1</span><br><span class="line">[root@frx01 u]<span class="comment"># docker exec -it 5d80a700eff5 bash</span></span><br><span class="line">root@5d80a700eff5:/<span class="comment"># cd /tmp/</span></span><br><span class="line">root@5d80a700eff5:/tmp<span class="comment"># ls</span></span><br><span class="line">u1_data.txt  u2_data.txt <span class="comment">#u1中也有u2的</span></span><br></pre></td></tr></table></figure><h4 id="9-5-2、数据共享"><a href="#9-5-2、数据共享" class="headerlink" title="9.5.2、数据共享"></a>9.5.2、数据共享</h4><p>上面讲述的是主机和容器之间共享数据，那么如何实现容器和容器之间的共享数据呢？那就是创建 <strong>创建数据卷容器</strong>。</p><p>命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为 **数据卷容器(Data Volume Container)**。</p><p>通俗地来说，docker 容器数据卷可以看成使我们生活中常用的 U 盘，它存在于一个或多个的容器中，由 docker 挂载到容器，但不属于联合文件系统，Docker 不会在容器删除时删除其挂载的数据卷。在创建一个容器时候，使用命令绑定一个父容器，这个父容器就是 <strong>数据卷容器</strong>。</p><p>特点：</p><ul><li>数据卷可以在容器之间共享或重用数据</li><li>数据卷中的更改可以直接生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ul><p>命令格式：<code>docker run --volumes-from &lt;数据卷容器名&gt; &lt;镜像名[:TAG | ID]&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --volumes-from &lt;数据卷容器名&gt; &lt;镜像名[:TAG | ID]&gt;</span><br></pre></td></tr></table></figure><p><code>--volumes-from</code> 可以多次使用来挂载多个容器里的多个数据卷。即该命令是 <strong>链式</strong> 的。</p><p><strong>使用 –volumes-from 参数所挂载数据卷的容器自己并不需要保持在运行状态。</strong></p><p>注意</p><p><code>--volumes-from</code> 后的容器名才是 <strong>数据卷容器</strong>，并不是启动的这个容器。</p><blockquote><p><strong>例子 1：创建三个容器 tomcat10、tomcat11、tomcat12，其中 tomcat10 是数据卷容器</strong></p></blockquote><p>为了方便，不指定端口映射，<code>-P</code>（大写）直接让 Docker 随机生成端口映射。</p><p>创建数据卷容器的命令和创建容器的命令一样，创建 tomcat10 数据卷容器的时候指定一个数据卷。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">tomcat        8.5.73    7ec084df520c   2 days ago    249MB</span><br><span class="line">mysql         latest    b05128b000dd   3 days ago    516MB</span><br><span class="line">hello-world   latest    feb5d9fea6a5   8 weeks ago   13.3kB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动镜像，创建容器</span></span><br><span class="line">docker run -d -P --name tomcat10 -v tomcat10:/usr/local/tomcat/webapps tomcat:8.5.73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                     NAMES</span><br><span class="line">5516f026bf78   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   29 seconds ago   Up 29 seconds   0.0.0.0:49155-&gt;8080/tcp   tomcat10</span><br></pre></td></tr></table></figure><p>创建 tomcat11 和 tomcat12 容器，绑定 tomcat10 容器，也就是绑定数据卷容器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行两个命令</span></span><br><span class="line">docker run -d -P --name tomcat11 --volumes-from tomcat10 tomcat:8.5.73</span><br><span class="line">docker run -d -P --name tomcat12 --volumes-from tomcat10 tomcat:8.5.73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                     NAMES</span><br><span class="line">2cc6944ab955   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   15 seconds ago   Up 14 seconds   0.0.0.0:49157-&gt;8080/tcp   tomcat12</span><br><span class="line">0bd657b306d3   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   45 seconds ago   Up 44 seconds   0.0.0.0:49156-&gt;8080/tcp   tomcat11</span><br><span class="line">5516f026bf78   tomcat:8.5.73   <span class="string">&quot;catalina.sh run&quot;</span>   6 minutes ago    Up 6 minutes    0.0.0.0:49155-&gt;8080/tcp   tomcat10</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 2：证明三个容器的数据是否共享</strong></p></blockquote><p><strong>例子 1</strong> 已经创建好三个容器，并且 tomcat10 容器的数据卷目录是 tomcat10。我们可以在 tomcat10 容器的 webapps 目录下创建一个 test.txt 文件，看看 tomcat11 容器和 tomcat12 容器的 webapps 是否同步数据。</p><p>首先进入 tomcat10 容器的 webapps 目录，创建 test.txt 文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 tomcat10 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat10 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 webapps 目录</span></span><br><span class="line">root@f45ea598ee8d:/usr/local/tomcat<span class="comment"># cd webapps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 test.txt 文件</span></span><br><span class="line">root@f45ea598ee8d:/usr/local/tomcat/webapps<span class="comment"># touch test.txt</span></span><br></pre></td></tr></table></figure><p>然后我们进入 tomcat11 容器，看文件是否同步过来，并且创建 test2.txt 文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 tomcat11 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat11 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 webapps 目录</span></span><br><span class="line">root@31220638e2dc:/usr/local/tomcat<span class="comment"># cd webapps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 test.txt 文件</span></span><br><span class="line">root@31220638e2dc:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 test2.txt 文件</span></span><br><span class="line">root@31220638e2dc:/usr/local/tomcat/webapps<span class="comment"># touch test2.txt</span></span><br></pre></td></tr></table></figure><p>然后我们进入 tomcat12 容器，看文件是否同步过来</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 tomcat12 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat12 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 webapps 目录</span></span><br><span class="line">root@31220638e2dc:/usr/local/tomcat<span class="comment"># cd webapps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 test.txt 文件</span></span><br><span class="line">root@31220638e2dc:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">test2.txt  test.txt</span><br></pre></td></tr></table></figure><p>我们可以知道，数据是实现了共享。只要 tomcat10 数据卷容器的更新内容，其他绑定的容器都会同步内容。</p><p>最后我们看看宿主机的挂载目录</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入宿主机挂载目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/tomcat10/_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">test2.txt  test.txt</span><br></pre></td></tr></table></figure><p>说明无论是 tomcat10 容器的挂载目录，还是映射的宿主机挂载目录，只要任意一个发生改变，绑定的普通容器也会发生改变，实现共享。</p><p><strong>笔记</strong></p><p>普通容器绑定数据卷容器，其实就是绑定数据卷容器的数据卷。</p><p>所以删除 tomcat10 容器后 ，tomcat11 容器修改文件后， tomcat12 容器还可以正常共享数据，因为 tomcat10 容器的数据卷没有被删除。</p><p><img src="/2022/08/06/Docker/image.2zbxvbh9y2s0.webp" alt="image"></p><p>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。 存储在本机的文件则会一直保留。</p><p><strong>如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 docker rm -v 命令来指定同时删除关联的容器。这可以让用户在容器之间升级和移动数据卷。</strong></p><h4 id="9-5-3、数据备份"><a href="#9-5-3、数据备份" class="headerlink" title="9.5.3、数据备份"></a>9.5.3、数据备份</h4><p>可以利用数据卷对其中的数据进行进行备份、恢复。</p><p>数据备份命令格式：<code>docker run [options] --volumes-from &lt;数据卷容器&gt; [-v &lt;宿主机绝对路径&gt;:&lt;随机路径&gt;] &lt;镜像名&gt;:[TAG | ID] tar cvf &lt;随机路径/备份名&gt; &lt;数据卷容器路径&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run [options] --volumes-from &lt;数据卷容器&gt; [-v &lt;宿主机绝对路径&gt;:&lt;随机路径&gt;] &lt;镜像名&gt;:[TAG | ID] tar cvf &lt;随机路径/备份名&gt; &lt;数据卷容器路径&gt;</span><br></pre></td></tr></table></figure><p><strong>两个随机路径必须保持一致</strong>。备份路径默认在 <code>/var/lib/docker/overlay2/</code> 下的容器 ID 目录下生成。</p><blockquote><p><strong>例子 1：不指定宿主机挂载目录下和容器备份目录，备份 tomcat10 容器的数据卷 webapps 目录</strong></p></blockquote><p>这里是 tomcat10 容器，这个容器已经创建，并且容器的 <code>/usr/local/tomcat/webapps</code> 有 test.txt 和 test2.txt 文件，具体步骤在 数据共享实现了。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line">docker run --name tomcat-backup --volumes-from tomcat10 tomcat:8.5.73 tar cvf /backup.tar /usr/local/tomcat/webapps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找备份的文件</span></span><br><span class="line">find / -name backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">/var/lib/docker/overlay2/a9ef07977088b96970d926e95650a4810acf60429f9b9ca66625b6366597ff12/diff/backup.tar</span><br></pre></td></tr></table></figure><p>容器启动后，使用了 tar 命令来将容器的 &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps 目录备份到宿主机里，宿主机备份的路径看第 8 行数据，备份的文件是 backup.tar。</p><p><strong>如果容器删除，那么该方式的备份文件也被删除，并且备份目录是容器 ID 命名，并非容器名，看一长串字符串就知道了。</strong></p><p>如果解决删除问题，以及想要指定的路径进行备份，例子 2 方式可以解决。</p><blockquote><p><strong>例子 2：指定宿主机挂载目录下和容器备份目录，备份 tomcat10 容器的数据卷 webapps 目录</strong></p></blockquote><p><strong>这种方式如果容器删除，备份文件不会被删除。</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line">docker run --volumes-from tomcat10 -v /opt/backup:/backup tomcat:8.5.73 tar cvf /backup/backup.tar /usr/local/tomcat/webapps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找备份的文件</span></span><br><span class="line">find / -name backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">/opt/backup/backup.tar</span><br><span class="line">/var/lib/docker/overlay2/a9ef07977088b96970d926e95650a4810acf60429f9b9ca66625b6366597ff12/diff/backup.tar</span><br></pre></td></tr></table></figure><p>容器的挂载路径要和备份的文件路径保持一致，才能指定备份路径。否则如例子 3 报错：</p><blockquote><p><strong>例子 3：容器挂载路径和备份文件的路径不一致情况</strong></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line">docker run --volumes-from tomcat10 -v /opt/backup:/a tomcat:8.5.73 tar cvf /b/backup.tar /usr/local/tomcat/webapps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">tar: /b/backup.tar: Cannot open: No such file or directory</span><br><span class="line">tar: Error is not recoverable: exiting now</span><br></pre></td></tr></table></figure><p>容器的挂载路径是 a，但是备份的路径是 b，所以报错了，如果路径保持一致：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除例子 2的备份文件</span></span><br><span class="line"><span class="built_in">rm</span> -f /opt/backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份</span></span><br><span class="line">docker run --volumes-from tomcat10 -v /opt/backup:/a tomcat:8.5.73 tar cvf /a/backup.tar /usr/local/tomcat/webapps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找备份的文件</span></span><br><span class="line">find / -name backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">/opt/backup/backup.tar</span><br><span class="line">/var/lib/docker/overlay2/a9ef07977088b96970d926e95650a4810acf60429f9b9ca66625b6366597ff12/diff/backup.tar</span><br></pre></td></tr></table></figure><p>说明容器的挂载路径要和备份的文件路径保持一致，才能备份成功。建议使用路径 <code>/backup</code> 。</p><p>原理：首先将宿主机和容器的目录进行挂载，实现连通，接着容器内压缩成备份文件到 <code>/a</code> 目录下，实际上也会压缩到与 <code>/a</code> 挂载的 <code>/opt/backup</code> 目录下，所以这就是为什么将压缩文件的目录和宿主机的挂载目录保持一致，它们连通才能互相同步数据。</p><h4 id="9-5-4、数据恢复"><a href="#9-5-4、数据恢复" class="headerlink" title="9.5.4、数据恢复"></a>9.5.4、数据恢复</h4><p>备份了数据，那么就需要进行数据恢复。</p><p>恢复命令格式：<code>docker run --volumes-from &lt;恢复到哪个数据卷容器&gt; [-v &lt;宿主机绝对路径&gt;:&lt;随机路径&gt;] &lt;镜像名&gt;[:TAG | ID] tar xvf &lt;随机路径 | 路径&gt;</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --volumes-from &lt;恢复到哪个数据卷容器&gt; [-v &lt;宿主机绝对路径&gt;:&lt;随机路径&gt;] &lt;镜像名&gt;[:TAG | ID] tar xvf &lt;随机路径 | 路径&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>例子 1：数据恢复到 tomcat20 容器的数据卷里</strong></p></blockquote><p>如果要恢复数据到 tomcat20 容器，首先创建一个带有数据卷的容器 tomcat20，因为只能恢复数据到数据卷里。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name tomcat20 -v tomcat20:/usr/local/tomcat/webapps tomcat:8.5.73</span><br></pre></td></tr></table></figure><p>然后创建另一个容器，挂载 tomcat20 的容器，并使用 untar 解压备份文件到挂载的容器卷中。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --volumes-from tomcat20 -v /opt/backup:/backup tomcat:8.5.73 tar xvf /backup/backup.tar -C /</span><br></pre></td></tr></table></figure><p><code>-C /</code> 代表解压到根目录下，因为压缩包的文件基于根目录的，否则解压的目录是基于 <code>/backup</code>。</p><p>原理：此时 tomcat20 挂载目录是 <code>/usr/local/tomcat/webapps</code>，而新的容器只要挂载了 tomcat20 容器，它们两个的 <code>/usr/local/tomcat/webapps</code> 形成关联，新的容器的这个目录发生改变，则 tomcat20 的挂载目录也会发生改变，所以解压文件到新的容器的该目录下，实际上也是解压文件到 tomcat20 的挂载目录下，也就是实现恢复数据。</p><h3 id="9-6、挂载特性"><a href="#9-6、挂载特性" class="headerlink" title="9.6、挂载特性"></a>9.6、挂载特性</h3><p>关于到底是宿主机的挂载目录覆盖容器的挂载目录，还是反过来覆盖：</p><ul><li>默认目录挂载：<ul><li>当宿主机挂载目录已经存在时，双方挂载完成后，<strong>宿主机挂载目录覆盖容器挂载目录</strong></li><li>当宿主机挂载目录不存在时，双方挂载完成后，<strong>容器挂载目录覆盖宿主机挂载目录</strong></li></ul></li><li>具体目录挂载<ul><li>当宿主机挂载目录无论存不存在，双方挂载完成后，<strong>宿主机挂载目录都会覆盖容器挂载目录</strong></li></ul></li></ul><p><strong>默认目录挂载</strong></p><table><thead><tr><th>宿主机</th><th>容器</th><th>运行结果</th></tr></thead><tbody><tr><td>文件存在</td><td>文件存在</td><td>挂载成功，<strong>宿主机文件内容覆盖容器文件内容</strong></td></tr><tr><td>目录存在</td><td>目录存在</td><td>挂载成功，<strong>宿主机目录内容覆盖容器目录内容</strong></td></tr><tr><td>……</td><td>……</td><td>……</td></tr><tr><td>文件不存在</td><td>文件存在</td><td>挂载成功，<strong>容器文件内容覆盖宿主机文件内容</strong></td></tr><tr><td>目录不存在</td><td>目录存在</td><td>挂载成功，<strong>容器目录内容覆盖宿主机目录内容</strong></td></tr><tr><td>……</td><td>……</td><td>……</td></tr><tr><td>其他和 <strong>具体目录挂载</strong> 类似</td><td></td><td></td></tr></tbody></table><p><strong>具体目录挂载</strong></p><table><thead><tr><th>宿主机</th><th>容器</th><th>运行结果</th></tr></thead><tbody><tr><td>文件存在</td><td>文件存在</td><td>挂载成功，<strong>宿主机文件内容覆盖容器文件内容</strong></td></tr><tr><td>目录存在</td><td>目录存在</td><td>挂载成功，<strong>宿主机目录内容覆盖容器目录内容</strong></td></tr><tr><td>——</td><td>——</td><td>——</td></tr><tr><td>文件不存在</td><td>文件存在</td><td>挂载成功，<strong>宿主机创建空文件，并覆盖掉容器的文件，导致也为空</strong></td></tr><tr><td>目录不存在</td><td>目录存在</td><td>挂载成功，<strong>宿主机创建空目录，并覆盖掉容器的文件，导致也为空</strong></td></tr><tr><td>——</td><td>——</td><td>——</td></tr><tr><td>文件存在</td><td>文件不存在</td><td>挂载成功</td></tr><tr><td>目录存在</td><td>目录不存在</td><td>挂载成功</td></tr><tr><td>——</td><td>——</td><td>——</td></tr><tr><td>文件存在</td><td>目录存在</td><td>容器启动失败</td></tr><tr><td>目录存在</td><td>文件存在</td><td>容器启动失败</td></tr><tr><td>——</td><td>——</td><td>——</td></tr><tr><td>目录不存在</td><td>目录不存在</td><td>挂载成功，<strong>Docker 会自动在宿主机和容器内新建目录</strong></td></tr><tr><td>目录不存在</td><td>文件存在</td><td>容器启动失败</td></tr><tr><td>目录不存在</td><td>目录存在</td><td>挂载成功，<strong>宿主机空目录内容覆盖容器内目录（空）</strong></td></tr></tbody></table><h2 id="10、Docker-软件安装"><a href="#10、Docker-软件安装" class="headerlink" title="10、Docker 软件安装"></a>10、Docker 软件安装</h2><h3 id="10-1、Tomcat安装使用"><a href="#10-1、Tomcat安装使用" class="headerlink" title="10.1、Tomcat安装使用"></a>10.1、Tomcat安装使用</h3><p>tomcat 版本网址：<a href="https://registry.hub.docker.com/_/tomcat">https://registry.hub.docker.com/_&#x2F;tomcat(opens new window)</a></p><h4 id="10-1-1、版本选择"><a href="#10-1-1、版本选择" class="headerlink" title="10.1.1、版本选择"></a>10.1.1、版本选择</h4><p>tomcat 有很多的版本分支，一个版本可能有多个分支，如 <code>8-jre</code> 代表 Tomcat 8 内置 jre8 的版本、 <code>8-jdk8</code> 代表 Tomcat 8 内置 jdk8 的版本等等。所以根据需求进行版本选择。（jdk 包括了 jre，但是相对而言比较大）</p><p><img src="/2022/08/06/Docker/image.2ylgcekrxva0.webp" alt="image"></p><h4 id="10-1-2、安装修改"><a href="#10-1-2、安装修改" class="headerlink" title="10.1.2、安装修改"></a>10.1.2、安装修改</h4><p>这里选择的是 <code>8.5.82-jre8-temurin-focal</code> 版本，先下载：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull tomcat:8.5.82-jre8-temurin-jammy</span><br></pre></td></tr></table></figure><p>下载的版本名太长，我们可以创建短的版本，然后删除掉长的版本</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">REPOSITORY                                            TAG                         IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.91.166:5000/zzyyubuntu                        1.2                         658125043530        4 days ago          112MB</span><br><span class="line">registry.cn-shenzhen.aliyuncs.com/frx01/myubuntu1.3   1.3                         64df8ffb7faf        8 days ago          179MB</span><br><span class="line">tomcat                                                8.5.82-jre8-temurin-jammy   0065fb7141cd        2 weeks ago         240MB</span><br><span class="line">registry                                              latest                      b8604a3fe854        10 months ago       26.2MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增短版本</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># docker tag 0065fb7141cd tomcat:8.5.82</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除长版本</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># docker rmi tomcat:8.5.82-jre8-temurin-jammy</span></span><br><span class="line">Untagged: tomcat:8.5.82-jre8-temurin-jammy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询查看镜像</span></span><br><span class="line">[root@frx01 ~]<span class="comment"># docker images tomcat</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">tomcat              8.5.82              0065fb7141cd        2 weeks ago         240MB</span><br><span class="line">tomcat              8.5.27              a92c139758db        4 years ago         558MB</span><br></pre></td></tr></table></figure><h4 id="10-1-3、启动使用"><a href="#10-1-3、启动使用" class="headerlink" title="10.1.3、启动使用"></a>10.1.3、启动使用</h4><p>Tomcat 的使用相比较其他还是非常简单的，Tomcat 启动后，进入容器的默认目录是 <code>/usr/local/tomcat</code>，这里提供几个启动命令：</p><ul><li>命名后台启动</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name tomcat01 -p 8080:8080 tomcat:8.5.82</span><br></pre></td></tr></table></figure><ul><li>webapps 启动：创建 webapps 的数据卷，在宿主机的挂载目录部署项目，就会同步到容器的 webapps 目录下</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name tomcat01 -p 8080:8080 -v tomcat01-webapps:/usr/local/tomcat/webapps tomcat:8.5.82</span><br></pre></td></tr></table></figure><ul><li>配置文件启动：创建配置文件的数据卷，在宿主机的挂载目录修改配置文件，就会同步到容器的配置文件中</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name tomcat01 -p 8080:8080 -v tomcat01-webapps:/usr/local/tomcat/webapps -v tomcat01-conf:/usr/local/tomcat/conf tomcat:8.5.82</span><br></pre></td></tr></table></figure><p><code>tomcat01-webapps</code> 和 <code>tomcat01-conf</code> 根据需求创建数据卷名。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker run -d --name tomcat01 -p 8080:8080 -v tomcat01-webapps:/usr/local/tomcat/webapps tomcat:8.5.73</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat01 bash</span><br></pre></td></tr></table></figure><p>进入 webapps 目录，查看内容：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@efc01854d5e1:/usr/local/tomcat<span class="comment"># cd webapps</span></span><br><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#内容为空</span></span><br></pre></td></tr></table></figure><p>会发现为空，这是因为 Tomcat 官方把所有的初始化文件放到了 webapps.dist 目录下，我们去看看：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps<span class="comment"># cd ../webapps.dist/</span></span><br><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps.dist<span class="comment"># ls</span></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">docs  examples  host-manager  manager  ROOT</span><br></pre></td></tr></table></figure><p>所以我们需要把 webapps.dist 的内容拷贝到 webapps 目录中，为什么不删除 webapps 目录然后把 webapps.dist 重命名呢？因为容器运行期间无法删除文件，而不运行我们无法进入容器内部，所以只能一个一个拷贝过去</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps.dist<span class="comment"># cp -r docs/ ../webapps</span></span><br><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps.dist<span class="comment"># cp -r examples/ ../webapps</span></span><br><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps.dist<span class="comment"># cp -r host-manager/ ../webapps</span></span><br><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps.dist<span class="comment"># cp -r manager/ ../webapps</span></span><br><span class="line">root@efc01854d5e1:/usr/local/tomcat/webapps.dist<span class="comment"># cp -r ROOT/ ../webapps</span></span><br></pre></td></tr></table></figure><p>此时我们进入默认目录 <code>/var/lib/docker/volumes/tomcat01-webapps/_data</code> 下查看拷贝的内容是否同步过来：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入默认目录并查看内容</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/tomcat01-webapps/_data</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">docs  examples  host-manager  manager  ROOT</span><br></pre></td></tr></table></figure><p>虽然同步过来了，但是这样子会很累对吧，而且重新启动一个新的 Tomcat 容器，必须要重新执行 5 个拷贝操作，我们可以利用数据卷来同步数据。</p><h4 id="10-1-4、挂载特性"><a href="#10-1-4、挂载特性" class="headerlink" title="10.1.4、挂载特性"></a>10.1.4、挂载特性</h4><p>可以利用数据卷特性：</p><ul><li>默认目录挂载：<ul><li>当宿主机挂载目录已经存在时，双方挂载完成后，<strong>宿主机挂载目录覆盖容器挂载目录</strong></li><li>当宿主机挂载目录不存在时，双方挂载完成后，<strong>容器挂载目录覆盖宿主机挂载目录</strong></li></ul></li><li>具体目录挂载<ul><li>当宿主机挂载目录无论存不存在，双方挂载完成后，<strong>宿主机挂载目录都会覆盖容器挂载目录</strong></li></ul></li></ul><p>所以我们有两种方式：</p><p>首先我们手动拷贝一份 tomcat01 的宿主机挂载目录，该目录已经将数据同步过来，目录有 webapps 的内容了</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝一份 tomcat01 的宿主机挂载目录，新的目录名叫 tomcat02-webapps</span></span><br><span class="line"><span class="built_in">cp</span> -r tomcat01-webapps tomcat02-webapps</span><br></pre></td></tr></table></figure><blockquote><p><strong>方式 1：默认目录挂载</strong></p></blockquote><p>启动第二个 Tomcat 容器，利用 <strong>默认目录挂载</strong> 的第一个特性进行与容器的挂载</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name tomcat02 -p 8081:8080 -v tomcat02-webapps:/usr/local/tomcat/webapps tomcat:8.5.73</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 tomcat02 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat02  bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 webapps 目录，并查看内容</span></span><br><span class="line">root@50edd2a86a8d:/usr/local/tomcat<span class="comment"># cd webapps</span></span><br><span class="line">root@50edd2a86a8d:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">docs  examples  host-manager  manager  ROOT</span><br></pre></td></tr></table></figure><p>说明同步成功。</p><blockquote><p><strong>方式 2：具体目录挂载</strong></p></blockquote><p>启动第三个 Tomcat 容器，利用 <strong>具体目录挂载</strong> 方式进行与容器的挂载（缺点：指定到 _data 目录，因为该方式是从指定的目录覆盖容器的目录）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name tomcat03 -p 8082:8080 -v /var/lib/docker/volumes/tomcat02-webapps/_data:/usr/local/tomcat/webapps tomcat:8.5.73</span><br></pre></td></tr></table></figure><p>进入容器看看，是否同步过来了</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 tomcat03 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat03 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入 webapps 目录，并查看内容</span></span><br><span class="line">root@ba7961226856:/usr/local/tomcat<span class="comment"># cd webapps</span></span><br><span class="line">root@ba7961226856:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">docs  examples  host-manager  manager  ROOT</span><br></pre></td></tr></table></figure><p>说明同步成功。</p><blockquote><p><strong>总结：</strong></p></blockquote><p>推荐方式 1，因为方式 2 必须指定到 _data 目录，不灵活。而使用方式 1，必须先确保宿主机存在该目录，并且目录里有想要的内容。</p><p>Tomcat 也有配置文件，里面可以修改 8080 端口，上面的第三个启动命令就是给配置文件进行数据卷挂载，步骤和 webapps 的两个例子一样，这里不演示了。</p><p>值得注意的是：修改完配置文件的端口后，需要重新 run 一个新的 Tomcat 容器，然后该容器和宿主机修改后的配置文件目录挂载，才能真正实现端口的修改，因为第一次端口映射在 run 时是 8080:8080，无法修改为 8080:XXXX(修改的端口)，需要重新 run 才行，而 run 出来的配置文件默认端口还是 8080，所以需要利用数据卷特性，让宿主机的配置文件覆盖容器的 8080 端口配置文件。</p><h4 id="10-1-5、相关指令"><a href="#10-1-5、相关指令" class="headerlink" title="10.1.5、相关指令"></a>10.1.5、相关指令</h4><p>进入 Tomcat 容器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;容器名或 <span class="built_in">id</span>&gt; bash</span><br></pre></td></tr></table></figure><p>查看 Tomcat 容器的日志</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加 -f 代表实时监听日志动态</span></span><br><span class="line">docker logs [-f] &lt;容器名或 <span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="10-2、MySQL安装"><a href="#10-2、MySQL安装" class="headerlink" title="10.2、MySQL安装"></a>10.2、MySQL安装</h3><p>MySQL 版本网址：<a href="https://registry.hub.docker.com/_/mysql">https://registry.hub.docker.com/_&#x2F;mysql(opens new window)</a></p><h4 id="10-2-1、安装启动"><a href="#10-2-1、安装启动" class="headerlink" title="10.2.1、安装启动"></a>10.2.1、安装启动</h4><ul><li>拉取镜像到本地</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><ul><li>简单运行 MySQL 服务，将需要挂载的目录拷贝出来</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name mysql -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure><p>密码自行修改。使用 3307 是因为宿主机可能已经安装了 MySQL，它占用了 3306 端口。</p><p>拷贝挂载的目录：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先创建挂载目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /docker/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL的相关文件同步到挂载目录</span></span><br><span class="line">docker <span class="built_in">cp</span> mysql:/var/lib/mysql /docker/mysql/data</span><br><span class="line">docker <span class="built_in">cp</span> mysql:/etc/mysql/conf.d /docker/mysql/conf</span><br><span class="line">docker <span class="built_in">cp</span> mysql:/var/log /docker/mysql/log</span><br></pre></td></tr></table></figure><p>为什么要拷贝出来呢？因为一旦挂载成功，宿主机的挂载目录会覆盖容器的目录，所以我们确保宿主机的挂载目录不能为空，必须要有原来容器目录的文件。</p><ul><li><p>宿主机与容器实现挂载，保证数据安全，对应上方拷贝出来的目录</p></li><li><p><a href="https://frxcat.fun/project-management/Docker/Docker_Software_installation/#%E6%97%A0%E6%B3%A8%E8%A7%A3%E7%89%88(%E5%8F%AF%E7%94%A8)">无注解版(可用)</a></p></li><li><p><a href="https://frxcat.fun/project-management/Docker/Docker_Software_installation/#%E6%9C%89%E6%B3%A8%E8%A7%A3%E7%89%88(%E5%8F%AA%E7%9C%8B%E4%B8%8D%E7%94%A8)">有注解版(只看不用)</a></p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --name mysql \</span><br><span class="line">    --restart always \</span><br><span class="line">    -p 3307:3306 \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">    -v /docker/mysql/data:/var/lib/mysql \</span><br><span class="line">    -v /docker/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">    -v /docker/mysql/log:/var/log \</span><br><span class="line">    mysql:5.7</span><br></pre></td></tr></table></figure><p>宿主机的挂载目录、conf.d 目录、data 数据目录、日志目录根据需求决定，包括密码。</p><p>这里说明一下：主配置文件名叫 my.cnf，位置在 <code>/etc/mysql</code>，但是不建议直接操作 my.cnf 主配置文件，官方也是如此，所以官方提供了 conf.d 目录，只要在 conf.d 目录下创建 xx.cnf 配置文件，那么该配置文件自动被引入 my.cnf 主配置文件，避免直接操作 my.cnf 引起安全问题。</p><p>my.cnf 文件里有这么一句代码：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">includedir /etc/mysql/conf.d/</span><br></pre></td></tr></table></figure><p>可以看出，my.cnf 会自动读取该目录下的所有 .cnf 配置文件。</p><p><strong>笔记</strong></p><p>确保简单启动的密码和挂载启动的保持一致，因为启动后，密码保存在 <code>/var/lib/mysql</code> 目录下，而挂载的时候，宿主机的该目录会覆盖容器的目录，导致密码是简单启动的密码。所以确保两种启动方式密码保持一致。</p><ul><li><strong>配置 UTF-8 编码</strong></li></ul><p>进入宿主机的配置文件挂载目录：<code>/docker/mysql/conf</code>，有一个 mysql.cnf 配置文件，编辑它</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /docker/mysql/conf</span><br><span class="line">vim mysql.cnf</span><br></pre></td></tr></table></figure><p>添加如下内容（如果文件有 <code>[mysql]</code>，必须先删除掉）：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure><ul><li>进入 MySQL 容器，配置 UTF-8 编码</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器名 | 容器<span class="built_in">id</span> bash</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql bash</span><br></pre></td></tr></table></figure><p>进入容器后，登录 MySQL</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>查看数据库的编码是否是 UTF-8</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%char%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如图则代表配置成功：</p><p><img src="/2022/08/06/Docker/image.2fc62z4b02vw.webp" alt="image"></p><ul><li>外部查看 MySQL 日志（可选）</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker logs 容器<span class="built_in">id</span> | 容器名</span><br></pre></td></tr></table></figure><h4 id="10-2-2、其他命令"><a href="#10-2-2、其他命令" class="headerlink" title="10.2.2、其他命令"></a>10.2.2、其他命令</h4><ul><li>将 MySQL 数据库备份为 sql 文件<ul><li>导出全部数据库的数据为 sql 文件</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> 容器名 | 容器 <span class="built_in">id</span> bash -c <span class="string">&#x27;exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27;</span> &gt; /opt/all-database.sql </span><br></pre></td></tr></table></figure><ul><li>用户名要根据需求替换、<code>/opt/all-database</code> 是导出文件的路径，需要根据需求修改。密码不需要修改，它会自动获取登录的密码。</li><li>导出指定的数据库数据的 sql 文件</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> 容器名 | 容器 bash -c <span class="string">&#x27;exec mysqldump --databases 库名 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27;</span> &gt; /opt/one-database.sql</span><br></pre></td></tr></table></figure><ul><li>导出指定的数据库，但是不要数据</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> 容器名 | 容器 bash -c <span class="string">&#x27;exec mysqldump --no-data --databases 库名 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27;</span> &gt; /opt/one-database.sql</span><br></pre></td></tr></table></figure><ul><li>执行 sql 文件到 MySQL 中</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> 容器名 | 容器<span class="built_in">id</span> bash -c <span class="string">&#x27;exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27;</span> &lt; /opt/xxx.sql</span><br></pre></td></tr></table></figure><p><code>/opt/xxx.sql</code> 是 sql 文件的路径。</p><h3 id="10-3、Redis安装"><a href="#10-3、Redis安装" class="headerlink" title="10.3、Redis安装"></a>10.3、Redis安装</h3><h4 id="10-3-1、安装"><a href="#10-3-1、安装" class="headerlink" title="10.3.1、安装"></a>10.3.1、安装</h4><p>Redis 版本网址：<a href="https://registry.hub.docker.com/_/redis">https://registry.hub.docker.com/_&#x2F;redis(opens new window)</a></p><p>Redis 的安装还是比较简单的，这里安装 6.62 版本</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull redis:6.2.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 docker 容器</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h4 id="10-3-2、启动"><a href="#10-3-2、启动" class="headerlink" title="10.3.2、启动"></a>10.3.2、启动</h4><p>Redis 启动后，进入容器的默认目录是 <code>/data</code></p><p>启动指令：</p><ul><li>简单的启动，也是最快速的个人使用启动：</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis -p 6379:6379 redis:6.2.6</span><br></pre></td></tr></table></figure><ul><li><p>AOP 持久化启动</p><p>指定持久化的 .aop 文件路径，宿主机的文件路径根据需求存放，容器的文件路径默认在 <code>/data</code></p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis -p 6379:6379 -v redis_data:/data redis:6.2.6 redis-server --appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>容器的 <code>/data</code> 是 AOP 文件的默认路径，<code>redis_data</code> 根据需求修改，是宿主机的挂载目录，而 <code>redis-server --appendonly yes</code> 是必须的，这个命令会覆盖默认的命令，默认的命令是关闭持久化。</p><ul><li>自定义配置文件启动：指定配置文件的路径和容器的 <code>/usr/local/etc/redis</code> 挂载，一旦挂载后，容器的该目录获得配置文件，然后通过 <code>redis-server /usr/local/etc/redis/redis.conf</code> 启动该配置文件</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis -p 6379:6379 -v /opt/redis.conf:/usr/local/etc/redis/redis.conf -d redis:6.2.6 redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p><code>/opt/redis_conf</code> 是在宿主机的配置文件路径，根据需求修改。</p><blockquote><p><strong>注意：Redis 容器内没有 redis.conf 文件，启动的配置信息都是默认的。我们需要自己准备好一份 redis.conf 文件，然后通过数据卷传进容器内</strong></p></blockquote><p>如何准备一份 redis.conf 文件呢？</p><ul><li><p>去官网下载对应的 Windows 版本，然后拷贝 redis.conf 到 Linux 下，再启动配置，这样很麻烦对吧</p></li><li><p>直接 Linux 下创建一个 redis.conf 文件，虽然不如原生的全面，但是我们只需要加入自己的一些配置即可，其他配置 Redis 自动使用默认的</p><p>比如：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据需求指定创建路径</span></span><br><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">vim redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 redis.conf 加入如下内容</span></span><br><span class="line"><span class="comment"># 限制能访问 redis 的地址，根据需求修改</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认是 yes，开启保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 redis 连接密码，可选</span></span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以守护进程方式启动，可后台启动</span></span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改本地 redis 数据库存放文件夹（可选）</span></span><br><span class="line"><span class="built_in">dir</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># AOP 持久化</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><ul><li>redis.conf常用配置</li></ul><blockquote><ul><li><p>bind 0.0.0</p><p>限制 redis 只能本地访问，根据需求修改</p></li><li><p>protected-mode no</p><p>默认是 yes，开启保护模式，限制为本地访问</p></li><li><p>requirepass 123456</p><p>配置redis连接密码，默认是注释的</p></li><li><p>daemonize no</p><p>默认 no，改为 yes 代表以守护进程方式启动，可后台运行，除非kill进程（可选），改为 yes 会使配置文件方式启动 redis 失败</p></li><li><p>dir .&#x2F;</p><p>更改本地 redis 数据库存放文件夹（可选）</p></li><li><p>appendonly yes</p><p>redis 持久化（开启了这个，redis 就不会每次重启时自动清空了）</p></li></ul></blockquote><p>如果不加入 <code>appendonly yes</code>，可以利用 AOP 持久化启动来指定 <code>appendonly yes</code> 启动。</p><h4 id="10-3-3、其他"><a href="#10-3-3、其他" class="headerlink" title="10.3.3、其他"></a>10.3.3、其他</h4><p>启动后进入 redis 容器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis bash</span><br></pre></td></tr></table></figure><p>查看 redis 的日志</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加 -f 代表实时监听日志动态</span></span><br><span class="line">docker logs [-f] redis</span><br></pre></td></tr></table></figure><p>输入 <code>redis-cli</code> 连接 redis，如果是连接其他服务器的 redis，则需要加参数</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -h IP地址 -p 6379</span><br></pre></td></tr></table></figure><h3 id="10-4、ElasticSearch安装"><a href="#10-4、ElasticSearch安装" class="headerlink" title="10.4、ElasticSearch安装"></a>10.4、ElasticSearch安装</h3><h4 id="10-4-1、安装"><a href="#10-4-1、安装" class="headerlink" title="10.4.1、安装"></a>10.4.1、安装</h4><p>ElasticSearch 版本网址：<a href="https://registry.hub.docker.com/_/elasticsearch">https://registry.hub.docker.com/_&#x2F;elasticsearch(opens new window)</a></p><p>这里下载的版本是 7.14.2</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:7.14.2</span><br></pre></td></tr></table></figure><h4 id="10-4-2、配置"><a href="#10-4-2、配置" class="headerlink" title="10.4.2、配置"></a>10.4.2、配置</h4><p>如果启动报错</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">max virtual memory areas vm.max_map_count [65530] is too low，increase to at least [262144]</span><br></pre></td></tr></table></figure><p>则需要进行配置，没有出现错误可以跳过</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改配置 sysctl.conf</span></span><br><span class="line">vim /etc/stsctl.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入配置信息</span></span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用配置</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><h4 id="10-4-3、启动"><a href="#10-4-3、启动" class="headerlink" title="10.4.3、启动"></a>10.4.3、启动</h4><p>三种启动方式：</p><ul><li>简单启动</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 elasticsearch:7.14.2</span><br></pre></td></tr></table></figure><p>如果报错，请看 <a href="https://frxcat.fun/project-management/Docker/Docker_Software_installation#%E9%85%8D%E7%BD%AE">配置</a> 进行解决</p><p>浏览器访问的是 9200 端口</p><ul><li>持久化和配置文件启动</li></ul><p>ES 中所有的数据都在容器中的 <code>/usr/share/elasticsearch/data</code> 目录，配置文件在 <code>/usr/share/elasticsearch/config</code>，所以需要挂载出来</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -v es_data:/usr/share/elasticsearch/data -v es_config:/usr/share/elasticsearch/config elasticsearch:7.14.2</span><br></pre></td></tr></table></figure><p>挂载成功后，哪怕容器被删除了，数据还是会存在宿主机的 <code>/.../es_data</code> 目录下</p><ul><li>ik 分词器启动</li></ul><blockquote><p><strong>方式 1：</strong></p></blockquote><p>首先下载好 ik 分词器，版本要和 ES 版本一致，放到 Linux 系统中，我们知道，ES 的插件目录是 <code>/usr/share/elasticsearch/plugins</code> 下，所以需要挂载出来</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -v es_data:/usr/share/elasticsearch/data -v es_config:/usr/share/elasticsearch/config -v es_plugins:/usr/share/elasticsearch/plugins elasticsearch:7.14.2</span><br></pre></td></tr></table></figure><p>此时的 <code>es_plugins</code> 目录下为空，我们把下载好的 ik 分词器放到该目录下，然后重启 ES 即可</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> &lt;ik 分词器&gt; /var/lib/docker/volumes/es_plugins/_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 es</span></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure><blockquote><p><strong>方式 2：</strong></p></blockquote><p>先创建数据卷，把 ik 分词器放到数据卷里</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume create es_plugins</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> &lt;ik 分词器&gt; /var/lib/docker/volumes/es_plugins/_data</span><br></pre></td></tr></table></figure><p>再启动容器进行挂载</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -v es_data:/usr/share/elasticsearch/data -v es_config:/usr/share/elasticsearch/config -v es_plugins:/usr/share/elasticsearch/plugins elasticsearch:7.14.2</span><br></pre></td></tr></table></figure><h3 id="10-5、Kibana安装"><a href="#10-5、Kibana安装" class="headerlink" title="10.5、Kibana安装"></a>10.5、Kibana安装</h3><p>Kibana 版本网址：<a href="https://registry.hub.docker.com/_/kibana">https://registry.hub.docker.com/_&#x2F;kibana(opens new window)</a></p><p>下载 Kibaba 镜像，版本要和 ElasticSearch 一致。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull kibana:7.14.2</span><br></pre></td></tr></table></figure><p>启动</p><ul><li><p>简单启动</p><p>此时没有指定连接 ES</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name kibana -p 5601:5601 kibaba:7.14.2</span><br></pre></td></tr></table></figure><ul><li>连接 ES 启动</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name kibana -p 5601:5601 -e ELASTICSEARCH_URL=http://IP地址:9200 kibaba:7.14.2</span><br></pre></td></tr></table></figure><ul><li>先简单启动，后在配置文件再连接 ES，重启生效</li></ul><p>首先知道配置文件的路径是 <code>/usr/share/kibana/config</code>，将它挂载出来</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name kibana -p 5601:5601 -v kibana_conf:/usr/share/kibana/config kibana:7.14.2</span><br></pre></td></tr></table></figure><p>启动后进入宿主机的 kibana_conf 目录或者 容器的 <code>/usr/share/kibana/config</code> 目录，这里演示前者</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/kibana_conf/_data</span><br><span class="line"></span><br><span class="line">vim kibana.yml</span><br></pre></td></tr></table></figure><p>修改为 ES 的 IP 地址</p><p><img src="/2022/08/06/Docker/image.4uzub0kmmoi0.webp" alt="image"></p><h1 id="二、高级篇"><a href="#二、高级篇" class="headerlink" title="二、高级篇"></a>二、高级篇</h1><h2 id="1、Docker复杂安装"><a href="#1、Docker复杂安装" class="headerlink" title="1、Docker复杂安装"></a>1、Docker复杂安装</h2><h3 id="1-1、Mysql主从复制"><a href="#1-1、Mysql主从复制" class="headerlink" title="1.1、Mysql主从复制"></a>1.1、Mysql主从复制</h3><h4 id="1-1-1、数据库主从复制原理"><a href="#1-1-1、数据库主从复制原理" class="headerlink" title="1.1.1、数据库主从复制原理"></a>1.1.1、数据库主从复制原理</h4><p>主从复制原理，简言之，分三步曲进行：</p><p>主数据库有个 bin log 二进制文件，记录了所有增删改 SQL 语句。(binlog线程)<br>从数据库把主数据库的 bin log 文件的 SQL 语句复制到自己的中继日志 relay log(io线程)<br>从数据库的 relay log 重做日志文件，再执行一次这些sql语句。(sql执行线程)<br>详细的主从复制过程如图：</p><p><img src="/2022/08/06/Docker/76b42ef2fbbb2486d09c3b854aeb9f35.png" alt="img"></p><p>上图主从复制过程分了五个步骤进行：</p><ul><li>主库的更新SQL(update、insert、delete)被写到binlog</li><li>从库发起连接，连接到主库。</li><li>此时主库创建一个 binlog dump thread，把 bin log 的内容发送到从库。</li><li>从库启动之后，创建一个 I&#x2F;O 线程，读取主库传过来的 bin log 内容并写到 relay log</li><li>从库还会创建一个SQL线程，从 relay log 里面读取内容，从 ExecMasterLog_Pos 位置开始执行读取到的更新事件，将更新内容写入到 slave 的db</li></ul><h4 id="1-1-2、主从搭建步骤"><a href="#1-1-2、主从搭建步骤" class="headerlink" title="1.1.2、主从搭建步骤"></a>1.1.2、主从搭建步骤</h4><p><strong>数据库主从</strong>：一台是主数据库，同时对外提供读写操作。一台是<strong>从数据库，对外提供读的操作。</strong>数据从主库同步到从库。<img src="/2022/08/06/Docker/142869fab2ca481effb2ed3acbe28a95.png" alt="img"><br>从库和备库，就是slave库功能不同因此叫法不一样而已。一般slave库都会对外提供读的功能的，因此，大家日常听得最多的就是<strong>主从</strong>。注意关闭防火墙<code>sytemctl disable firewalld</code></p><ul><li>新建主服务器容器实例3307</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 3307:3306 --name mysql-master \</span><br><span class="line">-v /mydata/mysql-master/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-master/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-master/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root  \</span><br><span class="line">-d mysql:5.7</span><br><span class="line">[root@hua conf]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS         PORTS                                                  NAMES</span><br><span class="line">2e4da9502453   mysql:5.7   &quot;docker-entrypoint.s…&quot;   10 minutes ago   Up 3 minutes   33060/tcp, 0.0.0.0:3307-&gt;3306/tcp, :::3307-&gt;3306/tcp   mysql-master</span><br></pre></td></tr></table></figure><ul><li>进入&#x2F;mydata&#x2F;mysql-master&#x2F;conf目录下新建my.cnf</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua conf]# vim my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置server_id，同一局域网中需要唯一</span></span></span><br><span class="line">server_id=101 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 指定不需要同步的数据库名称</span></span></span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 开启二进制日志功能</span></span></span><br><span class="line">log-bin=mall-mysql-bin  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置二进制日志使用内存大小（事务）</span></span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置使用的二进制日志格式（mixed,statement,row）</span></span></span><br><span class="line">binlog_format=mixed  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span></span><br><span class="line">expire_logs_days=7  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span></span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure><ul><li>修改完配置后重启master实例</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua conf]# docker restart mysql-master</span><br></pre></td></tr></table></figure><ul><li>进入mysql-master容器</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua conf]# docker exec -it mysql-master /bin/bash</span><br><span class="line">root@2e4da9502453:/# mysql -uroot -p</span><br><span class="line">Enter password:root</span><br></pre></td></tr></table></figure><ul><li>master容器实例内创建数据同步用户</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">CREATE USER <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span></span><br></pre></td></tr></table></figure><ul><li>新建从服务器容器实例3308</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 3308:3306 --name mysql-slave \</span><br><span class="line">-v /mydata/mysql-slave/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-slave/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-slave/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root  \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><ul><li>·进入&#x2F;mydata&#x2F;mysql-slave&#x2F;conf目录下新建my.cnf</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua conf]# vim my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置server_id，同一局域网中需要唯一</span></span></span><br><span class="line">server_id=102</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 指定不需要同步的数据库名称</span></span></span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span></span></span><br><span class="line">log-bin=mall-mysql-slave1-bin  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置二进制日志使用内存大小（事务）</span></span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置使用的二进制日志格式（mixed,statement,row）</span></span></span><br><span class="line">binlog_format=mixed  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span></span><br><span class="line">expire_logs_days=7  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span></span><br><span class="line">slave_skip_errors=1062  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># relay_log配置中继日志</span></span></span><br><span class="line">relay_log=mall-mysql-relay-bin  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span></span><br><span class="line">log_slave_updates=1  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># slave设置为只读（具有super权限的用户除外）</span></span></span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure><ul><li>修改完配置后重启slave实例</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart mysql-slave</span><br></pre></td></tr></table></figure><ul><li>在<strong>主数据库中查看主从同步状态</strong></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show master status;</span></span><br><span class="line">+-----------------------+----------+--------------+------------------+---------------                   ----+</span><br><span class="line">| File                  | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_                   Set |</span><br><span class="line">+-----------------------+----------+--------------+------------------+---------------                   ----+</span><br><span class="line">| mall-mysql-bin.000001 |     617 |              | mysql            |                                      |</span><br><span class="line">+-----------------------+----------+--------------+------------------+---------------                   ----+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>进入mysql-slave容器</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua ~]# docker exec -it mysql-slave /bin/bash</span><br><span class="line">root@4557df93e926:/# mysql -uroot -p</span><br><span class="line">Enter password:root</span><br></pre></td></tr></table></figure><ul><li>在从数据库中配置主从复制</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;宿主机ip&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=617, master_connect_retry=30;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;192.168.182.129&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=617, master_connect_retry=30;</span><br></pre></td></tr></table></figure><blockquote><p>主从复制命令参数说明</p><p>master_host：主数据库的IP地址；</p><p>master_port：主数据库的运行端口；</p><p>master_user：在主数据库创建的用于同步数据的用户账号；</p><p>master_password：在主数据库创建的用于同步数据的用户密码；</p><p>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</p><p>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</p><p>master_connect_retry：连接失败重试的时间间隔，单位为秒。</p></blockquote><ul><li>在从数据库中查看主从同步状态</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show slave status \G;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/image-20221013213057313.png" alt="image-20221013213057313"></p><ul><li>在从数据库中开启主从同步</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/image-20221013213224880.png" alt="image-20221013213224880"></p><ul><li>主从复制测试</li></ul><p>主机新建库-使用库-新建表-插入数据，ok</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create database db01;</span></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">use db01;</span></span><br><span class="line">Database changed</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create table user(<span class="built_in">id</span> int ,name varchar(20));</span></span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">insert into user values(1,<span class="string">&#x27;zhang&#x27;</span>),(2,<span class="string">&#x27;san&#x27;</span>);</span></span><br><span class="line">Query OK, 2 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">select * from user;</span></span><br><span class="line">+------+-------+</span><br><span class="line">| id   | name  |</span><br><span class="line">+------+-------+</span><br><span class="line">|    1 | zhang |</span><br><span class="line">|    2 | san   |</span><br><span class="line">+------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>从机使用库-查看记录，ok</p><h3 id="1-2、安装Redis集群"><a href="#1-2、安装Redis集群" class="headerlink" title="1.2、安装Redis集群"></a>1.2、安装Redis集群</h3><h4 id="1-2-1、cluster-集群-模式-docker版-哈希槽分区进行亿级数据存储"><a href="#1-2-1、cluster-集群-模式-docker版-哈希槽分区进行亿级数据存储" class="headerlink" title="1.2.1、cluster(集群)模式-docker版 哈希槽分区进行亿级数据存储"></a>1.2.1、cluster(集群)模式-docker版 哈希槽分区进行亿级数据存储</h4><p>问题：1~2亿条数据需要缓存，请问如何设计这个存储案例</p><p>单机单台100%不可能，肯定是分布式存储，用redis如何落地</p><h5 id="哈希取余分区"><a href="#哈希取余分区" class="headerlink" title="哈希取余分区"></a>哈希取余分区</h5><p><img src="/2022/08/06/Docker/image-20221015103628343.png" alt="image-20221015103628343"></p><blockquote><p>2亿条记录就是2亿个k,v，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：<code>hash(key) % N</code>个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。</p></blockquote><p><strong>优点：</strong></p><p>简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。</p><p><strong>缺点：</strong></p><p>原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)&#x2F;3会变成Hash(key) &#x2F;?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。</p><p>某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</p><h5 id="一致性哈希算法分区"><a href="#一致性哈希算法分区" class="headerlink" title="一致性哈希算法分区"></a>一致性哈希算法分区</h5><p><strong>是什么</strong></p><p>一致性哈希算法在1997年由麻省理工学院中提出的，设计目标是为了解决分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数不OK了。</p><p><strong>能干嘛</strong></p><p>提出一致性Hash解决方案。 目的是当服务器个数发生变动时， 尽量减少影响客户端到服务器的映射关系。</p><h6 id="3大步骤"><a href="#3大步骤" class="headerlink" title="3大步骤"></a><strong>3大步骤</strong></h6><ul><li>算法构建一致性哈希环</li></ul><p>一致性哈希环</p><p>  一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 &#x3D; 2^32),这样让它逻辑上形成了一个环形空间。</p><p>它也是按照使用取模的方法，前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性Hash算法是对2^32取模，简单来说，<strong>一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，</strong>如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下图：<strong>整个空间按顺时针方向组织</strong>，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。</p><p><img src="/2022/08/06/Docker/image-20221015124718040.png" alt="image-20221015124718040"></p><ul><li>服务器IP节点映射</li></ul><p>节点映射</p><p><strong>将集群中各个IP节点映射到环上的某一个位置。</strong></p><p>将各个服务器使用Hash进行一个哈希，具体可以<strong>选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置</strong>。假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算(hash(ip))，使用IP地址哈希后在环空间的位置如下： </p><p><img src="/2022/08/06/Docker/image-20221015124806345.png" alt="image-20221015124806345"></p><ul><li>key落到服务器的落键规则</li></ul><p>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，<strong>从此位置沿环顺时针“行走”</strong>，<strong>第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</strong></p><p>如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p><p><img src="/2022/08/06/Docker/image-20221015124902869.png" alt="image-20221015124902869"></p><p><strong>优点</strong></p><ul><li>一致性哈希算法的容错性</li></ul><p><strong>容错性</strong></p><p>假设Node C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，<strong>如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响</strong>。简单说，就是C挂了，受到影响的只是B、C之间的数据，并且这些数据会转移到D进行存储。</p><p><img src="/2022/08/06/Docker/clip_image002.jpg" alt="graphic"></p><ul><li>一致性哈希算法的<strong>扩展性</strong></li></ul><p> 扩展性</p><p>数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，</p><p>不会导致hash取余全部数据重新洗牌。</p><p><img src="/2022/08/06/Docker/clip_image004.jpg" alt="graphic"></p><p> 缺点</p><ul><li>一致性哈希算法的数据倾斜问题</li></ul><p>Hash环的数据倾斜问题</p><p>一致性Hash算法在服务<strong>节点太少时</strong>，容易因为节点分布不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上）问题，</p><p>例如系统中只有两台服务器：</p><p> <img src="/2022/08/06/Docker/clip_image005.jpg" alt="graphic"></p><h6 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h6><p>为了在节点数目发生改变时尽可能少的迁移数据。将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到临近的存储节点存放。而当有节点加入或退出时仅影响该节点在Hash环上顺时针相邻的后续节点。 </p><p><strong>优点</strong></p><p>加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</p><p><strong>缺点</strong> </p><p>数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</p><h5 id="哈希槽分区"><a href="#哈希槽分区" class="headerlink" title="哈希槽分区"></a>哈希槽分区</h5><p>哈希槽实质就是一个数组，数组[0,2^14 -1]形成hash slot空间。</p><p><strong>能干什么</strong></p><p><strong>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。</strong></p><p><img src="/2022/08/06/Docker/clip_image002-16658095468534.jpg" alt="graphic"></p><p>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。</p><p>哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。</p><p><strong>多少个hash槽</strong></p><p>一个集群只能有16384个槽，编号0-16383（0-2^14-1）。<strong>这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点</strong>。集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取余，余数是几key就落入对应的槽里。slot &#x3D; CRC16(key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p><p> <strong>哈希槽计算</strong></p><p>Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。如下代码，key之A 、B在Node2， key之C落在Node3上。</p><p><img src="/2022/08/06/Docker/clip_image004-16658095468545.jpg" alt="graphic"><img src="/2022/08/06/Docker/clip_image006.jpg" alt="graphic"></p><h4 id="1-2-2、3主3从redis集群扩缩容配置案例架构说明"><a href="#1-2-2、3主3从redis集群扩缩容配置案例架构说明" class="headerlink" title="1.2.2、3主3从redis集群扩缩容配置案例架构说明"></a>1.2.2、3主3从redis集群扩缩容配置案例架构说明</h4><h5 id="3主3从redis集群配置"><a href="#3主3从redis集群配置" class="headerlink" title="3主3从redis集群配置"></a>3主3从redis集群配置</h5><ul><li>关闭防火墙+启动docker后台服务</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">docker start docker</span><br></pre></td></tr></table></figure><ul><li>新建6个docker容器redis实例</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis-node-1 --net host --privileged=true -v /data/redis/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-2 --net host --privileged=true -v /data/redis/share/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-3 --net host --privileged=true -v /data/redis/share/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-4 --net host --privileged=true -v /data/redis/share/redis-node-4:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-5 --net host --privileged=true -v /data/redis/share/redis-node-5:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6385</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-6 --net host --privileged=true -v /data/redis/share/redis-node-6:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386</span><br></pre></td></tr></table></figure><p><strong>如果运行成功，效果如下：</strong></p><p><img src="/2022/08/06/Docker/image-20221015134934504.png" alt="image-20221015134934504"></p><blockquote><p>#创建并运行docker容器实例</p><p>docker run</p><p>#容器名字</p><p>–name redis-node-6</p><p>#使用宿主机的IP和端口，默认</p><p>–net host</p><p>#获取宿主机root用户权限</p><p>–privileged&#x3D;true</p><p>#容器卷，宿主机地址:docker内部地址</p><p>-v &#x2F;data&#x2F;redis&#x2F;share&#x2F;redis-node-6:&#x2F;data</p><p>#redis镜像和版本号</p><p>redis:6.0.8</p><p>#开启redis集群</p><p>–cluster-enabled yes</p><p>#开启持久化</p><p>–appendonly yes</p><p>#redis端口号</p><p>–port 6386</p></blockquote><ul><li>进入容器redis-node-1并为6台机器构建集群关系</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua ~]# docker exec -it redis-node-1 /bin/bash</span><br><span class="line">root@hua:/data# redis-cli --cluster create 192.168.182.129:6381 192.168.182.129:6382 192.168.182.129:6383 192.168.182.129:6384 192.168.182.129:6385 192.168.182.129:6386 --cluster-replicas 1</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 192.168.182.129:6385 to 192.168.182.129:6381</span><br><span class="line">Adding replica 192.168.182.129:6386 to 192.168.182.129:6382</span><br><span class="line">Adding replica 192.168.182.129:6384 to 192.168.182.129:6383</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span></span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: ca047127cc88177ace8529eec236c99735aa29cf 192.168.182.129:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 84da5624cbdaa8ea4b25be089b89aecc377c3d90 192.168.182.129:6382</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00 192.168.182.129:6383</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 59f62200185f23135a791505f2122da5c38b417a 192.168.182.129:6384</span><br><span class="line">   replicates 1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00</span><br><span class="line">S: f39c163fabdcc288c01202609aeb082427e257a7 192.168.182.129:6385</span><br><span class="line">   replicates ca047127cc88177ace8529eec236c99735aa29cf</span><br><span class="line">S: 36b3aeacc83ab768c73471fec37adfdb6c3fb4a5 192.168.182.129:6386</span><br><span class="line">   replicates 84da5624cbdaa8ea4b25be089b89aecc377c3d90</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Sending CLUSTER MEET messages to <span class="built_in">join</span> the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><strong>–cluster-replicas 1 表示为每个master创建一个slave节点</strong></p><ul><li><p>一切OK的话，3主3从搞定</p></li><li><p>链接进入6381作为切入点，查看集群状态</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@hua:/data# redis-cli -p 6381 -c</span><br><span class="line">127.0.0.1:6381&gt; cluster info</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:170</span><br><span class="line">cluster_stats_messages_pong_sent:173</span><br><span class="line">cluster_stats_messages_sent:343</span><br><span class="line">cluster_stats_messages_ping_received:168</span><br><span class="line">cluster_stats_messages_pong_received:170</span><br><span class="line">cluster_stats_messages_meet_received:5</span><br><span class="line">cluster_stats_messages_received:343</span><br></pre></td></tr></table></figure><ul><li>链接进入6381作为切入点，查看节点状态</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt;  cluster nodes</span><br><span class="line"></span><br><span class="line">1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00 192.168.182.129:6383@16383 master - 0 1665810893011 3 connected 10923-16383</span><br><span class="line"></span><br><span class="line">84da5624cbdaa8ea4b25be089b89aecc377c3d90 192.168.182.129:6382@16382 master - 0 1665810891000 2 connected 5461-10922</span><br><span class="line"></span><br><span class="line">ca047127cc88177ace8529eec236c99735aa29cf 192.168.182.129:6381@16381 myself,master - 0 1665810890000 1 connected 0-5460</span><br><span class="line"></span><br><span class="line">59f62200185f23135a791505f2122da5c38b417a 192.168.182.129:6384@16384 slave 1c5a4ebddbd b9305e8fe2b02a43a6a84193d4c00 0 1665810890001 3 connected</span><br><span class="line"></span><br><span class="line">f39c163fabdcc288c01202609aeb082427e257a7 192.168.182.129:6385@16385 slave ca047127cc8                       8177ace8529eec236c99735aa29cf 0 1665810891004 1 connected</span><br><span class="line"></span><br><span class="line">36b3aeacc83ab768c73471fec37adfdb6c3fb4a5 192.168.182.129:6386@16386 slave 84da5624cbd                       aa8ea4b25be089b89aecc377c3d90 0 1665810892008 2 connected</span><br></pre></td></tr></table></figure><h5 id="主从容错切换迁移案例"><a href="#主从容错切换迁移案例" class="headerlink" title="主从容错切换迁移案例"></a>主从容错切换迁移案例</h5><p><strong>数据读写存储</strong></p><ul><li><p>启动6机构成的集群并通过exec进入</p></li><li><p>对6381新增两个key</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt; set k1 v1</span><br><span class="line">(error) MOVED 12706 192.168.182.129:6383</span><br><span class="line">127.0.0.1:6381&gt; exit</span><br></pre></td></tr></table></figure><p>防止路由失效加参数-c并新增两个key</p><p><strong>加入参数-c，优化路由</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@hua:/data# redis-cli -p 6381 -c</span><br><span class="line">127.0.0.1:6381&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6381&gt; set k1 v1</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [12706] located at 192.168.182.129:6383</span></span><br><span class="line">OK</span><br><span class="line">192.168.182.129:6383&gt; keys *</span><br><span class="line">1) &quot;k1&quot;</span><br></pre></td></tr></table></figure><ul><li>查看集群信息</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@hua:/data# redis-cli --cluster check 192.168.182.129:6381</span><br><span class="line">192.168.182.129:6381 (ca047127...) -&gt; 2 keys | 5461 slots | 1 slaves.</span><br><span class="line">192.168.182.129:6383 (1c5a4ebd...) -&gt; 1 keys | 5461 slots | 1 slaves.</span><br><span class="line">192.168.182.129:6382 (84da5624...) -&gt; 1 keys | 5462 slots | 1 slaves.</span><br><span class="line">[OK] 4 keys in 3 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node 192.168.182.129:6381)</span></span><br><span class="line">M: ca047127cc88177ace8529eec236c99735aa29cf 192.168.182.129:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00 192.168.182.129:6383</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 84da5624cbdaa8ea4b25be089b89aecc377c3d90 192.168.182.129:6382</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 59f62200185f23135a791505f2122da5c38b417a 192.168.182.129:6384</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00</span><br><span class="line">S: f39c163fabdcc288c01202609aeb082427e257a7 192.168.182.129:6385</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates ca047127cc88177ace8529eec236c99735aa29cf</span><br><span class="line">S: 36b3aeacc83ab768c73471fec37adfdb6c3fb4a5 192.168.182.129:6386</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 84da5624cbdaa8ea4b25be089b89aecc377c3d90</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p><strong>容错切换迁移</strong></p><ul><li>主6381和从机切换，先停止主机6381</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop redis-node-1</span><br></pre></td></tr></table></figure><ul><li><p>6381主机停了，对应的真实从机上位</p></li><li><p>查看集群信息</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua ~]# docker stop redis-node-1</span><br><span class="line">redis-node-1</span><br><span class="line">[root@hua ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND                  CREATED             STATUS             PORTS     NAMES</span><br><span class="line">ef5c8dc0e4e3   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-6</span><br><span class="line">fef20b91d661   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-5</span><br><span class="line">7dce83d92716   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-4</span><br><span class="line">720512c556a2   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-3</span><br><span class="line">4c69a4a36031   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-2</span><br><span class="line">[root@hua ~]# docker exec -it redis-node-2 bash</span><br><span class="line">root@hua:/data# redis-cli -p 6382 -c</span><br><span class="line">127.0.0.1:6382&gt; cluster nodes</span><br><span class="line">ca047127cc88177ace8529eec236c99735aa29cf 192.168.182.129:6381@16381 master,fail - 1665813882486 1665813878000 1 disconnected</span><br><span class="line">59f62200185f23135a791505f2122da5c38b417a 192.168.182.129:6384@16384 slave 1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00 0 1665813965945 3 connected</span><br><span class="line">36b3aeacc83ab768c73471fec37adfdb6c3fb4a5 192.168.182.129:6386@16386 slave 84da5624cbdaa8ea4b25be089b89aecc377c3d90 0 1665813963937 2 connected</span><br><span class="line">1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00 192.168.182.129:6383@16383 master - 0 1665813965000 3 connected 10923-16383</span><br><span class="line">84da5624cbdaa8ea4b25be089b89aecc377c3d90 192.168.182.129:6382@16382 myself,master - 0 1665813964000 2 connected 5461-10922</span><br><span class="line">f39c163fabdcc288c01202609aeb082427e257a7 192.168.182.129:6385@16385 master - 0 1665813962000 7 connected 0-5460</span><br><span class="line">127.0.0.1:6382&gt; get k2</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [449] located at 192.168.182.129:6385</span></span><br><span class="line">&quot;v2&quot;</span><br><span class="line">192.168.182.129:6385&gt; exit</span><br></pre></td></tr></table></figure><p>6381宕机了，6385上位成为了新的master。</p><ul><li>先还原之前的3主3从</li><li>重启6381</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua ~]# docker start redis-node-1</span><br><span class="line">redis-node-1</span><br><span class="line">[root@hua ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND                  CREATED             STATUS             PORTS     NAMES</span><br><span class="line">ef5c8dc0e4e3   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-6</span><br><span class="line">fef20b91d661   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-5</span><br><span class="line">7dce83d92716   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-4</span><br><span class="line">720512c556a2   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-3</span><br><span class="line">4c69a4a36031   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up About an hour             redis-node-2</span><br><span class="line">243752f0641f   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   About an hour ago   Up 9 seconds                 redis-node-1</span><br><span class="line">[root@hua ~]# docker exec -it redis-node-1 bash</span><br><span class="line">root@hua:/data# redis-cli -p 6381 -c</span><br><span class="line">127.0.0.1:6381&gt; cluster nodes</span><br><span class="line">84da5624cbdaa8ea4b25be089b89aecc377c3d90 192.168.182.129:6382@16382 master - 0 1665814203000 2 connected 5461-10922</span><br><span class="line">59f62200185f23135a791505f2122da5c38b417a 192.168.182.129:6384@16384 slave 1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00 0 1665814204000 3 connected</span><br><span class="line">36b3aeacc83ab768c73471fec37adfdb6c3fb4a5 192.168.182.129:6386@16386 slave 84da5624cbdaa8ea4b25be089b89aecc377c3d90 0 1665814206446 2 connected</span><br><span class="line">1c5a4ebddbdb9305e8fe2b02a43a6a84193d4c00 192.168.182.129:6383@16383 master - 0 1665814204436 3 connected 10923-16383</span><br><span class="line">ca047127cc88177ace8529eec236c99735aa29cf 192.168.182.129:6381@16381 myself,slave f39c163fabdcc288c01202609aeb082427e257a7 0 1665814203000 7 connected</span><br><span class="line">f39c163fabdcc288c01202609aeb082427e257a7 192.168.182.129:6385@16385 master - 0 1665814205441 7 connected 0-5460</span><br></pre></td></tr></table></figure><p><strong>可以看到，重启后的6381变为6385的从机。</strong></p><ul><li>切换至之前的3主3从，只需将6385主机进行重启，6381又会重新变为主机。</li></ul><h5 id="主从扩容案例"><a href="#主从扩容案例" class="headerlink" title="主从扩容案例"></a>主从扩容案例</h5><ul><li>新建6387、6388两个节点+新建后启动+查看是否8节点</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis-node-7 --net host --privileged=true -v /data/redis/share/redis-node-7:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6387</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-8 --net host --privileged=true -v /data/redis/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388</span><br><span class="line"></span><br><span class="line">[root@hua ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND                  CREATED          STATUS                                                                                                      PORTS     NAMES</span><br><span class="line">733b0742469b   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   9 seconds ago    Up 8 seconds                                                                                                          redis-node-8</span><br><span class="line">8cafa60f7a2a   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   29 seconds ago   Up 29 seconds                                                                                                         redis-node-7</span><br><span class="line">ef5c8dc0e4e3   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   2 hours ago      Up 2 hours                                                                                                            redis-node-6</span><br><span class="line">fef20b91d661   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   2 hours ago      Up 33 minutes                                                                                                         redis-node-5</span><br><span class="line">7dce83d92716   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   2 hours ago      Up 2 hours                                                                                                            redis-node-4</span><br><span class="line">720512c556a2   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   2 hours ago      Up 2 hours                                                                                                            redis-node-3</span><br><span class="line">4c69a4a36031   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   2 hours ago      Up 2 hours                                                                                                            redis-node-2</span><br><span class="line">243752f0641f   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   2 hours ago      Up 38 minutes                                                                                                         redis-node-1</span><br></pre></td></tr></table></figure><ul><li>进入6387容器实例内部</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it redis-node-7 /bin/bash</span><br></pre></td></tr></table></figure><ul><li>将新增的6387节点(空槽号)作为master节点加入原集群</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将新增的6387作为master节点加入集群</span></span><br><span class="line">edis-cli --cluster add-node 自己实际IP地址:6387 自己实际IP地址:6381</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6387 就是将要作为master新增节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6381 就是原来集群节点里面的领路人，相当于6387拜拜6381的码头从而找到组织加入集群</span></span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/image-20221015154912081.png" alt="image-20221015154912081"></p><ul><li>重新分派槽号</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新分派槽号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令:redis-cli --cluster reshard IP地址:端口号</span></span><br><span class="line">redis-cli --cluster reshard 192.168.182.129:6381</span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/image-20221015155045924.png" alt="image-20221015155045924"></p><p><img src="/2022/08/06/Docker/image-20221015155059217.png" alt="image-20221015155059217"></p><ul><li>检查集群情况</li></ul><p><img src="/2022/08/06/Docker/image-20221015155243267.png" alt="image-20221015155243267"></p><blockquote><p>槽号分派说明</p><p>为什么6387是3个新的区间，以前的还是连续？</p><p>重新分配成本太高，所以前3家各自匀出来一部分，从6381&#x2F;6382&#x2F;6383三个旧节点分别匀出1364个坑位给新节点6387。</p></blockquote><ul><li>为主节点6387分配从节点6388</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令：redis-cli --cluster add-node ip:新slave端口 ip:新master端口 --cluster-slave --cluster-master-id 新主机节点ID</span></span><br><span class="line"></span><br><span class="line">redis-cli --cluster add-node 192.168.182.129:6388 192.168.182.129:6387 --cluster-slave --cluster-master-id 2551cec91dba763fcf3a7f00727cacff463dec57-------这个是6387的编号，按照自己实际情况</span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/image-20221015155706840.png" alt="image-20221015155706840"></p><h5 id="主从缩容案例"><a href="#主从缩容案例" class="headerlink" title="主从缩容案例"></a>主从缩容案例</h5><p>目的：6387和6388下线</p><p>步骤：先删除从机6388；再重新分配槽点；再删除主机6387；</p><ul><li><p>检查集群情况获得6388的节点ID</p></li><li><p>将6388删除 从集群中将4号从节点6388删除</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">命令：redis-cli  --cluster del-node ip:从机端口 从机6388节点ID</span><br><span class="line"></span><br><span class="line">root@hua:/data# redis-cli --cluster del-node 192.168.182.129:6388 ef399e48add1979652435de01c7c0fe7abb4051e</span><br></pre></td></tr></table></figure><p> <code>redis-cli  --cluster check 192.168.182.129:6382  </code></p><p> 检查一下发现，6388被删除了，只剩下7台机器了。</p><p><img src="/2022/08/06/Docker/image-20221015160225738.png" alt="image-20221015160225738"></p><ul><li>将6387的槽号清空，重新分配，本例将清出来的槽号都给6381</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard 192.168.182.129:6381</span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/clip_image008.jpg" alt="graphic"></p><p><img src="/2022/08/06/Docker/clip_image010.jpg" alt="graphic"></p><p><img src="/2022/08/06/Docker/clip_image012.jpg" alt="graphic"></p><ul><li>检查集群情况</li></ul><p> 4096个槽位都指给6381，它变成了8192个槽位，相当于全部都给6381了，不然要输入3次，一锅端。</p><p><img src="/2022/08/06/Docker/image-20221015160526037.png" alt="image-20221015160526037"></p><ul><li>将6387删除</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令：redis-cli  --cluster del-node ip:端口 6387节点ID</span>     </span><br><span class="line">redis-cli --cluster del-node 192.168.182.129:6387  2551cec91dba763fcf3a7f00727cacff463dec57</span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/image-20221015160654248.png" alt="image-20221015160654248"></p><h2 id="2、DockerFile解析"><a href="#2、DockerFile解析" class="headerlink" title="2、DockerFile解析"></a>2、<strong>DockerFile</strong>解析</h2><h3 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h3><p>·    Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p><p><img src="/2022/08/06/Docker/clip_image002-16658845802211.jpg" alt="graphic"></p><p>官网</p><p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><p>构建三步骤</p><ul><li>编写Dockerfile文件</li><li>docker build命令构建镜像</li><li>docker run依镜像运行容器实例</li></ul><h3 id="2-2、DockerFile构建过程解析"><a href="#2-2、DockerFile构建过程解析" class="headerlink" title="2.2、DockerFile构建过程解析"></a>2.2、<strong>DockerFile构建过程解析</strong></h3><p>Dockerfile内容基础知识</p><ol><li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层并对镜像进行提交</li></ol><p>Docker执行Dockerfile的大致流程</p><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器作出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个新容器</li><li>执行dockerfile中的下一条指令直到所有指令都执行完成</li></ol><p><strong>小总结</strong></p><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p><ul><li>Dockerfile是软件的原材料</li><li>Docker镜像是软件的交付品</li><li>Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例</li></ul><p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p><p><img src="/2022/08/06/Docker/clip_image002-16658847063063.jpg" alt="graphic"></p><ol><li>Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</li><li>Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时会真正开始提供服务;</li><li>Docker容器，容器是直接提供服务的。</li></ol><h3 id="2-3、DockerFile常用保留字指令"><a href="#2-3、DockerFile常用保留字指令" class="headerlink" title="2.3、DockerFile常用保留字指令"></a>2.3、<strong>DockerFile常用保留字指令</strong></h3><p>参考tomcat8的dockerfile入——<a href="https://github.com/docker-library/tomcat">https://github.com/docker-library/tomcat</a></p><ul><li><code>FROM</code></li></ul><p>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from</p><ul><li><code>MAINTAINER</code></li></ul><p>镜像维护者的姓名和邮箱地址</p><ul><li><code>RUN</code></li></ul><p>容器构建时需要运行的命令</p><p>两种格式</p><ol><li>shell格式</li></ol><p><img src="/2022/08/06/Docker/clip_image002-16658848772485.jpg" alt="graphic"></p><p>例：<code>RUN yum -y install vim</code></p><p>​2. exec格式</p><p><img src="/2022/08/06/Docker/clip_image004-16658848772486.jpg" alt="graphic"></p><p><strong>RUN是在 docker build时运行</strong></p><ul><li><code>EXPOSE</code></li></ul><p>当前容器对外暴露出的端口</p><ul><li><code>WORKDIR</code></li></ul><p>指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p><ul><li><code>USER</code></li></ul><p>指定该镜像以什么样的用户去执行，如果都不指定，默认是root</p><ul><li><code>ENV</code></li></ul><p>用来在构建镜像过程中设置环境变量</p><p>例·：<code>ENV MY_PATH /usr/mytest</code></p><p>这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；</p><p>也可以在其它指令中直接使用这些环境变量，</p><p>比如：<code>WORKDIR $MY_PATH</code></p><ul><li><code>ADD</code></li></ul><p>将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</p><ul><li><code>COPY</code></li></ul><p>类似ADD，拷贝文件和目录到镜像中。 将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</p><p>例：<code>COPY src dest</code></p><p><code>COPY [&quot;src&quot;, &quot;dest&quot;]</code></p><p>&lt;src源路径&gt;：源文件或者源目录</p><p>&lt;dest目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><ul><li><code>VOLUME</code></li></ul><p>容器数据卷，用于数据保存和持久化工作</p><ul><li><code>CMD</code></li></ul><p>指定容器启动后的要干的事情</p><p><img src="/2022/08/06/Docker/clip_image006.gif" alt="graphic"></p><p><strong>注意</strong></p><blockquote><p>Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p></blockquote><p>参考官网Tomcat的dockerfile演示讲解</p><p>官网最后一行命令</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="/2022/08/06/Docker/clip_image008-16658848772487.jpg" alt="img"></td></tr></tbody></table><p>我们演示自己的覆盖操作</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="/2022/08/06/Docker/clip_image010-16658848772499.jpg" alt="img"></td></tr></tbody></table><p><strong>它和前面RUN命令的区别</strong></p><p><strong>CMD是在docker run 时运行。</strong></p><p><strong>RUN是在 docker build时运行。</strong></p><ul><li>ENTRYPOINT</li></ul><p>也是用来指定一个容器启动时要运行的命令，类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖， 而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序</p><p>命令格式和案例说明0</p><p>命令格式：<img src="/2022/08/06/Docker/clip_image012-16658848772498.jpg" alt="graphic"></p><p>ENTRYPOINT可以和CMD一起用，一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参。</p><p>当指定了ENTRYPOINT后，CMD的含义就发生了变化，不再是直接运行其命令而是将CMD的内容作为参数传递给ENTRYPOINT指令，他两个组合会变成<img src="/2022/08/06/Docker/clip_image013.jpg" alt="graphic"></p><p>案例如下：假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><p><img src="/2022/08/06/Docker/clip_image014.jpg" alt="graphic"></p><table><thead><tr><th>是否传参</th><th>按照dockerfile编写执行</th><th>传参运行</th></tr></thead><tbody><tr><td>Docker命令</td><td>docker run   nginx:test</td><td>docker run   nginx:test -c &#x2F;etc&#x2F;nginx&#x2F;new.conf</td></tr><tr><td>衍生出的实际命令</td><td>nginx -c  &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</td><td>nginx -c  &#x2F;etc&#x2F;nginx&#x2F;new.conf</td></tr></tbody></table><p><strong>优点</strong></p><p>在执行docker run的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p>注意</p><blockquote><p>如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p></blockquote><p><strong>小总结</strong></p><p><img src="/2022/08/06/Docker/clip_image016.jpg" alt="graphic"></p><h3 id="2-4、案例"><a href="#2-4、案例" class="headerlink" title="2.4、案例"></a>2.4、案例</h3><ul><li><p>自定义镜像mycentosjava8</p><ul><li><p>要求</p></li><li><p>Centos7镜像具备vim+ifconfig+jdk8</p></li><li><p>JDK的下载镜像地址</p></li></ul></li><li><p>官网</p></li></ul><p> 下载地址：</p><p><a href="https://www.oracle.com/java/technologies/downloads/#java8">https://www.oracle.com/java/technologies/downloads/#java8</a></p><p><img src="/2022/08/06/Docker/clip_image002-166588543087419.jpg" alt="graphic"></p><p><a href="https://mirrors.yangxingzhen.com/jdk/">https://mirrors.yangxingzhen.com/jdk/</a></p><ul><li>编写<ul><li>准备编写Dockerfile文件</li></ul></li></ul><p><img src="/2022/08/06/Docker/clip_image004-166588543087420.jpg" alt="graphic"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER zzyy&lt;zzyybs@126.com&gt;</span><br><span class="line"> </span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"> </span><br><span class="line">#安装vim编辑器</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">#安装ifconfig命令查看网络IP</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line">#安装java8及lib库</span><br><span class="line">RUN yum -y install glibc.i686</span><br><span class="line">RUN mkdir /usr/local/java</span><br><span class="line">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/</span><br><span class="line">#配置java环境变量</span><br><span class="line">ENV JAVA_HOME /usr/local/java/jdk1.8.0_171</span><br><span class="line">ENV JRE_HOME $JAVA_HOME/jre</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"> </span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;success--------------ok&quot;</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><ul><li>构建</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t 新镜像名字:TAG .</span><br><span class="line"></span><br><span class="line">docker build -t centosjava8:1.5 .</span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/clip_image006-166588543087522.jpg" alt="graphic"></p><p><img src="/2022/08/06/Docker/clip_image008-166588543087421.jpg" alt="graphic"></p><p><strong>注意，上面TAG后面有个空格，有个点</strong></p><ul><li>运行</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it 新镜像名字:TAG</span><br><span class="line"></span><br><span class="line">docker run -it centosjava8:1.5 /bin/bash</span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/clip_image010-166588543087523.jpg" alt="graphic"></p><ul><li>再体会下UnionFS（联合文件系统）</li></ul><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对<strong>文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。<strong>镜像可以通过分层来进行继承</strong>，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p><img src="/2022/08/06/Docker/clip_image012-166588543087524.jpg" alt="graphic"> </p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h2 id="3、Docker微服务实战"><a href="#3、Docker微服务实战" class="headerlink" title="3、Docker微服务实战"></a>3、Docker微服务实战</h2><h3 id="3-1、通过IDEA新建一个普通微服务模块"><a href="#3-1、通过IDEA新建一个普通微服务模块" class="headerlink" title="3.1、通过IDEA新建一个普通微服务模块"></a>3.1、通过IDEA新建一个普通微服务模块</h3><ul><li>建Module</li></ul><p><img src="/2022/08/06/Docker/image-20221016133208866.png" alt="image-20221016133208866"></p><ul><li>改POM</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;DockerBoot&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;DockerBoot&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;DockerBoot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;<span class="number">1.8</span>&lt;/java.version&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-<span class="number">8</span>&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;spring-boot.version&gt;<span class="number">2.3</span><span class="number">.7</span>.RELEASE&lt;/spring-boot.version&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">1.8</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">1.8</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;junit.version&gt;<span class="number">4.12</span>&lt;/junit.version&gt;</span><br><span class="line">        &lt;log4j.version&gt;<span class="number">1.2</span><span class="number">.17</span>&lt;/log4j.version&gt;</span><br><span class="line">        &lt;lombok.version&gt;<span class="number">1.16</span><span class="number">.18</span>&lt;/lombok.version&gt;</span><br><span class="line">        &lt;mysql.version&gt;<span class="number">5.1</span><span class="number">.47</span>&lt;/mysql.version&gt;</span><br><span class="line">        &lt;druid.version&gt;<span class="number">1.1</span><span class="number">.16</span>&lt;/druid.version&gt;</span><br><span class="line">        &lt;mapper.version&gt;<span class="number">4.1</span><span class="number">.5</span>&lt;/mapper.version&gt;</span><br><span class="line">        &lt;mybatis.spring.boot.version&gt;<span class="number">1.3</span><span class="number">.0</span>&lt;/mybatis.spring.boot.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--SpringBoot通用依赖模块--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--test--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">3.8</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;<span class="number">1.8</span>&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;<span class="number">1.8</span>&lt;/target&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-<span class="number">8</span>&lt;/encoding&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">2.3</span><span class="number">.7</span>.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;mainClass&gt;com.example.dockerboot.DockerBootApplication&lt;/mainClass&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;repackage&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><ul><li>写YML</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6001</span></span><br></pre></td></tr></table></figure><ul><li>主启动类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.dockerboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DockerBootApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DockerBootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.dockerboot.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/10/16 13:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/order/docker&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">helloDocker</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello docker&quot;</span>+<span class="string">&quot;\t&quot;</span>+port+<span class="string">&quot;\t&quot;</span>+ UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value =&quot;/order/index&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;服务端口号: &quot;</span>+<span class="string">&quot;\t&quot;</span>+port+<span class="string">&quot;\t&quot;</span>+UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、通过dockerfile发布微服务部署到docker容器"><a href="#3-2、通过dockerfile发布微服务部署到docker容器" class="headerlink" title="3.2、通过dockerfile发布微服务部署到docker容器"></a>3.2、通过dockerfile发布微服务部署到docker容器</h3><ul><li>打包之后上传到mydocker文件下</li></ul><p><img src="/2022/08/06/Docker/image-20221016133559133.png" alt="image-20221016133559133"></p><p><img src="/2022/08/06/Docker/image-20221016133623282.png" alt="image-20221016133623282"></p><ul><li>将微服务jar包和Dockerfile文件放到到同一个目录下&#x2F;mydocker，然后构建镜像</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua mydocker]# vim Dockerfile</span><br><span class="line">[root@hua mydocker]# docker build -t zzyy_docker:1.6 .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基础镜像使用java</span></span><br><span class="line">FROM java:8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">作者</span></span><br><span class="line">MAINTAINER zzyy</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span></span><br><span class="line">VOLUME /tmp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将jar包添加到容器中并更名为zzyy_docker.jar</span></span><br><span class="line">ADD DockerBoot-0.0.1-SNAPSHOT.jar zzyy_docker.jar</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行jar包</span></span><br><span class="line">RUN bash -c &#x27;touch /zzyy_docker.jar&#x27;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">暴露6001端口作为微服务</span></span><br><span class="line">EXPOSE 6001</span><br></pre></td></tr></table></figure><ul><li>运行容器</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6001:6001 zzyy_docker:1.6</span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/image-20221016134034413.png" alt="image-20221016134034413"></p><ul><li>测试——<a href="http://192.168.182.129:6001/order/docker">192.168.182.129:6001&#x2F;order&#x2F;docker</a></li></ul><p><img src="/2022/08/06/Docker/image-20221016134105082.png" alt="image-20221016134105082"></p><h2 id="4、Docker网络"><a href="#4、Docker网络" class="headerlink" title="4、Docker网络"></a>4、Docker网络</h2><h3 id="4-1、概述"><a href="#4-1、概述" class="headerlink" title="4.1、概述"></a>4.1、概述</h3><ol><li>docker不启动，默认网络情况</li></ol><p><img src="/2022/08/06/Docker/clip_image002-166590512161757.jpg" alt="graphic"></p><ul><li>ens33</li><li>lo</li><li>virbr0</li></ul><p>在CentOS7的安装过程中如果有选择相关虚拟化的的服务安装系统后，启动网卡时会发现有一个以网桥连接的私网地址的virbr0网卡(virbr0网卡：它还有一个固定的默认IP地址192.168.122.1)，是做虚拟机网桥的使用的，其作用是为连接其上的虚机网卡提供 NAT访问外网的功能。</p><p>我们之前学习Linux安装，勾选安装系统的时候附带了libvirt服务才会生成的一个东西，如果不需要可以直接将libvirtd服务卸载，<code>yum remove libvirt-libs.x86_64</code></p><p>​2. docker启动后，网络情况</p><p><strong>会产生一个名为docker0的虚拟网桥</strong></p><p><img src="/2022/08/06/Docker/clip_image004-166590512161758.jpg" alt="graphic"></p><p>​3. 查看docker网络模式命令</p><p>默认创建3大网络模式</p><p><img src="/2022/08/06/Docker/clip_image006-166590512161872.jpg" alt="graphic"></p><h3 id="4-2、常用基本命令"><a href="#4-2、常用基本命令" class="headerlink" title="4.2、常用基本命令"></a>4.2、常用基本命令</h3><ul><li>All命令</li></ul><p><img src="/2022/08/06/Docker/clip_image008-166590512161756.jpg" alt="graphic"></p><ul><li>查看网络</li></ul><p><code>docker network ls</code></p><ul><li>查看网络源数据</li></ul><p><code>docker network inspect XXX网络名字</code></p><ul><li>删除网络</li></ul><p><code>docker network rm XXX网络名字</code></p><ul><li>案例</li></ul><p><img src="/2022/08/06/Docker/clip_image010-166590512161771.jpg" alt="graphic"></p><h3 id="4-3、能干嘛"><a href="#4-3、能干嘛" class="headerlink" title="4.3、能干嘛"></a>4.3、能干嘛</h3><ul><li>容器间的互联和通信以及端口映射</li><li>容器IP变动时候可以通过服务名直接网络通信而不受到影响</li></ul><h3 id="4-4、网络模式"><a href="#4-4、网络模式" class="headerlink" title="4.4、网络模式"></a>4.4、网络模式</h3><ol><li>总体介绍</li></ol><p><img src="/2022/08/06/Docker/clip_image012-166590512161759.jpg" alt="graphic"></p><ul><li><p>bridge模式：使用–network bridge指定，默认使用docker0</p></li><li><p>host模式：使用–network host指定</p></li><li><p>none模式：使用–network none指定</p></li><li><p>container模式：使用–network container:NAME或者容器ID指定</p></li><li><p>容器实例内默认网络IP生产规则</p></li></ul><p>​2. 说明</p><ul><li>先启动两个ubuntu容器实例</li></ul><p><img src="/2022/08/06/Docker/clip_image014-166590512161761.jpg" alt="graphic"></p><ul><li><code>docker inspect 容器ID or 容器名字</code></li></ul><p><img src="/2022/08/06/Docker/clip_image016-166590512161760.jpg" alt="graphic"></p><ul><li>关闭u2实例，新建u3，查看ip变化</li></ul><p><img src="/2022/08/06/Docker/clip_image018-166590512161763.jpg" alt="graphic"></p><p>​3. 结论</p><p>docker容器内部的ip是有可能会发生改变的</p><p><strong>案例说明</strong></p><h4 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h4><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在内核层连通了其他的物理或虚拟网卡，这就<strong>将所有容器和本地主机都放到同一个物理网络。</strong>Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，<strong>让主机和容器之间可以通过网桥相互通信。</strong></p><p># 查看 bridge 网络的详细信息，并通过 grep 获取名称项</p><p><code>docker network inspect bridge | grep name</code></p><p><img src="/2022/08/06/Docker/clip_image020-166590512161765.jpg" alt="graphic"></p><p><code>ifconfig</code></p><p><img src="/2022/08/06/Docker/clip_image022-166590512161762.jpg" alt="graphic"></p><h5 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a><strong>案例说明</strong></h5><ol><li>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</li><li>docker run 的时候，没有指定network的话默认使用的网桥模式就是bridge，使用的就是docker0。在宿主机ifconfig,就可以看到docker0和自己create的network(后面讲)eth0，eth1，eth2……代表网卡一，网卡二，网卡三……，lo代表127.0.0.1，即localhost，inet addr用来表示网卡的IP地址</li><li>网桥docker0创建一对对等虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。<ol><li>整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair）；</li><li>每个容器实例内部也有一块网卡，每个接口叫eth0；</li><li>docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。</li></ol></li></ol><p> 通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。</p><p><img src="/2022/08/06/Docker/clip_image024-166590512161764.jpg" alt="graphic"></p><p><strong>代码</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8080  --name tomcat81 billygoo/tomcat8-jdk8</span><br><span class="line"></span><br><span class="line">docker run -d -p 8082:8080  --name tomcat82 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><ul><li>两两匹配验证</li></ul><p><img src="/2022/08/06/Docker/clip_image026-166590512161768.jpg" alt="graphic"></p><h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><h5 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h5><p>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。</p><h5 id="案例说明-1"><a href="#案例说明-1" class="headerlink" title="案例说明"></a>案例说明</h5><p>容器将不会获得一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。</p><p><img src="/2022/08/06/Docker/clip_image028-166590512161769.jpg" alt="graphic"></p><p><strong>代码</strong></p><ul><li>警告<code>docker run -d -p 8083:8080 --network host --name tomcat83 billygoo/tomcat8-jdk8</code></li></ul><p><img src="/2022/08/06/Docker/clip_image030-166590512161766.jpg" alt="graphic"></p><ul><li>问题：</li></ul><p>docke启动时总是遇见标题中的警告</p><ul><li>原因：</li></ul><p>docker启动时指定–network&#x3D;host或-net&#x3D;host，如果还指定了-p映射端口，那这个时候就会有此警告，并且通过-p设置的参数将不会起到任何作用，端口号会以主机端口号为主，重复时则递增。</p><ul><li>解决:</li></ul><p>解决的办法就是使用docker的其他网络模式，例如–network&#x3D;bridge，这样就可以解决问题，或者直接无视</p><ul><li>正确命令<code>docker run -d --network host --name tomcat83 billygoo/tomcat8-jdk8</code><ul><li>无之前的配对显示了，看容器实例内部</li></ul></li></ul><p><img src="/2022/08/06/Docker/clip_image032-166590512161767.jpg" alt="graphic"></p><ul><li>没有设置-p的端口映射了，如何访问启动的tomcat83？？</li></ul><p><code>http://宿主机IP:8080/</code></p><p>在CentOS里面用默认的火狐浏览器访问容器内的tomcat83看到访问成功，因为此时容器的IP借用主机的，所以容器共享宿主机网络IP，这样的好处是外部主机与容器可以直接通信。</p><h4 id="none"><a href="#none" class="headerlink" title="none"></a>none</h4><h5 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h5><p>在none模式下，并不为Docker容器进行任何网络配置。 </p><p>也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo</p><p>需要我们自己为Docker容器添加网卡、配置IP等。</p><ul><li>禁用网络功能，只有lo标识(就是127.0.0.1表示本地回环)</li></ul><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h5><p><code>docker run -d -p 8084:8080 --network none --name tomcat84 billygoo/tomcat8-jdk8</code></p><p> 进入容器内部查看</p><p><img src="/2022/08/06/Docker/clip_image034-166590512161770.jpg" alt="graphic"></p><p>在容器外部查看</p><p><img src="/2022/08/06/Docker/clip_image002-166590495099632.jpg" alt="graphic"></p><p><code>docker run -d -p 8084:8080 --network none --name tomcat84 billygoo/tomcat8-jdk8</code></p><h4 id="container"><a href="#container" class="headerlink" title="container"></a>container</h4><h5 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h5><p>container⽹络模式 </p><p>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p><p><img src="/2022/08/06/Docker/clip_image004-166590495099734.jpg" alt="graphic"></p><h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><ul><li>错误演示</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8085:8080 --name tomcat85 billygoo/tomcat8-jdk8</span><br><span class="line"></span><br><span class="line">docker run -d -p 8086:8080 --network container:tomcat85 --name tomcat86 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><ul><li>运行结果</li></ul><p><img src="/2022/08/06/Docker/clip_image008-166590495099733.jpg" alt="graphic"></p><blockquote><p>相当于tomcat86和tomcat85公用同一个ip同一个端口，导致端口冲突</p><p>本案例用tomcat演示不合适。。。演示坑。。。。。。o(╥﹏╥)o</p></blockquote><p>换一个镜像给大家演示，</p><ul><li>案例2——正确演示</li></ul><p>Alpine操作系统是一个面向安全的轻型 Linux发行版。</p><p>Alpine Linux 是一款独立的、非商业的通用 Linux 发行版，专为追求安全性、简单性和资源效率的用户而设计。 可能很多人没听说过这个 Linux 发行版本，但是经常用 Docker 的朋友可能都用过，因为他小，简单，安全而著称，所以作为基础镜像是非常好的一个选择，可谓是麻雀虽小但五脏俱全，镜像非常小巧，不到 6M的大小，所以特别适合容器打包。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name alpine1 alpine /bin/sh</span><br><span class="line"></span><br><span class="line">docker run -it --network container:alpine1 --name alpine2 alpine /bin/sh</span><br></pre></td></tr></table></figure><ul><li>运行结果，验证共用搭桥</li></ul><p><img src="/2022/08/06/Docker/clip_image012-166590495099737.jpg" alt="graphic"></p><ul><li>假如此时关闭alpine1，再看看alpine2</li></ul><p><img src="/2022/08/06/Docker/clip_image014-166590495099735.jpg" alt="graphic"></p><p>15: eth0@if16: 消失了。。。。。。关闭alpine1，再看看alpine2</p><p><img src="/2022/08/06/Docker/clip_image016-166590495099736.jpg" alt="graphic"></p><h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><ul><li>过时的link</li></ul><p><img src="/2022/08/06/Docker/clip_image018.jpg" alt="graphic"></p><h5 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h5><p><strong>before</strong></p><ul><li>案例</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8080  --name tomcat81 billygoo/tomcat8-jdk8</span><br><span class="line"></span><br><span class="line">docker run -d -p 8082:8080  --name tomcat82 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><p>上述成功启动并用docker exec进入各自容器实例内部</p><ul><li>问题</li></ul><p>按照IP地址ping是OK的</p><p><img src="/2022/08/06/Docker/clip_image020.jpg" alt="graphic"></p><p><img src="/2022/08/06/Docker/clip_image022.jpg" alt="graphic"></p><p>按照服务名ping结果???</p><p><img src="/2022/08/06/Docker/clip_image024.jpg" alt="graphic"></p><p><img src="/2022/08/06/Docker/clip_image026.jpg" alt="graphic"></p><p><strong>after</strong></p><p>案例</p><p>自定义桥接网络,自定义网络默认使用的是桥接网络bridge</p><ul><li>新建自定义网络</li></ul><p><img src="/2022/08/06/Docker/clip_image028.jpg" alt="graphic"></p><ul><li>新建容器加入上一步新建的自定义网络</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8080 --network zzyy_network --name tomcat81 billygoo/tomcat8-jdk8</span><br><span class="line"></span><br><span class="line">docker run -d -p 8082:8080 --network zzyy_network --name tomcat82 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><ul><li>互相ping测试</li></ul><p><img src="/2022/08/06/Docker/clip_image030.jpg" alt="graphic"></p><p><img src="/2022/08/06/Docker/clip_image032.jpg" alt="graphic"></p><ul><li>问题结论</li></ul><p>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p><p>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p><p>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p><h3 id="4-5、Docker平台架构图解"><a href="#4-5、Docker平台架构图解" class="headerlink" title="4.5、Docker平台架构图解"></a>4.5、Docker平台架构图解</h3><ul><li>整体说明</li></ul><p>从其架构和运行流程来看，Docker 是一个 C&#x2F;S 模式的架构，后端是一个松耦合架构，众多模块各司其职。 </p><p>Docker 运行的基本流程为：</p><ol><li>用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。</li><li>Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。</li><li>Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</li><li>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver将下载镜像以Graph的形式存储。</li><li>当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</li><li>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。</li><li>Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。</li></ol><ul><li>整体架构</li></ul><p><img src="/2022/08/06/Docker/clip_image034.jpg" alt="graphic"></p><h2 id="5、Docker-compose容器编排"><a href="#5、Docker-compose容器编排" class="headerlink" title="5、Docker-compose容器编排"></a>5、Docker-compose容器编排</h2><h3 id="5-1、是什么"><a href="#5-1、是什么" class="headerlink" title="5.1、是什么"></a>5.1、是什么</h3><p>Compose 是 Docker 公司推出的一个工具软件，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件docker-compose.yml，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动&#x2F;关闭这些容器。</p><p>Docker-Compose是Docker官方的开源项目， 负责实现对Docker容器集群的快速编排。</p><h3 id="5-2、能干嘛"><a href="#5-2、能干嘛" class="headerlink" title="5.2、能干嘛"></a>5.2、能干嘛</h3><p>docker建议我们每一个容器中只运行一个服务,因为docker容器本身占用资源极少,所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？</p><p>如果我需要同时部署好多个服务,难道要每个服务单独写Dockerfile然后在构建镜像,构建容器,这样累都累死了,所以docker官方给我们提供了docker-compose多服务部署的工具。</p><p>例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysql服务容器，redis服务器，注册中心eureka，甚至还包括负载均衡容器等等。。。。。。</p><p><strong>Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</strong> </p><p>可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p><h3 id="5-3、下载安装"><a href="#5-3、下载安装" class="headerlink" title="5.3、下载安装"></a>5.3、下载安装</h3><ul><li>官网</li></ul><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><ul><li>官网安装</li></ul><p><a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></p><ul><li>安装步骤</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua ~]# curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_">  % </span><span class="language-bash">Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:--  0:00:16 --:--:--     0</span><br><span class="line">100 12.1M  100 12.1M    0     0   610k      0  0:00:20  0:00:20 --:--:-- 3260k</span><br><span class="line">[root@hua ~]# chmod +x /usr/local/bin/docker-compose</span><br><span class="line">[root@hua ~]# docker-compose --version</span><br><span class="line">docker-compose version 1.29.2, build 5becea4c</span><br></pre></td></tr></table></figure><p><strong>卸载</strong></p><p><img src="/2022/08/06/Docker/image-20221017220946523.png" alt="image-20221017220946523"></p><h3 id="5-4、Compose核心概念"><a href="#5-4、Compose核心概念" class="headerlink" title="5.4、Compose核心概念"></a>5.4、Compose核心概念</h3><p><strong>一文件</strong></p><p><code>docker-compose.yml</code></p><p><strong>两要素</strong></p><ul><li>服务（service）</li></ul><p>一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器。</p><ul><li>工程（project）</li></ul><p>由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</p><h4 id="Compose使用的三个步骤"><a href="#Compose使用的三个步骤" class="headerlink" title="Compose使用的三个步骤"></a>Compose使用的三个步骤</h4><ul><li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件。</li><li>使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li><li>最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线。</li></ul><h3 id="5-5、常用命令"><a href="#5-5、常用命令" class="headerlink" title="5.5、常用命令"></a>5.5、常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看帮助</span></span><br><span class="line">docker-compose -h</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动所有docker-compose服务</span></span><br><span class="line">docker-compose up </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动所有docker-compose服务并后台运行</span></span><br><span class="line">docker-compose up -d  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止并删除容器、网络、卷、镜像。</span></span><br><span class="line">docker-compose down                         </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器实例内部  docker-compose <span class="built_in">exec</span> docker-compose.yml文件中写的服务<span class="built_in">id</span> /bin/bash</span></span><br><span class="line">docker-compose exec  yml里面的服务id  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">展示当前docker-compose编排过的运行的所有容器</span></span><br><span class="line">docker-compose ps   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">展示当前docker-compose编排过的容器进程</span></span><br><span class="line">docker-compose top        </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器输出日志</span></span><br><span class="line">docker-compose logs  yml里面的服务id    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查配置</span></span><br><span class="line">docker-compose config     </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查配置，有问题才有输出</span></span><br><span class="line">docker-compose config -q  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启服务</span></span><br><span class="line">docker-compose restart  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动服务</span></span><br><span class="line">docker-compose start   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止服务</span></span><br><span class="line">docker-compose stop      </span><br></pre></td></tr></table></figure><h3 id="5-6、Compose编排微服务"><a href="#5-6、Compose编排微服务" class="headerlink" title="5.6、Compose编排微服务"></a>5.6、Compose编排微服务</h3><h4 id="微服务测试"><a href="#微服务测试" class="headerlink" title="微服务测试"></a>微服务测试</h4><p>测试项目地址——<a href="https://gitee.com/tingting-hua/DockerBoot">TINGTING-HUA&#x2F;DockerBoot (gitee.com)</a></p><ul><li>SQL建表建库</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `sex` tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;性别 0=女 1=男 &#x27;</span>,</span><br><span class="line">  `deleted` tinyint(<span class="number">4</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标志，默认0不删除，1删除&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>改pom</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;DockerBoot&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;DockerBoot&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;DockerBoot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;<span class="number">1.8</span>&lt;/java.version&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-<span class="number">8</span>&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;spring-boot.version&gt;<span class="number">2.3</span><span class="number">.7</span>.RELEASE&lt;/spring-boot.version&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">1.8</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;<span class="number">1.8</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;junit.version&gt;<span class="number">4.12</span>&lt;/junit.version&gt;</span><br><span class="line">        &lt;log4j.version&gt;<span class="number">1.2</span><span class="number">.17</span>&lt;/log4j.version&gt;</span><br><span class="line">        &lt;lombok.version&gt;<span class="number">1.16</span><span class="number">.18</span>&lt;/lombok.version&gt;</span><br><span class="line">        &lt;mysql.version&gt;<span class="number">5.1</span><span class="number">.47</span>&lt;/mysql.version&gt;</span><br><span class="line">        &lt;druid.version&gt;<span class="number">1.1</span><span class="number">.16</span>&lt;/druid.version&gt;</span><br><span class="line">        &lt;mapper.version&gt;<span class="number">4.1</span><span class="number">.5</span>&lt;/mapper.version&gt;</span><br><span class="line">        &lt;mybatis.spring.boot.version&gt;<span class="number">1.3</span><span class="number">.0</span>&lt;/mybatis.spring.boot.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--guava Google 开源的 Guava 中自带的布隆过滤器--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">23.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- redisson --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.13</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--SpringBoot通用依赖模块--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--swagger2--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--SpringBoot与Redis整合依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--springCache--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--springCache连接池依赖包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- jedis --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--Mysql数据库驱动--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.1</span><span class="number">.47</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--SpringBoot集成druid连接池--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.1</span><span class="number">.10</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--mybatis-plus启动器--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.5</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 添加springboot对amqp的支持 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.10</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--通用基础配置junit/devtools/test/log4j/lombok/hutool--&gt;</span><br><span class="line">        &lt;!--hutool--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--persistence--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.persistence&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;persistence-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--通用Mapper--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mapper&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;mapper.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">3.8</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;<span class="number">1.8</span>&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;<span class="number">1.8</span>&lt;/target&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-<span class="number">8</span>&lt;/encoding&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">2.3</span><span class="number">.7</span>.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;mainClass&gt;com.example.dockerboot.DockerBootApplication&lt;/mainClass&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;repackage&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><ul><li>写yml</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.port=6001</span><br><span class="line">  # ========================alibaba.druid????=====================</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://192.168.182.129:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.druid.test-while-idle=false</span><br><span class="line">  # ========================redis????=====================</span><br><span class="line">spring.redis.database=0</span><br><span class="line">spring.redis.host=192.168.182.129</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">spring.redis.password=</span><br><span class="line">spring.redis.lettuce.pool.max-active=8</span><br><span class="line">spring.redis.lettuce.pool.max-wait=-1ms</span><br><span class="line">spring.redis.lettuce.pool.max-idle=8</span><br><span class="line">spring.redis.lettuce.pool.min-idle=0</span><br><span class="line">  # ========================mybatis????===================</span><br><span class="line">mybatis.mapper-locations=classpath:mapper/*.xml</span><br><span class="line">mybatis.type-aliases-package=com.example.dockerboot.pojo</span><br><span class="line">  # ========================swagger=====================</span><br><span class="line">spring.swagger2.enabled=true</span><br></pre></td></tr></table></figure><ul><li>使用Mybatis一键生成</li><li>主启动</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.dockerboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScans;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.dockerboot.mapper&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DockerBootApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DockerBootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…………….</p><ul><li><p>mvn package命令将微服务形成新的jar包 并上传到Linux服务器&#x2F;mydocker目录下</p></li><li><p>编写Dockerfile</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基础镜像使用java</span><br><span class="line">FROM java:8</span><br><span class="line"># 作者</span><br><span class="line">MAINTAINER zzyy</span><br><span class="line"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span><br><span class="line">VOLUME /tmp</span><br><span class="line"># 将jar包添加到容器中并更名为zzyy_docker.jar</span><br><span class="line">ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar</span><br><span class="line"># 运行jar包</span><br><span class="line">RUN bash -c &#x27;touch /zzyy_docker.jar&#x27;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;]</span><br><span class="line">#暴露6001端口作为微服务</span><br><span class="line">EXPOSE 6001</span><br></pre></td></tr></table></figure><p> <img src="/2022/08/06/Docker/image-20221017221724609.png" alt="image-20221017221724609"></p><ul><li>构建镜像</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t zzyy_docker:1.6 .</span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/image-20221017221909721.png" alt="image-20221017221909721"></p><h4 id="不用Compose"><a href="#不用Compose" class="headerlink" title="不用Compose"></a>不用<strong>Compose</strong></h4><ul><li>新建mysql容器实例</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p  3306:3306 --name mysql57 --privileged=true -v  /zzyyuse/mysql/conf:/etc/mysql/conf.d -v /zzyyuse/mysql/logs:/logs -v  /zzyyuse/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7  </span><br></pre></td></tr></table></figure><ul><li>进入mysql容器实例并新建库db2021+新建表t_user</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql57 /bin/bash</span><br><span class="line"></span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line">create database db2021;</span><br><span class="line"></span><br><span class="line">use db2021;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `t_user` (</span><br><span class="line">  `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户名&#x27;,</span><br><span class="line">  `password` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;,</span><br><span class="line">  `sex` TINYINT(4) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;性别 0=女 1=男 &#x27;,</span><br><span class="line">  `deleted` TINYINT(4) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志，默认0不删除，1删除&#x27;,</span><br><span class="line">  `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">  `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;;</span><br></pre></td></tr></table></figure><ul><li>单独的redis容器实例</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis608 --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d redis:6.0.8 redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><ul><li>微服务工程</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6001:6001 zzyy_docker:1.6</span><br></pre></td></tr></table></figure><ul><li>上面三个容器实例依次顺序启动成功</li></ul><p><img src="/2022/08/06/Docker/image-20221017222310328.png" alt="image-20221017222310328"></p><ul><li>swagger测试</li></ul><p><a href="http://192.168.182.129:6001/swagger-ui.html#/">http://192.168.182.129:6001/swagger-ui.html#/</a></p><p><img src="/2022/08/06/Docker/image-20221017222427440.png" alt="image-20221017222427440"></p><ul><li>添加数据</li></ul><p><img src="/2022/08/06/Docker/image-20221017222600311.png" alt="image-20221017222600311"></p><p>MySQL中数据</p><p><img src="/2022/08/06/Docker/image-20221017222629010.png" alt="image-20221017222629010"></p><p>Redis中数据</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua ~]# docker exec -it redis608 bash</span><br><span class="line">root@1ed8f848268b:/data# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;user:3&quot;</span><br><span class="line">2) &quot;user:2&quot;</span><br><span class="line">3) &quot;user:1&quot;</span><br><span class="line">127.0.0.1:6379&gt; get user:3</span><br><span class="line">&quot;&#123;\&quot;@class\&quot;:\&quot;com.example.dockerboot.pojo.User\&quot;,\&quot;id\&quot;:[\&quot;java.lang.Long\&quot;,3],\&quot;username\&quot;:\&quot;zzyy3\&quot;,\&quot;password\&quot;:\&quot;1b3f46\&quot;,\&quot;sex\&quot;:0,\&quot;deleted\&quot;:0,\&quot;updateTime\&quot;:[\&quot;java.util.Date\&quot;,1666013136000],\&quot;createTime\&quot;:[\&quot;java.util.Date\&quot;,1666013136000]&#125;&quot;</span><br><span class="line">127.0.0.1:6379&gt; get user:2</span><br><span class="line">&quot;&#123;\&quot;@class\&quot;:\&quot;com.example.dockerboot.pojo.User\&quot;,\&quot;id\&quot;:[\&quot;java.lang.Long\&quot;,2],\&quot;username\&quot;:\&quot;zzyy2\&quot;,\&quot;password\&quot;:\&quot;ec0d4a\&quot;,\&quot;sex\&quot;:0,\&quot;deleted\&quot;:0,\&quot;updateTime\&quot;:[\&quot;java.util.Date\&quot;,1666013136000],\&quot;createTime\&quot;:[\&quot;java.util.Date\&quot;,1666013136000]&#125;&quot;</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line">&quot;&#123;\&quot;@class\&quot;:\&quot;com.example.dockerboot.pojo.User\&quot;,\&quot;id\&quot;:[\&quot;java.lang.Long\&quot;,1],\&quot;username\&quot;:\&quot;zzyy1\&quot;,\&quot;password\&quot;:\&quot;9ea40c\&quot;,\&quot;sex\&quot;:1,\&quot;deleted\&quot;:0,\&quot;updateTime\&quot;:[\&quot;java.util.Date\&quot;,1666013135000],\&quot;createTime\&quot;:[\&quot;java.util.Date\&quot;,1666013135000]&#125;&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>上面成功了，有哪些问题?</p><ul><li><p>先后顺序要求固定，先mysql+redis才能微服务访问成功</p></li><li><p>多个run命令……</p></li><li><p>容器间的启停或宕机，有可能导致IP地址对应的容器实例变化，映射出错， 要么生产IP写死(可以但是不推荐)，要么通过服务调用</p></li></ul><h4 id="使用Compose"><a href="#使用Compose" class="headerlink" title="使用Compose"></a>使用Compose</h4><ul><li>在jar包的相同目录下编写docker-compose.yml文件</li></ul><p><img src="/2022/08/06/Docker/image-20221018204058333.png" alt="image-20221018204058333"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"> # 相当于docker run -d -p 6001:6001 -v /app/microService:/data</span><br><span class="line">--network atguigu_net –name ms01 zzyy_docker:1.6 </span><br><span class="line">services:</span><br><span class="line">  microService:</span><br><span class="line">    image: zzyy_docker:1.6</span><br><span class="line">    container_name: ms01</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6001:6001&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - /app/microService:/data</span><br><span class="line">    networks: </span><br><span class="line">      - atguigu_net </span><br><span class="line">#依赖于（启动前提）</span><br><span class="line">    depends_on: </span><br><span class="line">      - redis</span><br><span class="line">      - mysql</span><br><span class="line"> </span><br><span class="line">  redis:</span><br><span class="line">    image: redis:6.0.8</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - /app/redis/redis.conf:/etc/redis/redis.conf</span><br><span class="line">      - /app/redis/data:/data</span><br><span class="line">    networks: </span><br><span class="line">      - atguigu_net</span><br><span class="line">    command: redis-server /etc/redis/redis.conf</span><br><span class="line"> </span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: &#x27;123456&#x27;</span><br><span class="line">      MYSQL_ALLOW_EMPTY_PASSWORD: &#x27;no&#x27;</span><br><span class="line">      MYSQL_DATABASE: &#x27;db2021&#x27;</span><br><span class="line">      MYSQL_USER: &#x27;zzyy&#x27;</span><br><span class="line">      MYSQL_PASSWORD: &#x27;zzyy123&#x27;</span><br><span class="line">    ports:</span><br><span class="line">       - &quot;3306:3306&quot;</span><br><span class="line">    volumes:</span><br><span class="line">       - /app/mysql/db:/var/lib/mysql</span><br><span class="line">       - /app/mysql/conf/my.cnf:/etc/my.cnf</span><br><span class="line">       - /app/mysql/init:/docker-entrypoint-initdb.d</span><br><span class="line">    networks:</span><br><span class="line">      - atguigu_net</span><br><span class="line">      #解决外部无法访问</span><br><span class="line">    command: --default-authentication-plugin=mysql_native_password </span><br><span class="line"> # 相当于docker network create atguigu_net</span><br><span class="line">networks: </span><br><span class="line">   atguigu_net: </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>修改微服务工程docker_boot</li></ul><p>通过服务名访问，与IP无关</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">server.port=6001</span></span><br><span class="line">  <span class="comment"># ========================alibaba.druid????=====================</span></span><br><span class="line"><span class="string">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="string">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#spring.datasource.url=jdbc:mysql://192.168.182.129:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://mysql:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line"></span><br><span class="line"><span class="string">spring.datasource.username=root</span></span><br><span class="line"><span class="string">spring.datasource.password=123456</span></span><br><span class="line"><span class="string">spring.datasource.druid.test-while-idle=false</span></span><br><span class="line">  <span class="comment"># ========================redis????=====================</span></span><br><span class="line"><span class="string">spring.redis.database=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#spring.redis.host=192.168.182.129</span></span><br><span class="line"><span class="string">spring.redis.host=redis</span></span><br><span class="line"></span><br><span class="line"><span class="string">spring.redis.port=6379</span></span><br><span class="line"><span class="string">spring.redis.password=</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.max-active=8</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.max-wait=-1ms</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.max-idle=8</span></span><br><span class="line"><span class="string">spring.redis.lettuce.pool.min-idle=0</span></span><br><span class="line">  <span class="comment"># ========================mybatis????===================</span></span><br><span class="line"><span class="string">mybatis.mapper-locations=classpath:mapper/*.xml</span></span><br><span class="line"><span class="string">mybatis.type-aliases-package=com.example.dockerboot.pojo</span></span><br><span class="line">  <span class="comment"># ========================swagger=====================</span></span><br><span class="line"><span class="string">spring.swagger2.enabled=true</span></span><br></pre></td></tr></table></figure><ul><li>mvn package命令将微服务形成新的jar包 并上传到Linux服务器&#x2F;mydocker目录下</li><li>编写Dockerfile</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基础镜像使用java</span><br><span class="line">FROM java:8</span><br><span class="line"># 作者</span><br><span class="line">MAINTAINER zzyy</span><br><span class="line"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span><br><span class="line">VOLUME /tmp</span><br><span class="line"># 将jar包添加到容器中并更名为zzyy_docker.jar</span><br><span class="line">ADD docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar</span><br><span class="line"># 运行jar包</span><br><span class="line">RUN bash -c &#x27;touch /zzyy_docker.jar&#x27;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/zzyy_docker.jar&quot;]</span><br><span class="line">#暴露6001端口作为微服务</span><br><span class="line">EXPOSE 6001</span><br></pre></td></tr></table></figure><ul><li>重新构建镜像</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t zzyy_docker:1.6 .</span><br></pre></td></tr></table></figure><ul><li>执行 <code>docker-compose up</code> 或者 执行 <code>docker-compose up -d</code></li></ul><p>全部都启动起来了（一键启动）</p><p><img src="/2022/08/06/Docker/image-20221018204507200.png" alt="image-20221018204507200"></p><blockquote><p><strong>Compose</strong>常用命令</p><p>docker-compose -h              # 查看帮助</p><p>docker-compose up              # 启动所有docker-compose服务</p><p>docker-compose up -d            # 启动所有docker-compose服务并后台运行</p><p>docker-compose down             # 停止并删除容器、网络、卷、镜像。</p><p>docker-compose exec  yml里面的服务id         # 进入容器实例内部 docker-compose exec docker-compose.yml文件中写的服务id &#x2F;bin&#x2F;bash</p><p>docker-compose ps           # 展示当前docker-compose编排过的运行的所有容器</p><p>docker-compose top           # 展示当前docker-compose编排过的容器进程</p><p>docker-compose logs  yml里面的服务id   # 查看容器输出日志</p><p>dokcer-compose config   # 检查配置</p><p>dokcer-compose config -q # 检查配置，有问题才有输出</p><p>docker-compose restart  # 重启服务</p><p>docker-compose start   # 启动服务</p><p>docker-compose stop    # 停止服务</p></blockquote><ul><li>进入mysql容器实例并新建库db2021+新建表t_user</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hua mydocker]# docker exec -it 2adcd75aadb3 bash</span><br><span class="line">root@2adcd75aadb3:/# mysql -uroot -p</span><br><span class="line">Enter password:</span><br><span class="line">.............</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show databases;</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| db2021             |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">use db2021;</span></span><br><span class="line">Database changed</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">CREATE TABLE `t_user` (</span></span><br><span class="line">    -&gt;   `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt;   `username` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;&#x27;,</span><br><span class="line">    -&gt;   `password` VARCHAR(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;&#x27;,</span><br><span class="line">    -&gt;   `sex` TINYINT(4) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27; 0= 1= &#x27;,</span><br><span class="line">    -&gt;   `deleted` TINYINT(4) UNSIGNED NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;01&#x27;,</span><br><span class="line">    -&gt;   `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT                                                                                            _TIMESTAMP COMMENT &#x27;&#x27;,</span><br><span class="line">    -&gt;   `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;&#x27;,</span><br><span class="line">    -&gt;   PRIMARY KEY (`id`)</span><br><span class="line">    -&gt; ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">select * from t_user;</span></span><br><span class="line">Empty set (0.03 sec)</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><p><a href="http://192.168.182.129:6001/swagger-ui.html#/">http://192.168.182.129:6001/swagger-ui.html#/</a></p><p>添加数据</p><p><img src="/2022/08/06/Docker/image-20221018204938439.png" alt="image-20221018204938439"></p><p>添加成功</p><p><img src="/2022/08/06/Docker/image-20221018205003523.png" alt="image-20221018205003523"></p><p><img src="/2022/08/06/Docker/image-20221018205016204.png" alt="image-20221018205016204"></p><ul><li>一键停止</li></ul><p><img src="/2022/08/06/Docker/image-20221018205057052.png" alt="image-20221018205057052"></p><h2 id="6、Docker轻量级可视化工具Portainer"><a href="#6、Docker轻量级可视化工具Portainer" class="headerlink" title="6、Docker轻量级可视化工具Portainer"></a>6、Docker轻量级可视化工具Portainer</h2><h3 id="6-1、是什么"><a href="#6-1、是什么" class="headerlink" title="6.1、是什么"></a>6.1、是什么</h3><p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。</p><h3 id="6-2、安装"><a href="#6-2、安装" class="headerlink" title="6.2、安装"></a>6.2、安装</h3><ul><li>官网</li></ul><p><a href="https://www.portainer.io/">https://www.portainer.io/</a></p><p><a href="https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux">https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux</a></p><ul><li>步骤</li></ul><p>docker命令安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p  8000:8000 -p 9000:9000 --name portainer   --restart=always    -v /var/run/docker.sock:/var/run/docker.sock    -v portainer_data:/data   portainer/portainer  </span><br></pre></td></tr></table></figure><p><img src="/2022/08/06/Docker/image-20221018220218819.png" alt="image-20221018220218819"></p><h3 id="6-3、使用"><a href="#6-3、使用" class="headerlink" title="6.3、使用"></a>6.3、使用</h3><ul><li>第一次登录需创建admin，访问地址：<a href="http://192.168.182.129:9000/">http://192.168.182.129:9000</a></li></ul><table><thead><tr><th>用户名，直接用默认admin</th></tr></thead><tbody><tr><td>密码记得8位，随便你写</td></tr></tbody></table><p><img src="/2022/08/06/Docker/clip_image006-16661015352553.jpg" alt="graphic"></p><ul><li>设置admin用户和密码后首次登陆</li></ul><p><img src="/2022/08/06/Docker/clip_image008-16661015352554.jpg" alt="graphic"></p><ul><li>选择local选项卡后本地docker详细信息展示</li></ul><p><img src="/2022/08/06/Docker/clip_image010-16661015352555.jpg" alt="graphic"></p><ul><li>上一步的图形展示，能想得起对应命令吗？</li></ul><p><img src="/2022/08/06/Docker/clip_image012-16661015352556.jpg" alt="graphic"></p><ul><li>登陆并演示介绍常用操作case</li></ul><h3 id="6-4、汉化"><a href="#6-4、汉化" class="headerlink" title="6.4、汉化"></a>6.4、汉化</h3><ul><li>下载汉化包</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1VBmvho7L3H7ILzocNIG_ww</span><br><span class="line"></span><br><span class="line">提取码: hejp</span><br></pre></td></tr></table></figure><ul><li>解压至Portainer的工作目录</li></ul><p><img src="/2022/08/06/Docker/v2-c70aa1b681b90c8f9f200021f3325997_1440w.webp" alt="img"></p><ul><li>修改docker-compose 配置文件映射工作目录</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">volumes: </span><br><span class="line">    - /var/run/docker.sock:/var/run/docker.sock:rw</span><br><span class="line">    - ./ortainer_data:/data:rw</span><br><span class="line">    # 汉化包</span><br><span class="line">    - ./public:/public:rw</span><br></pre></td></tr></table></figure><ul><li>重新启动容器</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">docker-compose down &amp;&amp; docker-compose up -d</span><br></pre></td></tr></table></figure><p>看到这个界面，汉化成功 </p><p><img src="/2022/08/06/Docker/v2-00dad9371617261e244556bafb896ffa_1440w.webp" alt="img"></p><p><a href="https://link.zhihu.com/?target=https://www.portainer.io/">更多功能使用，请查询官网</a></p><h2 id="7、Docker容器监控之-CAdvisor-InfluxDB-Granfana"><a href="#7、Docker容器监控之-CAdvisor-InfluxDB-Granfana" class="headerlink" title="7、Docker容器监控之 CAdvisor+InfluxDB+Granfana"></a>7、Docker容器监控之 CAdvisor+InfluxDB+Granfana</h2><h3 id="7-1、原生命令docker-stats"><a href="#7-1、原生命令docker-stats" class="headerlink" title="7.1、原生命令docker stats"></a>7.1、原生命令docker stats</h3><p>操作</p><p><img src="/2022/08/06/Docker/clip_image002-16661852967601.jpg" alt="graphic"></p><p><strong>docker stats****命令的结果</strong></p><p><img src="/2022/08/06/Docker/clip_image004-16661852967612.jpg" alt="graphic"></p><p>问题</p><p>通过docker stats命令可以很方便的看到当前宿主机上所有容器的CPU,内存以及网络流量等数据，一般小公司够用了。。。。</p><p>但是，docker stats统计结果只能是当前宿主机的全部容器，数据资料是实时的，没有地方存储、没有健康指标过线预警等功能。</p><h3 id="7-2、是什么"><a href="#7-2、是什么" class="headerlink" title="7.2、是什么"></a>7.2、是什么</h3><p>容器监控3剑客</p><p>一句话</p><p><img src="/2022/08/06/Docker/clip_image006-16661852967613.jpg" alt="graphic"></p><ul><li>CAdvisor监控收集+InfluxDB存储数据+Granfana展示图表</li></ul><h4 id="CAdvisor监控收集"><a href="#CAdvisor监控收集" class="headerlink" title="CAdvisor监控收集"></a>CAdvisor监控收集</h4><p><img src="/2022/08/06/Docker/clip_image008-16661852967614.jpg" alt="graphic"></p><h4 id="InfluxDB存储数据"><a href="#InfluxDB存储数据" class="headerlink" title="InfluxDB存储数据"></a>InfluxDB存储数据</h4><p><img src="/2022/08/06/Docker/clip_image010-16661852967617.jpg" alt="graphic"></p><h4 id="Granfana展示图表"><a href="#Granfana展示图表" class="headerlink" title="Granfana展示图表"></a>Granfana展示图表</h4><p><img src="/2022/08/06/Docker/clip_image012-16661852967615.jpg" alt="graphic"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2022/08/06/Docker/clip_image014-16661852967616.jpg" alt="graphic"></p><h3 id="7-3、安装"><a href="#7-3、安装" class="headerlink" title="7.3、安装"></a>7.3、安装</h3><h4 id="compose容器编排，一套带走"><a href="#compose容器编排，一套带走" class="headerlink" title="compose容器编排，一套带走"></a>compose容器编排，一套带走</h4><ul><li>新建目录</li></ul><p><img src="/2022/08/06/Docker/clip_image015.jpg" alt="graphic"></p><ul><li>新建3件套组合的 docker-compose.yml</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3.1&#x27;</span><br><span class="line"> </span><br><span class="line">volumes:</span><br><span class="line">  grafana_data: &#123;&#125;</span><br><span class="line"> </span><br><span class="line">services:</span><br><span class="line"> influxdb:</span><br><span class="line">  image: tutum/influxdb:0.9</span><br><span class="line">  restart: always</span><br><span class="line">  environment:</span><br><span class="line">    - PRE_CREATE_DB=cadvisor</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;8083:8083&quot;</span><br><span class="line">    - &quot;8086:8086&quot;</span><br><span class="line">  volumes:</span><br><span class="line">    - ./data/influxdb:/data</span><br><span class="line"> </span><br><span class="line"> cadvisor:</span><br><span class="line">  image: google/cadvisor</span><br><span class="line">  links:</span><br><span class="line">    - influxdb:influxsrv</span><br><span class="line">  command: -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxsrv:8086</span><br><span class="line">  restart: always</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;8080:8080&quot;</span><br><span class="line">  volumes:</span><br><span class="line">    - /:/rootfs:ro</span><br><span class="line">    - /var/run:/var/run:rw</span><br><span class="line">    - /sys:/sys:ro</span><br><span class="line">    - /var/lib/docker/:/var/lib/docker:ro</span><br><span class="line"> </span><br><span class="line"> grafana:</span><br><span class="line">  user: &quot;104&quot;</span><br><span class="line">  image: grafana/grafana</span><br><span class="line">  user: &quot;104&quot;</span><br><span class="line">  restart: always</span><br><span class="line">  links:</span><br><span class="line">    - influxdb:influxsrv</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;3000:3000&quot;</span><br><span class="line">  volumes:</span><br><span class="line">    - grafana_data:/var/lib/grafana</span><br><span class="line">  environment:</span><br><span class="line">    - HTTP_USER=admin</span><br><span class="line">    - HTTP_PASS=admin</span><br><span class="line">    - INFLUXDB_HOST=influxsrv</span><br><span class="line">    - INFLUXDB_PORT=8086</span><br><span class="line">    - INFLUXDB_NAME=cadvisor</span><br><span class="line">    - INFLUXDB_USER=root</span><br><span class="line">    - INFLUXDB_PASS=root</span><br></pre></td></tr></table></figure><ul><li>启动docker-compose文件</li></ul><p><code>docker-compose up</code></p><p><img src="/2022/08/06/Docker/clip_image017.jpg" alt="graphic"></p><p><img src="/2022/08/06/Docker/clip_image019.jpg" alt="graphic"></p><ul><li>查看三个服务容器是否启动</li></ul><p><img src="/2022/08/06/Docker/clip_image021.jpg" alt="graphic"></p><ul><li><p>测试</p></li><li><p>浏览cAdvisor收集服务，<a href="http://ip:8080/">http://ip:8080/</a></p></li></ul><p><img src="/2022/08/06/Docker/clip_image023.jpg" alt="graphic"></p><p>第一次访问慢，请稍等</p><p>cadvisor也有基础的图形展现功能，这里主要用它来作数据采集</p><ul><li>浏览influxdb存储服务，<a href="http://ip:8083/">http://ip:8083/</a></li></ul><p><img src="/2022/08/06/Docker/image-20221019211956869.png" alt="image-20221019211956869"></p><ul><li>浏览grafana展现服务，<a href="http://ip:3000/">http://ip:3000</a></li></ul><p>ip+3000端口的方式访问,默认帐户密码（admin&#x2F;admin）</p><p><img src="/2022/08/06/Docker/clip_image025.jpg" alt="graphic"></p><p><strong>配置步骤</strong></p><ul><li>配置数据源</li></ul><p><img src="/2022/08/06/Docker/clip_image027.jpg" alt="graphic"></p><ul><li>选择influxdb数据源</li></ul><p><img src="/2022/08/06/Docker/clip_image029.jpg" alt="graphic"></p><ul><li>配置细节</li></ul><p><img src="/2022/08/06/Docker/clip_image031.jpg" alt="graphic"></p><p><img src="/2022/08/06/Docker/clip_image033.jpg" alt="graphic"></p><p><img src="/2022/08/06/Docker/clip_image035.jpg" alt="graphic"></p><ul><li>配置面板panel</li></ul><p><img src="/2022/08/06/Docker/clip_image037.jpg" alt="graphic"></p><p><img src="/2022/08/06/Docker/clip_image039.jpg" alt="graphic"></p><p><img src="/2022/08/06/Docker/image-20221019212419722.png" alt="image-20221019212419722"></p><p>选择展示的图形界面</p><p><img src="/2022/08/06/Docker/clip_image041.jpg" alt="graphic"></p><p><img src="/2022/08/06/Docker/clip_image043.jpg" alt="graphic"></p><p>选择展示的数据源</p><p><img src="/2022/08/06/Docker/clip_image045.jpg" alt="graphic"></p><p><img src="/2022/08/06/Docker/clip_image047.jpg" alt="graphic"></p><ul><li>到这里cAdvisor+InfluxDB+Grafana容器监控系统就部署完成了</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/2022/07/13/SpringCloud/"/>
      <url>/2022/07/13/SpringCloud/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><p><img src="/2022/07/13/SpringCloud/1659446586999.png" alt="1659446586999"></p><h2 id="微服务架构概述"><a href="#微服务架构概述" class="headerlink" title="微服务架构概述"></a>微服务架构概述</h2><h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><blockquote><p>In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.——James Lewis and </p><p>Martin Fowler (2014)</p></blockquote><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相协作（通常是基于HTTP协议的RESTful API）。每个服务都围绕着具本业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。<br><strong>主题词01：现代数字化生活-落地维度</strong></p><p>手机<br>PC<br>智能家居<br>…<br><strong>主题词02：分布式微服务架构-落地维度</strong></p><p>满足哪些维度？支撑起这些维度的具体技术？</p><p><img src="/2022/07/13/SpringCloud/fa69e6841ce850672a3ec9cf8f4acad8.png" alt="img"></p><ul><li>服务调用服务降级服务注册与发现服务熔断负载均衡服务消息队列服务网关配置中心管理自动化构建部署服务监控全链路追踪服务定时任务调度操作</li></ul><h3 id="Spring-Cloud简介"><a href="#Spring-Cloud简介" class="headerlink" title="Spring Cloud简介"></a>Spring Cloud简介</h3><p>是什么？符合微服务技术维度</p><p>SpringCloud&#x3D;分布式微服务架构的站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶。</p><p>猜猜SpringCloud这个大集合里有多少种技术?</p><p><img src="/2022/07/13/SpringCloud/eeb48f15799b978e45ed980172c9f06e.png" alt="img"></p><p>SpringCloud俨然已成为微服务开发的主流技术栈，在国内开发者社区非常火爆。</p><p>“微”力十足，互联网大厂微服务架构案例：</p><p>京东的：</p><p><img src="/2022/07/13/SpringCloud/2b9f44abea91af3c4b77c1c77eae6eb3.png" alt="京东的"></p><p>阿里的：</p><p><img src="/2022/07/13/SpringCloud/ef6092b03932cb7f6f4b7e20ff370261.png" alt="阿里的"></p><p>京东物流的：</p><p><img src="/2022/07/13/SpringCloud/b7f15e802845e6ecdc4c13e2685789c1.png" alt="京东物流"></p><p><img src="/2022/07/13/SpringCloud/60b96a66ac3b4dceda8f7ac2f8d8d79e.png" alt="微服务的简单概括"></p><p>Spring Cloud技术栈：</p><p><img src="/2022/07/13/SpringCloud/fa347f3da197c3df86bf5d36961c8cde.png" alt="netflix"></p><p><img src="/2022/07/13/SpringCloud/1657698172433.png" alt="1657698172433"></p><p>总结</p><p><img src="/2022/07/13/SpringCloud/fc8ed10fca5f7cc56e4d4623a39245eb.png" alt="img"></p><p><img src="/2022/07/13/SpringCloud/735076e24e1096e38b0ee8ef50f08a17.png" alt="img"></p><h2 id="第二季Boot和Cloud版本选型"><a href="#第二季Boot和Cloud版本选型" class="headerlink" title="第二季Boot和Cloud版本选型"></a>第二季Boot和Cloud版本选型</h2><ul><li><p>Spring Boot 2.X 版</p><ul><li><p>[源码地址]: <a href="https://github.com/spring-projects/spring-boot/releases/">https://github.com/spring-projects/spring-boot/releases/</a>“源码地址”</p></li><li><p>[SpringBoot 2的新特性]: <a href="https://github.com/spring-projects/spring-boot/wiki/spring-Boot-2.0-Release-Notes">https://github.com/spring-projects/spring-boot/wiki/spring-Boot-2.0-Release-Notes</a>“SpringBoot 2的新特性”</p></li><li><p>通过上面官网发现，Boot官方强烈建议你升级到2.X以上版本</p></li></ul></li><li><p>Spring Cloud H版</p><ul><li><p>[源码地址]: <a href="https://github.com/spring-projects/spring-cloud/wiki">https://github.com/spring-projects/spring-cloud/wiki</a>“源码地址”</p></li><li><p>[官网]: <a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a>“官网”</p></li></ul></li><li><p>Spring Boot 与 Spring Cloud 兼容性查看</p><ul><li><p>[文档]: <a href="https://spring.io/projects/spring-cloud#overview">https://spring.io/projects/spring-cloud#overview</a>“文档”</p></li><li><p>[JSON接口]: <a href="https://start.spring.io/actuator/info">https://start.spring.io/actuator/info</a>“JSON接口”</p></li></ul></li><li><p>接下来开发用到的组件版本</p><ul><li>Cloud - Hoxton.SR1</li><li>Boot - 2.2.2.RELEASE</li><li>Cloud Alibaba - 2.1.0.RELEASE</li><li>Java - Java 8</li><li>Maven - 3.5及以上</li><li>MySQL - 5.7及以上</li></ul></li></ul><h2 id="Cloud组件停更说明"><a href="#Cloud组件停更说明" class="headerlink" title="Cloud组件停更说明"></a>Cloud组件停更说明</h2><ul><li><p>停更引发的“升级惨案”</p><ul><li>停更不停用</li><li>被动修复bugs</li><li>不再接受合并请求</li><li>不再发布新版本</li><li>Cloud升级</li></ul></li><li><p>服务注册中心</p><ul><li>× Eureka</li><li>√ Zookeeper</li><li>√ Consul</li><li>√ Nacos</li></ul></li><li><p>服务调用</p><ul><li>√ Ribbon</li><li>√ LoadBalancer</li></ul></li><li><p>服务调用2</p><ul><li>× Feign</li><li>√ OpenFeign</li></ul></li><li><p>服务降级</p><ul><li>× Hystrix</li><li>√ resilience4j</li><li>√ sentienl</li></ul></li><li><p>服务网关</p><ul><li>× Zuul</li><li>! Zuul2</li><li>√ gateway</li></ul></li><li><p>服务配置</p><ul><li>× Config</li><li>√ Nacos</li></ul></li><li><p>服务总线</p><ul><li>× Bus</li><li>√ Nacos</li></ul></li></ul><p>[Spring]: <a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/">https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/</a>“Spring Cloud官方文档”<br>[Spring]: <a href="https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md">https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md</a>“Spring Cloud中文文档”<br>[Spring]: <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/">https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/</a>“Spring Boot官方文档”</p><h2 id="微服务架构编码构建"><a href="#微服务架构编码构建" class="headerlink" title="微服务架构编码构建"></a>微服务架构编码构建</h2><h3 id="父工程Project空间新建"><a href="#父工程Project空间新建" class="headerlink" title="父工程Project空间新建"></a>父工程Project空间新建</h3><p>约定 &gt; 配置 &gt; 编码</p><p>创建微服务cloud整体聚合父工程Project，有8个关键步骤：</p><ul><li>New Project - maven工程 - create from archetype: maven-archetype-site</li><li>聚合总父工程名字</li><li>Maven选版本</li><li>工程名字</li><li>字符编码 - Settings - File encoding</li><li>注解生效激活 - Settings - Annotation Processors</li><li>Java编译版本选8</li><li>File Type过滤 - Settings - File Type</li></ul><h3 id="pom文件设置"><a href="#pom文件设置" class="headerlink" title="pom文件设置"></a>pom文件设置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">  xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">  &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line">  &lt;packaging&gt;pom&lt;/packaging&gt;&lt;!-- 这里添加，注意不是jar或war --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 统一管理jar包版本 --&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;<span class="number">1.8</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;<span class="number">1.8</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;junit.version&gt;<span class="number">4.12</span>&lt;/junit.version&gt;</span><br><span class="line">    &lt;log4j.version&gt;<span class="number">1.2</span><span class="number">.17</span>&lt;/log4j.version&gt;</span><br><span class="line">    &lt;lombok.version&gt;<span class="number">1.18</span><span class="number">.24</span>&lt;/lombok.version&gt;</span><br><span class="line">    &lt;mysql.version&gt;<span class="number">8.0</span><span class="number">.29</span>&lt;/mysql.version&gt;</span><br><span class="line">    &lt;druid.version&gt;<span class="number">1.1</span><span class="number">.12</span>&lt;/druid.version&gt;</span><br><span class="line">    &lt;mybatis.spring.boot.version&gt;<span class="number">2.2</span><span class="number">.2</span>&lt;/mybatis.spring.boot.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 子模块继承之后，提供作用：</span><br><span class="line">      锁定版本+子modlue不用写groupId和version --&gt;</span><br><span class="line">  &lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">      &lt;!--spring boot <span class="number">2.2</span><span class="number">.2</span>--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.2</span><span class="number">.2</span>.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!--spring cloud Hoxton.SR1--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;Hoxton.SR1&lt;/version&gt;</span><br><span class="line">        &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!--spring cloud alibaba <span class="number">2.1</span><span class="number">.0</span>.RELEASE--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.1</span><span class="number">.0</span>.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;mybatis.spring.boot.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">  &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;fork&gt;<span class="literal">true</span>&lt;/fork&gt;</span><br><span class="line">          &lt;addResources&gt;<span class="literal">true</span>&lt;/addResources&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h3 id="复习DependencyManagement和Dependencies"><a href="#复习DependencyManagement和Dependencies" class="headerlink" title="复习DependencyManagement和Dependencies"></a>复习DependencyManagement和Dependencies</h3><p>Maven使用dependencyManagement元素来提供了一种管理依赖版本号的方式。通常会在一个组织或者项目的最顶层的父POM中看到dependencyManagement元素。</p><p>使用pom.xml中的dependencyManagement元素能让所有在子项目中引用个依赖而不用显式的列出版本量。</p><p>Maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用这个dependencyManagement元素中指定的版本号。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysq1&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">5.1</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure><p>然后在子项目里就可以添加mysql-connector时可以不指定版本号，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysq1&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>这样做的好处就是：如果有多个子项目都引用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号，这样当想升级或切换到另一个版本时，只需要在顶层父容器里更新，而不需要一个一个子项目的修改；另外如果某个子项目需要另外的一个版本，只需要声明version就可。</p><ul><li>dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。</li><li>如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项,并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom。</li><li>如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</li></ul><p>IDEA右侧旁的Maven插件有Toggle ‘ Skip Tests’ Mode按钮，这样maven可以跳过单元测试</p><p>父工程创建完成执行mvn : install将父工程发布到仓库方便子工程继承。</p><h3 id="支付模块构建-上"><a href="#支付模块构建-上" class="headerlink" title="支付模块构建(上)"></a>支付模块构建(上)</h3><p>创建微服务模块套路：</p><ol><li>建Module</li><li>改POM</li><li>写YML</li><li>主启动</li><li>业务类</li></ol><p><img src="/2022/07/13/SpringCloud/1657713300963.png" alt="1657713300963"></p><p>创建cloud-provider-payment8001微服务提供者支付Module模块：</p><h4 id="1-建名为cloud-provider-payment8001的Maven工程"><a href="#1-建名为cloud-provider-payment8001的Maven工程" class="headerlink" title="1.建名为cloud-provider-payment8001的Maven工程"></a>1.建名为cloud-provider-payment8001的Maven工程</h4><h4 id="2-改POM"><a href="#2-改POM" class="headerlink" title="2.改POM"></a>2.改POM</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-provider-payment8001&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.1</span><span class="number">.10</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--mysql-connector-java--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--jdbc--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h4 id="3-写YML"><a href="#3-写YML" class="headerlink" title="3.写YML"></a>3.写YML</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8001</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-payment-service</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver           # mysql驱动包</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/springcloud?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapperLocations: classpath:mapper<span class="comment">/*.xml</span></span><br><span class="line"><span class="comment">  type-aliases-package: com.hua.springcloud.entities    # 所有Entity别名类所在包</span></span><br></pre></td></tr></table></figure><h4 id="4-主启动"><a href="#4-主启动" class="headerlink" title="4.主启动"></a>4.主启动</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.springcloud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain8001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="支付模块构建-中"><a href="#支付模块构建-中" class="headerlink" title="支付模块构建(中)"></a>支付模块构建(中)</h3><h4 id="5-业务类"><a href="#5-业务类" class="headerlink" title="5.业务类"></a>5.业务类</h4><p>SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `payment`(</span><br><span class="line">`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">    `serial` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4</span><br></pre></td></tr></table></figure><p>Entities：</p><p>实体类Payment：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.springcloud.entities;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Payment</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String serial;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JSON封装体CommonResult：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.springcloud.entities;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonResult</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span>  String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommonResult</span><span class="params">(Integer code,String message)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(code,message,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DAO：</p><p>接口PaymentDao：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.springcloud.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">create</span><span class="params">(Payment payment)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Payment <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBatis映射文件PaymentMapper.xml，路径：resources&#x2F;mapper&#x2F;PaymentMapper.xml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.hua.springcloud.dao.PaymentDao&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=<span class="string">&quot;create&quot;</span> parameterType=<span class="string">&quot;Payment&quot;</span> useGeneratedKeys=<span class="string">&quot;true&quot;</span> keyProperty=<span class="string">&quot;id&quot;</span>&gt;</span><br><span class="line">        insert into <span class="title function_">payment</span><span class="params">(serial)</span>  values(#&#123;serial&#125;);</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id=<span class="string">&quot;BaseResultMap&quot;</span> type=<span class="string">&quot;com.hua.springcloud.entities.Payment&quot;</span>&gt;</span><br><span class="line">        &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span> jdbcType=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span><br><span class="line">        &lt;id column=<span class="string">&quot;serial&quot;</span> property=<span class="string">&quot;serial&quot;</span> jdbcType=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">&quot;getPaymentById&quot;</span> parameterType=<span class="string">&quot;Long&quot;</span> resultMap=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span><br><span class="line">        select * from payment where id=#&#123;id&#125;;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>Service：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.springcloud.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">create</span><span class="params">(Payment payment)</span>;</span><br><span class="line">    <span class="keyword">public</span> Payment <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类PaymentServiceImpl:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.springcloud.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.dao.PaymentDao;</span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.service.PaymentService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentDao paymentDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">create</span><span class="params">(Payment payment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> paymentDao.create(payment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Payment <span class="title function_">getPaymentById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> paymentDao.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.springcloud.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.service.PaymentService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/payment/create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">create</span><span class="params">(Payment payment)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> paymentService.create(payment);</span><br><span class="line">        log.info(<span class="string">&quot;————插入结果：&quot;</span>+result);</span><br><span class="line">        <span class="keyword">if</span> (result &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;插入数据成功&quot;</span>,result);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">444</span>,<span class="string">&quot;插入数据失败&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="type">Payment</span> <span class="variable">paymentById</span> <span class="operator">=</span> paymentService.getPaymentById(id);</span><br><span class="line">        log.info(<span class="string">&quot;————插入结果：&quot;</span>+paymentById);</span><br><span class="line">        <span class="keyword">if</span> (paymentById != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;查询数据成功&quot;</span>,paymentById);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">444</span>,<span class="string">&quot;没有对应记录，查询ID：&quot;</span>+id,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="支付模块构建-下"><a href="#支付模块构建-下" class="headerlink" title="支付模块构建(下)"></a>支付模块构建(下)</h3><h4 id="6-测试"><a href="#6-测试" class="headerlink" title="6.测试"></a>6.测试</h4><p>浏览器 - <a href="http://localhost:8001/payment/get/1">http://localhost:8001/payment/get/1</a><br>Postman - <a href="http://localhost:8001/payment/create?serial=yong">http://localhost:8001/payment/create?serial=yong</a></p><h4 id="7-小总结"><a href="#7-小总结" class="headerlink" title="7.小总结"></a>7.小总结</h4><p>创建微服务模块套路：</p><ul><li>建Module</li><li>改POM</li><li>写YML</li><li>主启动</li><li>业务类</li></ul><h3 id="热部署Devtools"><a href="#热部署Devtools" class="headerlink" title="热部署Devtools"></a>热部署Devtools</h3><p><strong>开发时使用，生产环境关闭</strong></p><h4 id="1-Adding-devtools-to-your-project"><a href="#1-Adding-devtools-to-your-project" class="headerlink" title="1.Adding devtools to your project"></a>1.Adding devtools to your project</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="2-Adding-plugin-to-your-pom-xml"><a href="#2-Adding-plugin-to-your-pom-xml" class="headerlink" title="2.Adding plugin to your pom.xml"></a>2.Adding plugin to your pom.xml</h4><p>下段配置复制到聚合父类总工程的pom.xml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    &lt;finalName&gt;你的工程名&lt;/finalName&gt;（单一工程时添加）</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;fork&gt;<span class="literal">true</span>&lt;/fork&gt;</span><br><span class="line">          &lt;addResources&gt;<span class="literal">true</span>&lt;/addResources&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><h4 id="3-Enabling-automatic-build"><a href="#3-Enabling-automatic-build" class="headerlink" title="3.Enabling automatic build"></a>3.Enabling automatic build</h4><p>File -&gt; Settings(New Project Settings-&gt;Settings for New Projects) -&gt;Compiler</p><p>下面项勾选</p><ul><li>Automatically show first error in editor</li><li>Display notification on build completion</li><li>Build project automatically</li><li>Compile independent modules in parallel</li></ul><h4 id="4-Update-the-value-of"><a href="#4-Update-the-value-of" class="headerlink" title="4.Update the value of"></a>4.Update the value of</h4><p>键入Ctrl + Shift + Alt + &#x2F; ，打开Registry，勾选：</p><ul><li><p>compiler.automake.allow.when.app.running</p></li><li><p>actionSystem.assertFocusAccessFromEdt</p></li></ul><p>勾选该选项，idea2021版本无compiler.automake.allow.when.app.running，我们需要多做下面一步设置</p><p>settings→advanced settings 勾选下图内容，与勾选compiler.automake.allow.when.app.running是等价的。</p><p><img src="/2022/07/13/SpringCloud/beceb7867d3f483e8098a6b9a34b6f8a.png" alt="请添加图片描述"></p><h4 id="5-重启IDEA"><a href="#5-重启IDEA" class="headerlink" title="5.重启IDEA"></a>5.重启IDEA</h4><h3 id="消费者订单模块-上"><a href="#消费者订单模块-上" class="headerlink" title="消费者订单模块(上)"></a>消费者订单模块(上)</h3><h4 id="1-建Module"><a href="#1-建Module" class="headerlink" title="1.建Module"></a>1.建Module</h4><p>创建名为cloud-consumer-order80的maven工程。</p><h4 id="2-改POM-1"><a href="#2-改POM-1" class="headerlink" title="2.改POM"></a>2.改POM</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-consumer-order80&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h4 id="3-写YML-1"><a href="#3-写YML-1" class="headerlink" title="3.写YML"></a>3.写YML</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">80</span></span><br></pre></td></tr></table></figure><h4 id="4-主启动-1"><a href="#4-主启动-1" class="headerlink" title="4.主启动"></a>4.主启动</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.springcloud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderMain80</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-业务类-1"><a href="#5-业务类-1" class="headerlink" title="5.业务类"></a>5.业务类</h4><p>实体类：同支付模块一样直接复制即可</p><p>配置类：</p><p><strong>RestTemplate</strong></p><p>RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集。</p><p>[官网地址]: <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html</a>“官网地址”</p><p>使用：</p><ul><li>使用restTemplate访问restful接口非常的简单粗暴无脑。</li><li>(url, requestMap, ResponseBean.class)这三个参数分别代表。</li><li>REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.springcloud.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制层：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.springcloud.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PAYMENT_URL</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8001&quot;</span>;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">create</span><span class="params">(Payment payment)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL+<span class="string">&quot;/payment/create&quot;</span>,payment,CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL+<span class="string">&quot;/payment/get/&quot;</span>+id,CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-测试-1"><a href="#6-测试-1" class="headerlink" title="6.测试"></a>6.测试</h4><p>运行cloud-consumer-order80与cloud-provider-payment8001两工程</p><p>浏览器 -<a href="http://localhost//consumer/payment/get/1">http://localhost//consumer/payment/get/1</a></p><h3 id="消费者订单模块-下"><a href="#消费者订单模块-下" class="headerlink" title="消费者订单模块(下)"></a>消费者订单模块(下)</h3><p>浏览器 - <a href="http://localhost///consumer/payment/create?serial=pw">http://localhost///consumer/payment/create?serial=pw</a></p><p>虽然，返回成功，但是在数据库中，并没有数据。</p><p>解决之道：在loud-provider-payment8001工程的PaymentController中添加@RequestBody注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//需要RequestBody：当我们使⽤post请求的时候，我们会将参数放在requestbody中，加上@RequestBody⽤来接受到前端传过来的requestbody</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/payment/create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span><span class="comment">/*添加到这里*/</span> Payment payment)</span>&#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过修改idea的workspace.xml的方式来快速打开Run Dashboard窗口（这个用来显示哪些Spring Boot工程运行，停止等信息。我idea 2022.1版本在名为Services窗口就可以显示哪些Spring Boot工程运行，停止等信息出来）。</p><p>开启Run DashBoard</p><ul><li><p>打开工程路径下的.idea文件夹的workspace.xml</p></li><li><p>在<component name="RunDashboard">中修改或添加以下代码：</component></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;option name=<span class="string">&quot;configurationTypes&quot;</span>&gt;</span><br><span class="line">&lt;set&gt;</span><br><span class="line">&lt;option value=<span class="string">&quot;SpringBootApplicationConfigurationType&quot;</span>/&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">&lt;/option&gt;</span><br></pre></td></tr></table></figure><ul><li>没有<component name="RunDashboard">，直接添加</component></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;component name=<span class="string">&quot;RunDashboard&quot;</span>&gt;</span><br><span class="line">    &lt;option name=<span class="string">&quot;configurationTypes&quot;</span>&gt;</span><br><span class="line">      &lt;set&gt;</span><br><span class="line">        &lt;option value=<span class="string">&quot;SpringBootApplicationConfigurationType&quot;</span> /&gt;</span><br><span class="line">      &lt;/set&gt;</span><br><span class="line">    &lt;/option&gt;</span><br><span class="line">    &lt;option name=<span class="string">&quot;ruleStates&quot;</span>&gt;</span><br><span class="line">      &lt;list&gt;</span><br><span class="line">        &lt;RuleState&gt;</span><br><span class="line">          &lt;option name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;ConfigurationTypeDashboardGroupingRule&quot;</span> /&gt;</span><br><span class="line">        &lt;/RuleState&gt;</span><br><span class="line">        &lt;RuleState&gt;</span><br><span class="line">          &lt;option name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;StatusDashboardGroupingRule&quot;</span> /&gt;</span><br><span class="line">        &lt;/RuleState&gt;</span><br><span class="line">      &lt;/list&gt;</span><br><span class="line">    &lt;/option&gt;</span><br><span class="line">  &lt;/component&gt;</span><br></pre></td></tr></table></figure><p>由于idea版本差异，可能需要关闭重启，后在server可操作。</p><h3 id="工程重构"><a href="#工程重构" class="headerlink" title="工程重构"></a>工程重构</h3><p>观察cloud-consumer-order80与cloud-provider-payment8001两工程有重复代码（entities包下的实体），重构。</p><p>1.新建 cloud-api-commons 工程</p><p>2.POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>3.entities</p><ul><li>将cloud-consumer-order80与cloud-provider-payment8001两工程的公有entities包移至cloud-api-commons工程下。</li></ul><p>4.maven clean、install cloud-api-commons工程，以供给cloud-consumer-order80与cloud-provider-payment8001两工程调用。</p><p>5.订单80和支付8001分别改造。</p><ul><li><p>将cloud-consumer-order80与cloud-provider-payment8001两工程的公有entities包移除。</p></li><li><p>引入cloud-api-commons依赖。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;&lt;!--引入自定义的api通用包，可以使Payment支付Entity--&gt;</span><br><span class="line">    &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><p>6.测试</p><h2 id="Eureka服务注册与发现"><a href="#Eureka服务注册与发现" class="headerlink" title="Eureka服务注册与发现"></a>Eureka服务注册与发现</h2><h3 id="Eureka基础知识"><a href="#Eureka基础知识" class="headerlink" title="Eureka基础知识"></a>Eureka基础知识</h3><h4 id="什么是服务治理"><a href="#什么是服务治理" class="headerlink" title="什么是服务治理"></a>什么是服务治理</h4><p>Spring Cloud封装了Netflix 公司开发的Eureka模块来实现服务治理</p><p>在传统的RPC远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。</p><h4 id="什么是服务注册与发现"><a href="#什么是服务注册与发现" class="headerlink" title="什么是服务注册与发现"></a>什么是服务注册与发现</h4><p>Eureka采用了CS的设计架构，Eureka Sever作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。</p><p>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方(消费者服务提供者)，以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用。RPC远程调用框架核心设计思想:在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何RPC远程框架中，都会有一个注册中心存放服务地址相关信息(接口地址)。</p><p><img src="/2022/07/13/SpringCloud/3956561052b9dc3909f16f1ff26d01bb.png" alt="img"></p><h4 id="Eureka包含两个组件-Eureka-Server和Eureka-Client"><a href="#Eureka包含两个组件-Eureka-Server和Eureka-Client" class="headerlink" title="Eureka包含两个组件:Eureka Server和Eureka Client"></a>Eureka包含两个组件:Eureka Server和Eureka Client</h4><p><strong>Eureka Server提供服务注册服务</strong></p><p>各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p><p><strong>EurekaClient通过注册中心进行访问</strong></p><p>它是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒)</p><h3 id="单机Eureka构建步骤"><a href="#单机Eureka构建步骤" class="headerlink" title="单机Eureka构建步骤"></a>单机Eureka构建步骤</h3><h4 id="IDEA生成eurekaServer端服务注册中心，类似物业公司"><a href="#IDEA生成eurekaServer端服务注册中心，类似物业公司" class="headerlink" title="IDEA生成eurekaServer端服务注册中心，类似物业公司"></a>IDEA生成eurekaServer端服务注册中心，类似物业公司</h4><p>1.创建名为cloud-eureka-server7001的Maven工程</p><p>2.修改pom.xml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-eureka-server7001&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--eureka-server--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--boot web actuator--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--一般通用配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>3.添加application.yml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">7001</span></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    #<span class="literal">false</span>表示不向注册中心注册自己。</span><br><span class="line">    register-with-eureka: <span class="literal">false</span></span><br><span class="line">    #<span class="literal">false</span>表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    fetch-registry: <span class="literal">false</span></span><br><span class="line">    service-url:</span><br><span class="line">      #设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。</span><br><span class="line">      defaultZone: http:<span class="comment">//$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><p>4.主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.springcloud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span><span class="comment">/*表示为服务注册中心Eureka Server*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurkaMain7001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurkaMain7001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.测试运行EurekaMain7001，浏览器输入<a href="http://localhost:7001/%E5%9B%9E%E8%BD%A6%EF%BC%8C%E4%BC%9A%E6%9F%A5%E7%9C%8B%E5%88%B0Spring">http://localhost:7001/回车，会查看到Spring</a> Eureka服务主页。</p><h4 id="EurekaClient端将注册进EurekaServer成为服务提供者provider"><a href="#EurekaClient端将注册进EurekaServer成为服务提供者provider" class="headerlink" title="EurekaClient端将注册进EurekaServer成为服务提供者provider"></a>EurekaClient端将注册进EurekaServer成为服务提供者provider</h4><h5 id="EurekaClient端cloud-provider-payment8001将注册进EurekaServer成为服务提供者provider，类似学校对外提供授课服务。"><a href="#EurekaClient端cloud-provider-payment8001将注册进EurekaServer成为服务提供者provider，类似学校对外提供授课服务。" class="headerlink" title="EurekaClient端cloud-provider-payment8001将注册进EurekaServer成为服务提供者provider，类似学校对外提供授课服务。"></a>EurekaClient端cloud-provider-payment8001将注册进EurekaServer成为服务提供者provider，类似学校对外提供授课服务。</h5><p>1.修改cloud-provider-payment8001</p><p>2.改POM</p><p>添加spring-cloud-starter-netflix-eureka-client依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>3.在YML添加</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进Eurekaserver默认为<span class="literal">true</span>。</span><br><span class="line">    register-with-eureka: <span class="literal">true</span></span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为<span class="literal">true</span>。单节点无所谓，集群必须设置为<span class="literal">true</span>才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: <span class="literal">true</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br></pre></td></tr></table></figure><p>4.主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span><span class="comment">//&lt;-----添加该注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain8001</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.测试</p><p>启动cloud-provider-payment8001和cloud-eureka-server7001工程。</p><p>浏览器输入 - <a href="http://localhost:7001/">http://localhost:7001/</a> 主页内的Instances currently registered with Eureka会显示cloud-provider-payment8001的配置文件application.yml设置的应用名cloud-payment-service</p><p><img src="/2022/07/13/SpringCloud/1657784966960.png" alt="1657784966960"><br>6.自我保护机制</p><p>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARELESSER THAN THRESHOLD AND HENCFT ARE NOT BEING EXPIRED JUST TO BE SAFE.</p><p>紧急情况！EUREKA可能错误地声称实例在没有启动的情况下启动了。续订小于阈值，因此实例不会为了安全而过期。</p><h5 id="EurekaClient端cloud-consumer-order80将注册进EurekaServer成为服务消费者consumer-类似来尚硅谷上课消费的各位同学"><a href="#EurekaClient端cloud-consumer-order80将注册进EurekaServer成为服务消费者consumer-类似来尚硅谷上课消费的各位同学" class="headerlink" title="EurekaClient端cloud-consumer-order80将注册进EurekaServer成为服务消费者consumer,类似来尚硅谷上课消费的各位同学"></a>EurekaClient端cloud-consumer-order80将注册进EurekaServer成为服务消费者consumer,类似来尚硅谷上课消费的各位同学</h5><p>1.修改cloud-consumer-order80</p><p>2.POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>3.YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">80</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-order-service</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进Eurekaserver默认为<span class="literal">true</span>。</span><br><span class="line">    register-with-eureka: <span class="literal">true</span></span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为<span class="literal">true</span>。单节点无所谓，集群必须设置为<span class="literal">true</span>才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: <span class="literal">true</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br></pre></td></tr></table></figure><p>4.主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span><span class="comment">//&lt;--- 添加该标签</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderMain80</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span>&#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.测试</p><p>启动cloud-provider-payment8001、cloud-eureka-server7001和cloud-consumer-order80这三工程。<br>浏览器输入 <a href="http://localhost:7001/">http://localhost:7001</a> , 在主页的Instances currently registered with Eureka将会看到cloud-provider-payment8001、cloud-consumer-order80两个工程名。</p><p><img src="/2022/07/13/SpringCloud/1657785306915.png" alt="1657785306915">注意，application.yml配置中层次缩进和空格，两者不能少，否则，会抛出异常Failed to bind properties under ‘eureka.client.service-url’ to java.util.Map &lt;java.lang.String, java.lang.String&gt;。</p><h3 id="集群Eureka构建步骤"><a href="#集群Eureka构建步骤" class="headerlink" title="集群Eureka构建步骤"></a>集群Eureka构建步骤</h3><h4 id="Eureka集群原理说明"><a href="#Eureka集群原理说明" class="headerlink" title="Eureka集群原理说明"></a>Eureka集群原理说明</h4><p><img src="/2022/07/13/SpringCloud/14570c4b7c4dd8653be6211da2675e45.png" alt="img"></p><p>服务注册：将服务信息注册进注册中心</p><p>服务发现：从注册中心上获取服务信息</p><p>实质：存key服务命名，取value闭用地址</p><ol><li>先启动eureka注册中心</li><li>启动服务提供者payment支付服务</li><li>支付服务启动后会把自身信息(比服务地址L以别名方式注朋进eureka</li><li>消费者order服务在需要调用接口时，使用服务别名去注册中心获取实际的RPC远程调用地址</li><li>消去者导调用地址后，底屋实际是利用HttpClient技术实现远程调用</li><li>消费者获得服务地址后会缓存在本地jvm内存中，默认每间隔30秒更新—次服务调用地址</li></ol><p><strong>问题:微服务RPC远程服务调用最核心的是什么</strong><br><strong>高可用</strong>，试想你的注册中心只有一个only one，万一它出故障了，会导致整个为服务环境不可用。</p><p><strong>解决办法：搭建Eureka注册中心集群，实现负载均衡+故障容错。</strong></p><p><strong>互相注册，相互守望。</strong></p><h4 id="EurekaServer集群环境构建步骤"><a href="#EurekaServer集群环境构建步骤" class="headerlink" title="EurekaServer集群环境构建步骤"></a>EurekaServer集群环境构建步骤</h4><ul><li>创建cloud-eureka-server7002工程，和cloud-eureka-server7001创建步骤一样</li></ul><p><img src="/2022/07/13/SpringCloud/1657785931933.png" alt="1657785931933"></p><ul><li><p>找到C:\Windows\System32\drivers\etc路径下的hosts文件，修改映射配置添加进hosts文件</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">127.0.0.1 eureka7001.com</span><br><span class="line">127.0.0.1 eureka7002.com</span><br></pre></td></tr></table></figure></li><li><p>修改cloud-eureka-server7001配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">7001</span></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7001.com #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    #<span class="literal">false</span>表示不向注册中心注册自己。</span><br><span class="line">    register-with-eureka: <span class="literal">false</span></span><br><span class="line">    #<span class="literal">false</span>表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    fetch-registry: <span class="literal">false</span></span><br><span class="line">    service-url:</span><br><span class="line">      #设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。</span><br><span class="line">      defaultZone: http:<span class="comment">//eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure></li><li><p>修改cloud-eureka-server7002配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">7002</span></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7002.com #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    #<span class="literal">false</span>表示不向注册中心注册自己。</span><br><span class="line">    register-with-eureka: <span class="literal">false</span></span><br><span class="line">    #<span class="literal">false</span>表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span><br><span class="line">    fetch-registry: <span class="literal">false</span></span><br><span class="line">    service-url:</span><br><span class="line">      #设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。</span><br><span class="line">      defaultZone: http:<span class="comment">//eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure></li></ul><p>测试-  <a href="http://eureka7001.com:7001/">http://eureka7001.com:7001/</a></p><p><img src="/2022/07/13/SpringCloud/1657786756137.png" alt="1657786756137"></p><h4 id="将微服务发布到Eureka集群配置中"><a href="#将微服务发布到Eureka集群配置中" class="headerlink" title="将微服务发布到Eureka集群配置中"></a>将微服务发布到Eureka集群配置中</h4><ul><li><p>将支付服务8001微服务发布到上面2台Eureka集群配置中</p></li><li><p>将8001的配置文件的eureka.client.service-url.defaultZone进行修改</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进Eurekaserver默认为<span class="literal">true</span>。</span><br><span class="line">    register-with-eureka: <span class="literal">true</span></span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为<span class="literal">true</span>。单节点无所谓，集群必须设置为<span class="literal">true</span>才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: <span class="literal">true</span></span><br><span class="line">    service-url:</span><br><span class="line">#      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br><span class="line">       defaultZone: http:<span class="comment">//eureka7001.com:7001/eureka, http://eureka7002.com:7002/eureka #集群版</span></span><br></pre></td></tr></table></figure><ul><li><p>将订单服务80微服务发布到上面2台Eureka集群配置中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示是否将自己注册进Eurekaserver默认为<span class="literal">true</span>。</span><br><span class="line">    register-with-eureka: <span class="literal">true</span></span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为<span class="literal">true</span>。单节点无所谓，集群必须设置为<span class="literal">true</span>才能配合ribbon使用负载均衡</span><br><span class="line">    fetchRegistry: <span class="literal">true</span></span><br><span class="line">    service-url:</span><br><span class="line"> #     defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br><span class="line">      defaultZone: http:<span class="comment">//eureka7001.com:7001/eureka, http://eureka7002.com:7002/eureka #集群版</span></span><br></pre></td></tr></table></figure></li></ul><p>测试01</p><ul><li>先要启动EurekaServer，7001&#x2F;7002服务</li><li>再要启动服务提供者provider，8001</li><li>再要启动消费者，80</li><li>浏览器输入 - <a href="http://localhost/consumer/payment/get/1">http://localhost/consumer/payment/get/1</a></li></ul><h4 id="支付服务提供者8001集群环境构建"><a href="#支付服务提供者8001集群环境构建" class="headerlink" title="支付服务提供者8001集群环境构建"></a>支付服务提供者8001集群环境构建</h4><p>参考cloud-provicer-payment8001</p><p>1.新建cloud-provider-payment8002</p><p>2.改POM</p><p>3.写YML - 端口8002</p><p>4.主启动</p><p>5.业务类</p><p>6.修改8001&amp;8002的Controller，添加serverPort</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;<span class="comment">//读取到yml文件的port</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/payment/create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> Payment payment)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> paymentService.create(payment);</span><br><span class="line">        log.info(<span class="string">&quot;————插入结果：&quot;</span>+result);</span><br><span class="line">        <span class="keyword">if</span> (result &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;插入数据成功:&quot;</span>+serverPort,result);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">444</span>,<span class="string">&quot;插入数据失败&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="type">Payment</span> <span class="variable">paymentById</span> <span class="operator">=</span> paymentService.getPaymentById(id);</span><br><span class="line">        log.info(<span class="string">&quot;————插入结果：&quot;</span>+paymentById);</span><br><span class="line">        <span class="keyword">if</span> (paymentById != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;查询数据成功:&quot;</span>+serverPort,paymentById);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">444</span>,<span class="string">&quot;没有对应记录，查询ID：&quot;</span>+id,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负载均衡</p><p>cloud-consumer-order80订单服务访问地址不能写死</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PAYMENT_URL</span> <span class="operator">=</span> <span class="string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Config中使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.springcloud.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span><span class="comment">//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContextBean - 提前说一下Ribbon的负载均衡功能</p><p>测试</p><p>先要启动EurekaServer，7001&#x2F;7002服务</p><p>再要启动服务提供者provider，8001&#x2F;8002服务</p><p>浏览器输入 - <a href="http://localhost/consumer/payment/get/1">http://localhost/consumer/payment/get/1</a></p><p>结果：负载均衡效果达到，8001&#x2F;8002端口交替出现</p><p>Ribbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号，且该服务还有负载功能。</p><p>相互注册，相互守望</p><p><img src="/2022/07/13/SpringCloud/94c4c3eca8c2f9eb7497fe643b9b0622.png" alt="img"></p><h3 id="actuator微服务信息完善"><a href="#actuator微服务信息完善" class="headerlink" title="actuator微服务信息完善"></a>actuator微服务信息完善</h3><p>主机名称：服务名称修改（也就是将IP地址，换成可读性高的名字）</p><p>修改cloud-provider-payment8001，cloud-provider-payment8002</p><p>修改部分 - YML - eureka.instance.instance-id</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  ...</span><br><span class="line">  instance:</span><br><span class="line">    instance-id: payment8001 #添加此处</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  ...</span><br><span class="line">  instance:</span><br><span class="line">    instance-id: payment8002 #添加此处</span><br></pre></td></tr></table></figure><p>修改之后</p><p>eureka主页将显示payment8001，payment8002代替原来显示的IP地址。</p><p><img src="/2022/07/13/SpringCloud/1658754780600.png" alt="1658754780600"></p><p>访问信息有IP信息提示，（就是将鼠标指针移至payment8001，payment8002名下，会有IP地址提示）</p><p>修改部分 - YML - eureka.instance.prefer-ip-address</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  ...</span><br><span class="line">  instance:</span><br><span class="line">    instance-id: payment8001 </span><br><span class="line">    prefer-ip-address: <span class="literal">true</span> #添加此处</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  ...</span><br><span class="line">  instance:</span><br><span class="line">    instance-id: payment8002</span><br><span class="line">    prefer-ip-address: <span class="literal">true</span> #添加此处</span><br></pre></td></tr></table></figure><h3 id="服务发现Discovery"><a href="#服务发现Discovery" class="headerlink" title="服务发现Discovery"></a>服务发现Discovery</h3><p>对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息</p><ul><li><p>修改cloud-provider-payment8001的Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span>&#123;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/discovery&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">discovery</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; services = discoveryClient.getServices();</span><br><span class="line">        <span class="keyword">for</span> (String element : services) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;*****element: &quot;</span>+element);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (ServiceInstance instance : instances) &#123;</span><br><span class="line">            log.info(instance.getServiceId()+<span class="string">&quot;\t&quot;</span>+instance.getHost()+<span class="string">&quot;\t&quot;</span>+instance.getPort()+<span class="string">&quot;\t&quot;</span>+instance.getUri());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.discoveryClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>8001主启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span><span class="comment">//添加该注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain001</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自测</p></li></ul><p>先要启动EurekaServer</p><p>再启动8001主启动类，需要稍等一会儿</p><p>浏览器输入<a href="http://localhost:8001/payment8001/discovery">http://localhost:8001/payment8001/discovery</a></p><p>浏览器输出：</p><p><img src="/2022/07/13/SpringCloud/1658756448788.png" alt="1658756448788"></p><p>后台输出：</p><p><img src="/2022/07/13/SpringCloud/1658756510159.png" alt="1658756510159"></p><h3 id="Eureka自我保护理论知识"><a href="#Eureka自我保护理论知识" class="headerlink" title="Eureka自我保护理论知识"></a>Eureka自我保护理论知识</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。<strong>一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。</strong></p><p><strong>如果在Eureka Server的首页看到</strong>以下这段提示，则说明Eureka进入了保护模式:</p><p><img src="/2022/07/13/SpringCloud/1658756657232.png" alt="1658756657232"></p><h4 id="导致原因"><a href="#导致原因" class="headerlink" title="导致原因"></a>导致原因</h4><p>一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。</p><p>属于CAP里面的AP分支。</p><h4 id="为什么会产生Eureka自我保护机制"><a href="#为什么会产生Eureka自我保护机制" class="headerlink" title="为什么会产生Eureka自我保护机制?"></a>为什么会产生Eureka自我保护机制?</h4><p>为了EurekaClient可以正常运行，防止与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除</p><h4 id="什么是自我保护模式"><a href="#什么是自我保护模式" class="headerlink" title="什么是自我保护模式?"></a>什么是自我保护模式?</h4><p>默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例(默认90秒)。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，<strong>此时本不应该注销这个微服务</strong>。Eureka通过“自我保护模式”来解决这个问题——<strong>当EurekaServer节点在短时间内丢失过多客户端时(可能发生了网络分区故障)，那么这个节点就会进入自我保护模式。</strong></p><p><img src="/2022/07/13/SpringCloud/264b66e8099a3761beaea2ba44b8fc5e.png" alt="img"></p><p>自我保护机制∶默认情况下EurekaClient定时向EurekaServer端发送心跳包，如果Eureka在server端在一定时间内(<strong>默认90秒</strong>)没有收到EurekaClient发送心跳包，便会直接从服务注册列表中剔除该服务，但是<strong>在短时间( 90秒中</strong>)内<strong>丢失了大量的服务实例心跳</strong>，这时候Eurekaserver会开启自我保护机制，不会剔除该服务（该现象可能出现在如果网络不通但是EurekaClient为出现宕机，此时如果换做别的注册中心如果一定时间内没有收到心跳会将剔除该服务，这样就出现了严重失误，因为<strong>客户端还能正常发送心跳，只是网络延迟问题</strong>，而保护机制是为了解决此问题而产生的)。</p><p><strong>在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。</strong></p><p>它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解：<strong>好死不如赖活着。</strong></p><p>综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁<strong>可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务</strong>。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。</p><h4 id="怎么禁止自我保护"><a href="#怎么禁止自我保护" class="headerlink" title="怎么禁止自我保护"></a>怎么禁止自我保护</h4><p>在eurekaServer端7001和7002处设置关闭自我保护机制<br>出厂默认，自我保护机制是开启的</p><ul><li>使用eureka.server.enable-self-preservation &#x3D; false可以禁用自我保护模式</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  ...</span><br><span class="line">  server:</span><br><span class="line">    #关闭自我保护机制，保证不可用服务被及时踢除</span><br><span class="line">    enable-self-preservation: <span class="literal">false</span></span><br><span class="line">    #让服务端每隔<span class="number">2</span>秒扫描一次，使服务能尽快的剔除</span><br><span class="line">    eviction-interval-timer-in-ms: <span class="number">2000</span></span><br></pre></td></tr></table></figure><p>关闭效果：</p><p>spring-eureka主页会显示出一句：</p><p><img src="/2022/07/13/SpringCloud/1658839346031.png" alt="1658839346031"></p><ul><li>生产者客户端eureakeClient端8001和8002<br>默认：<ul><li>eureka.instance.lease-renewal-interval-in-seconds&#x3D;30</li><li>eureka.instance.lease-expiration-duration-in-seconds&#x3D;90</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  ...</span><br><span class="line">  instance:</span><br><span class="line">    instance-id: payment8001</span><br><span class="line">    prefer-ip-address: <span class="literal">true</span></span><br><span class="line">    #心跳检测与续约时间</span><br><span class="line">    #开发时没置小些，保证服务关闭后注册中心能即使剔除服务</span><br><span class="line">    #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是<span class="number">30</span>秒)</span><br><span class="line">    lease-renewal-interval-in-seconds: <span class="number">1</span></span><br><span class="line">    #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是<span class="number">90</span>秒)，超时将剔除服务</span><br><span class="line">    lease-expiration-duration-in-seconds: <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>测试<ul><li>7001、7002和8001、8002都配置完成</li><li>先启动7001、7002再启动8001、8002</li></ul></li><li>结果：先关闭8001，马上被删除了</li></ul><h2 id="Zookeeper服务注册与发现"><a href="#Zookeeper服务注册与发现" class="headerlink" title="Zookeeper服务注册与发现"></a>Zookeeper服务注册与发现</h2><h3 id="Eureka停更说明"><a href="#Eureka停更说明" class="headerlink" title="Eureka停更说明"></a>Eureka停更说明</h3><p><a href="https://github.com/Netflix/eureka/wiki">https://github.com/Netflix/eureka/wiki</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Eureka 2.0 (Discontinued)</span><br><span class="line"></span><br><span class="line">The existing open source work on eureka 2.0 is discontinued. The code base and artifacts that were released as part of the existing repository of work on the 2.x branch is considered use at your own risk.</span><br><span class="line"></span><br><span class="line">Eureka 1.x is a core part of Netflix’s service discovery system and is still an active project.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们用ZooKeeper代替Eureka功能。</p><h3 id="支付服务注册进zookeeper"><a href="#支付服务注册进zookeeper" class="headerlink" title="支付服务注册进zookeeper"></a>支付服务注册进zookeeper</h3><h4 id="注册中心Zookeeper"><a href="#注册中心Zookeeper" class="headerlink" title="注册中心Zookeeper"></a>注册中心Zookeeper</h4><p>zookeeper是一个分布式协调工具，可以实现注册中心功能</p><ul><li><p>tar -zxvf apache-zookeeper-3.5.8-bin.tar.gz进行解压</p></li><li><p>进入bin目录</p><p><img src="/2022/07/13/SpringCloud/1658841333252.png" alt="1658841333252"></p></li><li><p>关闭Linux服务器防火墙后，启动zookeeper服务器</p></li><li><p>用到的Linux命令行：</p><ul><li><p>systemctl stop firewalld关闭防火墙</p></li><li><p>systemctl status firewalld查看防火墙状态</p></li><li><p>ifconfig查看IP地址</p><p><img src="/2022/07/13/SpringCloud/1658841485283.png" alt="1658841485283"></p></li><li><p>ping查验结果</p><p><img src="/2022/07/13/SpringCloud/1658841598356.png" alt="1658841598356"></p></li></ul></li></ul><p>zookeeper服务器取代Eureka服务器，zk作为服务注册中心</p><h4 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h4><ol><li><p>新建名为cloud-provider-payment8005的Maven工程</p></li><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-provider-payment8005&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- SpringBoot整合Web组件 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br><span class="line">            &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- SpringBoot整合zookeeper客户端 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;</span><br><span class="line">            &lt;!--先排除自带的zookeeper3<span class="number">.5</span><span class="number">.3</span> 防止与<span class="number">3.4</span><span class="number">.9</span>起冲突--&gt;</span><br><span class="line">            &lt;!--&lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;--&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--添加zookeeper3<span class="number">.4</span><span class="number">.9</span>版本--&gt;</span><br><span class="line">        &lt;!--&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.4</span><span class="number">.9</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#<span class="number">8005</span>表示注册到zookeeper服务器的支付服务提供者端口号</span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">8005</span></span><br><span class="line"></span><br><span class="line">#服务别名----注册zookeeper到注册中心名称</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-provider-payment</span><br><span class="line">  cloud:</span><br><span class="line">    zookeeper:</span><br><span class="line">      connect-string: <span class="number">192.168</span><span class="number">.237</span><span class="number">.128</span>:<span class="number">2181</span> </span><br></pre></td></tr></table></figure></li><li><p>主启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span><span class="comment">//该注解用于向使用consul或者zookeeper作为注册中心时注册服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain8005</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8005.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/payment/zk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentzk</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springcloud with zookeeper: &quot;</span>+serverPort+<span class="string">&quot;\t&quot;</span>+ UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动8005注册进zookeeper</p></li><li><p>要先启动zookeeper的server</p><ul><li><p>你的压缩包是3.5以上的版本，随着版本的更新，3.5版本以后，都会自动把8080端口给占用了，所以启动不成功了</p></li><li><p>将zoo***.cfg文件改为zoo.cfg，在配置文件conf中的zoo.cfg添加以下命令即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># admin port</span><br><span class="line">admin.serverPort=9000</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/07/13/SpringCloud/1658928985563.png" alt="1658928985563"></p><p><img src="/2022/07/13/SpringCloud/1658929275192.png" alt="1658929275192"></p><p>可以与虚拟机上的zookeeper进行连接</p><p><img src="/2022/07/13/SpringCloud/1658929486354.png" alt="1658929486354"></p><p><img src="/2022/07/13/SpringCloud/1658930164185.png" alt="1658930164185"></p></li><li><p>验证测试：浏览器 - <a href="http://localhost:8005/payment/zk">http://localhost:8005/payment/zk</a></p><p><img src="/2022/07/13/SpringCloud/1658930201398.png" alt="1658930201398"></p></li><li><p>验证测试2 ：接着用zookeeper客户端操作</p><p><img src="/2022/07/13/SpringCloud/1658930354286.png" alt="1658930354286"></p></li></ol><ul><li><p>json格式化get &#x2F;services&#x2F;cloud-provider-payment&#x2F;a4567f50-6ad9-47a3-9fbb-7391f41a9f3d的结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cloud-provider-payment&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9eb18cbd-c4d9-4a21-8f18-db4f35de269e&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.43.168&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">8005</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sslPort&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;payload&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.cloud.zookeeper.discovery.ZookeeperInstance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application-1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cloud-provider-payment&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;registrationTimeUTC&quot;</span><span class="punctuation">:</span> <span class="number">1658929852914</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;serviceType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DYNAMIC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;uriSpec&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;parts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;scheme&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;variable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;://&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;variable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;address&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;variable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;:                                                                              &quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;variable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;port&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;variable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="临时还是持久节点"><a href="#临时还是持久节点" class="headerlink" title="临时还是持久节点"></a>临时还是持久节点</h3><p>ZooKeeper的服务节点是临时节点，没有Eureka那含情脉脉。</p><h3 id="订单服务注册进zookeeper"><a href="#订单服务注册进zookeeper" class="headerlink" title="订单服务注册进zookeeper"></a>订单服务注册进zookeeper</h3><ol><li><p>新建cloud-consumerzk-order80</p></li><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-consumerzk-order80&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- SpringBoot整合Web组件 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- SpringBoot整合zookeeper客户端 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;</span><br><span class="line">            &lt;!--先排除自带的zookeeper--&gt;</span><br><span class="line">          &lt;!--  &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;--&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--添加zookeeper3<span class="number">.4</span><span class="number">.9</span>版本--&gt;</span><br><span class="line">      &lt;!--  &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.4</span><span class="number">.9</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">80</span></span><br><span class="line"></span><br><span class="line">#服务别名----注册zookeeper到注册中心名称</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-consumer-order</span><br><span class="line">  cloud:</span><br><span class="line">    zookeeper:</span><br><span class="line">      connect-string: <span class="number">192.168</span><span class="number">.237</span><span class="number">.128</span>:<span class="number">2181</span></span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/7/28 20:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderZkMain80</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderZkMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderZKController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INVOKE_URL</span> <span class="operator">=</span> <span class="string">&quot;http://cloud-provider-payment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/zk&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(INVOKE_URL+<span class="string">&quot;/payment/zk&quot;</span>,String.class);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>验证测试</p><ul><li>运行ZooKeeper服务端，cloud-consumerzk-order80，cloud-provider-payment8004</li></ul></li></ol><p>  <img src="/2022/07/13/SpringCloud/1659013693238.png" alt="1659013693238"></p><ul><li>打开ZooKeeper客户端：</li></ul><ol start="7"><li>访问测试地址 - <a href="http://localhost/consumer/payment/zk">http://localhost/consumer/payment/zk</a></li></ol><h2 id="Consul服务注册与发现"><a href="#Consul服务注册与发现" class="headerlink" title="Consul服务注册与发现"></a>Consul服务注册与发现</h2><h3 id="Consul简介"><a href="#Consul简介" class="headerlink" title="Consul简介"></a>Consul简介</h3><p>[Consul官网]: <a href="https://www.consul.io/">https://www.consul.io/</a>“Consul官网”<br>[Consul下载地址]: <a href="https://www.consul.io/downloads">https://www.consul.io/downloads</a>“Consul下载地址”<br>[Consul中文文档]: <a href="https://www.springcloud.cc/spring-cloud-consul.html">https://www.springcloud.cc/spring-cloud-consul.html</a>“Consul中文文档”</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">What is Consul?</span><br><span class="line"></span><br><span class="line">Consul is a service mesh solution providing a full featured control plane with service discovery, configuration, and segmentation functionality. Each of these features can be used individually as needed, or they can be used together to build a full service mesh. Consul requires a data plane and supports both a proxy and native integration model. Consul ships with a simple built-in proxy so that everything works out of the box, but also supports 3rd party proxy integrations such as Envoy. link</span><br><span class="line"></span><br><span class="line">Consul是一个服务网格解决方案，它提供了一个功能齐全的控制平面，具有服务发现、配置和分段功能。这些特性中的每一个都可以根据需要单独使用，也可以一起用于构建全服务网格。Consul需要一个数据平面，并支持代理和本机集成模型。Consul船与一个简单的内置代理，使一切工作的开箱即用，但也支持第三方代理集成，如Envoy。</span><br></pre></td></tr></table></figure><p>Consul是一套开源的分布式服务发现和配置管理系统，由HashiCorp 公司用Go语言开发。</p><p>提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。</p><p>它具有很多优点。包括：基于raft协议，比较简洁；支持健康检查，同时支持HTTP和DNS协议支持跨数据中心的WAN集群提供图形界面跨平台，支持Linux、Mac、Windows。</p><p>能干嘛？</p><ul><li>服务发现 - 提供HTTP和DNS两种发现方式。</li><li>健康监测 - 支持多种方式，HTTP、TCP、Docker、Shell脚本定制化</li><li>KV存储 - Key、Value的存储方式</li><li>多数据中心 - Consul支持多数据中心</li><li>可视化Web界面</li></ul><h3 id="安装并运行Consul"><a href="#安装并运行Consul" class="headerlink" title="安装并运行Consul"></a>安装并运行Consul</h3><p>[官网安装说明]: <a href="https://learn.hashicorp.com/tutorials/consul/get-started-install">https://learn.hashicorp.com/tutorials/consul/get-started-install</a>“官网安装说明”</p><p>windows版解压缩后，得consul.exe，打开cmd</p><ul><li><p>查看版本consul -v：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">F:\BaiduNetdiskDownload\安装包&gt;consul -v</span><br><span class="line">Consul v1<span class="number">.8</span><span class="number">.3</span></span><br><span class="line">Revision a9322b9c7</span><br><span class="line">Protocol <span class="number">2</span> spoken by <span class="keyword">default</span>, understands <span class="number">2</span> to <span class="number">3</span> (agent will automatically use protocol &gt;<span class="number">2</span> when speaking to compatible agents)</span><br></pre></td></tr></table></figure></li><li><p>开发模式启动：consul agent -dev</p></li></ul><p>浏览器输入 - <a href="http://localhost:8500/">http://localhost:8500/</a> - 打开Consul控制页。</p><h3 id="服务提供者注册进Consul"><a href="#服务提供者注册进Consul" class="headerlink" title="服务提供者注册进Consul"></a>服务提供者注册进Consul</h3><ol><li><p>新建Module支付服务cloud-providerconsul-payment8006</p></li><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-providerconsul-payment8006&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-consul-discovery --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">###consul服务端口号</span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">8006</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consul-provider-payment</span><br><span class="line">####consul注册中心地址</span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: localhost</span><br><span class="line">      port: <span class="number">8500</span></span><br><span class="line">      discovery:</span><br><span class="line">        #hostname: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">        service-name: $&#123;spring.application.name&#125;</span><br></pre></td></tr></table></figure></li><li><p>主启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain8006</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            SpringApplication.run(PaymentMain8006.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务类Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/payment/consul&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentConsul</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springcloud with consul: &quot;</span>+serverPort+<span class="string">&quot;\t   &quot;</span>+ UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>验证测试</p></li></ol><p><a href="http://localhost:8006/payment/consul">http://localhost:8006/payment/consul</a><br><a href="http://localhost:8500/">http://localhost:8500</a> - 会显示consul-provider-payment</p><h3 id="服务消费者注册进Consul"><a href="#服务消费者注册进Consul" class="headerlink" title="服务消费者注册进Consul"></a>服务消费者注册进Consul</h3><ol><li><p>新建Module消费服务order80 - cloud-consumerconsul-order80</p></li><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-consumerconsul-order80&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-consul-discovery --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line">        &lt;!-- SpringBoot整合Web组件 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt;</span></span><br><span class="line">        &lt;!--日常通用jar包配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">###consul服务端口号</span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">80</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-consumer-order</span><br><span class="line">####consul注册中心地址</span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: localhost</span><br><span class="line">      port: <span class="number">8500</span></span><br><span class="line">      discovery:</span><br><span class="line">        #hostname: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">        service-name: $&#123;spring.application.name&#125;</span><br></pre></td></tr></table></figure></li><li><p>主启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//该注解用于向使用consul或者zookeeper作为注册中心时注册服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderConsulMain80</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            SpringApplication.run(OrderConsulMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderConsulController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INVOKE_URL</span> <span class="operator">=</span> <span class="string">&quot;http://consul-provider-payment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/consul&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(INVOKE_URL+<span class="string">&quot;/payment/consul&quot;</span>,String.class);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>验证测试</p></li></ol><p>运行consul，cloud-providerconsul-payment8006，cloud-consumerconsul-order80</p><p><a href="http://localhost:8500/">http://localhost:8500/</a> 主页会显示出consul，cloud-providerconsul-payment8006，cloud-consumerconsul-order80三服务。</p><p>8.访问测试地址 - <a href="http://localhost/consumer/payment/consul">http://localhost/consumer/payment/consul</a></p><h2 id="三个注册中心异同点"><a href="#三个注册中心异同点" class="headerlink" title="三个注册中心异同点"></a>三个注册中心异同点</h2><table><thead><tr><th>组件名</th><th>语言</th><th>CAP</th><th>服务健康检查</th><th>对外暴露接口</th><th>Spring Cloud集成</th></tr></thead><tbody><tr><td>Eureka</td><td>Java</td><td>AP</td><td>可配支持</td><td>HTTP</td><td>已集成</td></tr><tr><td>Consul</td><td>Go</td><td>CP</td><td>支持</td><td>HTTP&#x2F;DNS</td><td>已集成</td></tr><tr><td>Zookeeper</td><td>Java</td><td>CP</td><td>支持</td><td>客户端</td><td>已集成</td></tr></tbody></table><p>CAP：CAP理论关注粒度是数据，而不是整体系统设计的策略</p><ul><li>C：Consistency (强一致性)</li><li>A：Availability (可用性)</li><li>P：Partition tolerance （分区容错性)</li></ul><p><img src="/2022/07/13/SpringCloud/b41e0791c9652955dd3a2bc9d2d60983.png" alt="img"></p><p>最多只能同时较好的满足两个。</p><p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求。</p><p>因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类:</p><ul><li>CA - 单点集群，满足—致性，可用性的系统，通常在可扩展性上不太强大。</li><li>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</li><li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li></ul><hr><p>AP架构（Eureka）</p><p>当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。</p><p>结论：违背了一致性C的要求，只满足可用性和分区容错，即AP</p><p><img src="/2022/07/13/SpringCloud/2d07748539300b9c466eb1d9bac5cd1b.png" alt="img"></p><hr><p>CP架构（ZooKeeper&#x2F;Consul）</p><p>当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性。</p><p>结论：违背了可用性A的要求，只满足一致性和分区容错，即CP。</p><p><img src="/2022/07/13/SpringCloud/c6f2926a97420015fcebc89b094c5598.png" alt="img"></p><p>CP 与 AP 对立同一的矛盾关系。</p><h2 id="Ribbon负载均衡服务调用"><a href="#Ribbon负载均衡服务调用" class="headerlink" title="Ribbon负载均衡服务调用"></a>Ribbon负载均衡服务调用</h2><h3 id="Ribbon入门介绍"><a href="#Ribbon入门介绍" class="headerlink" title="Ribbon入门介绍"></a>Ribbon入门介绍</h3><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。</p><p>简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供<strong>客户端的软件负载均衡算法和服务调用</strong>。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。</p><p>简单的说，就是在配置文件中列出Load Balancer(简称LB)后面所有的机器，Ribbon会自动的帮助你基于某种规则(如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。</p><p>[Github - Ribbon]: <a href="https://github.com/Netflix/ribbon/wiki/Getting-Started">https://github.com/Netflix/ribbon/wiki/Getting-Started</a>“Github - Ribbon”</p><p>Ribbon目前也进入维护模式。</p><p>Ribbon未来可能被Spring Cloud LoadBalacer替代。</p><h4 id="LB负载均衡-Load-Balance-是什么"><a href="#LB负载均衡-Load-Balance-是什么" class="headerlink" title="LB负载均衡(Load Balance)是什么"></a>LB负载均衡(Load Balance)是什么</h4><p>简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高可用)。</p><p>常见的负载均衡有软件Nginx，LVS，硬件F5等。</p><h4 id="Ribbon本地负载均衡客户端VS-Nginx服务端负载均衡区别"><a href="#Ribbon本地负载均衡客户端VS-Nginx服务端负载均衡区别" class="headerlink" title="Ribbon本地负载均衡客户端VS Nginx服务端负载均衡区别"></a>Ribbon本地负载均衡客户端VS Nginx服务端负载均衡区别</h4><p>Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。<br>Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。</p><h4 id="集中式LB"><a href="#集中式LB" class="headerlink" title="集中式LB"></a>集中式LB</h4><p>即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx)，由该设施负责把访问请求通过某种策略转发至服务的提供方;</p><h4 id="进程内LB"><a href="#进程内LB" class="headerlink" title="进程内LB"></a>进程内LB</h4><p>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。</p><p>Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p><h4 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h4><p>负载均衡 + RestTemplate调用</p><h3 id="Ribbon的负载均衡和Rest调用"><a href="#Ribbon的负载均衡和Rest调用" class="headerlink" title="Ribbon的负载均衡和Rest调用"></a>Ribbon的负载均衡和Rest调用</h3><h4 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h4><p>总结：Ribbon其实就是一个软负载均衡的客户端组件，它可以和其他所需请求的客户端结合使用，和Eureka结合只是其中的一个实例。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/145b915e56a85383b3ad40f0bb2256e0.png" alt="img"></p><p>Ribbon在工作时分成两步：</p><ul><li><p>第一步先选择EurekaServer ,它优先选择在同一个区域内负载较少的server。</p></li><li><p>第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。</p></li></ul><p>其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。</p><h4 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h4><p>先前工程项目没有引入spring-cloud-starter-netflix-ribbon也可以使用ribbon。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupld&gt;org.springframework.cloud&lt;/groupld&gt;</span><br><span class="line">    &lt;artifactld&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactid&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>这是因为spring-cloud-starter-netflix-eureka-client自带了spring-cloud-starter-ribbon引用。</strong></p><h4 id="二说RestTemplate的使用"><a href="#二说RestTemplate的使用" class="headerlink" title="二说RestTemplate的使用"></a>二说RestTemplate的使用</h4><p>[RestTemplate Java Doc]: <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html</a>“RestTemplate Java Doc”</p><p><strong>getForObject() &#x2F; getForEntity() - GET请求方法</strong></p><p>getForObject()：返回对象为响应体中数据转化成的对象，基本上可以理解为Json。</p><p>getForEntity()：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等。</p><p><img src="/2022/07/13/SpringCloud/1659169722531.png" alt="1659169722531"></p><p><strong>postForObject() &#x2F; postForEntity()</strong> - POST请求方法</p><p><img src="/2022/07/13/SpringCloud/1659170298284.png" alt="1659170298284"></p><h3 id="Ribbon核心组件IRule"><a href="#Ribbon核心组件IRule" class="headerlink" title="Ribbon核心组件IRule"></a>Ribbon核心组件IRule</h3><h4 id="Ribbon默认自带的负载规则"><a href="#Ribbon默认自带的负载规则" class="headerlink" title="Ribbon默认自带的负载规则"></a>Ribbon默认自带的负载规则</h4><p>lRule：根据特定算法中从服务列表中选取一个要访问的服务</p><p><img src="/2022/07/13/SpringCloud/87243c00c0aaea211819c0d8fc97e445.png" alt="img"></p><ul><li>RoundRobinRule： 轮询</li><li>RandomRule ：随机</li><li>RetryRule ：先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重</li><li>WeightedResponseTimeRule： 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择</li><li>BestAvailableRule ：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</li><li>AvailabilityFilteringRule ：先过滤掉故障实例，再选择并发较小的实例</li><li>ZoneAvoidanceRule： 默认规则,复合判断server所在区域的性能和server的可用性选择服务器</li></ul><h4 id="Ribbon负载规则替换"><a href="#Ribbon负载规则替换" class="headerlink" title="Ribbon负载规则替换"></a>Ribbon负载规则替换</h4><ol><li><p>修改cloud-consumer-order80</p></li><li><p>注意配置细节</p><ul><li>官方文档明确给出了警告:</li><li>这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了。（<strong>也就是说不要将Ribbon配置类与主启动类在同一层</strong>）</li></ul></li><li><p>新建package - com.hua.myrule</p></li><li><p>在com.lun.myrule下新建MySelfRule规则类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.myrule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.IRule;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/7/30 16:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySelfRule</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">myRule</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//定义为随机        </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主启动类添加@RibbonClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.springcloud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.myrule.MySelfRule;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.ribbon.RibbonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//添加到此处</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;, configuration = MySelfRule.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderMain80</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><p>开启cloud-eureka-server7001，cloud-eureka-server7002，cloud-consumer-order80，cloud-provider-payment8001，cloud-provider-payment8002</p><p>浏览器-输入<a href="http://localhost/consumer/payment/get/1">http://localhost/consumer/payment/get/1</a></p><p>返回结果中的serverPort在8001与8002两种间随机反复横跳。</p><h3 id="Ribbon负载均衡算法——轮询"><a href="#Ribbon负载均衡算法——轮询" class="headerlink" title="Ribbon负载均衡算法——轮询"></a>Ribbon负载均衡算法——轮询</h3><h4 id="Ribbon默认负载轮询算法原理"><a href="#Ribbon默认负载轮询算法原理" class="headerlink" title="Ribbon默认负载轮询算法原理"></a>Ribbon默认负载轮询算法原理</h4><p><strong>默认负载轮训算法: rest接口第几次请求数 % 服务器集群总数量 &#x3D; 实际调用服务器位置下标，每次服务重启动后rest接口计数从1开始。</strong></p><p>List<Servicelnstance> instances &#x3D; discoveryClient.getInstances(“CLOUD-PAYMENT-SERVICE”);</Servicelnstance></p><p>如:</p><ul><li>List [0] instances &#x3D; 127.0.0.1:8002</li><li>List [1] instances &#x3D; 127.0.0.1:8001</li></ul><p>8001+ 8002组合成为集群，它们共计2台机器，集群总数为2，按照轮询算法原理：</p><ul><li>当总请求数为1时:1%2&#x3D;1对应下标位置为1，则获得服务地址为127.0.0.1:8001</li><li>当总请求数位2时:2%2&#x3D;0对应下标位置为0，则获得服务地址为127.0.0.1:8002</li><li>当总请求数位3时:3%2&#x3D;1对应下标位置为1，则获得服务地址为127.0.0.1:8001</li><li>当总请求数位4时:4%2&#x3D;0对应下标位置为0，则获得服务地址为127.0.0.1:8002</li><li>如此类推…</li></ul><h4 id="RoundRobinRule源码分析"><a href="#RoundRobinRule源码分析" class="headerlink" title="RoundRobinRule源码分析"></a>RoundRobinRule源码分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRule</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * choose one alive server from lb.allServers or</span></span><br><span class="line"><span class="comment">     * lb.upServers according to key</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @return choosen Server object. NULL is returned if none</span></span><br><span class="line"><span class="comment">     *  server is available </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点关注这方法</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ILoadBalancer <span class="title function_">getLoadBalancer</span><span class="params">()</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.client.config.IClientConfig;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The most well known and basic load balancing strategy, i.e. Round Robin Rule.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Nikos Michalakis &lt;nikos@netflix.com&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundRobinRule</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalancerRule</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger nextServerCyclicCounter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">AVAILABLE_ONLY_SERVERS</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">ALL_SERVERS</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(RoundRobinRule.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoundRobinRule</span><span class="params">()</span> &#123;</span><br><span class="line">        nextServerCyclicCounter = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoundRobinRule</span><span class="params">(ILoadBalancer lb)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        setLoadBalancer(lb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点关注这方法。</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lb == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;no load balancer&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (server == <span class="literal">null</span> &amp;&amp; count++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">            List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">            <span class="type">int</span> <span class="variable">upCount</span> <span class="operator">=</span> reachableServers.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">serverCount</span> <span class="operator">=</span> allServers.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((upCount == <span class="number">0</span>) || (serverCount == <span class="number">0</span>)) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;No up servers available from load balancer: &quot;</span> + lb);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextServerIndex</span> <span class="operator">=</span> incrementAndGetModulo(serverCount);</span><br><span class="line">            server = allServers.get(nextServerIndex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">/* Transient. */</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">                <span class="keyword">return</span> (server);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Next.</span></span><br><span class="line">            server = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;No available alive servers after 10 tries from load balancer: &quot;</span></span><br><span class="line">                    + lb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inspired by the implementation of &#123;<span class="doctag">@link</span> AtomicInteger#incrementAndGet()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modulo The modulo to bound the value of the counter.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The next value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">incrementAndGetModulo</span><span class="params">(<span class="type">int</span> modulo)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋锁</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> nextServerCyclicCounter.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (current + <span class="number">1</span>) % modulo;<span class="comment">//求余法</span></span><br><span class="line">            <span class="keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))<span class="comment">//CAS操作</span></span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Ribbon之手写轮询算法"><a href="#Ribbon之手写轮询算法" class="headerlink" title="Ribbon之手写轮询算法"></a>Ribbon之手写轮询算法</h4><p>自己试着写一个类似RoundRobinRule的本地负载均衡器。</p><ul><li><p>7001&#x2F;7002集群启动</p></li><li><p>8001&#x2F;8002微服务改造- controller</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/payment/lb&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPaymentLB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serverPort;<span class="comment">//返回服务接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>80订单微服务改造</p><ul><li>ApplicationContextConfig去掉注解@LoadBalanced，OrderMain80去掉注解@RibbonClient</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建LoadBalancer接口</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadBalancer</span></span><br><span class="line">&#123;</span><br><span class="line">    ServiceInstance <span class="title function_">instances</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MyLB：实现LoadBalancer接口</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//需要跟主启动类同包，或者在其子孙包下。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLB</span> <span class="keyword">implements</span> <span class="title class_">LoadBalancer</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> current;</span><br><span class="line">        <span class="type">int</span> next;<span class="comment">//当前访问的次数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            current = <span class="built_in">this</span>.atomicInteger.get();</span><br><span class="line">            <span class="comment">//2147483647为整形(integer)的最大值</span></span><br><span class="line">            next = current &gt;= <span class="number">2147483647</span> ? <span class="number">0</span> : current + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(!<span class="built_in">this</span>.atomicInteger.compareAndSet(current,next));</span><br><span class="line">        System.out.println(<span class="string">&quot;*****第几次访问，次数next: &quot;</span>+next);</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//负载均衡算法：rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标  ，每次服务重启动后rest接口计数从1开始。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInstance <span class="title function_">instances</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getAndIncrement() % serviceInstances.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> serviceInstances.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>OrderController</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.cloud.client.ServiceInstance;</span><br><span class="line">import org.springframework.cloud.client.discovery.DiscoveryClient;</span><br><span class="line">import com.lun.springcloud.lb.LoadBalancer;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    //public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;</span><br><span class="line">    public static final String PAYMENT_URL = &quot;http://CLOUD-PAYMENT-SERVICE&quot;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = &quot;/consumer/payment/lb&quot;)</span><br><span class="line">    public String getPaymentLB()</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);</span><br><span class="line"></span><br><span class="line">        if(instances == null || instances.size() &lt;= 0)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ServiceInstance serviceInstance = loadBalancer.instances(instances);</span><br><span class="line">        URI uri = serviceInstance.getUri();</span><br><span class="line"></span><br><span class="line">        return restTemplate.getForObject(uri+&quot;/payment/lb&quot;,String.class);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试 不停地刷新<a href="http://localhost/consumer/payment/lb%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B08001/8002%E4%BA%A4%E6%9B%BF%E5%87%BA%E7%8E%B0%E3%80%82">http://localhost/consumer/payment/lb，可以看到8001/8002交替出现。</a></p></li></ul><h2 id="OpenFeign服务接口调用"><a href="#OpenFeign服务接口调用" class="headerlink" title="OpenFeign服务接口调用"></a>OpenFeign服务接口调用</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><h4 id="OpenFeign是什么"><a href="#OpenFeign是什么" class="headerlink" title="OpenFeign是什么"></a>OpenFeign是什么</h4><p>[官方文档]: <a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/#spring-cloud-openfeign">https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/#spring-cloud-openfeign</a>“官方文档”<br>[Github地址]: <a href="https://github.com/spring-cloud/spring-cloud-openfeign">https://github.com/spring-cloud/spring-cloud-openfeign</a>“Github地址”</p><blockquote><p>Feign is a declarative web service client. It makes writing web service clients easier. To use Feign create an interface and annotate it. It has pluggable annotation support including Feign annotations and JAX-RS annotations. Feign also supports pluggable encoders and decoders. Spring Cloud adds support for Spring MVC annotations and for using the same HttpMessageConverters used by default in Spring Web. Spring Cloud integrates Ribbon and Eureka, as well as Spring Cloud LoadBalancer to provide a load-balanced http client when using Feign. link</p><p>Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。<strong>它的使用方法是定义一个服务接口然后在上面添加注解</strong>。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。</p></blockquote><h4 id="Feign能干什么"><a href="#Feign能干什么" class="headerlink" title="Feign能干什么"></a>Feign能干什么</h4><p>Feign旨在使编写Java Http客户端变得更容易。</p><p>前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，<strong>往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用</strong>。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，**我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)**，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。</p><h4 id="Feign集成了Ribbon"><a href="#Feign集成了Ribbon" class="headerlink" title="Feign集成了Ribbon"></a>Feign集成了Ribbon</h4><p>利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过<strong>feign只需要定义服务绑定接口且以声明式的方法</strong>，优雅而简单的实现了服务调用。</p><h4 id="Feign和OpenFeign两者区别"><a href="#Feign和OpenFeign两者区别" class="headerlink" title="Feign和OpenFeign两者区别"></a>Feign和OpenFeign两者区别</h4><p>Feign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是:使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>OpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@Feignclient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>feign<br>英 [feɪn] 美 [feɪn]<br>v. 假装，装作，佯装(有某种感觉或生病、疲倦等)</p></blockquote><h3 id="OpenFeign服务调用"><a href="#OpenFeign服务调用" class="headerlink" title="OpenFeign服务调用"></a>OpenFeign服务调用</h3><p>接口+注解：<strong>微服务调用接口 + @FeignClient</strong></p><ol><li><p>新建cloud-consumer-feign-order80</p></li><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-consumer-feign-order80&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--openfeign--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--eureka client--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--web--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--一般基础通用配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">80</span></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="literal">false</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/2 21:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFeignMain80</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderFeignMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务类</p><ul><li>业务逻辑接口+@FeignClient配置调用provider服务</li><li>新建PaymentFeignService接口并新增注解@FeignClient</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentFeignService</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制层Controller</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/2 21:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFeignController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><ul><li>先启动2个eureka集群7001&#x2F;7002</li><li>再启动2个微服务8001&#x2F;8002</li><li>启动OpenFeign启动</li><li><a href="http://localhost/consumer/payment/get/1">http://localhost/consumer/payment/get/1</a></li><li>Feign自带负载均衡配置项</li></ul></li></ol><p><img src="/2022/07/13/SpringCloud/1659448737605.png" alt="1659448737605"></p><h3 id="OpenFeign超时控制"><a href="#OpenFeign超时控制" class="headerlink" title="OpenFeign超时控制"></a>OpenFeign超时控制</h3><p><strong>超时设置，故意设置超时演示出错情况</strong></p><ol><li><p>服务提供方8001&#x2F;8002故意写暂停程序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/feign/timeout&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentFeignTimeout</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑处理正确，但是需要耗费3秒钟</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务消费方80PaymentFeignService中添加超时方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentFeignService</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/feign/timeout&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentFeignTimeout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务消费方80OrderFeignController中添加超时方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFeignController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/feign/timeout&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentFeignTimeout</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// OpenFeign-ribbon,客户端一般默认等待1秒钟</span></span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.paymentFeignTimeout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><ul><li><p><a href="http://localhost:8001/payment/feign/timeout">localhost:8001&#x2F;payment&#x2F;feign&#x2F;timeout</a></p></li><li><p>多次刷新<a href="http://localhost/consumer/payment/feign/timeout">http://localhost/consumer/payment/feign/timeout</a></p></li></ul></li></ol><ul><li><p>将会跳出错误Spring Boot默认错误页面，主要异常：feign.RetryableException:Read timed out executing GET <a href="http://cloud-payment-servce/payment/feign/timeout%E3%80%82">http://CLOUD-PAYMENT-SERVCE/payment/feign/timeout。</a></p><ul><li><strong>OpenFeign默认等待1秒钟，超过后报错</strong></li></ul><p><img src="/2022/07/13/SpringCloud/1659449765611.png" alt="1659449765611"></p><ul><li><strong>feign-order80中YML文件里需要设置OpenFeign客户端超时控制</strong></li></ul> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#设置feign客户端超时时间(OpenFeign默认支持ribbon)(单位：毫秒)</span><br><span class="line">ribbon:</span><br><span class="line">  #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间</span><br><span class="line">  ReadTimeout: <span class="number">5000</span></span><br><span class="line">  #指的是建立连接后从服务器读取到可用资源所用的时间</span><br><span class="line">  ConnectTimeout: <span class="number">5000</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="OpenFeign日志增强"><a href="#OpenFeign日志增强" class="headerlink" title="OpenFeign日志增强"></a>OpenFeign日志增强</h3><h4 id="日志打印功能"><a href="#日志打印功能" class="headerlink" title="日志打印功能"></a>日志打印功能</h4><p>Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解Feign 中 Http请求的细节。</p><p>说白了就是<strong>对Feign接口的调用情况进行监控和输出</strong></p><h4 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h4><ul><li>NONE：默认的，不显示任何日志;</li><li>BASIC：仅记录请求方法、URL、响应状态码及执行时间;</li><li>HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息;</li><li>FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</li></ul><p><strong>配置日志bean</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/3 20:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>YML文件里需要开启日志的Feign客户端</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    # feign日志以什么级别监控哪个接口</span><br><span class="line">    com.hua.study.service.PaymentFeignService: debug</span><br></pre></td></tr></table></figure><p><strong>后台日志查看</strong></p><p>得到更多日志信息。</p><p><img src="/2022/07/13/SpringCloud/1659531299086.png" alt="1659531299086"></p><h2 id="Hystrix断路器"><a href="#Hystrix断路器" class="headerlink" title="Hystrix断路器"></a>Hystrix断路器</h2><h3 id="Hystrix是什么"><a href="#Hystrix是什么" class="headerlink" title="Hystrix是什么"></a>Hystrix是什么</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>分布式系统面临的问题</p><p>复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。</p><h4 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h4><p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“<strong>扇出</strong>”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.<br>对于高流量的应用来说，单一的后避依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p><p>所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。</p><h4 id="Hystrix是什么-1"><a href="#Hystrix是什么-1" class="headerlink" title="Hystrix是什么"></a>Hystrix是什么</h4><p>Hystrix是一个用于处理分布式系统的<strong>延迟和容错</strong>的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，<strong>不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性</strong>。</p><p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的<strong>故障监控（类似熔断保险丝</strong>)，<strong>向调用方返回一个符合预期的、可处理的备选响应（FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常</strong>，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p><h4 id="Hystrix停更进维"><a href="#Hystrix停更进维" class="headerlink" title="Hystrix停更进维"></a>Hystrix停更进维</h4><p><strong>能干嘛</strong></p><ul><li>服务降级</li><li>服务熔断</li><li>接近实对的监控</li><li>…</li></ul><p><strong>官网资料</strong></p><p><a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">link</a></p><p><strong>Hystrix官宣，停更进维</strong></p><p><a href="https://github.com/Netflix/Hystrix">link</a></p><ul><li>被动修bugs</li><li>不再接受合并请求</li><li>不再发布新版本</li></ul><h3 id="Hystrix重要概念"><a href="#Hystrix重要概念" class="headerlink" title="Hystrix重要概念"></a>Hystrix重要概念</h3><h4 id="服务降级（fallback）"><a href="#服务降级（fallback）" class="headerlink" title="服务降级（fallback）"></a>服务降级（fallback）</h4><p>服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback</p><h5 id="哪些情况会触发降级"><a href="#哪些情况会触发降级" class="headerlink" title="哪些情况会触发降级"></a>哪些情况会触发降级</h5><ul><li>程序运行导常</li><li>超时</li><li>服务熔断触发服务降级</li><li>线程池&#x2F;信号量打满也会导致服务降级</li></ul><h4 id="服务熔断（break）"><a href="#服务熔断（break）" class="headerlink" title="服务熔断（break）"></a>服务熔断（break）</h4><p>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。</p><p>服务的降级 -&gt; 进而熔断 -&gt; 恢复调用链路</p><h4 id="服务限流（flowlimit）"><a href="#服务限流（flowlimit）" class="headerlink" title="服务限流（flowlimit）"></a>服务限流（flowlimit）</h4><p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行。</p><h3 id="Hystrix支付微服务构建"><a href="#Hystrix支付微服务构建" class="headerlink" title="Hystrix支付微服务构建"></a>Hystrix支付微服务构建</h3><p>将cloud-eureka-server7001改配置成单机版</p><ol><li><p>新建cloud-provider-hygtrix-payment8001</p></li><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-provider-hygtrix-payment8001&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;cloud-provider-hygtrix-payment8001&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--hystrix--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--eureka client--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--web--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br><span class="line">            &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8001</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-provider-hystrix-payment</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="literal">true</span></span><br><span class="line">    fetch-registry: <span class="literal">true</span></span><br><span class="line">    service-url:</span><br><span class="line">      #defaultZone: http:<span class="comment">//eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br><span class="line">      defaultZone: http:<span class="comment">//eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/3 21:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentHystrixMain8001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务层</p><ul><li>service</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.springcloud.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/3 21:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常访问</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池:  &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  paymentInfo_OK,id:  &quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;O(∩_∩)O哈哈~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时访问</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">timeNumber</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(timeNumber);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池:  &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  paymentInfo_TimeOut,id:  &quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;O(∩_∩)O哈哈~耗时&quot;</span>+timeNumber+<span class="string">&quot;秒&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>controller</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.PaymentService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/3 22:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String serverPort;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentService.paymentInfo_OK(id);</span><br><span class="line">        log.info(<span class="string">&quot;*****result: &quot;</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentService.paymentInfo_TimeOut(id);</span><br><span class="line">        log.info(<span class="string">&quot;*****result: &quot;</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><ul><li>启动eureka7001</li><li>启动cloud-provider-hystrix-payment8001</li><li>访问success的方法 - <a href="http://localhost:8001/payment/hystrix/ok/1">http://localhost:8001/payment/hystrix/ok/1</a></li><li>每次调用耗费5秒钟 - <a href="http://localhost:8001/payment/hystrix/timeout/1">http://localhost:8001/payment/hystrix/timeout/1</a></li></ul></li></ol><p>上述module均OK</p><p>以上述为根基平台，从正确 -&gt; 错误 -&gt; 降级熔断 -&gt; 恢复。</p><h3 id="JMeter高并发压测后卡顿"><a href="#JMeter高并发压测后卡顿" class="headerlink" title="JMeter高并发压测后卡顿"></a>JMeter高并发压测后卡顿</h3><p><strong>上述在非高并发情形下，还能勉强满足</strong></p><h4 id="Jmeter压测测试"><a href="#Jmeter压测测试" class="headerlink" title="Jmeter压测测试"></a><strong>Jmeter压测测试</strong></h4><p>[JMeter官网]: <a href="https://jmeter.apache.org/index.html">https://jmeter.apache.org/index.html</a>“JMeter官网”</p><blockquote><p>The Apache JMeter™ application is open source software, a 100% pure Java application designed to load test functional behavior and measure performance. It was originally designed for testing Web Applications but has since expanded to other test functions.</p></blockquote><p>开启Jmeter（解压之后运行bin目录下的jmeter.bat），来20000个并发压死8001，20000个请求都去访问paymentInfo_TimeOut服务</p><ol><li><p>测试计划中右键添加-&gt;线程-&gt;线程组（线程组2022，线程数：200，线程数：100，其他参数默认）</p><p><img src="/2022/07/13/SpringCloud/1659962690726.png" alt="1659962690726"></p></li><li><p>刚刚新建线程组2022，右键它-&gt;添加-&gt;取样器-&gt;Http请求-&gt;基本 输入<a href="http://localhost:8001/payment/hystrix/timeout/1">http://localhost:8001/payment/hystrix/timeout/1</a></p><p><img src="/2022/07/13/SpringCloud/1659962920515.png" alt="1659962920515"></p></li><li><p>点击绿色三角形图标启动。</p></li></ol><p>看演示结果：俩个都在转圈，被拖慢，原因：tomcat的默认的工作线程数被打满了，没有多余的线程来分解压力和处理。</p><h4 id="Jmeter压测结论"><a href="#Jmeter压测结论" class="headerlink" title="Jmeter压测结论"></a>Jmeter压测结论</h4><p>上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖慢。</p><h3 id="订单微服务调用支付服务出现卡顿"><a href="#订单微服务调用支付服务出现卡顿" class="headerlink" title="订单微服务调用支付服务出现卡顿"></a>订单微服务调用支付服务出现卡顿</h3><p><strong>看热闹不嫌弃事大，80新建加入</strong></p><ol><li><p>新建 - cloud-consumer-feign-hystrix-order80</p></li><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">    &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line">  &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;artifactId&gt;cloud-consumer-feign-hystrix-order80&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;!--openfeign--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--hystrix--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--eureka client--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--web--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--一般基础通用配置--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">      &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">      &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">      &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">80</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="literal">false</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/8 21:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderHystrixMain80</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderHystrixMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务类</p><ul><li>service</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentHystrixService</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>controller</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.PaymentHystrixService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/8 21:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderHystirxController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentHystrixService paymentHystrixService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentHystrixService.paymentInfo_OK(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>正常测试</p><ul><li><a href="http://localhost/consumer/payment/hystrix/ok/1">http://localhost/consumer/payment/hystrix/ok/1</a></li></ul></li><li><p>高并发测试</p><p>2W个线程压8001</p><p>消费端80微服务再去访问正常的Ok微服务8001地址</p><p><a href="http://localhost/consumer/payment/hystrix/ok/32">http://localhost/consumer/payment/hystrix/ok/32</a></p><p>消费者80被拖慢</p><p>原因：8001同一层次的其它接口服务被困死，因为tomcat线程池里面的工作线程已经被挤占完毕。</p><p>正因为有上述故障或不佳表现才有我们的降级&#x2F;容错&#x2F;限流等技术诞生。</p></li></ol><h3 id="降级容错解决的维度要求"><a href="#降级容错解决的维度要求" class="headerlink" title="降级容错解决的维度要求"></a>降级容错解决的维度要求</h3><p>超时导致服务器变慢(转圈) - 超时不再等待</p><p>出错(宕机或程序运行出错) - 出错要有兜底</p><p>解决：</p><ul><li>对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级。</li><li>对方服务(8001)down机了，调用者(80)不能一直卡死等待，必须有服务降级。</li><li>对方服务(8001)OK，调用者(80)自己出故障或有自我要求(自己的等待时间小于服务提供者)，自己处理降级。</li></ul><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><h4 id="Hystrix之服务降级支付侧fallback"><a href="#Hystrix之服务降级支付侧fallback" class="headerlink" title="Hystrix之服务降级支付侧fallback"></a>Hystrix之服务降级支付侧fallback</h4><p><strong>降级配置 - @HystrixCommand</strong></p><p>8001先从自身找问题</p><p><strong>设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处埋，作服务降级fallback。</strong></p><p><strong>8001fallback</strong></p><p>业务类启用 - @HystrixCommand报异常后如何处理</p><p>—旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时访问</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;/*指定善后方法名*/,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;3000&quot;)//该线程的超时时间为3秒钟</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">timeNumber</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//int age = 10/0;</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(timeNumber);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池:  &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  paymentInfo_TimeOut,id:  &quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;O(∩_∩)O哈哈~耗时&quot;</span>+timeNumber+<span class="string">&quot;秒&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//善后的方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOutHandler</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池:  &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  paymentInfo_TimeOutHandler：8001系统繁忙或者运行报错，请稍后再试,id:  &quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>主启动类激活</strong></p><p>添加新注解@EnableCircuitBreaker</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/8 20:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span><span class="comment">//添加到此处</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentHystrixMain8001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><p><a href="http://localhost:8001/payment/hystrix/timeout/31">http://localhost:8001/payment/hystrix/timeout/31</a></p><p>上面故意制造两种异常:</p><ol><li>int age &#x3D; 10&#x2F;0，运行异常</li><li>我们能接受3秒钟，它运行5秒钟，超时异常。</li></ol><p>当前服务不可用了，做服务降级，兜底的方案都是paymentInfo_TimeOutHandler</p><p><img src="/2022/07/13/SpringCloud/1659966226265.png" alt="1659966226265"></p><h4 id="Hystrix之服务降级订单侧fallback"><a href="#Hystrix之服务降级订单侧fallback" class="headerlink" title="Hystrix之服务降级订单侧fallback"></a>Hystrix之服务降级订单侧fallback</h4><p>80订单微服务，也可以更好的保护自己，自己也依样画葫芦进行客户端降级保护</p><p>题外话，切记 - 我们自己配置过的热部署方式对java代码的改动明显，<strong>但对@HystrixCommand内属性的修改建议重启微服务</strong></p><ol><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">80</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="literal">false</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//eureka7001.com:7001/eureka/</span></span><br><span class="line">#开启</span><br><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.hystrix.EnableHystrix;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/8 21:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableHystrix</span><span class="comment">//添加到此处，开启Hystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderHystrixMain80</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderHystrixMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.PaymentHystrixService;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/8 21:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderHystirxController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentHystrixService paymentHystrixService;</span><br><span class="line">    </span><br><span class="line">......</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;1500&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="comment">//int age = 10/0;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//善后方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentTimeOutFallbackMethod</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>测试</p><p><a href="http://localhost/consumer/payment/hystrix/timeout/31">http://localhost/consumer/payment/hystrix/timeout/31</a></p><p><img src="/2022/07/13/SpringCloud/1659967367508.png" alt="1659967367508"></p><h4 id="Hystrix之全局服务降级DefaultProperties"><a href="#Hystrix之全局服务降级DefaultProperties" class="headerlink" title="Hystrix之全局服务降级DefaultProperties"></a>Hystrix之全局服务降级DefaultProperties</h4><p>目前问题1 每个业务方法对应一个兜底的方法，代码膨胀</p><p>解决方法</p><p>1:1每个方法配置一个服务降级方法，技术上可以，但是不聪明</p><p>1:N除了个别重要核心业务有专属，其它普通的可以通过@DefaultProperties(defaultFallback &#x3D; “ ”)统一跳转到统一处理结果页面</p><p><img src="/2022/07/13/SpringCloud/1659967870940.png" alt="1659967870940"></p><p>通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.PaymentHystrixService;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/8 21:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)</span><span class="comment">//添加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderHystirxController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentHystrixService paymentHystrixService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentHystrixService.paymentInfo_OK(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="comment">/*@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="comment">            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;1500&quot;)</span></span><br><span class="line"><span class="comment">    &#125;)*/</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="comment">//int age = 10/0;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//善后方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentTimeOutFallbackMethod</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全局fallback方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">payment_Global_FallbackMethod</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hystrix之通配服务降级FeignFallback"><a href="#Hystrix之通配服务降级FeignFallback" class="headerlink" title="Hystrix之通配服务降级FeignFallback"></a>Hystrix之通配服务降级FeignFallback</h4><p>目前问题2 统一和自定义的分开，代码混乱</p><p>服务降级，客户端去调用服务端，碰上服务端宕机或关闭</p><p>本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，<strong>只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦</strong></p><p>未来我们要面对的异常</p><ul><li>运行</li><li>超时</li><li>宕机</li></ul><h5 id="修改cloud-consumer-feign-hystrix-order80"><a href="#修改cloud-consumer-feign-hystrix-order80" class="headerlink" title="修改cloud-consumer-feign-hystrix-order80"></a>修改cloud-consumer-feign-hystrix-order80</h5><p>根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，<br><strong>重新新建一个类(PaymentFallbackService)实现该接口，统一为接口里面的方法进行异常处理</strong></p><p>PaymentFallbackService类实现PaymentHystrixService接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/8 22:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title class_">PaymentHystrixService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-----PaymentFallbackService fall back-paymentInfo_OK ,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-----PaymentFallbackService fall back-paymentInfo_TimeOut ,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="YML"><a href="#YML" class="headerlink" title="YML"></a>YML</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">80</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: <span class="literal">false</span></span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//eureka7001.com:7001/eureka/</span></span><br><span class="line">#开启</span><br><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: <span class="literal">true</span> #在Feign中开启Hystrix</span><br></pre></td></tr></table></figure><h5 id="PaymentHystrixService接口"><a href="#PaymentHystrixService接口" class="headerlink" title="PaymentHystrixService接口"></a>PaymentHystrixService接口</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallback = PaymentFallbackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentHystrixService</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><ul><li>单个eureka先启动7001</li><li>PaymentHystrixMain8001启动</li><li>正常访问测试 - <a href="http://localhost/consumer/payment/hystrix/ok/1">http://localhost/consumer/payment/hystrix/ok/1</a></li><li>故意关闭微服务8001</li></ul><p><img src="/2022/07/13/SpringCloud/1659968884040.png" alt="1659968884040"></p><p>客户端自己调用提示 - 此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器。</p><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><h4 id="Hystrix之服务熔断理论"><a href="#Hystrix之服务熔断理论" class="headerlink" title="Hystrix之服务熔断理论"></a>Hystrix之服务熔断理论</h4><p>断路器，相当于保险丝。</p><p>熔断机制概述</p><p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。<strong>当检测到该节点微服务调用响应正常后，恢复调用链路。</strong></p><p>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。<strong>熔断机制的注解是@HystrixCommand。</strong><br><a href="https://martinfowler.com/bliki/CircuitBreaker.html">Martin Fowler的相关论文</a></p><p><img src="/2022/07/13/SpringCloud/84d60234d01c4b7e9cae515066eb711b.png" alt="img"></p><h4 id="Hystrix之服务熔断案例-上"><a href="#Hystrix之服务熔断案例-上" class="headerlink" title="Hystrix之服务熔断案例(上)"></a>Hystrix之服务熔断案例(上)</h4><p><a href="https://hutool.cn/">Hutool国产工具类</a></p><ul><li><p>修改cloud-provider-hystrix-payment8001</p><blockquote><p>The precise way that the circuit opening and closing occurs is as follows:</p><ol><li>Assuming the volume across a circuit meets a certain threshold : <strong>HystrixCommandProperties.circuitBreakerRequestVolumeThreshold()</strong></li><li>And assuming that the error percentage, as defined above exceeds the error percentage defined in : <strong>HystrixCommandProperties.circuitBreakerErrorThresholdPercentage()</strong></li><li>Then the circuit-breaker transitions from CLOSED to OPEN.</li><li>While it is open, it short-circuits all requests made against that circuit-breaker.</li><li>After some amount of time (<strong>HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds()</strong>), the next request is let through. If it fails, the command stays OPEN for the sleep window. If it succeeds, it transitions to CLOSED and the logic in 1) takes over again.</li></ol><p><a href="https://github.com/Netflix/Hystrix/issues/674">断路器将永远不会再关闭，如果HystrixBadRequestException抛出！ ·第674期 ·Netflix&#x2F;Hystrix (github.com)</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.IdUtil;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/8 20:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//=====服务熔断</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            // 例：在10秒钟有10次请求失败率达到60%就开启断路器</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),// 是否开启断路器</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),// 请求次数</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;), // 时间窗口期（时间范围）</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),// 失败率达到多少后跳闸</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;******id 不能负数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serialNumber</span> <span class="operator">=</span> IdUtil.simpleUUID();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;调用成功，流水号: &quot;</span> + serialNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentCircuitBreaker_fallback</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: &quot;</span> +id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HystrixCommandProperties配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.hystrix;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HystrixCommandProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HystrixCommandProperties.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* defaults */</span></span><br><span class="line">    <span class="comment">/* package */</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">default_metricsRollingStatisticalWindow</span> <span class="operator">=</span> <span class="number">10000</span>;<span class="comment">// default =&gt; statisticalWindow: 10000 = 10 seconds (and default of 10 buckets so each bucket is 1 second)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">default_metricsRollingStatisticalWindowBuckets</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">// default =&gt; statisticalWindowBuckets: 10 = 10 buckets in a 10 second window so each bucket is 1 second</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">default_circuitBreakerRequestVolumeThreshold</span> <span class="operator">=</span> <span class="number">20</span>;<span class="comment">// default =&gt; statisticalWindowVolumeThreshold: 20 requests in 10 seconds must occur before statistics matter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">default_circuitBreakerSleepWindowInMilliseconds</span> <span class="operator">=</span> <span class="number">5000</span>;<span class="comment">// default =&gt; sleepWindow: 5000 = 5 seconds that we will sleep before trying again after tripping the circuit</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">default_circuitBreakerErrorThresholdPercentage</span> <span class="operator">=</span> <span class="number">50</span>;<span class="comment">// default =&gt; errorThresholdPercentage = 50 = if 50%+ of requests in 10 seconds are failures or latent then we will trip the circuit</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">default_circuitBreakerForceOpen</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">// default =&gt; forceCircuitOpen = false (we want to allow traffic)</span></span><br><span class="line">    <span class="comment">/* package */</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">default_circuitBreakerForceClosed</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">// default =&gt; ignoreErrors = false </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">default_executionTimeoutInMilliseconds</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">// default =&gt; executionTimeoutInMilliseconds: 1000 = 1 second</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">default_executionTimeoutEnabled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Hystrix之服务熔断案例-下"><a href="#Hystrix之服务熔断案例-下" class="headerlink" title="Hystrix之服务熔断案例(下)"></a>Hystrix之服务熔断案例(下)</h4><p>controller层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.PaymentService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/8 20:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String serverPort;</span><br><span class="line">   </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//====服务熔断</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/circuit/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> paymentService.paymentCircuitBreaker(id);</span><br><span class="line">        log.info(<span class="string">&quot;****result: &quot;</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><ul><li>自测cloud-provider-hystrix-payment8001</li><li>正确 - <a href="http://localhost:8001/payment/circuit/1">http://localhost:8001/payment/circuit/1</a></li><li>错误 - <a href="http://localhost:8001/payment/circuit/-1">http://localhost:8001/payment/circuit/-1</a></li><li>多次错误，再来次正确，但显示错误（断路器打开）</li><li>重点测试 - 多次错误，然后多次正确，发现刚开始正确显示错误，一直正确，过一会后恢复正常</li></ul><h4 id="Hystrix之服务熔断总结"><a href="#Hystrix之服务熔断总结" class="headerlink" title="Hystrix之服务熔断总结"></a>Hystrix之服务熔断总结</h4><h5 id="大神结论"><a href="#大神结论" class="headerlink" title="大神结论"></a><strong>大神结论</strong></h5><p><a href="https://martinfowler.com/bliki/CircuitBreaker.html">Martin Fowler的相关论文</a></p><p><img src="/2022/07/13/SpringCloud/84d60234d01c4b7e9cae515066eb711b-1659593345961.png" alt="img"></p><h5 id="熔断类型"><a href="#熔断类型" class="headerlink" title="熔断类型"></a>熔断类型</h5><ul><li>熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态。</li><li>熔断关闭：熔断关闭不会对服务进行熔断。</li><li>熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断。</li></ul><h5 id="官网断路器流程图"><a href="#官网断路器流程图" class="headerlink" title="官网断路器流程图"></a>官网断路器流程图</h5><p><img src="/2022/07/13/SpringCloud/825d02fd7925521b1d76be0a21c15db0.png" alt="img"></p><h5 id="官网步骤"><a href="#官网步骤" class="headerlink" title="官网步骤"></a><strong>官网步骤</strong></h5><blockquote><p>The precise way that the circuit opening and closing occurs is as follows:</p><ol><li>Assuming the volume across a circuit meets a certain threshold : <strong>HystrixCommandProperties.circuitBreakerRequestVolumeThreshold()</strong></li><li>And assuming that the error percentage, as defined above exceeds the error percentage defined in : <strong>HystrixCommandProperties.circuitBreakerErrorThresholdPercentage()</strong></li><li>Then the circuit-breaker transitions from CLOSED to OPEN.</li><li>While it is open, it short-circuits all requests made against that circuit-breaker.</li><li>After some amount of time (<strong>HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds()</strong>), the next request is let through. If it fails, the command stays OPEN for the sleep window. If it succeeds, it transitions to CLOSED and the logic in 1) takes over again.</li></ol><p>[断路器将永远不会再关闭，如果HystrixBadRequestException抛出！ ·第674期 ·Netflix&#x2F;Hystrix (github.com)](</p></blockquote><h5 id="断路器在什么情况下开始起作用"><a href="#断路器在什么情况下开始起作用" class="headerlink" title="断路器在什么情况下开始起作用"></a><strong>断路器在什么情况下开始起作用</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//=====服务熔断</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            // 例：在10秒钟有10次请求失败率达到60%就开启断路器</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),// 是否开启断路器</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),// 请求次数</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;), // 时间窗口期（时间范围）</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),// 失败率达到多少后跳闸</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="涉及到断路器的三个重要参数："><a href="#涉及到断路器的三个重要参数：" class="headerlink" title="涉及到断路器的三个重要参数："></a>涉及到断路器的三个重要参数：</h5><ul><li>快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</li><li>请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次,即使所有的请求都超时或其他原因失败，断路器都不会打开。</li><li>错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。</li></ul><h5 id="断路器开启或者关闭的条件（默认设置）"><a href="#断路器开启或者关闭的条件（默认设置）" class="headerlink" title="断路器开启或者关闭的条件（默认设置）"></a>断路器开启或者关闭的条件（默认设置）</h5><ul><li>到达以下阀值，断路器将会开启：<ul><li>当满足一定的阀值的时候（默认10秒内超过20个请求次数)</li><li>当失败率达到一定的时候（默认10秒内超过50%的请求失败)</li></ul></li><li>当断路器开启的时候，所有请求都不会进行转发</li><li>一段时间之后（默认是5秒)，这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。</li></ul><h5 id="断路器打开之后"><a href="#断路器打开之后" class="headerlink" title="断路器打开之后"></a>断路器打开之后</h5><p>1：再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。</p><p>2：原来的主逻辑要如何恢复呢？</p><p>对于这一问题，hystrix也为我们实现了自动恢复功能。</p><p>当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。</p><h5 id="AI配置"><a href="#AI配置" class="headerlink" title="AI配置"></a>AI配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;fallbackMethod&quot;, </span></span><br><span class="line"><span class="meta">                groupKey = &quot;strGroupCommand&quot;, </span></span><br><span class="line"><span class="meta">                commandKey = &quot;strCommand&quot;, </span></span><br><span class="line"><span class="meta">                threadPoolKey = &quot;strThreadPool&quot;,</span></span><br><span class="line"><span class="meta">                </span></span><br><span class="line"><span class="meta">                commandProperties = &#123;</span></span><br><span class="line"><span class="meta">                    // 设置隔离策略，THREAD 表示线程池 SEMAPHORE：信号池隔离</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;execution.isolation.strategy&quot;, value = &quot;THREAD&quot;),</span></span><br><span class="line"><span class="meta">                    // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数）</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;execution.isolation.semaphore.maxConcurrentRequests&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                    // 配置命令执行的超时时间</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;execution.isolation.thread.timeoutinMilliseconds&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                    // 是否启用超时时间</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;execution.timeout.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                    // 执行超时的时候是否中断</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;execution.isolation.thread.interruptOnTimeout&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                    </span></span><br><span class="line"><span class="meta">                    // 执行被取消的时候是否中断</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;execution.isolation.thread.interruptOnCancel&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                    // 允许回调方法执行的最大并发数</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;fallback.isolation.semaphore.maxConcurrentRequests&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                    // 服务降级是否启用，是否执行回调函数</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;fallback.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                    // 是否启用断路器</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                    // 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为 20 的时候，如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;20&quot;),</span></span><br><span class="line"><span class="meta">                    </span></span><br><span class="line"><span class="meta">                    // 该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过 circuitBreaker.requestVolumeThreshold 的情况下，如果错误请求数的百分比超过50, 就把断路器设置为 &quot;打开&quot; 状态，否则就设置为 &quot;关闭&quot; 状态。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;50&quot;),</span></span><br><span class="line"><span class="meta">                    // 该属性用来设置当断路器打开之后的休眠时间窗。 休眠时间窗结束之后，会将断路器置为 &quot;半开&quot; 状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为 &quot;打开&quot; 状态，如果成功就设置为 &quot;关闭&quot; 状态。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;circuitBreaker.sleepWindowinMilliseconds&quot;, value = &quot;5000&quot;),</span></span><br><span class="line"><span class="meta">                    // 断路器强制打开</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;circuitBreaker.forceOpen&quot;, value = &quot;false&quot;),</span></span><br><span class="line"><span class="meta">                    // 断路器强制关闭</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;circuitBreaker.forceClosed&quot;, value = &quot;false&quot;),</span></span><br><span class="line"><span class="meta">                    // 滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingStats.timeinMilliseconds&quot;, value = &quot;10000&quot;),</span></span><br><span class="line"><span class="meta">                    </span></span><br><span class="line"><span class="meta">                    // 该属性用来设置滚动时间窗统计指标信息时划分&quot;桶&quot;的数量，断路器在收集指标信息的时候会根据设置的时间窗长度拆分成多个 &quot;桶&quot; 来累计各度量值，每个&quot;桶&quot;记录了一段时间内的采集指标。</span></span><br><span class="line"><span class="meta">                    // 比如 10 秒内拆分成 10 个&quot;桶&quot;收集这样，所以 timeinMilliseconds 必须能被 numBuckets 整除。否则会抛异常</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingStats.numBuckets&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                    // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为 false, 那么所有的概要统计都将返回 -1。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingPercentile.enabled&quot;, value = &quot;false&quot;),</span></span><br><span class="line"><span class="meta">                    // 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingPercentile.timeInMilliseconds&quot;, value = &quot;60000&quot;),</span></span><br><span class="line"><span class="meta">                    // 该属性用来设置百分位统计滚动窗口中使用 “ 桶 ”的数量。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingPercentile.numBuckets&quot;, value = &quot;60000&quot;),</span></span><br><span class="line"><span class="meta">                    // 该属性用来设置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，</span></span><br><span class="line"><span class="meta">                    // 就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个 “桶 ”中发生了500次执行，</span></span><br><span class="line"><span class="meta">                    // 那么该 “桶” 中只保留 最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;metrics.rollingPercentile.bucketSize&quot;, value = &quot;100&quot;),</span></span><br><span class="line"><span class="meta">                    </span></span><br><span class="line"><span class="meta">                    // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、 错误百分比）的间隔等待时间。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;metrics.healthSnapshot.intervalinMilliseconds&quot;, value = &quot;500&quot;),</span></span><br><span class="line"><span class="meta">                    // 是否开启请求缓存</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;requestCache.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">                    // HystrixCommand的执行和事件是否打印日志到 HystrixRequestLog 中</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;requestLog.enabled&quot;, value = &quot;true&quot;),</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">                &#125;,</span></span><br><span class="line"><span class="meta">                threadPoolProperties = &#123;</span></span><br><span class="line"><span class="meta">                    // 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;coreSize&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">                    // 该参数用来设置线程池的最大队列大小。当设置为 -1 时，线程池将使用 SynchronousQueue 实现的队列，否则将使用 LinkedBlockingQueue 实现的队列。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;-1&quot;),</span></span><br><span class="line"><span class="meta">                    // 该参数用来为队列设置拒绝阈值。 通过该参数， 即使队列没有达到最大值也能拒绝请求。</span></span><br><span class="line"><span class="meta">                    // 该参数主要是对 LinkedBlockingQueue 队列的补充,因为 LinkedBlockingQueue 队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。</span></span><br><span class="line"><span class="meta">                    @HystrixProperty(name = &quot;queueSizeRejectionThreshold&quot;, value = &quot;5&quot;),</span></span><br><span class="line"><span class="meta">                &#125;</span></span><br><span class="line"><span class="meta">               )</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hystrix工作流程最后总结"><a href="#Hystrix工作流程最后总结" class="headerlink" title="Hystrix工作流程最后总结"></a>Hystrix工作流程最后总结</h3><p><strong>服务限流 - 后面高级篇讲解alibaba的Sentinel说明</strong></p><p><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">官方解释</a></p><p>官网图例</p><p><img src="/2022/07/13/SpringCloud/hystrix-command-flow-chart.png" alt="img"></p><h4 id="步骤说明"><a href="#步骤说明" class="headerlink" title="步骤说明"></a>步骤说明</h4><ul><li>创建HystrixCommand （用在依赖的服务返回单个操作结果的时候）或HystrixObserableCommand（用在依赖的服务返回多个操作结果的时候）对象。</li><li>命令执行。</li><li>其中 HystrixCommand实现了下面前两种执行方式<ul><li>execute()：同步执行，从依赖的服务返回一个单一的结果对象或是在发生错误的时候抛出异常。</li><li>queue()：异步执行，直接返回一个Future对象，其中包含了服务执行结束时要返回的单一结果对象。</li></ul></li><li>而 HystrixObservableCommand实现了后两种执行方式：<ul><li>obseve()：返回Observable对象，它代表了操作的多个结果，它是一个Hot Observable （不论“事件源”是否有“订阅者”，都会在创建后对事件进行发布，所以对于Hot Observable的每一个“订阅者”都有可能是从“事件源”的中途开始的，并可能只是看到了整个操作的局部过程）。</li><li>toObservable()：同样会返回Observable对象，也代表了操作的多个结果，但它返回的是一个Cold Observable（没有“订阅者”的时候并不会发布事件，而是进行等待，直到有“订阅者”之后才发布事件，所以对于Cold Observable 的订阅者，它可以保证从一开始看到整个操作的全部过程）。</li></ul></li><li>若当前命令的请求缓存功能是被启用的，并且该命令缓存命中，那么缓存的结果会立即以Observable对象的形式返回。</li><li>检查断路器是否为打开状态。如果断路器是打开的，那么Hystrix不会执行命令，而是转接到fallback处理逻辑(第8步)；如果断路器是关闭的，检查是否有可用资源来执行命令(第5步)。</li><li>线程池&#x2F;请求队列信号量是否占满。如果命令依赖服务的专有线程地和请求队列，或者信号量（不使用线程的时候）已经被占满，那么Hystrix也不会执行命令，而是转接到fallback处理理辑(第8步) 。</li><li>Hystrix会根据我们编写的方法来决定采取什么样的方式去请求依赖服务。<ul><li>HystrixCommand.run()：返回一个单一的结果，或者抛出异常。</li><li>HystrixObservableCommand.construct()：返回一个Observable对象来发射多个结果，或通过onError发送错误通知。</li></ul></li><li>Hystix会将“成功”、“失败”、“拒绝”、“超时” 等信息报告给断路器，而断路器会维护一组计数器来统计这些数据。断路器会使用这些统计数据来决定是否要将断路器打开，来对某个依赖服务的请求进行”熔断&#x2F;短路”。</li><li>当命令执行失败的时候，Hystix会进入fallback尝试回退处理，我们通常也称波操作为“服务降级”。而能够引起服务降级处理的情况有下面几种：<ul><li>第4步∶当前命令处于“熔断&#x2F;短路”状态，断洛器是打开的时候。</li><li>第5步∶当前命令的钱程池、请求队列或者信号量被占满的时候。</li><li>第6步∶HystrixObsevableCommand.construct()或HytrixCommand.run()抛出异常的时候。</li><li>当Hystrix命令执行成功之后，它会将处理结果直接返回或是以Observable的形式返回。</li></ul></li><li>tips：如果我们没有为命令实现降级逻辑或者在降级处理逻辑中抛出了异常，Hystrix依然会运回一个Obsevable对象，但是它不会发射任结果数惯，而是通过onError方法通知命令立即中断请求，并通过onError方法将引起命令失败的异常发送给调用者。</li></ul><h3 id="Hystrix图形化Dashboard搭建"><a href="#Hystrix图形化Dashboard搭建" class="headerlink" title="Hystrix图形化Dashboard搭建"></a>Hystrix图形化Dashboard搭建</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>除了隔离依赖服务的调用以外，Hystrix还提供了**准实时的调用监控(Hystrix Dashboard)**，Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。</p><p>Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。</p><h4 id="仪表盘9001"><a href="#仪表盘9001" class="headerlink" title="仪表盘9001"></a>仪表盘9001</h4><ol><li><p>新建cloud-consumer-hystrix-dashboard9001</p></li><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-consumer-hystrix-dashboard9001&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9001</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>HystrixDashboardMain9001+新注解@EnableHystrixDashboard</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/9 21:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixDashboardMain9001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(HystrixDashboardMain9001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所有Provider微服务提供类(8001&#x2F;8002&#x2F;8003)都需要监控依赖配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--actuator监控信息完善--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>启动cloud-consumer-hystrix-dashboard9001该微服务后续将监控微服务8001</p><ul><li>浏览器输入<a href="http://localhost:9001/hystrix">http://localhost:9001/hystrix</a></li></ul></li></ol><h3 id="Hystrix图形化Dashboard监控实战"><a href="#Hystrix图形化Dashboard监控实战" class="headerlink" title="Hystrix图形化Dashboard监控实战"></a>Hystrix图形化Dashboard监控实战</h3><ol><li><p><strong>修改cloud-provider-hystrix-payment8001</strong></p><ul><li>注意：新版本Hystrix需要在主启动类PaymentHystrixMain8001中指定监控路径</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/8 20:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span><span class="comment">//添加到此处</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentHystrixMain8001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑</span></span><br><span class="line"><span class="comment">     *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;，</span></span><br><span class="line"><span class="comment">     *只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment">     *否则，Unable to connect to Command Metric Stream 404</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">getServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HystrixMetricsStreamServlet</span> <span class="variable">streamServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixMetricsStreamServlet</span>();</span><br><span class="line">        <span class="type">ServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>监控测试</strong></p><ul><li>启动1个eureka；启动8001，9001</li></ul></li><li><p><strong>观察监控窗口</strong></p><ul><li><p>9001监控8001 - 填写监控地址 - <a href="http://localhost:8001/hystrix.stream">http://localhost:8001/hystrix.stream</a> 到 <a href="http://localhost:9001/hystrix%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BE%93%E5%85%A5%E6%A1%86%E3%80%82">http://localhost:9001/hystrix页面的输入框。</a></p><p><img src="/2022/07/13/SpringCloud/1660051669535.png" alt="1660051669535"></p></li><li><p>测试地址</p><ul><li><a href="http://localhost:8001/payment/circuit/1">http://localhost:8001/payment/circuit/1</a></li><li><a href="http://localhost:8001/payment/circuit/-1">http://localhost:8001/payment/circuit/-1</a></li><li>测试通过</li><li>先访问正确地址，再访问错误地址，再正确地址，会发现图示断路器都是慢慢放开的。</li></ul></li></ul></li></ol><p><img src="/2022/07/13/SpringCloud/34bd091b54f913b088bace6c3a89a79c.png" alt="img"></p><p><strong>如何看?</strong></p><ul><li>7色</li></ul><p><img src="/2022/07/13/SpringCloud/6740b2a462751db0ce8f2813f740c5b5.png" alt="img"></p><ul><li><p>1圈</p><ul><li>实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，它的健康度从绿色&lt;黄色&lt;橙色&lt;红色递减。</li><li>该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，就可以在大量的实例中快速的发现<strong>故障实例和高压力实例</strong>。</li></ul></li><li><p>1线</p><ul><li>曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升和下降趋势。</li></ul></li><li><p>整图说明</p></li></ul><p><img src="/2022/07/13/SpringCloud/8a8c682ab027e313e4d9af9e4bd96206.png" alt="img"></p><ul><li>整图说明2</li></ul><p><img src="/2022/07/13/SpringCloud/7fe0003d738028e6e20a3bf8f802cd2d.png" alt="img"></p><h2 id="Gateway新一代网关"><a href="#Gateway新一代网关" class="headerlink" title="Gateway新一代网关"></a>Gateway新一代网关</h2><h3 id="GateWay是什么"><a href="#GateWay是什么" class="headerlink" title="GateWay是什么"></a>GateWay是什么</h3><p><a href="https://github.com/Netflix/zuul/wiki">上一代zuul 1.x官网</a></p><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/">Gateway官网</a></p><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>Cloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关;</p><p>但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关替代Zuul，那就是SpringCloud Gateway—句话：<strong>gateway是原zuul1.x版的替代</strong><br><img src="/2022/07/13/SpringCloud/54b61d819aa1630bc61732de340b55b4.png" alt="img"></p><p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和Project Reactor等技术。</p><p>Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能，例如:熔断、限流、重试等。</p><p>SpringCloud Gateway是Spring Cloud的一个全新项目，基于Spring 5.0+Spring Boot 2.0和Project Reactor等技术开发的网关，它旨在为微服务架构提供—种简单有效的统一的API路由管理方式。</p><p>SpringCloud Gateway作为Spring Cloud 生态系统中的网关，目标是替代Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，<strong>SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。</strong></p><p>Spring Cloud Gateway的目标提供统一的路由方式且基于 Filter链的方式提供了网关基本的功能，例如:安全，监控&#x2F;指标，和限流。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>方向代理</li><li>鉴权</li><li>流量控制</li><li>熔断</li><li>日志监控</li><li>…</li></ul><h4 id="微服务架构中网关的位置"><a href="#微服务架构中网关的位置" class="headerlink" title="微服务架构中网关的位置"></a>微服务架构中网关的位置</h4><p><img src="/2022/07/13/SpringCloud/5877d4b9035ead9cd2d037609dceb442.png" alt="img"></p><h3 id="GateWay非阻塞异步模型"><a href="#GateWay非阻塞异步模型" class="headerlink" title="GateWay非阻塞异步模型"></a>GateWay非阻塞异步模型</h3><h4 id="有Zuull了怎么又出来Gateway？我们为什么选择Gateway"><a href="#有Zuull了怎么又出来Gateway？我们为什么选择Gateway" class="headerlink" title="有Zuull了怎么又出来Gateway？我们为什么选择Gateway?"></a>有Zuull了怎么又出来Gateway？我们为什么选择Gateway?</h4><ul><li>netflix不太靠谱，zuul2.0一直跳票，迟迟不发布。<ul><li>一方面因为Zuul1.0已经进入了维护阶段，而且Gateway是SpringCloud团队研发的，是亲儿子产品，值得信赖。而且很多功能Zuul都没有用起来也非常的简单便捷。</li><li>Gateway是基于<strong>异步非阻塞模型</strong>上进行开发的，性能方面不需要担心。虽然Netflix早就发布了最新的Zuul 2.x，但Spring Cloud貌似没有整合计划。而且Netflix相关组件都宣布进入维护期；不知前景如何?</li><li>多方面综合考虑Gateway是很理想的网关选择。</li></ul></li><li>SpringCloud Gateway具有如下特性<ul><li><strong>基于Spring Framework 5，Project Reactor和Spring Boot 2.0进行构建；</strong></li><li>动态路由：能够匹配任何请求属性；</li><li>可以对路由指定Predicate (断言)和Filter(过滤器)；</li><li>集成Hystrix的断路器功能；</li><li>集成Spring Cloud 服务发现功能；</li><li>易于编写的Predicate (断言)和Filter (过滤器)；</li><li>请求限流功能；</li><li>支持路径重写。</li></ul></li><li>SpringCloud Gateway与Zuul的区别<ul><li>在SpringCloud Finchley正式版之前，Spring Cloud推荐的网关是Netflix提供的Zuul。</li><li>Zuul 1.x，是一个基于阻塞I&#x2F;O的API Gateway。</li><li>Zuul 1.x<strong>基于Servlet 2.5使用阻塞架构</strong>它不支持任何长连接(如WebSocket)Zuul的设计模式和Nginx较像，每次I&#x2F;О操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx用C++实现，Zuul用Java实现，而JVM本身会有第-次加载较慢的情况，使得Zuul的性能相对较差。</li><li>Zuul 2.x理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。Zuul .x的性能较Zuul 1.x有较大提升。在性能方面，根据官方提供的基准测试,Spring Cloud Gateway的RPS(每秒请求数)是Zuul的1.6倍。</li><li>Spring Cloud Gateway建立在Spring Framework 5、Project Reactor和Spring Boot2之上，使用非阻塞API。</li><li>Spring Cloud Gateway还支持WebSocket，并且与Spring紧密集成拥有更好的开发体验</li></ul></li></ul><h4 id="Zuul1-x模型"><a href="#Zuul1-x模型" class="headerlink" title="Zuul1.x模型"></a>Zuul1.x模型</h4><p>Springcloud中所集成的Zuul版本，采用的是Tomcat容器，使用的是传统的Serviet IO处理模型。</p><p>Servlet的生命周期？servlet由servlet container进行生命周期管理。</p><ul><li>container启动时构造servlet对象并调用servlet init()进行初始化；</li><li>container运行时接受请求，并为每个请求分配一个线程（一般从线程池中获取空闲线程）然后调用service)；</li><li>container关闭时调用servlet destory()销毁servlet。</li></ul><p><img src="/2022/07/13/SpringCloud/b71ecbfb29c939615c988123a0704306.png" alt="img"></p><p>上述模式的缺点：</p><p>Servlet是一个简单的网络IO模型，当请求进入Servlet container时，Servlet container就会为其绑定一个线程，在并发不高的场景下这种模型是适用的。但是一旦高并发(如抽风用Jmeter压)，线程数量就会上涨，而线程资源代价是昂贵的（上线文切换，内存消耗大）严重影响请求的处理时间。在一些简单业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servlet模型没有优势。</p><p>所以<strong>Zuul 1.X是基于servlet之上的一个阻塞式处理模型</strong>，即Spring实现了处理所有request请求的一个servlet (DispatcherServlet)并由该servlet阻塞式处理处理。所以SpringCloud Zuul无法摆脱servlet模型的弊端。</p><h4 id="Gateway模型"><a href="#Gateway模型" class="headerlink" title="Gateway模型"></a>Gateway模型</h4><p>WebFlux是什么？<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux">官方文档</a></p><p>传统的Web框架，比如说: Struts2，SpringMVC等都是基于Servlet APl与Servlet容器基础之上运行的。</p><p><strong>但是在Servlet3.1之后有了异步非阻塞的支持</strong>。而<strong>WebFlux是一个典型非阻塞异步的框架</strong>，它的核心是基于Reactor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程(Spring 5必须让你使用Java 8)。</p><p>Spring WebFlux是Spring 5.0 引入的新的响应式框架，区别于Spring MVC，它不需要依赖Servlet APl，它是完全异步非阻塞的，并且基于Reactor来实现响应式流规范。</p><blockquote><p>Spring Cloud Gateway requires the Netty runtime provided by Spring Boot and Spring Webflux. It does not work in a traditional Servlet Container or when built as a WAR.link</p></blockquote><h3 id="Gateway工作流程"><a href="#Gateway工作流程" class="headerlink" title="Gateway工作流程"></a>Gateway工作流程</h3><h4 id="三大核心概念"><a href="#三大核心概念" class="headerlink" title="三大核心概念"></a>三大核心概念</h4><ul><li>Route(路由) - 路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由；</li><li>Predicate(断言) - 参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),<strong>如果请求与断言相匹配则进行路由；</strong></li><li>Filter(过滤) - 指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路由前或者之后对请求进行修改。</li></ul><p><img src="/2022/07/13/SpringCloud/1660056781726.png" alt="1660056781726"></p><p>web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制。</p><p>predicate就是我们的匹配条件；而fliter，就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由了</p><h4 id="Gateway工作流程-1"><a href="#Gateway工作流程-1" class="headerlink" title="Gateway工作流程"></a>Gateway工作流程</h4><p>官网总结</p><p><img src="/2022/07/13/SpringCloud/62be54501c6e2b95620b79cc918a2e9a.png" alt="img"></p><blockquote><p>Clients make requests to Spring Cloud Gateway. If the Gateway Handler Mapping determines that a request matches a route, it is sent to the Gateway Web Handler. This handler runs the request through a filter chain that is specific to the request. The reason the filters are divided by the dotted line is that filters can run logic both before and after the proxy request is sent. All “pre” filter logic is executed. Then the proxy request is made. After the proxy request is made, the “post” filter logic is run.<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-how-it-works">link</a> </p></blockquote><p>客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到GatewayWeb Handler。</p><p>Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。</p><p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(“pre”)或之后(“post”）执行业务逻辑。</p><p>Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。</p><p><strong>核心逻辑：路由转发 + 执行过滤器链</strong></p><h3 id="Gateway9527搭建"><a href="#Gateway9527搭建" class="headerlink" title="Gateway9527搭建"></a>Gateway9527搭建</h3><ol><li><p>新建Module - cloud-gateway-gateway9527</p></li><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-gateway-gateway9527&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--gateway--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--eureka-client--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--一般基础配置类--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9527</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: cloud-gateway-service</span><br><span class="line">  client: #服务提供者provider注册进eureka服务列表内</span><br><span class="line">    service-url:</span><br><span class="line">      register-with-eureka: <span class="literal">true</span></span><br><span class="line">      fetch-registry: <span class="literal">true</span></span><br><span class="line">      defaultZone: http:<span class="comment">//eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure></li><li><p>业务类</p></li><li><p>主启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/10 20:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GateWayMain9527</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GateWayMain9527.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>9527网关如何做路由映射?</p><ul><li>cloud-provider-payment8001看看controller的访问地址<ul><li>get（@GetMapping(“&#x2F;payment&#x2F;get&#x2F;{id}”)）</li><li>lb（@GetMapping(value &#x3D; “&#x2F;payment&#x2F;lb”)）</li></ul></li><li>我们目前不想暴露8001端口，希望在8001外面套一层9527</li></ul></li><li><p>YML新增网关配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9527</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line">  #############################新增网关配置###########################</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          uri: http:<span class="comment">//localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          #uri: lb:<span class="comment">//cloud-payment-service #匹配后提供服务的路由地址</span></span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/payment/get<span class="comment">/**         # 断言，路径相匹配的进行路由</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line"><span class="comment">          uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line"><span class="comment">          #uri: lb://cloud-payment-service #匹配后提供服务的路由地址</span></span><br><span class="line"><span class="comment">          predicates:</span></span><br><span class="line"><span class="comment">            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由</span></span><br><span class="line"><span class="comment">####################################################################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">eureka:</span></span><br><span class="line"><span class="comment">  instance:</span></span><br><span class="line"><span class="comment">    hostname: cloud-gateway-service</span></span><br><span class="line"><span class="comment">  client: #服务提供者provider注册进eureka服务列表内</span></span><br><span class="line"><span class="comment">    service-url:</span></span><br><span class="line"><span class="comment">      register-with-eureka: true</span></span><br><span class="line"><span class="comment">      fetch-registry: true</span></span><br><span class="line"><span class="comment">      defaultZone: http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><ul><li>启动7001</li><li>启动8001-cloud-provider-payment8001</li><li>启动9527网关</li><li>访问说明<ul><li>添加网关前 - <a href="http://localhost:8001/payment/get/1">http://localhost:8001/payment/get/1</a></li><li>添加网关后 - <a href="http://localhost:9527/payment/get/1">http://localhost:9527/payment/get/1</a></li><li>两者访问成功，返回相同结果</li></ul></li></ul></li></ol><h3 id="Gateway配置路由的两种方式"><a href="#Gateway配置路由的两种方式" class="headerlink" title="Gateway配置路由的两种方式"></a>Gateway配置路由的两种方式</h3><h4 id="在配置文件yml中配置，见上一章节"><a href="#在配置文件yml中配置，见上一章节" class="headerlink" title="在配置文件yml中配置，见上一章节"></a><strong>在配置文件yml中配置，见上一章节</strong></h4><h4 id="代码中注入RouteLocator的Bean"><a href="#代码中注入RouteLocator的Bean" class="headerlink" title="代码中注入RouteLocator的Bean"></a><strong>代码中注入RouteLocator的Bean</strong></h4><p>官方案例 - <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#modifying-the-way-remote-addresses-are-resolved">link</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RemoteAddressResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> XForwardedRemoteAddressResolver</span><br><span class="line">    .maxTrustedIndex(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">.route(<span class="string">&quot;direct-route&quot;</span>,</span><br><span class="line">    r -&gt; r.remoteAddr(<span class="string">&quot;10.1.1.1&quot;</span>, <span class="string">&quot;10.10.1.1/24&quot;</span>)</span><br><span class="line">        .uri(<span class="string">&quot;https://downstream1&quot;</span>)</span><br><span class="line">.route(<span class="string">&quot;proxied-route&quot;</span>,</span><br><span class="line">    r -&gt; r.remoteAddr(resolver, <span class="string">&quot;10.10.1.1&quot;</span>, <span class="string">&quot;10.10.1.1/24&quot;</span>)</span><br><span class="line">        .uri(<span class="string">&quot;https://downstream2&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>百度国内新闻网址，需要外网 - <a href="http://news.baidu.com/guonei">http://news.baidu.com/guonei</a></p><p><strong>自己写一个</strong></p><p>业务需求 - 通过9527网关访问到外网的百度新闻网址</p><p><strong>编码</strong></p><p>cloud-gateway-gateway9527业务实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.RouteLocator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/10 20:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GateWayConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置了一个id为route-name的路由规则，</span></span><br><span class="line"><span class="comment">     * 当访问地址http://localhost:9527/guonei时会自动转发到地址：http://news.baidu.com/guonei</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">routeLocator</span><span class="params">(RouteLocatorBuilder routeLocatorBuilder)</span>&#123;</span><br><span class="line">        RouteLocatorBuilder.<span class="type">Builder</span> <span class="variable">routes</span> <span class="operator">=</span> routeLocatorBuilder.routes();</span><br><span class="line">        routes.route(<span class="string">&quot;path_route_atguigu&quot;</span>,</span><br><span class="line">                r -&gt; r.path(<span class="string">&quot;/guonei&quot;</span>)</span><br><span class="line">                        .uri(<span class="string">&quot;http://news.baidu.com/guonei&quot;</span>)).build();</span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">routeLocator2</span><span class="params">(RouteLocatorBuilder routeLocatorBuilder)</span>&#123;</span><br><span class="line">        RouteLocatorBuilder.<span class="type">Builder</span> <span class="variable">routes</span> <span class="operator">=</span> routeLocatorBuilder.routes();</span><br><span class="line">        routes.route(<span class="string">&quot;path_route_atguigu2&quot;</span>,</span><br><span class="line">                r -&gt; r.path(<span class="string">&quot;/guoji&quot;</span>)</span><br><span class="line">                        .uri(<span class="string">&quot;http://news.baidu.com/guoji&quot;</span>)).build();</span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><p>浏览器输入<a href="http://localhost:9527/guonei%EF%BC%8C%E8%BF%94%E5%9B%9Ehttp://news.baidu.com/guonei%E7%9B%B8%E5%90%8C%E7%9A%84%E9%A1%B5%E9%9D%A2%E3%80%82">http://localhost:9527/guonei，返回http://news.baidu.com/guonei相同的页面。</a></p><h3 id="GateWay配置动态路由"><a href="#GateWay配置动态路由" class="headerlink" title="GateWay配置动态路由"></a>GateWay配置动态路由</h3><p>默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建<strong>动态路由进行转发，从而实现动态路由的功能</strong>（不写死一个地址）。</p><ol><li><p><strong>启动</strong></p><ul><li>eureka7001</li><li>payment8001&#x2F;8002</li></ul></li><li><p><strong>POM</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--eureka-client--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>YML</p><ul><li>需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能</li><li>lb:&#x2F;&#x2F;serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9527</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line">  #############################新增网关配置###########################</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: <span class="literal">true</span> #开启从注册中心动态创建路由的功能，利用微服务名进行路由</span><br><span class="line">      routes:</span><br><span class="line">        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          #uri: http:<span class="comment">//localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          uri: lb:<span class="comment">//cloud-payment-service #匹配后提供服务的路由地址</span></span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/payment/get<span class="comment">/**         # 断言，路径相匹配的进行路由</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line"><span class="comment">          #uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line"><span class="comment">          uri: lb://cloud-payment-service #匹配后提供服务的路由地址</span></span><br><span class="line"><span class="comment">          predicates:</span></span><br><span class="line"><span class="comment">            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由</span></span><br><span class="line"><span class="comment">####################################################################</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">eureka:</span></span><br><span class="line"><span class="comment">  instance:</span></span><br><span class="line"><span class="comment">    hostname: cloud-gateway-service</span></span><br><span class="line"><span class="comment">  client: #服务提供者provider注册进eureka服务列表内</span></span><br><span class="line"><span class="comment">    service-url:</span></span><br><span class="line"><span class="comment">      register-with-eureka: true</span></span><br><span class="line"><span class="comment">      fetch-registry: true</span></span><br><span class="line"><span class="comment">      defaultZone: http://eureka7001.com:7001/eureka</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><ul><li>浏览器输入 - <a href="http://localhost:9527/payment/lb">http://localhost:9527/payment/lb</a></li><li>结果：不停刷新页面，8001&#x2F;8002两个端口切换。</li></ul></li></ol><h3 id="GateWay常用的Predicate"><a href="#GateWay常用的Predicate" class="headerlink" title="GateWay常用的Predicate"></a>GateWay常用的Predicate</h3><p><img src="/2022/07/13/SpringCloud/1660137898140.png" alt="1660137898140"></p><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">官方文档</a></p><h4 id="Route-Predicate-Factories这个是什么"><a href="#Route-Predicate-Factories这个是什么" class="headerlink" title="Route Predicate Factories这个是什么"></a>Route Predicate Factories这个是什么</h4><blockquote><p>Spring Cloud Gateway matches routes as part of the Spring WebFlux HandlerMapping infrastructure. Spring Cloud Gateway includes many built-in route predicate factories. All of these predicates match on different attributes of the HTTP request. You can combine multiple route predicate factories with logical and statements.<br><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">link</a></p></blockquote><p>Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping基础架构的一部分。</p><p>Spring Cloud Gateway包括许多内置的Route Predicate工厂。所有这些Predicate都与HTTP请求的不同属性匹配。多个RoutePredicate工厂可以进行组合。</p><p>Spring Cloud Gateway创建Route 对象时，使用RoutePredicateFactory 创建 Predicate对象，Predicate 对象可以赋值给Route。Spring Cloud Gateway包含许多内置的Route Predicate Factories。<br>所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合，并通过逻辑and。</p><h4 id="常用的Route-Predicate-Factory"><a href="#常用的Route-Predicate-Factory" class="headerlink" title="常用的Route Predicate Factory"></a>常用的Route Predicate Factory</h4><ol><li>The After Route Predicate Factory</li><li>The Before Route Predicate Factory</li><li>The Between Route Predicate Factory</li><li>The Cookie Route Predicate Factory</li><li>The Header Route Predicate Factory</li><li>The Host Route Predicate Factory</li><li>The Method Route Predicate Factory</li><li>The Path Route Predicate Factory</li><li>The Query Route Predicate Factory</li><li>The RemoteAddr Route Predicate Factory</li><li>The weight Route Predicate Factory</li></ol><h4 id="讨论几个Route-Predicate-Factory"><a href="#讨论几个Route-Predicate-Factory" class="headerlink" title="讨论几个Route Predicate Factory"></a>讨论几个Route Predicate Factory</h4><p><strong>The After Route Predicate Factory</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">        #uri: http:<span class="comment">//localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">        uri: lb:<span class="comment">//cloud-payment-service #匹配后提供服务的路由地址</span></span><br><span class="line">        predicates:</span><br><span class="line">          - Path=/payment/lb<span class="comment">/**         # 断言，路径相匹配的进行路由</span></span><br><span class="line"><span class="comment">          - After=2022-08-10T21:37:47.613+08:00[Asia/Shanghai] #当前设置时间之后路由才可以匹配</span></span><br></pre></td></tr></table></figure><p>可以通过下述方法获得上述格式的时间戳字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/10 21:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">zbj</span> <span class="operator">=</span> ZonedDateTime.now(); <span class="comment">// 默认时区</span></span><br><span class="line">        System.out.println(zbj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2022-08-10T21:37:47.613+08:00[Asia/Shanghai]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>The Between Route Predicate Factory</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          #uri: http:<span class="comment">//localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          uri: lb:<span class="comment">//cloud-payment-service #匹配后提供服务的路由地址</span></span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/payment/lb<span class="comment">/**         # 断言，路径相匹配的进行路由</span></span><br><span class="line"><span class="comment">            - Between=2022-08-10T21:37:47.613+08:00[Asia/Shanghai], 2022-08-12T21:37:47.613+08:00[Asia/Shanghai] #两个时间之间</span></span><br></pre></td></tr></table></figure><p><strong>The Cookie Route Predicate Factory</strong></p><p>Cookie Route Predicate需要两个参数，一个是Cookie name，一个是正则表达式。路由规则会通过获取对应的Cookie name值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: cookie_route</span><br><span class="line">        uri: https:<span class="comment">//example.org</span></span><br><span class="line">        predicates:</span><br><span class="line">        - Cookie=chocolate, chip</span><br></pre></td></tr></table></figure><p>The cookie route predicate factory takes two parameters, the cookie name and a regular expression.</p><p>This predicate matches cookies that have the given name and whose values match the regular expression.<br>测试（cmd命令）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 该命令相当于发get请求，且没带cookie（访问失败）</span><br><span class="line">curl http:<span class="comment">//localhost:9527/payment/lb</span></span><br><span class="line"></span><br><span class="line"># 带cookie的</span><br><span class="line">curl http:<span class="comment">//localhost:9527/payment/lb --cookie &quot;chocolate=chip&quot;（访问成功）</span></span><br></pre></td></tr></table></figure><p><strong>The Header Route Predicate Factory</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: header_route</span><br><span class="line">        uri: https:<span class="comment">//example.org</span></span><br><span class="line">        predicates:</span><br><span class="line">        - Header=X-Request-Id, \d+</span><br></pre></td></tr></table></figure><p>The header route predicate factory takes two parameters, the header name and a regular expression.</p><p>This predicate matches with a header that has the given name whose value matches the regular expression.</p><p>两个参数：一个是属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。</p><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 带指定请求头的参数的CURL命令</span><br><span class="line">curl http:<span class="comment">//localhost:9527/payment/lb -H &quot;X-Request-Id:123&quot;</span></span><br></pre></td></tr></table></figure><p>其它的，举一反三。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>说白了，Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。</p><h3 id="GateWay的Filter"><a href="#GateWay的Filter" class="headerlink" title="GateWay的Filter"></a>GateWay的Filter</h3><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gatewayfilter-factories">官方文档</a></p><blockquote><p>Route filters allow the modification of the incoming HTTP request or outgoing HTTP response in some manner. Route filters are scoped to a particular route. Spring Cloud Gateway includes many built-in GatewayFilter Factories.</p></blockquote><p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。Spring Cloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生。</p><p>Spring Cloud Gateway的Filter:</p><ul><li>生命周期：<ul><li>pre</li><li>post</li></ul></li><li>种类（具体看官方文档）：<ul><li>GatewayFilter - 有31种</li><li>GlobalFilter - 有10种</li></ul></li></ul><p>常用的GatewayFilter：AddRequestParameter GatewayFilter</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span><br><span class="line">          #uri: http:<span class="comment">//localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          uri: lb:<span class="comment">//cloud-payment-service #匹配后提供服务的路由地址</span></span><br><span class="line">          filters:</span><br><span class="line">            - AddRequestParameter=X-Request-Id,<span class="number">1024</span> #过滤器工厂会在匹配的请求头加上一对请求头，名称为X-Request-Id值为<span class="number">1024</span></span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/payment/lb<span class="comment">/**         # 断言，路径相匹配的进行路由</span></span><br><span class="line"><span class="comment">            - After=2022-08-10T21:37:47.613+08:00[Asia/Shanghai] #当前设置时间之后路由才可以匹配</span></span><br></pre></td></tr></table></figure><p>自定义全局GlobalFilter：</p><p>两个主要接口介绍：</p><ul><li>GlobalFilter</li><li>Ordered</li></ul><p>能干什么：</p><ul><li>全局日志记录</li><li>统一网关鉴权</li><li>…</li></ul><p>代码案例：</p><p>GateWay9527项目添加MyLogGateWayFilter类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/10 22:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogGateWayFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;***********come in MyLogGateWayFilter:  &quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(uname == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            log.info(<span class="string">&quot;*******用户名为null，非法用户，o(╥﹏╥)o&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 过滤器加载优先级（越小越高）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p>启动：</p><ul><li>EurekaMain7001</li><li>PaymentMain8001</li><li>GateWayMain9527</li><li>PaymentMain8002</li></ul><p>浏览器输入：</p><ul><li><a href="http://localhost:9527/payment/lb">http://localhost:9527/payment/lb</a> - 反问异常</li><li><a href="http://localhost:9527/payment/lb?uname=abc">http://localhost:9527/payment/lb?uname=abc</a> - 正常反问</li></ul><h2 id="SpringCloud-config分布式配置中心"><a href="#SpringCloud-config分布式配置中心" class="headerlink" title="SpringCloud config分布式配置中心"></a>SpringCloud config分布式配置中心</h2><h3 id="Config分布式配置中心介绍"><a href="#Config分布式配置中心介绍" class="headerlink" title="Config分布式配置中心介绍"></a>Config分布式配置中心介绍</h3><h4 id="分布式系统面临的配置问题"><a href="#分布式系统面临的配置问题" class="headerlink" title="分布式系统面临的配置问题"></a>分布式系统面临的配置问题</h4><p>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。</p><p>SpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理.……</p><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><img src="/2022/07/13/SpringCloud/d5462e3b8c3a063561f5f8fc7fde327e.png" alt="img"></p><p>SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为<strong>各个不同微服务应用</strong>的所有环境提供了<strong>一个中心化的外部配置</strong>。</p><h4 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h4><p>SpringCloud Config分为服务端和客户端两部分。</p><ul><li><p>服务端也称为<strong>分布式配置中心，它是一个独立的微服务应用</strong>，用来连接配置服务器并为客户端提供获取配置信息，加密&#x2F;解密信息等访问接口。</p></li><li><p>客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。</p></li></ul><h4 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h4><ul><li>集中管理配置文件</li><li>不同环境不同配置，动态化的配置更新，分环境部署比如dev&#x2F;test&#x2F;prod&#x2F;beta&#x2F;release</li><li>运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</li><li>当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置</li><li>将配置信息以REST接口的形式暴露 - post&#x2F;crul访问刷新即可…</li></ul><h4 id="与GitHub整合配置"><a href="#与GitHub整合配置" class="headerlink" title="与GitHub整合配置"></a><strong>与GitHub整合配置</strong></h4><p>由于SpringCloud Config默认使用Git来存储配置文件(也有其它方式,比如支持SVN和本地文件)，但最推荐的还是Git，而且使用的是http&#x2F;https访问的形式。</p><h4 id="官网"><a href="#官网" class="headerlink" title="官网"></a><strong>官网</strong></h4><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/</a></p><h3 id="Config配置总控中心搭建"><a href="#Config配置总控中心搭建" class="headerlink" title="Config配置总控中心搭建"></a>Config配置总控中心搭建</h3><p>用你自己的账号在GitHub上新建一个名为springcloud-config的新Repository。</p><p>由上一步获得刚新建的git地址 - <a href="mailto:&#x67;&#x69;&#116;&#64;&#x67;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;">&#x67;&#x69;&#116;&#64;&#x67;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;</a>:TINGTING-GIT&#x2F;springcloud-config.git</p><p>本地硬盘目录上新建git仓库并clone。</p><ul><li><p>工作目录为D:\SpringCloud2022</p></li><li><p>git clone <a href="mailto:&#103;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;">&#103;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;</a>:TINGTING-GIT&#x2F;springcloud-config.git</p></li></ul><p>此时在工作目录会创建名为springcloud-config的文件夹。</p><p>在springcloud-config的文件夹种创建三个配置文件（为本次教学使用的）,随后git add .，git commit -m “init yml”，git push origin master等一系列上传操作上传到springcloud-config的新Repository。</p><ul><li>config-dev.yml</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config:</span><br><span class="line">  info: <span class="string">&quot;master branch,springcloud-config/config-dev.yml version=7&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>config-prod.yml</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config:</span><br><span class="line">  info: <span class="string">&quot;master branch,springcloud-config/config-prod.yml version=1&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>config-test.yml</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config:</span><br><span class="line">  info: <span class="string">&quot;master branch,springcloud-config/config-test.yml version=1&quot;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="新建Module模块cloud-config-center-3344，它即为Cloud的配置中心模块CloudConfig-Center"><a href="#新建Module模块cloud-config-center-3344，它即为Cloud的配置中心模块CloudConfig-Center" class="headerlink" title="新建Module模块cloud-config-center-3344，它即为Cloud的配置中心模块CloudConfig Center"></a>新建Module模块cloud-config-center-3344，它即为Cloud的配置中心模块CloudConfig Center</h4><ol><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-config-center-<span class="number">3344</span>&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--添加消息总线RabbitMQ支持--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">3344</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name:  cloud-config-center #注册进Eureka服务器的微服务名</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https:<span class="comment">//github.com/TINGTING-GIT/springcloud-config.git #GitHub上面的git仓库名字</span></span><br><span class="line">          ####搜索目录</span><br><span class="line">          search-paths:</span><br><span class="line">            - springcloud-config</span><br><span class="line">          force-pull: <span class="literal">true</span></span><br><span class="line">          username: TINGTING-GIT</span><br><span class="line">          password: 200107292395hua</span><br><span class="line">          skip-ssl-validation: <span class="literal">true</span></span><br><span class="line">      ####读取分支</span><br><span class="line">      label: master</span><br><span class="line"></span><br><span class="line">#服务注册到eureka地址</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>主启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/11 21:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainAppConfigCenter3344</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainAppConfigCenter3344.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>windows下修改hosts文件，增加映射（C:\Windows\System32\drivers\etc）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1 config-3344.com</span><br></pre></td></tr></table></figure></li><li><p>测试通过Config微服务是否可以从GitHub上获取配置内容</p><ul><li><p>启动ConfigCenterMain3344</p></li><li><p>浏览器防问 - <a href="http://config-3344.com:3344/master/config-dev.yml">http://config-3344.com:3344/master/config-dev.yml</a></p></li><li><p>页面返回结果：</p><p><img src="/2022/07/13/SpringCloud/1660228219633.png" alt="1660228219633"></p></li></ul></li></ol><h4 id="配置读取规则"><a href="#配置读取规则" class="headerlink" title="配置读取规则"></a>配置读取规则</h4><ul><li><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/#_quick_start">官方文档</a></li><li>&#x2F;{label}&#x2F;{application}-{profile}.yml（推荐）<ul><li>master分支<ul><li><a href="http://config-3344.com:3344/master/config-dev.yml">http://config-3344.com:3344/master/config-dev.yml</a></li><li><a href="http://config-3344.com:3344/master/config-test.yml">http://config-3344.com:3344/master/config-test.yml</a></li><li><a href="http://config-3344.com:3344/master/config-prod.yml">http://config-3344.com:3344/master/config-prod.yml</a></li></ul></li><li>dev分支<ul><li><a href="http://config-3344.com:3344/dev/config-dev.yml">http://config-3344.com:3344/dev/config-dev.yml</a></li><li><a href="http://config-3344.com:3344/dev/config-test.yml">http://config-3344.com:3344/dev/config-test.yml</a></li><li><a href="http://config-3344.com:3344/dev/config-prod.yml">http://config-3344.com:3344/dev/config-prod.yml</a></li></ul></li></ul></li><li>&#x2F;{application}-{profile}.yml<ul><li><a href="http://config-3344.com:3344/config-dev.yml">http://config-3344.com:3344/config-dev.yml</a></li><li><a href="http://config-3344.com:3344/config-test.yml">http://config-3344.com:3344/config-test.yml</a></li><li><a href="http://config-3344.com:3344/config-prod.yml">http://config-3344.com:3344/config-prod.yml</a></li><li><a href="http://config-3344.com:3344/config-xxxx.yml(%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E9%85%8D%E7%BD%AE)">http://config-3344.com:3344/config-xxxx.yml(不存在的配置)</a></li></ul></li><li>&#x2F;{application}&#x2F;{profile}[&#x2F;{label}]<ul><li><a href="http://config-3344.com:3344/config/dev/master">http://config-3344.com:3344/config/dev/master</a></li><li><a href="http://config-3344.com:3344/config/test/master">http://config-3344.com:3344/config/test/master</a></li><li><a href="http://config-3344.com:3344/config/test/dev">http://config-3344.com:3344/config/test/dev</a></li></ul></li><li>重要配置细节总结<ul><li>&#x2F;{name}-{profiles}.yml</li><li>&#x2F;{label}-{name}-{profiles}.yml</li><li>label：分支(branch)</li><li>name：服务名</li><li>profiles：环境(dev&#x2F;test&#x2F;prod)</li></ul></li><li>成功实现了用SpringCloud Config通过GitHub获取配置信息</li></ul><h3 id="Config客户端配置与测试"><a href="#Config客户端配置与测试" class="headerlink" title="Config客户端配置与测试"></a>Config客户端配置与测试</h3><ol><li><p>新建cloud-config-client-3355</p></li><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-config-client-<span class="number">3355</span>&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--添加消息总线RabbitMQ支持--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>bootstrap.yml</p><ul><li>applicaiton.yml是用户级的资源配置项</li><li>bootstrap.yml是系统级的，<strong>优先级更加高</strong></li><li>Spring Cloud会创建一个Bootstrap Context，作为Spring应用的Application Context的父上下文。</li><li>初始化的时候，BootstrapContext负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的Environment。</li><li>Bootstrap属性有高优先级，默认情况下，它们不会被本地配置覆盖。Bootstrap context和Application Context有着不同的约定，所以新增了一个bootstrap.yml文件，保证Bootstrap Context和Application Context配置的分离。</li><li><strong>要将Client模块下的application.yml文件改为bootstrap.yml,这是很关键的</strong>，因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">3355</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-client</span><br><span class="line">  cloud:</span><br><span class="line">    #Config客户端配置</span><br><span class="line">    config:</span><br><span class="line">      label: master #分支名称</span><br><span class="line">      name: config #配置文件名称</span><br><span class="line">      profile: dev #读取后缀名称   上述<span class="number">3</span>个综合：master分支上config-dev.yml的配置文件被读取http:<span class="comment">//config-3344.com:3344/master/config-dev.yml</span></span><br><span class="line">      uri: http:<span class="comment">//localhost:3344 #配置中心地址k</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#服务注册到eureka地址</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>修改config-dev.yml配置并提交到GitHub中，比如加个变量age或者版本号version</strong></p></li><li><p>主启动</p></li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/12 20:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientMain3355</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConfigClientMain3355.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>业务类</li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/12 20:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li><p>测试</p><ul><li>启动Config配置中心3344微服务并自测<ul><li><a href="http://config-3344.com:3344/master/config-prod.yml">http://config-3344.com:3344/master/config-prod.yml</a></li><li><a href="http://config-3344.com:3344/master/config-dev.yml">http://config-3344.com:3344/master/config-dev.yml</a></li></ul></li><li>启动3355作为Client准备访问<ul><li><a href="http://localhost:3355/configInfo">http://localhost:3355/configInfo</a></li></ul></li></ul></li></ol><p><strong>成功实现了客户端3355访问SpringCloud Config3344通过GitHub获取配置信息，可问题随时而来</strong></p><p><strong>分布式配置的动态刷新问题</strong></p><ul><li>Linux运维修改GitHub上的配置文件内容做调整</li><li>刷新3344，发现ConfigServer配置中心立刻响应</li><li>刷新3355，发现ConfigClient客户端没有任何响应</li><li>3355没有变化除非自己重启或者重新加载难到每次运维修改配置文件，客户端都需要重启??噩梦</li></ul><h3 id="Config动态刷新之手动版"><a href="#Config动态刷新之手动版" class="headerlink" title="Config动态刷新之手动版"></a>Config动态刷新之手动版</h3><p>避免每次更新配置都要重启客户端微服务3355</p><p><strong>动态刷新步骤</strong>：</p><ol><li><p>修改3355模块</p></li><li><p>POM引入actuator监控</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>修改YML，添加暴露监控端口配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 暴露监控端点</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>@RefreshScope业务类Controller修改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span><span class="comment">//&lt;-----</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><p>此时修改github配置文件内容 -&gt; 访问3344 -&gt; 访问3355</p><p><a href="http://localhost:3355/configInfo">http://localhost:3355/configInfo</a></p><p>3355改变没有??? 没有，还需一步</p><p>How</p><p>需要运维人员发送Post请求刷新3355（windows命令行界面）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X POST &quot;http://localhost:3355/actuator/refresh&quot;</span><br></pre></td></tr></table></figure><p>再次测试</p><p><a href="http://localhost:3355/configInfo">http://localhost:3355/configInfo</a></p><p>3355改变没有??? 改了。</p><p>成功实现了客户端3355刷新到最新配置内容，避免了服务重启</p><p>想想还有什么问题?</p><ul><li>假如有多个微服务客户端3355&#x2F;3366&#x2F;3377</li><li>每个微服务都要执行—次post请求，手动刷新?</li><li>可否广播，一次通知，处处生效?</li><li>我们想大范围的自动刷新，求方法</li></ul><h2 id="SpringCloud-Bus-消息总线"><a href="#SpringCloud-Bus-消息总线" class="headerlink" title="SpringCloud Bus 消息总线"></a>SpringCloud Bus 消息总线</h2><h3 id="Bus消息总线是什么"><a href="#Bus消息总线是什么" class="headerlink" title="Bus消息总线是什么"></a>Bus消息总线是什么</h3><p>上—讲解的加深和扩充</p><p>一言以蔽之，分布式自动刷新配置功能。</p><p>Spring Cloud Bus配合Spring Cloud Config使用可以实现配置的动态刷新。</p><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><p>Spring Cloud Bus 配合Spring Cloud Config 使用可以实现配置的动态刷新。<br><img src="/2022/07/13/SpringCloud/458fd679c01274ca84f785e1f75c1336.png" alt="img"></p><p>Spring Cloud Bus是用来将分布式系统的节点与轻量级消息系统链接起来的框架，它整合了Java的事件处理机制和消息中间件的功能。Spring Clud Bus目前支持RabbitMQ和Kafka。</p><h4 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a><strong>能干嘛</strong></h4><p>Spring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。</p><p><img src="/2022/07/13/SpringCloud/26c6ced30935219d4717814a446eb67a.png" alt="img"></p><h4 id="为何被称为总线"><a href="#为何被称为总线" class="headerlink" title="为何被称为总线"></a>为何被称为总线</h4><p>什么是总线</p><p>在微服务架构的系统中，通常会使用<strong>轻量级的消息代理</strong>来构建一个<strong>共用的消息主题</strong>，并让系统中所有微服务实例都连接上来。由于<strong>该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线</strong>。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。</p><p>基本原理</p><p>ConfigClient实例都监听MQ中同一个topic(默认是Spring Cloud Bus)。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。</p><h3 id="Bus之RabbitMQ环境配置"><a href="#Bus之RabbitMQ环境配置" class="headerlink" title="Bus之RabbitMQ环境配置"></a>Bus之RabbitMQ环境配置</h3><p>安装Erlang，下载地址：<a href="http://erlang.org/download/otp_win64_21.3.exe">http://erlang.org/download/otp_win64_21.3.exe</a></p><p>安装RabbitMQ，下载地址：<a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-3.8.3.exe">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-3.8.3.exe</a></p><p>打开cmd进入RabbitMQ安装目录下的sbin目录，如：D:\SpringCloud2022\rabbitmq_server-3.7.14</p><p>输入以下命令启动管理功能</p><ol><li><p># 开启RabbitMQ节</p><p>rabbitmqctl start_app</p></li><li></li></ol><p>   # 开启RabbitMQ管理模块的插件，并配置到RabbitMQ节点</p><p>   rabbitmq-plugins enable rabbitmq_management</p><ol start="3"><li></li></ol><p>   # 关闭RabbitMQ节</p><p>   rabbitmqctl stop</p><p>点击start启动</p><p><img src="/2022/07/13/SpringCloud/1660310694373.png" alt="1660310694373"></p><p>这样就可以添加可视化插件。</p><ul><li>启动RabbitMQ，访问地址查看是否安装成功：<a href="http://localhost:15672/">http://localhost:15672/</a></li><li>输入账号密码并登录：guest guest</li></ul><h3 id="Bus动态刷新全局广播的设计思想和选型"><a href="#Bus动态刷新全局广播的设计思想和选型" class="headerlink" title="Bus动态刷新全局广播的设计思想和选型"></a>Bus动态刷新全局广播的设计思想和选型</h3><p>必须先具备良好的RabbitMQ环境先</p><p>演示广播效果，增加复杂度，再以3355为模板再制作一个3366</p><ol><li><p>新建cloud-config-client-3366</p></li><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-config-client-<span class="number">3366</span>&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">3366</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-client</span><br><span class="line">  cloud:</span><br><span class="line">    #Config客户端配置</span><br><span class="line">    config:</span><br><span class="line">      label: master #分支名称</span><br><span class="line">      name: config #配置文件名称</span><br><span class="line">      profile: dev #读取后缀名称   上述<span class="number">3</span>个综合：master分支上config-dev.yml的配置文件被读取http:<span class="comment">//config-3344.com:3344/master/config-dev.yml</span></span><br><span class="line">      uri: http:<span class="comment">//localhost:3344 #配置中心地址</span></span><br><span class="line"></span><br><span class="line">#rabbitmq相关配置 <span class="number">15672</span>是Web管理界面的端口；<span class="number">5672</span>是MQ访问的端口</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line"></span><br><span class="line">#服务注册到eureka地址</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br><span class="line"></span><br><span class="line"># 暴露监控端点</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/13 15:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientMain3366</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConfigClientMain3366.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/13 15:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">configInfo</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;serverPort: &quot;</span>+serverPort+<span class="string">&quot;\t\n\n configInfo: &quot;</span>+configInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a><strong>设计思想</strong></h4><p>1.利用消息总线触发一个客户端&#x2F;bus&#x2F;refresh,而刷新所有客户端的配置</p><p><img src="/2022/07/13/SpringCloud/3a0975f4bac7393fe406821531e9daef-1660101481631.png" alt="img"></p><p>2.利用消息总线触发一个服务端ConfigServer的&#x2F;bus&#x2F;refresh端点，而刷新所有客户端的配置</p><p><img src="/2022/07/13/SpringCloud/e2809f728b8eb3e776883e4f905b8712.png" alt="img"></p><p>图二的架构显然更加适合，图—不适合的原因如下：</p><ul><li>打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。</li><li>破坏了微服务各节点的对等性。</li><li>有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改。</li></ul><h3 id="Bus动态刷新全局广播配置实现"><a href="#Bus动态刷新全局广播配置实现" class="headerlink" title="Bus动态刷新全局广播配置实现"></a>Bus动态刷新全局广播配置实现</h3><p><strong>给cloud-config-center-3344配置中心服务端添加消息总线支持</strong></p><ol><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--添加消息总线RabbitNQ支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-bus-amap&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org-springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">3344</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name:  cloud-config-center #注册进Eureka服务器的微服务名</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https:<span class="comment">//github.com/TINGTING-GIT/springcloud-config.git #GitHub上面的git仓库名字</span></span><br><span class="line">          ####搜索目录</span><br><span class="line">          search-paths:</span><br><span class="line">            - springcloud-config</span><br><span class="line">          force-pull: <span class="literal">true</span></span><br><span class="line">          username: TINGTING-GIT</span><br><span class="line">          password: 200107292395hua</span><br><span class="line">          skip-ssl-validation: <span class="literal">true</span></span><br><span class="line">      ####读取分支</span><br><span class="line">      label: master</span><br><span class="line">#rabbitmq相关配置&lt;--------------------------</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">#服务注册到eureka地址</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br><span class="line">##rabbitmq相关配置,暴露bus刷新配置的端点&lt;--------------------------</span><br><span class="line">management:</span><br><span class="line">  endpoints: #暴露bus刷新配置的端点</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&#x27;bus-refresh&#x27;</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure></li></ol><p><strong>给cloud-config-client-3355客户端添加消息总线支持</strong></p><ol><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--添加消息总线RabbitNQ支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-bus-amap&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org-springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">3355</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-client</span><br><span class="line">  cloud:</span><br><span class="line">    #Config客户端配置</span><br><span class="line">    config:</span><br><span class="line">      label: master #分支名称</span><br><span class="line">      name: config #配置文件名称</span><br><span class="line">      profile: dev #读取后缀名称   上述<span class="number">3</span>个综合：master分支上config-dev.yml的配置文件被读取http:<span class="comment">//config-3344.com:3344/master/config-dev.yml</span></span><br><span class="line">      uri: http:<span class="comment">//localhost:3344 #配置中心地址k</span></span><br><span class="line"></span><br><span class="line">#rabbitmq相关配置 <span class="number">15672</span>是Web管理界面的端口；<span class="number">5672</span>是MQ访问的端口&lt;----------------------</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line"></span><br><span class="line">#服务注册到eureka地址</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br><span class="line"></span><br><span class="line"># 暴露监控端点</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><strong>给cloud-config-client-3366客户端添加消息总线支持</strong></p><ol><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--添加消息总线RabbitNQ支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-bus-amap&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org-springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">3366</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-client</span><br><span class="line">  cloud:</span><br><span class="line">    #Config客户端配置</span><br><span class="line">    config:</span><br><span class="line">      label: master #分支名称</span><br><span class="line">      name: config #配置文件名称</span><br><span class="line">      profile: dev #读取后缀名称   上述<span class="number">3</span>个综合：master分支上config-dev.yml的配置文件被读取http:<span class="comment">//config-3344.com:3344/master/config-dev.yml</span></span><br><span class="line">      uri: http:<span class="comment">//localhost:3344 #配置中心地址</span></span><br><span class="line"></span><br><span class="line">#rabbitmq相关配置 <span class="number">15672</span>是Web管理界面的端口；<span class="number">5672</span>是MQ访问的端口&lt;-----------------------</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line"></span><br><span class="line">#服务注册到eureka地址</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br><span class="line"></span><br><span class="line"># 暴露监控端点</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><strong>测试</strong></p><ul><li>启动<ul><li>EurekaMain7001</li><li>ConfigcenterMain3344</li><li>ConfigclientMain3355</li><li>ConfigclicntMain3366</li></ul></li><li>运维工程师<ul><li>修改Github上配置文件内容，增加版本号</li><li>发送POST请求<ul><li>curl -X POST “<a href="http://localhost:3344/actuator/bus-refresh&quot;">http://localhost:3344/actuator/bus-refresh&quot;</a></li><li>—次发送，处处生效</li></ul></li></ul></li><li>配置中心<ul><li><a href="http://config-3344.com:3344/config-dev.yml">http://config-3344.com:3344/config-dev.yml</a></li></ul></li><li>客户端<ul><li><a href="http://localhost:3355/configInfo">localhost:3355&#x2F;configInfo</a></li><li><a href="http://localhost:3366/configInfo">http://localhost:3366/configInfo</a></li><li>获取配置信息，发现都已经刷新了</li></ul></li></ul><p><strong>—次修改，广播通知，处处生效</strong></p><h3 id="Bus动态刷新定点通知"><a href="#Bus动态刷新定点通知" class="headerlink" title="Bus动态刷新定点通知"></a>Bus动态刷新定点通知</h3><p>不想全部通知，只想定点通知</p><ul><li>只通知3355</li><li>不通知3366</li></ul><p><strong>简单一句话 - 指定具体某一个实例生效而不是全部</strong></p><ul><li>公式：<a href="http://localhost:3344/actuator/bus-refresh/%7Bdestination%7D">http://localhost:3344/actuator/bus-refresh/{destination}</a></li><li>&#x2F;bus&#x2F;refresh请求不再发送到具体的服务实例上，而是发给config server通过destination参数类指定需要更新配置的服务或实例</li></ul><p>案例</p><ul><li>我们这里以刷新运行在3355端口上的config-client（配置文件中设定的应用名称）为例，只通知3355，不通知3366</li><li>curl -X POST “<a href="http://localhost:3344/actuator/bus-refresh/config-client:3355">http://localhost:3344/actuator/bus-refresh/config-client:3355</a></li></ul><p>通知总结</p><p><img src="/2022/07/13/SpringCloud/ccd5fcc8293edec24d7e889e189d0bfe.png" alt="img"></p><h2 id="SpringCloud-Stream消息驱动"><a href="#SpringCloud-Stream消息驱动" class="headerlink" title="SpringCloud Stream消息驱动"></a>SpringCloud Stream消息驱动</h2><h3 id="Stream为什么被引入"><a href="#Stream为什么被引入" class="headerlink" title="Stream为什么被引入"></a>Stream为什么被引入</h3><p>常见MQ(消息中间件)：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>有没有一种新的技术诞生，让我们不再关注具体MQ的细节，我们只需要用一种适配绑定的方式，自动的给我们在各种MQ内切换。（类似于Hibernate）</p><p>Cloud Stream是什么？屏蔽底层消息中间件的差异，降低切换成本，统一消息的<strong>编程模型。</strong></p><h3 id="Stream是什么及Binder介绍"><a href="#Stream是什么及Binder介绍" class="headerlink" title="Stream是什么及Binder介绍"></a>Stream是什么及Binder介绍</h3><p><a href="https://spring.io/projects/spring-cloud-stream#overview">官方文档1</a></p><p><a href="https://cloud.spring.io/spring-tloud-static/spring-cloud-stream/3.0.1.RELEASE/reference/html/Spring">官方文档2</a></p><p><a href="https://m.wang1314.com/doc/webapp/topic/20971999.html">Cloud Stream中文指导手册</a></p><h4 id="什么是Spring-Cloud-Stream？"><a href="#什么是Spring-Cloud-Stream？" class="headerlink" title="什么是Spring Cloud Stream？"></a>什么是Spring Cloud Stream？</h4><p>官方定义Spring Cloud Stream是一个构建消息驱动微服务的框架。</p><p>应用程序通过inputs或者 outputs 来与Spring Cloud Stream中binder对象交互。</p><p>通过我们配置来binding(绑定)，而Spring Cloud Stream 的binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。</p><p>通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。<br>Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了<strong>发布-订阅、消费组、消息分区</strong>的三个核心概念。</p><p>目前仅支持RabbitMQ、 Kafka。</p><h3 id="Stream的设计思想"><a href="#Stream的设计思想" class="headerlink" title="Stream的设计思想"></a>Stream的设计思想</h3><h4 id="标准MQ"><a href="#标准MQ" class="headerlink" title="标准MQ"></a><strong>标准MQ</strong></h4><p><img src="/2022/07/13/SpringCloud/dd57e502418ecdae99f29991abe8bb02.png" alt="img"></p><ul><li>生产者&#x2F;消费者之间靠<strong>消息媒介</strong>传递信息内容</li><li>消息必须走特定的通道 - 消息通道 Message Channel</li><li>消息通道里的消息如何被消费呢，谁负责收发处理 - 消息通道MessageChannel的子接口SubscribableChannel，由MessageHandler消息处理器所订阅。</li></ul><h4 id="为什么用Cloud-Stream？"><a href="#为什么用Cloud-Stream？" class="headerlink" title="为什么用Cloud Stream？"></a><strong>为什么用Cloud Stream？</strong></h4><p>比方说我们用到了RabbitMQ和Kafka，由于这两个消息中间件的架构上的不同，像RabbitMQ有exchange，kafka有Topic和Partitions分区。</p><p><img src="/2022/07/13/SpringCloud/5587b05def1c26b8c9d9874c78f80b28.png" alt="img"></p><p>这些中间件的差异性导致我们实际项目开发给我们造成了一定的困扰，我们如果用了两个消息队列的其中一种，后面的业务需求，我想往另外一种消息队列进行迁移，这时候无疑就是一个灾难性的，一大堆东西都要重新推倒重新做，因为它跟我们的系统耦合了，这时候Spring Cloud Stream给我们提供了—种解耦合的方式。</p><h4 id="Stream凭什么可以统一底层差异？"><a href="#Stream凭什么可以统一底层差异？" class="headerlink" title="Stream凭什么可以统一底层差异？"></a>Stream凭什么可以统一底层差异？</h4><p>在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离。通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现。</p><p><strong>通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离</strong>。</p><p><strong>Binder</strong>：</p><ul><li><strong>INPUT对应于消费者</strong></li><li><strong>OUTPUT对应于生产者</strong></li></ul><p><img src="/2022/07/13/SpringCloud/96256569e677453570b55209c26e0b8c.png" alt="img"></p><p><strong>Stream中的消息通信方式遵循了发布-订阅模式</strong></p><p>Topic主题进行广播</p><ul><li>在RabbitMQ就是Exchange</li><li>在Kakfa中就是Topic</li></ul><h3 id="Stream编码常用注解简介"><a href="#Stream编码常用注解简介" class="headerlink" title="Stream编码常用注解简介"></a>Stream编码常用注解简介</h3><h4 id="Spring-Cloud-Stream标准流程套路"><a href="#Spring-Cloud-Stream标准流程套路" class="headerlink" title="Spring Cloud Stream标准流程套路"></a><strong>Spring Cloud Stream标准流程套路</strong></h4><p><img src="/2022/07/13/SpringCloud/077a3b34aec6eed91a7019a9d5ca4e3c.png" alt="img"></p><p><img src="/2022/07/13/SpringCloud/1ca02dd31581d92a7a610bcd137f6848.png" alt="img"></p><ul><li><p>Binder - 很方便的连接中间件，屏蔽差异。</p></li><li><p>Channel - 通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置。</p></li><li><p>Source和Sink - 简单的可理解为参照对象是Spring Cloud Stream自身，从Stream发布消息就是输出，接受消息就是输入。</p></li></ul><h4 id="编码API和常用注解"><a href="#编码API和常用注解" class="headerlink" title="编码API和常用注解"></a>编码API和常用注解</h4><table><thead><tr><th><strong>组成</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Middleware</td><td>中间件，目前只支持RabbitMQ和Kafka</td></tr><tr><td>Binder</td><td>Binder是应用与消息中间件之间的封装，目前实行了Kafka和RabbitMQ的Binder，通过Binder可以很方便的连接中间件，可以动态的改变消息类型(对应于Kafka的topic,RabbitMQ的exchange)，这些都可以通过配置文件来实现</td></tr><tr><td>@Input</td><td>注解标识输入通道，通过该输乎通道接收到的消息进入应用程序</td></tr><tr><td>@Output</td><td>注解标识输出通道，发布的消息将通过该通道离开应用程序</td></tr><tr><td>@StreamListener</td><td>监听队列，用于消费者的队列的消息接收</td></tr><tr><td>@EnableBinding</td><td>指信道channel和exchange绑定在一起</td></tr></tbody></table><h4 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h4><p>准备RabbitMQ环境（Bus之RabbitMQ环境配置有提及）</p><p>工程中新建三个子模块</p><ul><li>cloud-stream-rabbitmq-provider8801，作为生产者进行发消息模块</li><li>cloud-stream-rabbitmq-consumer8802，作为消息接收模块</li><li>cloud-stream-rabbitmq-consumer8803，作为消息接收模块</li></ul><h3 id="Stream消息驱动之生产者"><a href="#Stream消息驱动之生产者" class="headerlink" title="Stream消息驱动之生产者"></a>Stream消息驱动之生产者</h3><p>新建Module：cloud-stream-rabbitmq-provider8801</p><ol><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-stream-rabbitmq-provider8801&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--基础配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>主启动类StreamMQMain8801</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/13 16:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamMQMain8801</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(StreamMQMain8801.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>业务类</p><ul><li>发送消息接口</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMessageProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>发送消息接口实现类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.IMessageProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.EnableBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Source;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.support.MessageBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/13 16:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableBinding(Source.class)</span> <span class="comment">//定义消息的推送管道</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageProviderImpl</span> <span class="keyword">implements</span> <span class="title class_">IMessageProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output; <span class="comment">// 消息发送管道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serial</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        output.send(MessageBuilder.withPayload(serial).build());</span><br><span class="line">        System.out.println(<span class="string">&quot;*****serial: &quot;</span>+serial);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>controller</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.IMessageProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/13 16:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMessageController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IMessageProvider messageProvider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/sendMessage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> messageProvider.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>测试</p><ul><li>启动 7001eureka</li><li>启动 RabpitMq（79_Bus之RabbitMQ环境配置）<ul><li>rabbitmq-plugins enable rabbitmq_management</li><li><a href="http://localhost:15672/">http://localhost:15672/</a></li></ul></li><li>启动 8801</li><li>访问 - <a href="http://localhost:8801/sendMessage">http://localhost:8801/sendMessage</a><ul><li>后台将打印serial: UUID字符串</li></ul></li></ul></li></ol><h3 id="Stream消息驱动之消费者"><a href="#Stream消息驱动之消费者" class="headerlink" title="Stream消息驱动之消费者"></a>Stream消息驱动之消费者</h3><p>新建Module：cloud-stream-rabbitmq-consumer8802</p><ol><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud-stream-rabbitmq-consumer8802&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--基础配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8802</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-stream-consumer</span><br><span class="line">  cloud:</span><br><span class="line">      stream:</span><br><span class="line">        binders: # 在此处配置要绑定的rabbitmq的服务信息；</span><br><span class="line">          defaultRabbit: # 表示定义的名称，用于于binding整合</span><br><span class="line">            type: rabbit # 消息组件类型</span><br><span class="line">            environment: # 设置rabbitmq的相关的环境配置</span><br><span class="line">              spring:</span><br><span class="line">                rabbitmq:</span><br><span class="line">                  host: localhost</span><br><span class="line">                  port: <span class="number">5672</span></span><br><span class="line">                  username: guest</span><br><span class="line">                  password: guest</span><br><span class="line">        bindings: # 服务的整合处理</span><br><span class="line">          input: # 这个名字是一个通道的名称</span><br><span class="line">            destination: studyExchange # 表示要使用的Exchange名称定义</span><br><span class="line">            content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”</span><br><span class="line">            binder: defaultRabbit # 设置要绑定的消息服务的具体设置</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client: # 客户端进行Eureka注册的配置</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br><span class="line">  instance:</span><br><span class="line">    lease-renewal-interval-in-seconds: <span class="number">2</span> # 设置心跳的时间间隔（默认是<span class="number">30</span>秒）</span><br><span class="line">    lease-expiration-duration-in-seconds: <span class="number">5</span> # 如果现在超过了<span class="number">5</span>秒的间隔（默认是<span class="number">90</span>秒）</span><br><span class="line">    instance-id: receive-<span class="number">8802.</span>com  # 在信息列表时显示主机名称</span><br><span class="line">    prefer-ip-address: <span class="literal">true</span>     # 访问的路径变为IP地址</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>主启动类StreamMQMain8802</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.hua.study;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hyl</span><br><span class="line"> * @version 2022.1</span><br><span class="line"> * @date 2022/8/13 17:09</span><br><span class="line"> */</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class StreamMQMain8802 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(StreamMQMain8802.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>业务类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.EnableBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.StreamListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Sink;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/13 17:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableBinding(Sink.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageListenerController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">input</span><span class="params">(Message&lt;String&gt; message)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1号,-----&gt;接受到的消息: &quot;</span>+message.getPayload()+<span class="string">&quot;\t  port: &quot;</span>+serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>测试</p><ul><li>启动EurekaMain7001</li><li>启动StreamMQMain8801</li><li>启动StreamMQMain8802</li><li>8801发送8802接收消息-<a href="http://localhost:8801/sendMessage">http://localhost:8801/sendMessage</a></li></ul></li></ol><h3 id="Stream之消息重复消费"><a href="#Stream之消息重复消费" class="headerlink" title="Stream之消息重复消费"></a>Stream之消息重复消费</h3><p>依照8802，克隆出来一份运行8803 - cloud-stream-rabbitmq-consumer8803。</p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><ul><li>RabbitMQ</li><li>服务注册 - 8801</li><li>消息生产 - 8801</li><li>消息消费 - 8802</li><li>消息消费 - 8802</li></ul><h4 id="运行后有两个问题"><a href="#运行后有两个问题" class="headerlink" title="运行后有两个问题"></a>运行后有两个问题</h4><ul><li>有重复消费问题</li><li>消息持久化问题</li></ul><h4 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h4><ul><li><a href="http://localhost:8801/sendMessage">http://localhost:8801/sendMessage</a></li><li>目前是8802&#x2F;8803同时都收到了，存在重复消费问题</li><li>如何解决：分组和持久化属性group（重要）</li></ul><h4 id="生产实际案例"><a href="#生产实际案例" class="headerlink" title="生产实际案例"></a>生产实际案例</h4><p>比如在如下场景中，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息，那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。这时我们就可以使用<strong>Stream中的消息分组来解决</strong>。<br><img src="/2022/07/13/SpringCloud/f61e83441af907a42e8886368bde59ff.png" alt="img"></p><p>注意在Stream中处于<strong>同一个group中的多个消费者是竞争关系</strong>，就能够保证消息只会<strong>被其中一个应用消费一次</strong>。**不同组是可以全面消费的(重复消费)**。</p><h3 id="Stream之group解决消息重复消费"><a href="#Stream之group解决消息重复消费" class="headerlink" title="Stream之group解决消息重复消费"></a>Stream之group解决消息重复消费</h3><p>原理</p><p>微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。</p><p><strong>不同的组是可以重复消费的，同一个组内会发生竞争关系，只有其中一个可以消费。</strong></p><ol><li><p><strong>8802&#x2F;8803都变成不同组，group两个不同</strong></p><ul><li><p>group: A_Group、B_Group</p></li><li><p>8802修改YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-stream-provider</span><br><span class="line">  cloud:</span><br><span class="line">      stream:</span><br><span class="line">        binders: # 在此处配置要绑定的rabbitmq的服务信息；</span><br><span class="line">          defaultRabbit: # 表示定义的名称，用于于binding整合</span><br><span class="line">            type: rabbit # 消息组件类型</span><br><span class="line">            environment: # 设置rabbitmq的相关的环境配置</span><br><span class="line">              spring:</span><br><span class="line">                rabbitmq:</span><br><span class="line">                  host: localhost</span><br><span class="line">                  port: <span class="number">5672</span></span><br><span class="line">                  username: guest</span><br><span class="line">                  password: guest</span><br><span class="line">        bindings: # 服务的整合处理</span><br><span class="line">          output: # 这个名字是一个通道的名称</span><br><span class="line">            destination: studyExchange # 表示要使用的Exchange名称定义</span><br><span class="line">            content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”</span><br><span class="line">            binder: defaultRabbit # 设置要绑定的消息服务的具体设置</span><br><span class="line">            group: A_Group #&lt;----------------------------------------关键</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>8803修改YML（与8802的类似位置 group: B_Group）</p></li><li><p>结论：<strong>还是重复消费</strong></p><p><img src="/2022/07/13/SpringCloud/1660384005590.png" alt="1660384005590"></p></li></ul></li><li><p>8802&#x2F;8803实现了轮询分组，每次只有一个消费者，8801模块的发的消息只能被8802或8803其中一个接收到，这样避免了重复消费。</p></li><li><p><strong>8802&#x2F;8803都变成相同组，group两个相同</strong></p><ul><li><p>group: A_Group</p></li><li><p>8802修改YMLgroup: A_Group</p></li><li><p>8803修改YMLgroup: A_Group</p><p><img src="/2022/07/13/SpringCloud/1660384258029.png" alt="1660384258029"></p></li><li><p>结论：同一个组的多个微服务实例，每次只会有一个拿到</p></li></ul></li></ol><h3 id="Stream之消息持久化"><a href="#Stream之消息持久化" class="headerlink" title="Stream之消息持久化"></a>Stream之消息持久化</h3><p>通过上述，解决了重复消费问题，再看看持久化。</p><p>停止8802&#x2F;8803并去除掉8802的分组group: A_Group，8803的分组group: A_Group没有去掉。</p><p>8801先发送4条消息到RabbitMq。</p><p>先启动8802，<strong>无分组属性配置</strong>，后台没有打出来消息。</p><p>再启动8803，<strong>有分组属性配置</strong>，后台打出来了MQ上的消息。(消息持久化体现)</p><h2 id="SpringCloud-Sleuth分布式请求链路追踪"><a href="#SpringCloud-Sleuth分布式请求链路追踪" class="headerlink" title="SpringCloud Sleuth分布式请求链路追踪"></a>SpringCloud Sleuth分布式请求链路追踪</h2><h3 id="Sleuth是什么"><a href="#Sleuth是什么" class="headerlink" title="Sleuth是什么"></a>Sleuth是什么</h3><h4 id="为什么会出现这个技术？要解决哪些问题？"><a href="#为什么会出现这个技术？要解决哪些问题？" class="headerlink" title="为什么会出现这个技术？要解决哪些问题？"></a>为什么会出现这个技术？要解决哪些问题？</h4><p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。</p><p><img src="/2022/07/13/SpringCloud/b40478e2b2c83d7181b9c71cdcae05ea.png" alt="img"></p><p><img src="/2022/07/13/SpringCloud/f97d15b5686264d45b46f6f188e99873.png" alt="链路多起来的情况"></p><h4 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a><strong>是什么</strong></h4><ul><li><a href="https://github.com/spring-cloud/spring-cloud-sleuth">https://github.com/spring-cloud/spring-cloud-sleuth</a></li><li>Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案</li><li>在分布式系统中提供追踪解决方案并且兼容支持了zipkin</li></ul><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p><img src="/2022/07/13/SpringCloud/ca541262b26f809a0c25014feaa069d7.png" alt="img"></p><h3 id="搭建链路监控步骤"><a href="#搭建链路监控步骤" class="headerlink" title="搭建链路监控步骤"></a>搭建链路监控步骤</h3><h4 id="Sleuth之zipkin搭建安装"><a href="#Sleuth之zipkin搭建安装" class="headerlink" title="Sleuth之zipkin搭建安装"></a>Sleuth之zipkin搭建安装</h4><p>1.zipkin</p><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><ul><li>SpringCloud从F版起已不需要自己构建Zipkin Server了，只需调用jar包即可</li><li><a href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/">https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/</a></li><li>zipkin-server-2.12.9-exec.jar</li></ul><h5 id="运行jar"><a href="#运行jar" class="headerlink" title="运行jar"></a>运行jar</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-<span class="number">2.12</span><span class="number">.9</span>-exec.jar</span><br></pre></td></tr></table></figure><h5 id="运行控制台"><a href="#运行控制台" class="headerlink" title="运行控制台"></a><strong>运行控制台</strong></h5><p><a href="http://localhost:9411/zipkin/">http://localhost:9411/zipkin/</a></p><h5 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h5><p>完整的调用链路</p><p>表示一请求链路，一条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来</p><p><img src="/2022/07/13/SpringCloud/ec45d9d026fee8c83eaaf7bf8cb6893d.png" alt="img"></p><p>—条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来。</p><p><img src="/2022/07/13/SpringCloud/f75fcfd2146df03428b9c8c53d13c1f1.png" alt="img"></p><p>整个链路的依赖关系如下：</p><p><img src="/2022/07/13/SpringCloud/c1d19c5e9724578ee9c8668903685fa4.png" alt="img"></p><p>名词解释</p><ul><li>Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识</li><li>span：表示调用链路来源，通俗的理解span就是一次请求信息</li></ul><h4 id="Sleuth链路监控展现"><a href="#Sleuth链路监控展现" class="headerlink" title="Sleuth链路监控展现"></a>Sleuth链路监控展现</h4><p>2.服务提供者-cloud-provider-payment8001</p><ol><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--包含了sleuth+zipkin--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8001</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-payment-service</span><br><span class="line">  zipkin: #&lt;-------------------------------------关键</span><br><span class="line">    base-url: http:<span class="comment">//localhost:9411</span></span><br><span class="line">  sleuth: #&lt;-------------------------------------关键</span><br><span class="line">    sampler:</span><br><span class="line">      #采样率值介于 <span class="number">0</span> 到 <span class="number">1</span> 之间，<span class="number">1</span> 则表示全部采集</span><br><span class="line">      probability: <span class="number">1</span></span><br><span class="line"> .....</span><br></pre></td></tr></table></figure></li><li><p>业务类PaymentController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"> <span class="meta">@GetMapping(&quot;/payment/zipkin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentZipkin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hi ,i&#x27;am paymentzipkin server fall back，welcome to here, O(∩_∩)O哈哈~&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>3.服务消费者(调用方)-cloue-consumer-order80</p><ol><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">80</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-order-service</span><br><span class="line">  zipkin:</span><br><span class="line">    base-url: http:<span class="comment">//localhost:9411</span></span><br><span class="line">  sleuth:</span><br><span class="line">    sampler:</span><br><span class="line">      probability: <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>业务类OrderController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ====================&gt; zipkin+sleuth</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/zipkin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentZipkin</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://localhost:8001&quot;</span>+<span class="string">&quot;/payment/zipkin/&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>依次启动eureka7001&#x2F;8001&#x2F;80 - 80调用8001几次测试下：<a href="http://localhost/consumer/payment/zipkin">http://localhost/consumer/payment/zipkin</a></p></li><li><p>打开浏览器访问: <a href="http://localhost:9411/">http://localhost:9411</a></p></li></ol><h2 id="SpringCloud-Alibaba入门简介"><a href="#SpringCloud-Alibaba入门简介" class="headerlink" title="SpringCloud Alibaba入门简介"></a>SpringCloud Alibaba入门简介</h2><h3 id="为什么会出现SpringCloud-alibaba"><a href="#为什么会出现SpringCloud-alibaba" class="headerlink" title="为什么会出现SpringCloud alibaba"></a>为什么会出现SpringCloud alibaba</h3><p>Spring Cloud Netflix项目进入维护模式</p><p><a href="https://spring.io/blog/2018/12/12/spring-cloud-greenwich-rc1-available-now">https://spring.io/blog/2018/12/12/spring-cloud-greenwich-rc1-available-now</a></p><p>什么是维护模式？</p><p>将模块置于维护模式，意味着Spring Cloud团队将不会再向模块添加新功能。</p><p>他们将修复block级别的 bug 以及安全问题，他们也会考虑并审查社区的小型pull request。</p><h3 id="SpringCloud-alibaba带来了什么"><a href="#SpringCloud-alibaba带来了什么" class="headerlink" title="SpringCloud alibaba带来了什么"></a>SpringCloud alibaba带来了什么</h3><h4 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h4><p><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">官网</a></p><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><p>诞生：2018.10.31，Spring Cloud Alibaba 正式入驻了Spring Cloud官方孵化器，并在Maven 中央库发布了第一个版本。</p><h4 id="能干嘛-2"><a href="#能干嘛-2" class="headerlink" title="能干嘛"></a>能干嘛</h4><ul><li>服务限流降级：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li><li>服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li><li>分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。</li><li>消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li><li>分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。</li><li>阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li>分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li><li>阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ul><h4 id="去哪下"><a href="#去哪下" class="headerlink" title="去哪下"></a>去哪下</h4><p>如果需要使用已发布的版本，在 父工程dependencyManagement 中添加如下配置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.2</span><span class="number">.8</span>.RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在 <code>dependencies</code> 中添加自己所需使用的依赖即可使用。</p><h4 id="怎么玩-1"><a href="#怎么玩-1" class="headerlink" title="怎么玩"></a>怎么玩</h4><ul><li><strong>Sentinel</strong>：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li><strong>Nacos</strong>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li><strong>RocketMQ</strong>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li><strong>Dubbo</strong>：Apache Dubbo™ 是一款高性能 Java RPC 框架。</li><li><strong>Seata</strong>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li><li><strong>Alibaba Cloud OSS:</strong> 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li><strong>Alibaba Cloud SchedulerX</strong>: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li><li><strong>Alibaba Cloud SMS</strong>: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ul><h3 id="Spring-Cloud-Alibaba学习资料获取"><a href="#Spring-Cloud-Alibaba学习资料获取" class="headerlink" title="Spring Cloud Alibaba学习资料获取"></a>Spring Cloud Alibaba学习资料获取</h3><p>官网</p><p><a href="https://spring.io/projects/spring-cloud-alibaba#overview">https://spring.io/projects/spring-cloud-alibaba#overview</a><br>英文</p><p><a href="https://github.com/alibaba/spring-cloud-alibaba">https://github.com/alibaba/spring-cloud-alibaba</a><br><a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html</a><br>中文</p><p><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</a></p><h2 id="SpringCloud-Alibaba-Nacos服务注册和配置中心"><a href="#SpringCloud-Alibaba-Nacos服务注册和配置中心" class="headerlink" title="SpringCloud Alibaba Nacos服务注册和配置中心"></a>SpringCloud Alibaba Nacos服务注册和配置中心</h2><h3 id="Nacos简介和下载"><a href="#Nacos简介和下载" class="headerlink" title="Nacos简介和下载"></a>Nacos简介和下载</h3><h4 id="为什么叫Nacos"><a href="#为什么叫Nacos" class="headerlink" title="为什么叫Nacos"></a>为什么叫Nacos</h4><ul><li>前四个字母分别为Naming和Configuration的前两个字母，最后的s为Service。</li></ul><h4 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h4><ul><li>一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li>Nacos: Dynamic Naming and Configuration Service</li><li>Nacos就是注册中心＋配置中心的组合 -&gt; Nacos &#x3D; Eureka+Config+Bus</li></ul><h4 id="能干嘛-3"><a href="#能干嘛-3" class="headerlink" title="能干嘛"></a>能干嘛</h4><ul><li>替代Eureka做服务注册中心</li><li>替代Config做服务配置中心</li></ul><h4 id="去哪下-1"><a href="#去哪下-1" class="headerlink" title="去哪下"></a>去哪下</h4><ul><li><a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></li><li>[官网文档](<a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring</a> cloud alibaba nacos_discovery)</li><li><a href="https://nacos.io/zh-cn/index.html">https://nacos.io/zh-cn/index.html</a></li></ul><h4 id="各中注册中心比较"><a href="#各中注册中心比较" class="headerlink" title="各中注册中心比较"></a><strong>各中注册中心比较</strong></h4><table><thead><tr><th><strong>服务注册与发现框架</strong></th><th>CAP模型</th><th>控制台管理</th><th><strong>社区活跃度</strong></th></tr></thead><tbody><tr><td>Eureka</td><td>AP</td><td>支持</td><td>低(2.x版本闭源)</td></tr><tr><td>Zookeeper</td><td>CP</td><td>不支持</td><td>中</td></tr><tr><td>consul</td><td>CP</td><td>支持</td><td>高</td></tr><tr><td>Nacos</td><td>AP</td><td>支持</td><td>高</td></tr></tbody></table><p>据说Nacos在阿里巴巴内部有超过10万的实例运行，已经过了类似双十一等各种大型流量的考验。</p><h3 id="Nacos安装"><a href="#Nacos安装" class="headerlink" title="Nacos安装"></a>Nacos安装</h3><ul><li><p>本地Java8+Maven环境已经OK先</p></li><li><p>从<a href="https://github.com/alibaba/nacos/releases">官网</a>下载Nacos（mysql 8+是在nacos 1.4.0才引入）下载1.4.0以上高版本</p></li><li><p>解压安装包，直接运行bin目录下的startup.cmd（cmd运行）cmd startup.cmd</p></li><li><p>命令运行成功后直接访问<a href="http://localhost:8848/nacos%EF%BC%8C%E9%BB%98%E8%AE%A4%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E9%83%BD%E6%98%AFnacos">http://localhost:8848/nacos，默认账号密码都是nacos</a></p></li><li><p>结果页面</p><p><img src="/2022/07/13/SpringCloud/1660659442716.png" alt="1660659442716"></p></li></ul><h3 id="Nacos作为服务注册中心演示"><a href="#Nacos作为服务注册中心演示" class="headerlink" title="Nacos作为服务注册中心演示"></a>Nacos作为服务注册中心演示</h3><p><a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery">官方文档</a></p><h4 id="Nacos之服务提供者注册"><a href="#Nacos之服务提供者注册" class="headerlink" title="Nacos之服务提供者注册"></a>Nacos之服务提供者注册</h4><p>新建Module - cloudalibaba-provider-payment9001</p><ol><li><p>POM</p><ul><li><p>父POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--spring cloud alibaba <span class="number">2.1</span><span class="number">.0</span>.RELEASE--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.1</span><span class="number">.0</span>.RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></li><li><p>本模块POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloudalibaba-provider-payment9001&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- SpringBoot整合Web组件 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--日常通用jar包配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9001</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-payment-provider</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span> #配置Nacos地址</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/17 19:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain9001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain9001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>业务类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/17 19:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;server.port&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;nacos registry, serverPort: &quot;</span>+ serverPort+<span class="string">&quot;\t id&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>测试</p><ul><li><p>启动9001</p></li><li><p><a href="http://localhost:9001/payment/nacos/1">http://localhost:9001/payment/nacos/1</a></p></li><li><p>nacos控制台</p></li><li><p>nacos服务注册中心+服务提供者9001都OK了</p><p><img src="/2022/07/13/SpringCloud/1660737531359.png" alt="1660737531359"></p></li></ul></li><li><p>为了下一章节演示nacos的负载均衡，参照9001新建9002</p><ul><li><p>新建cloudalibaba-provider-payment9002</p></li><li><p>9002其它步骤你懂的</p></li><li><p>或者<strong>取巧</strong>不想新建重复体力劳动，可以利用IDEA功能，直接拷贝虚拟端口映射</p><ul><li><p>直接右键微服务，点击Copy Configuration</p><p><img src="/2022/07/13/SpringCloud/1660737724085.png" alt="1660737724085"></p></li><li><p>填写名称和占用端口号</p><p><img src="/2022/07/13/SpringCloud/1660737964782.png" alt="1660737964782"></p></li></ul></li></ul></li></ol><h4 id="Nacos之服务消费者注册和负载"><a href="#Nacos之服务消费者注册和负载" class="headerlink" title="Nacos之服务消费者注册和负载"></a>Nacos之服务消费者注册和负载</h4><p>新建Module - cloudalibaba-consumer-nacos-order83</p><ol><li><p>POM（为什么nacos支持负载均衡？因为spring-cloud-starter-alibaba-nacos-discovery内含netflix-ribbon包。）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloudalibaba-consumer-nacos-order83&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- SpringBoot整合Web组件 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--日常通用jar包配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">83</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-order-consumer</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line"></span><br><span class="line">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span><br><span class="line">service-url:</span><br><span class="line">  nacos-user-service: http:<span class="comment">//nacos-payment-provider</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/17 20:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderNacosMain83</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderNacosMain83.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>业务类</p><ul><li><p>ApplicationContextConfig</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/17 20:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>OrderNacosController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/17 20:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderNacosController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(serverUrl+<span class="string">&quot;/payment/nacos/&quot;</span>+id,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>测试</p><ul><li>启动nacos控制台</li><li><a href="http://localhost:83/Eonsumer/payment/nacos/13">http://localhost:83/Eonsumer/payment/nacos/13</a><ul><li>83访问9001&#x2F;9002，轮询负载OK</li></ul></li></ul></li></ol><h4 id="Nacos服务注册中心对比提升"><a href="#Nacos服务注册中心对比提升" class="headerlink" title="Nacos服务注册中心对比提升"></a>Nacos服务注册中心对比提升</h4><ul><li><strong>Nacos全景图</strong></li></ul><p><img src="/2022/07/13/SpringCloud/a9c35ea022a95aa76bfec990d6b73d8a.png" alt="nacos全景图"></p><ul><li><strong>Nacos和CAP</strong></li></ul><p>Nacos与其他注册中心特性对比</p><p><img src="/2022/07/13/SpringCloud/62d5a8566a2dc588a5ed52346049a054.png" alt="Nacos与其他注册中心特性对比"></p><ul><li><strong>Nacos服务发现实例模型</strong></li></ul><p><img src="/2022/07/13/SpringCloud/6578e36df056a995a39034045c36fc40.png" alt="Nacos服务发现实例模型"></p><ul><li>Nacos支持AP和CP模式的切换</li></ul><p><strong>C是所有节点在同一时间看到的数据是一致的;而A的定义是所有的请求都会收到响应。</strong></p><p>何时选择使用何种模式?</p><p>—般来说，如果不需要存储服务级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如Spring cloud和Dubbo服务，都适用于AP模式，AP模式为了服务的可用性而减弱了一致性，因此AP模式下只支持注册临时实例。</p><p>如果需要在服务级别编辑或者存储配置信息，那么CP是必须，K8S服务和DNS服务则适用于CP模式。CP模式下则支持注册持久化实例，此时则是以Raft协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。</p><p>切换命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#x27;$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP</span><br></pre></td></tr></table></figure><h3 id="Nacos作为服务配置中心演示"><a href="#Nacos作为服务配置中心演示" class="headerlink" title="Nacos作为服务配置中心演示"></a>Nacos作为服务配置中心演示</h3><h4 id="Nacos之服务配置中心-基础配置"><a href="#Nacos之服务配置中心-基础配置" class="headerlink" title="Nacos之服务配置中心-基础配置"></a>Nacos之服务配置中心-基础配置</h4><p>cloudalibaba-config-nacos-client3377</p><ol><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloudalibaba-config-nacos-client3377&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--nacos-config--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--nacos-discovery--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--web + actuator--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--一般基础配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>YML</p><p>Nacos同springcloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取，拉取配置之后，才能保证项目的正常启动。</p><p>springboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application</p><ul><li><p>bootstrap.yml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># nacos配置</span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">3377</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-config-client</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span> #Nacos服务注册中心地址</span><br><span class="line">      config:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span> #Nacos作为配置中心地址</span><br><span class="line">        file-extension: yaml #指定yaml格式的配置</span><br><span class="line"></span><br><span class="line">#yaml命名格式 $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br><span class="line">#例： nacos-config-client-dev.yaml</span><br><span class="line"></span><br><span class="line"># nacos-config-client-test.yaml   ----&gt; config.info</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>application.yml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev # 表示开发环境</span><br><span class="line">    #active: test # 表示测试环境</span><br><span class="line">    #active: info</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/17 21:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosConfigClientMain3377</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(NacosConfigClientMain3377.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>业务类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hyl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2022.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/17 21:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">// 支持nacos的动态刷新功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>在Nacos中添加配置信息</strong></p><p>Nacos中的dataid的组成格式及与SpringBoot配置文件中的匹配规则</p><p><a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">官方文档</a></p><p>说明：之所以需要配置spring.application.name，是因为它是构成Nacos配置管理dataId 字段的一部分。</p><p>在 Nacos Spring Cloud中,dataId的完整格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;prefix&#125;-$&#123;spring-profile.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure><ul><li>prefix默认为spring.application.name的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置。</li><li>spring.profile.active即为当前环境对应的 profile，详情可以参考 Spring Boot文档。注意：当spring.profile.active为空时，对应的连接符 - 也将不存在，datald 的拼接格式变成${prefix}.${file-extension}</li><li>file-exetension为配置内容的数据格式，可以通过配置项spring .cloud.nacos.config.file-extension来配置。目前只支持properties和yaml类型。</li><li>通过Spring Cloud 原生注解@RefreshScope实现配置自动更新。</li></ul><p>最后公式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;spring.application.name)&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br></pre></td></tr></table></figure><p>配置新增</p><p><img src="/2022/07/13/SpringCloud/05d45948bf637614dbd70e2bc8ce992d.png" alt="img"></p><p>Nacos界面配置对应 - 设置DataId和相应设置——点击发布</p><p><img src="/2022/07/13/SpringCloud/c61619bbe5ea16f34efca8103b0f90ba.png" alt="img"></p><p>配置小结</p><p><img src="/2022/07/13/SpringCloud/b3bffc4a646b30f9bf64fc649bf26f7d.png" alt="img"></p></li><li><p>测试</p><ul><li>启动前需要在nacos客户端-配置管理-配置管理栏目下有对应的yaml配置文件</li><li>运行cloud-config-nacos-client3377的主启动类</li><li>调用接口查看配置信息 - <a href="http://localhost:3377/config/info">http://localhost:3377/config/info</a></li></ul></li><li><p><strong>自带动态刷新</strong></p><ul><li>修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新。</li></ul></li></ol><h4 id="Nacos作为配置中心-分类配置"><a href="#Nacos作为配置中心-分类配置" class="headerlink" title="Nacos作为配置中心-分类配置"></a>Nacos作为配置中心-分类配置</h4><h5 id="Nacos之命名空间分组和DataID三者关系"><a href="#Nacos之命名空间分组和DataID三者关系" class="headerlink" title="Nacos之命名空间分组和DataID三者关系"></a>Nacos之命名空间分组和DataID三者关系</h5><p>问题 - 多环境多项目管理</p><p><strong>问题1:</strong></p><p>实际开发中，通常一个系统会准备</p><ol><li>dev开发环境</li><li>test测试环境</li><li>prod生产环境。</li></ol><p>如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢?</p><p><strong>问题2:</strong></p><p>一个大型分布式微服务系统会有很多微服务子项目，每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境…那怎么对这些微服务配置进行管理呢?</p><p><strong>Nacos的图形化管理界面</strong><br><img src="/2022/07/13/SpringCloud/3a7d1ad9bea8356742997ed3ebbe9be3.png" alt="img"></p><p><img src="/2022/07/13/SpringCloud/fe336f99f44c4b0aefddf0ae38d1c470.png" alt="img"></p><h5 id="Namespace-Group-Data-lD三者关系？为什么这么设计？"><a href="#Namespace-Group-Data-lD三者关系？为什么这么设计？" class="headerlink" title="Namespace+Group+Data lD三者关系？为什么这么设计？"></a><strong>Namespace+Group+Data lD三者关系？为什么这么设计？</strong></h5><ol><li><p>是什么</p><p>类似Java里面的package名和类名。最外层的namespace是可以用于区分部署环境的，Group和DatalD逻辑上区分两个目标对象。</p></li><li><p>三者情况</p><p><img src="/2022/07/13/SpringCloud/60712abd615dd86ac6c119bf132a28d6.png" alt="img"></p></li></ol><p>默认情况：Namespace&#x3D;public，Group&#x3D;DEFAULT_GROUP，默认Cluster是DEFAULT</p><ul><li>Nacos默认的Namespace是public，Namespace主要用来实现隔离。<ul><li>比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。</li></ul></li><li>Group默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去</li><li>Service就是微服务:一个Service可以包含多个Cluster (集群)，Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。<ul><li>比方说为了容灾，将Service微服务分别部署在了杭州机房和广州机房，这时就可以给杭州机房的Service微服务起一个集群名称(HZ) ，给广州机房的Service微服务起一个集群名称(GZ)，还可以尽量让同一个机房的微服务互相调用，以提升性能。</li></ul></li><li>最后是Instance，就是微服务的实例。</li></ul><h5 id="Nacos之DataID配置"><a href="#Nacos之DataID配置" class="headerlink" title="Nacos之DataID配置"></a>Nacos之DataID配置</h5><p>指定spring.profile.active和配置文件的DatalD来使不同环境下读取不同的配置</p><p>默认空间+默认分组+新建dev和test两个DatalD</p><ul><li><p>新建dev配置DatalD</p><p><img src="/2022/07/13/SpringCloud/5ea4b3fd5ca8cb6e7de6f0d9ac98f051.png" alt="img"></p></li><li><p>新建test配置DatalD</p><p><img src="/2022/07/13/SpringCloud/b41fe36b41fa2d5abc6e5e492ee3625d.png" alt="img"></p></li><li><p>通过spring.profile.active属性就能进行多环境下配置文件的读取</p><p><img src="/2022/07/13/SpringCloud/281a70d387cb48ce82e94421adf17747.png" alt="img"></p></li><li><p>测试</p><ul><li><a href="http://localhost:3377/config/info">http://localhost:3377/config/info</a></li><li>配置是什么就加载什么 test&#x2F;dev</li></ul></li></ul><h5 id="Nacos之Group分组方案"><a href="#Nacos之Group分组方案" class="headerlink" title="Nacos之Group分组方案"></a>Nacos之Group分组方案</h5><ul><li><p>通过Group实现环境区分 - 新建Group</p><p><img src="/2022/07/13/SpringCloud/bdf592aa566fe50f7f454118a70ca03c.png" alt="img"></p></li><li><p>在nacos图形界面控制台上面新建配置文件DatalD</p><p><img src="/2022/07/13/SpringCloud/28aee2b45901bbb9a6776d5c4398a6bb.png" alt="img"></p></li><li><p>bootstrap+application</p><p>在config下增加一条group的配置即可。可配置为DEV_GROUP或TEST GROUP</p><p><img src="/2022/07/13/SpringCloud/342a167a8bd948d8ba5cbfd760cf66a6.png" alt="img"></p></li></ul><h5 id="Nacos之Namespace空间方案"><a href="#Nacos之Namespace空间方案" class="headerlink" title="Nacos之Namespace空间方案"></a>Nacos之Namespace空间方案</h5><ul><li><p>新建dev&#x2F;test的Namespace</p><p><img src="/2022/07/13/SpringCloud/a10c71978c75c214aca5fa7057bb2834.png" alt="img"></p></li><li><p>回到服务管理-服务列表查看</p><p><img src="/2022/07/13/SpringCloud/2a9f3fa415f5cead0219d404a47131a0.png" alt="img"></p></li><li><p>按照域名配置填写</p><p><img src="/2022/07/13/SpringCloud/2177c126090c0db553a8ce77e838a7c9.png" alt="img"></p></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># nacos配置</span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">3377</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-config-client</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span> #Nacos服务注册中心地址</span><br><span class="line">      config:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span> #Nacos作为配置中心地址</span><br><span class="line">        file-extension: yaml #指定yaml格式的配置</span><br><span class="line">        group: DEV_GROUP</span><br><span class="line">        namespace: 7d8f0f5a-6a53-<span class="number">4785</span>-<span class="number">9686</span>-dd460158e5d4 #&lt;------------指定namespace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br><span class="line"># nacos-config-client-dev.yaml</span><br><span class="line"></span><br><span class="line"># nacos-config-client-test.yaml   ----&gt; config.info</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="Nacos集群和持久化配置（重要）"><a href="#Nacos集群和持久化配置（重要）" class="headerlink" title="Nacos集群和持久化配置（重要）"></a>Nacos集群和持久化配置（重要）</h3><h4 id="Nacos集群-架构说明"><a href="#Nacos集群-架构说明" class="headerlink" title="Nacos集群_架构说明"></a>Nacos集群_架构说明</h4><blockquote><p><a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">官方文档</a></p><p>官网架构图</p><p>集群部署架构图</p><p>因此开源的时候推荐用户把所有服务列表放到一个vip下面，然后挂到一个域名下面</p><p><a href="http://ip1:port/openAPI直连ip模式，机器挂则需要修改ip才可以使用。">http://ip1:port/openAPI直连ip模式，机器挂则需要修改ip才可以使用。</a></p><p><a href="http://VIP:port/openAPI挂载VIP模式，直连vip即可，下面挂server真实ip，可读性不好。">http://VIP:port/openAPI挂载VIP模式，直连vip即可，下面挂server真实ip，可读性不好。</a></p><p><a href="http://nacos.com:port/openAPI域名＋VIP模式，可读性好，而且换ip方便，推荐模式">http://nacos.com:port/openAPI域名＋VIP模式，可读性好，而且换ip方便，推荐模式</a><br><img src="/2022/07/13/SpringCloud/59bfb9114980c13f42d14e64dd2dafab.png" alt="img"></p></blockquote><p>上图官网翻译，真实情况</p><p><img src="/2022/07/13/SpringCloud/681c3dc16a69f197896cbff482f2298e.png" alt="img"></p><p>按照上述，<strong>我们需要mysql数据库</strong>。</p><blockquote><p><a href="https://nacos.io/zh-cn/docs/deployment.html">官网说明</a></p><p>默认Nacos使用嵌入式数据库实现数据的存储。所以，如果启动多个默认配置下的Nacos节点，数据存储是存在一致性问题的。为了解决这个问题，<strong>Nacos采用了集中式存储的方式来支持集群化部署，目前只支持MySQL的存储。</strong></p><p><strong>Nacos支持三种部署模式</strong></p><ul><li>单机模式-用于测试和单机试用。</li><li>集群模式-用于生产环境，确保高可用。</li><li>多集群模式-用于多数据中心场景。</li></ul><p><strong>Windows</strong></p><p>cmd startup.cmd或者双击startup.cmd文件</p><p><strong>单机模式支持mysql</strong></p><p>在0.7版本之前，在单机模式时nacos使用嵌入式数据库实现数据的存储，不方便观察数据存储的基本情况。0.7版本增加了支持mysql数据源能力，但是 mysql 8+是在nacos 1.4.0才引入，具体的操作步骤:</p><ul><li><p>安装数据库，版本要求:5.6.5+</p></li><li><p>初始化mysq数据库，数据库初始化文件: nacos-mysql.sql</p></li><li><p>修改conf&#x2F;application.properties文件，增加支持mysql数据源配置（目前只支持mysql)，添加mysql数据源的url、用户名和密码。</p></li><li><p>当安装MySQL8.0以上时，需要nacos1.4.0以上版本，同时在nacos解压文件下创建&#x2F;plugin&#x2F;mysql目录，并复制本系统MySQL的jar包。</p><p><img src="/2022/07/13/SpringCloud/1661516746793.png" alt="1661516746793"></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line"></span><br><span class="line">db.num=<span class="number">1</span></span><br><span class="line">db.url<span class="number">.0</span>=jdbc:mysql:<span class="comment">//11.162.196.16:3306/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span></span><br><span class="line">db.user=nacos_devtest</span><br><span class="line">db.password=youdontknow</span><br></pre></td></tr></table></figure><ul><li>使用 <strong>startup.cmd -m standalone</strong> 启动</li><li>再以单机模式启动nacos，nacos所有写嵌入式数据库的数据都写到了mysql。</li><li>命令运行成功后直接访问<a href="http://localhost:8848/nacos%EF%BC%8C%E9%BB%98%E8%AE%A4%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E9%83%BD%E6%98%AFnacos">http://localhost:8848/nacos，默认账号密码都是nacos</a></li></ul></blockquote><h4 id="Nacos持久化切换配置"><a href="#Nacos持久化切换配置" class="headerlink" title="Nacos持久化切换配置"></a>Nacos持久化切换配置</h4><p>Nacos默认自带的是嵌入式数据库derby，nacos的pom.xml中可以看出。</p><p>derby到mysql切换配置步骤：</p><ol><li>nacos-server-1.1.4\nacos\conf录下找到nacos-mysql.sql文件，复制后直接在Navicat数据库中执行脚本。</li><li>nacos-server-1.1.4\nacos\conf目录下找到application.properties，添加以下配置（按需修改对应值）。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line"></span><br><span class="line">db.num=<span class="number">1</span></span><br><span class="line">db.url<span class="number">.0</span>=jdbc:mysql:<span class="comment">//localhost:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line">db.user=root</span><br><span class="line">db.password= root</span><br></pre></td></tr></table></figure><p>重新启动Nacos，可以看到是个全新的空记录界面，以前是记录进derby。</p><h4 id="Linux版Nacos-MySQL生产环境配置"><a href="#Linux版Nacos-MySQL生产环境配置" class="headerlink" title="Linux版Nacos+MySQL生产环境配置"></a>Linux版Nacos+MySQL生产环境配置</h4><h5 id="Nacos之Linux版本安装"><a href="#Nacos之Linux版本安装" class="headerlink" title="Nacos之Linux版本安装"></a>Nacos之Linux版本安装</h5><p>预计需要，1个Nginx+3个<a href="https://so.csdn.net/so/search?q=nacos&spm=1001.2101.3001.7020">nacos</a>注册中心+1个mysql</p><blockquote><p>请确保是在环境中安装使用:</p><ol><li>64 bit OS Linux&#x2F;Unix&#x2F;Mac，推荐使用Linux系统。</li><li>64 bit JDK 1.8+；<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">下载</a>.<a href="https://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/">配置</a>。</li><li>Maven 3.2.x+；<a href="https://maven.apache.org/download.cgi">下载</a>.<a href="https://maven.apache.org/settings.html">配置</a>。</li><li>3个或3个以上Nacos节点才能构成集群。</li></ol><p><a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">link</a></p></blockquote><p>Nacos下载Linux版</p><ul><li><a href="https://github.com/alibaba/nacos/releases/tag/1.1.4">https://github.com/alibaba/nacos/releases/tag/1.1.4</a></li><li>nacos-server-1.1.4.tar.gz 解压后安装（tar -zxvf nacos-server-1.1.4.tar.gz ）</li></ul><h5 id="Nacos集群配置"><a href="#Nacos集群配置" class="headerlink" title="Nacos集群配置"></a>Nacos集群配置</h5><p>集群配置步骤(重点)</p><ol><li><p><strong>Linux服务器上mysql数据库配置</strong></p></li><li><ul><li><p>安装mysql</p><ul><li><p>sudo rpm -Uvh <a href="http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm">http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</a></p></li><li><p>yum install mysql mysql-server</p></li><li><p>mysql -V（查看mysql的版本信息）</p></li><li><p>执行<strong>vi &#x2F;etc&#x2F;my.cnf</strong>命令打开MySQL的配置文件</p><ul><li>&#96;&#96;&#96;<h1 id="无密码登录"><a href="#无密码登录" class="headerlink" title="无密码登录"></a>无密码登录</h1>skip-grant-tables<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     - mysql -uroot -p 进行无密码登录</span><br><span class="line"></span><br><span class="line">     -  create database nacos_config;    （创建数据库）</span><br><span class="line"></span><br><span class="line">     - show databases;  （查看数据库）</span><br><span class="line"></span><br><span class="line">     - use nacos_config;   </span><br><span class="line"></span><br><span class="line">   - SQL脚本在哪里 - 目录nacos/conf/nacos-mysql.sql</span><br><span class="line"></span><br><span class="line">     -  source nacos-mysql.sql  运行sql文件</span><br><span class="line"></span><br><span class="line">     - show tables;</span><br><span class="line"></span><br><span class="line">       ![1661259010629](./SpringCloud/1661259010629.png)</span><br><span class="line"></span><br><span class="line">3. **application.properties配置**</span><br><span class="line"></span><br><span class="line">4. - 复制一份进行保留</span><br><span class="line"></span><br><span class="line">   ![img](https://img-blog.csdnimg.cn/img_convert/1f5549ab8a788ff450f4cfb2bed03f58.png)</span><br><span class="line"></span><br><span class="line">   - 添加以下内容</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>spring.datasource.platform&#x3D;mysql</p><p>db.num&#x3D;1<br>db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;nacos_devtest?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true<br>db.user&#x3D;root<br>db.password&#x3D;root</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. **Linux服务器上nacos的集群配置cluster.conf**</span><br><span class="line"></span><br><span class="line">   - 梳理出3台nacos集器的不同服务端口号，设置3个端口：</span><br><span class="line"></span><br><span class="line">     - 3333</span><br><span class="line">     - 4444</span><br><span class="line">     - 5555</span><br><span class="line"></span><br><span class="line">   - 复制出cluster.conf</span><br><span class="line"></span><br><span class="line">     ![img](https://img-blog.csdnimg.cn/img_convert/d742baa2bf4354db8dd9d588724e1f5c.png)</span><br><span class="line"></span><br><span class="line">   - 添加以下内容（**注意**，这个IP不能写127.0.0.1，必须是Linux命令`hostname -i`能够识别的IP）</span><br><span class="line"></span><br><span class="line">     ![1661259821967](./SpringCloud/1661259821967.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>192.168.182.128:3333<br>192.168.182.128:4444<br>192.168.182.128:5555</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. **编辑Nacos的启动脚本startup.sh，使它能够接受不同的启动端口**</span><br><span class="line"></span><br><span class="line">   - /mynacos/nacos/bin目录下有startup.sh</span><br><span class="line"></span><br><span class="line">     ![img](https://img-blog.csdnimg.cn/img_convert/2cd7289348079d580cefed591a7568b9.png)</span><br><span class="line"></span><br><span class="line">   - 平时单机版的启动，都是./startup.sh即可。但是，集群启动，我们希望可以类似其它软件的shell命令，**传递不同的端口号启动不同的nacos实例**。</span><br><span class="line">     **命令: ./startup.sh -p 3333**表示启动端口号为3333的nacos服务器实例，和上一步的cluster.conf配置的一致。</span><br><span class="line"></span><br><span class="line">   - 修改startup.sh内容</span><br><span class="line"></span><br><span class="line">     ![img](https://img-blog.csdnimg.cn/img_convert/5b1fc1f634176ad17a19e4021d2b3b5e.png)</span><br><span class="line"></span><br><span class="line">     ![img](https://img-blog.csdnimg.cn/img_convert/9a3b1d043e5d55236216a46f296e8606.png)</span><br><span class="line"></span><br><span class="line">     ![1661260938053](./SpringCloud/1661260938053.png)</span><br><span class="line"></span><br><span class="line">7. 执行方式 - `./startup.sh - p 端口号`</span><br><span class="line"></span><br><span class="line">   ![img](https://img-blog.csdnimg.cn/img_convert/c68aec0dbcc1ed3d61b7e482718f9270.png)</span><br><span class="line"></span><br><span class="line">   - 遇到的错误</span><br><span class="line"></span><br><span class="line">     ![1661262808072](./SpringCloud/1661262808072.png)</span><br><span class="line"></span><br><span class="line">   - 解决</span><br><span class="line"></span><br><span class="line">     - **查找原因：**输入echo $JAVA_HOME结果为空，说明没有配置java环境变量</span><br><span class="line"></span><br><span class="line">     - 配置JAVA环境变量</span><br><span class="line"></span><br><span class="line">       1.找到jdk安装路径</span><br><span class="line"></span><br><span class="line">       ```java</span><br><span class="line">       [root@localhost bin]# ls -lrt /usr/bin/java</span><br><span class="line">       lrwxrwxrwx 1 root root 22 Mar 15 09:59 /usr/bin/java -&gt; /etc/alternatives/java</span><br><span class="line">       [root@localhost bin]# ls -lrt /etc/alternatives/java</span><br><span class="line">       lrwxrwxrwx 1 root root 73 Mar 15 09:59 /etc/alternatives/java -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64/jre/bin/java</span><br><span class="line">       [root@localhost bin]# cd /usr/lib/jvm</span><br><span class="line">       [root@localhost jvm]# ll</span><br><span class="line">       total 4</span><br><span class="line">       drwxr-xr-x 3 root root 4096 Mar 15 09:59 java-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64</span><br><span class="line">       lrwxrwxrwx 1 root root   21 Mar 15 09:59 jre -&gt; /etc/alternatives/jre</span><br><span class="line">       lrwxrwxrwx 1 root root   27 Mar 15 09:59 jre-1.8.0 -&gt; /etc/alternatives/jre_1.8.0</span><br><span class="line">       lrwxrwxrwx 1 root root   35 Mar 15 09:59 jre-1.8.0-openjdk -&gt; /etc/alternatives/jre_1.8.0_openjdk</span><br><span class="line">       lrwxrwxrwx 1 root root   51 Mar 15 09:59 jre-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64 -&gt; java-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64/jre</span><br><span class="line">       lrwxrwxrwx 1 root root   29 Mar 15 09:59 jre-openjdk -&gt; /etc/alternatives/jre_openjdk</span><br></pre></td></tr></table></figure><p>  2.在&#x2F;etc&#x2F;profile文件下添加以下代码并执行</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64/          </span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</span><br><span class="line"> </span><br><span class="line">[root@localhost ~]# source /etc/profile</span><br></pre></td></tr></table></figure><ul><li><p>执行<code>./startup.sh - p 3333</code></p><p><img src="/2022/07/13/SpringCloud/1661263088000.png" alt="1661263088000"></p></li></ul></li></ul></li><li><p><strong>Nginx的配置，由它作为负载均衡器</strong></p><ul><li><p>安装nginx——<a href="https://blog.csdn.net/t8116189520/article/details/81909574">(50条消息) LINUX安装nginx详细步骤_大蛇王的博客-CSDN博客_linux安装nginx</a></p></li><li><p>修改nginx的配置文件 - nginx.conf</p><p><img src="https://img-blog.csdnimg.cn/img_convert/700b800ca2e5a3dc01d0312cbeacda38.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/769472eda4b6a5e1b284db80c705d17f.png" alt="img"></p></li><li><p>按照指定启动</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f97a514ee914fb6050fd7428beb20639.png" alt="img"></p></li></ul></li><li><p><strong>截止到此处，1个Nginx+3个nacos注册中心+1个mysql</strong></p></li></ol><h5 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h5><ul><li><p>启动3个nacos注册中心</p><ul><li>startup.sh - p 3333</li><li>startup.sh - p 4444</li><li>startup.sh - p 5555</li><li>查看nacos进程启动数——ps -ef | grep nacos | grep -v grep | wc -l</li></ul></li><li><p>启动nginx</p><ul><li>.&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</li><li>查看nginx进程——ps - ef| grep nginx</li></ul></li><li><p>测试通过nginx，访问nacos - <a href="http://192.168.111.144:1111/nacos/#/login">http://192.168.111.144:1111/nacos/#/login</a></p></li><li><p>新建一个配置测试</p></li><li><p>新建后，可在linux服务器的mysql新插入一条记录</p></li><li><p>让微服务cloudalibaba-provider-payment9002启动注册进nacos集群 - 修改配置文件</p></li><li><p>启动微服务cloudalibaba-provider-payment9002</p></li><li><p>访问nacos，查看注册结果</p></li></ul><h5 id="高可用小总结"><a href="#高可用小总结" class="headerlink" title="高可用小总结"></a><strong>高可用小总结</strong></h5><p><img src="/2022/07/13/SpringCloud/42ff7ef670012437b046f099192d7484.png" alt="img"></p><h2 id="SpringCloud-Alibaba-Sentinel实现熔断与限流"><a href="#SpringCloud-Alibaba-Sentinel实现熔断与限流" class="headerlink" title="SpringCloud Alibaba Sentinel实现熔断与限流"></a>SpringCloud Alibaba Sentinel实现熔断与限流</h2><h3 id="Sentinel是什么"><a href="#Sentinel是什么" class="headerlink" title="Sentinel是什么"></a>Sentinel是什么</h3><p><a href="https://github.com/alibaba/Sentinel">官方Github</a></p><p><a href="https://sentinelguard.io/zh-cn/docs/introduction.html">官方文档</a></p><blockquote><p>Sentinel 是什么？</p><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p>Sentinel 具有以下特征:</p><ul><li>丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li>完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li>广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架&#x2F;库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li>完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><p>Sentinel 的主要特性：</p><p><img src="/2022/07/13/SpringCloud/e4efa9c3547366ae4f747ad4007f6447.png" alt="img"></p><p><a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D#sentinel-%E6%98%AF%E4%BB%80%E4%B9%88">link</a></p></blockquote><p>—句话解释，之前我们讲解过的Hystrix。</p><p>Hystrix与Sentinel比较：</p><ul><li>Hystrix<ul><li>需要我们程序员自己手工搭建监控平台</li><li>没有一套web界面可以给我们进行更加细粒度化得配置流控、速率控制、服务熔断、服务降级</li></ul></li><li>Sentinel<ul><li>单独一个组件，可以独立出来。</li><li>直接界面化的细粒度统一配置。</li></ul></li><li>约定 &gt; 配置 &gt; 编码</li></ul><p>都可以写在代码里面，但是我们本次还是大规模的学习使用配置和注解的方式，尽量少写代码</p><h3 id="Sentinel下载安装运行"><a href="#Sentinel下载安装运行" class="headerlink" title="Sentinel下载安装运行"></a>Sentinel下载安装运行</h3><p><a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel">官方文档</a></p><p>服务使用中的各种问题：</p><ul><li>服务雪崩</li><li>服务降级</li><li>服务熔断</li><li>服务限流</li></ul><p>Sentinel 分为两个部分：</p><ul><li>核心库（Java 客户端）不依赖任何框架&#x2F;库，能够运行于所有 Java 运行时环境，同时对 Dubbo &#x2F; Spring Cloud 等框架也有较好的支持。</li><li>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</li></ul><p>安装步骤：</p><ul><li>下载<ul><li><a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a></li><li>下载到本地sentinel-dashboard-1.7.1.jar</li></ul></li><li>运行命令<ul><li><p>前提</p><ul><li><p>Java 8 环境（set Path&#x3D;D:\Java\jdk1.8.0_202\bin）</p><p><img src="/2022/07/13/SpringCloud/1661350216006.png" alt="1661350216006"></p></li><li><p>8080端口不能被占用</p></li></ul></li><li><p>命令</p><ul><li>java -jar sentinel-dashboard-1.7.1.jar</li></ul></li></ul></li><li>访问Sentinel管理界面<ul><li><a href="http://localhost:8080/#/login">http://localhost:8080/#/login</a></li><li>登录账号密码均为sentinel</li></ul></li></ul><h3 id="Sentinel初始化监控"><a href="#Sentinel初始化监控" class="headerlink" title="Sentinel初始化监控"></a>Sentinel初始化监控</h3><p><strong>启动Nacos8848成功</strong></p><p><strong>新建工程 - cloudalibaba-sentinel-service8401</strong></p><ol><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloudalibaba-sentinel-service8401&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br><span class="line">            &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--SpringCloud ailibaba sentinel --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--openfeign--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- SpringBoot整合Web组件+actuator --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--日常通用jar包配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">4.6</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8401</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloudalibaba-sentinel-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span> #Nacos服务注册中心地址</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: localhost:<span class="number">8080</span> #配置Sentinel dashboard地址</span><br><span class="line">        #默认<span class="number">8719</span>端口，假如被占用会自动从<span class="number">8719</span>开始依次+<span class="number">1</span>扫描，直至找到未被占用的端口</span><br><span class="line">        port: <span class="number">8719</span></span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: <span class="literal">true</span> # 激活Sentinel对Feign的支持</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp8401</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApp8401.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>业务类FlowLimitController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowLimitController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testA</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testB</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        log.info(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;...testB&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testB&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>启动Sentinel8080 - java -jar sentinel-dashboard-1.7.1.jar</strong></p><p><strong>启动微服务8401</strong></p><p><strong>启动8401微服务后查看sentienl控制台</strong></p><ul><li>刚启动，空空如也，啥都没有</li></ul><p><img src="/2022/07/13/SpringCloud/bab574546fe65f719c095cf7d9e1db64.png" alt="img"></p><ul><li>Sentinel采用的懒加载说明<ul><li>执行一次访问即可<ul><li><a href="http://localhost:8401/testA">http://localhost:8401/testA</a></li><li><a href="http://localhost:8401/testB">http://localhost:8401/testB</a></li></ul></li><li>刷新sentinel8080</li><li>实时监控效果 - sentinel8080正在监控微服务8401</li></ul></li></ul><p><img src="/2022/07/13/SpringCloud/cf6561c14a2214b90c9002f2161b296f.png" alt="img"></p><h3 id="Sentinel流控规则"><a href="#Sentinel流控规则" class="headerlink" title="Sentinel流控规则"></a>Sentinel流控规则</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p><img src="/2022/07/13/SpringCloud/d8ae2bea252af0bb278332b3aeb8fb77.png" alt="img"></p><p>进一步解释说明：</p><ul><li>资源名：唯一名称，默认请求路径。</li><li>针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）。</li><li>阈值类型&#x2F;单机阈值：<ul><li>QPS(每秒钟的请求数量)︰当调用该API的QPS达到阈值的时候，进行限流。</li><li>线程数：当调用该API的线程数达到阈值的时候，进行限流。</li></ul></li><li>是否集群：不需要集群。</li><li>流控模式：<ul><li>直接：API达到限流条件时，直接限流。</li><li>关联：当关联的资源达到阈值时，就限流自己。</li><li>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流)【API级别的针对来源】。</li></ul></li><li>流控效果：<ul><li>快速失败：直接失败，抛异常。</li><li>Warm up：根据Code Factor（冷加载因子，默认3）的值，从阈值&#x2F;codeFactor，经过预热时长，才达到设置的QPS阈值。</li><li>排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效。</li></ul></li></ul><h4 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h4><ul><li>testA就是资源名，点击流控进行流控界面</li></ul><p><img src="/2022/07/13/SpringCloud/1661518447659.png" alt="1661518447659"></p><ul><li>直接点击流控规则，然后点击新增流控规则</li></ul><p><img src="/2022/07/13/SpringCloud/1661518620520.png" alt="1661518620520"></p><h5 id="Sentinel流控模式-QPS直接失败"><a href="#Sentinel流控模式-QPS直接失败" class="headerlink" title="Sentinel流控模式-QPS直接失败"></a>Sentinel流控模式-QPS直接失败</h5><p><strong>直接 -&gt; 快速失败（系统默认）</strong></p><p><strong>配置及说明</strong></p><p>表示1秒钟内查询1次就是OK，若超过次数1，就直接-&gt;快速失败，报默认错误</p><p><img src="/2022/07/13/SpringCloud/56642cc2b7dd5b0d1252235c84f69173.png" alt="img"></p><p><img src="/2022/07/13/SpringCloud/1661518735849.png" alt="1661518735849"></p><p>测试</p><p>快速多次点击访问<a href="http://localhost:8401/testA">http://localhost:8401/testA</a></p><p>结果</p><p>返回页面 Blocked by Sentinel (flow limiting)</p><p><img src="/2022/07/13/SpringCloud/1661518783377.png" alt="1661518783377"></p><p>源码</p><p>com.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController</p><p>思考</p><p>直接调用默认报错信息，技术方面OK，但是，是否应该有我们自己的后续处理？类似有个fallback的兜底方法?</p><h5 id="Sentinel流控模式-线程数直接失败"><a href="#Sentinel流控模式-线程数直接失败" class="headerlink" title="Sentinel流控模式-线程数直接失败"></a>Sentinel流控模式-线程数直接失败</h5><p>如下图QPS是在外面对访问请求进行拦截，一个请求访问多次到达阈值就会报错；线程数是（在里面进行拦截）当一个访问请求访问时，他会占据这一个窗口（设定的阈值），这一个请求随便多次访问都可以，但另一个请求在它还没结束时访问将会报错进行限流。</p><p><img src="/2022/07/13/SpringCloud/1661519534443.png" alt="1661519534443"></p><p>线程数：当调用该API的线程数达到阈值的时候，进行限流。</p><p><img src="/2022/07/13/SpringCloud/65af4de19564cceebe7cd67589babd69.png" alt="img"></p><p>两个线程访问</p><p><img src="/2022/07/13/SpringCloud/1661519983033.png" alt="1661519983033"></p><h5 id="Sentinel流控模式-关联"><a href="#Sentinel流控模式-关联" class="headerlink" title="Sentinel流控模式-关联"></a>Sentinel流控模式-关联</h5><p>是什么？</p><ul><li><p>当自己关联的资源达到阈值时，就限流自己</p></li><li><p>当与A关联的资源B达到阀值后，就限流A自己（B惹事，A挂了）</p></li><li><p>例如：支付接口得到阈值后，就限流订单接口</p></li></ul><p>设置testA</p><p>当关联资源&#x2F;testB的QPS阀值超过1时，就限流&#x2F;testA的Rest访问地址，当关联资源到阈值后限制配置好的资源名。</p><p><img src="/2022/07/13/SpringCloud/12cd41ae91ba50fe3b5525bab7bc3805.png" alt="img"></p><p><strong>Postman模拟并发密集访问testB</strong></p><ul><li>点击Save——》save as</li></ul><p><img src="/2022/07/13/SpringCloud/1661520702724.png" alt="1661520702724"></p><ul><li>创建一个collection进行保存</li></ul><p><img src="/2022/07/13/SpringCloud/1661520791547.png" alt="1661520791547"></p><ul><li>在右侧collection进行配置运行</li></ul><p><img src="/2022/07/13/SpringCloud/531e3c582fd2be3aa543ecca5b88c26e.png" alt="img"></p><p>Run - 大批量线程高并发访问B</p><p>Postman运行后，点击访问<a href="http://localhost:8401/testA%EF%BC%8C%E5%8F%91%E7%8E%B0testA%E6%8C%82%E4%BA%86">http://localhost:8401/testA，发现testA挂了</a></p><ul><li>结果Blocked by Sentinel(flow limiting)</li></ul><p>HOMEWORK：</p><p>自己上机测试</p><p>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流)【API级别的针对来源】</p><h4 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h4><h5 id="Sentinel流控效果-预热"><a href="#Sentinel流控效果-预热" class="headerlink" title="Sentinel流控效果-预热"></a>Sentinel流控效果-预热</h5><blockquote><p>Warm Up</p><p>Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热&#x2F;冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 <a href="https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8">流量控制 - Warm Up 文档</a>，具体的例子可以参见 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/WarmUpFlowDemo.java">WarmUpFlowDemo</a>。</p><p>通常冷启动的过程系统允许通过的 QPS 曲线如下图所示：<br><img src="/2022/07/13/SpringCloud/ede9b7e029c54840e3b40b69c4f371b5.png" alt="img"></p><p><a href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6#warm-up">link</a></p></blockquote><blockquote><p>默认coldFactor为3，即请求QPS 从 threshold &#x2F; 3开始，经预热时长逐渐升至设定的QPS阈值。<a href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6#warm-up">link</a></p></blockquote><p>源码 - com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController</p><p><strong>WarmUp配置</strong></p><p>默认coldFactor（冷加载因子）为3，即请求QPS 从 threshold &#x2F; 3开始，经预热时长逐渐升至设定的QPS阈值。</p><p>案例，阀值为10+预热时长设置5秒。</p><p>系统初始化的阀值为10&#x2F; 3(冷加载默认因子)约等于3,即阀值刚开始为3;然后过了5秒后阀值才慢慢升高恢复到10<br><img src="/2022/07/13/SpringCloud/c26846d68d79eae1e962f37942a2c99f.png" alt="img"></p><p><strong>测试</strong></p><p>多次快速点击<a href="http://localhost:8401/testB">http://localhost:8401/testB</a> - 刚开始不行，5秒后阈值增加，后续慢慢OK</p><p><strong>应用场景</strong></p><p>如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来,慢慢的把阀值增长到设置的阀值。</p><h5 id="Sentinel流控-排队等待"><a href="#Sentinel流控-排队等待" class="headerlink" title="Sentinel流控-排队等待"></a>Sentinel流控-排队等待</h5><p>匀速排队，让请求以均匀的速度通过，阀值类型必须设成QPS，否则无效。</p><p>设置：&#x2F;testA每秒1次请求，超过的话就排队等待，等待的超时时间为20000毫秒。</p><p><img src="/2022/07/13/SpringCloud/0ddd217545dd0fe2b1f251dbea814ac2.png" alt="img"></p><blockquote><p><strong>匀速排队</strong></p><p>匀速排队（RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER）方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。详细文档可以参考 <a href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-%E5%8C%80%E9%80%9F%E6%8E%92%E9%98%9F%E6%A8%A1%E5%BC%8F">流量控制 - 匀速器模式</a>，具体的例子可以参见 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/PaceFlowDemo.java">PaceFlowDemo</a>。</p><p>该方式的作用如下图所示：<br><img src="/2022/07/13/SpringCloud/79f93ab9f5dc11b05bbed9b793ef7c20.png" alt="img"></p><p>这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p><p>注意：匀速排队模式暂时不支持 QPS &gt; 1000 的场景。<br><a href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6#%E5%8C%80%E9%80%9F%E6%8E%92%E9%98%9F">link</a></p></blockquote><p>源码 - com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController</p><p><strong>测试</strong></p><ul><li><p>添加日志记录代码到FlowLimitController的testA方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowLimitController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testA</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        log.info(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;...testA&quot;</span>);<span class="comment">//&lt;----</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Postman模拟并发密集访问testA。具体操作参考Sentinel流控-关联</p><p><img src="/2022/07/13/SpringCloud/1661521808254.png" alt="1661521808254"></p></li><li><p>后台结果</p></li></ul><h3 id="降级规则"><a href="#降级规则" class="headerlink" title="降级规则"></a>降级规则</h3><h4 id="Sentinel降级简介"><a href="#Sentinel降级简介" class="headerlink" title="Sentinel降级简介"></a>Sentinel降级简介</h4><p><a href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7">官方文档</a></p><blockquote><p><strong>熔断降级概述</strong></p><p>除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。</p><p>现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的<strong>弱依赖服务调用</strong>进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。<br><a href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7#%E6%A6%82%E8%BF%B0">link</a></p></blockquote><p><img src="/2022/07/13/SpringCloud/6a002ef360a4e5f20ee2748a092f0211.png" alt="img"></p><ul><li><strong>RT（平均响应时间，秒级）</strong><ul><li>平均响应时间 <strong>超出阈值</strong> 且 <strong>在时间窗口内通过的请求&gt;&#x3D;5</strong>，两个条件同时满足后触发降级。</li><li>窗口期过后关闭断路器。</li><li>RT最大4900（更大的需要通过-Dcsp.sentinel.statistic.max.rt&#x3D;XXXX才能生效）。</li></ul></li><li><strong>异常比列（秒级）</strong><ul><li>QPS &gt;&#x3D; 5且异常比例（秒级统计）超过阈值时，触发降级;时间窗口结束后，关闭降级 。</li></ul></li><li><strong>异常数(分钟级)</strong><ul><li>异常数(分钟统计）超过阈值时，触发降级;时间窗口结束后，关闭降级</li></ul></li></ul><p><strong>基本介绍</strong></p><ul><li><p>Sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高)，对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。</p></li><li><p>当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。</p></li></ul><p>Sentinei的断路器是<strong>没有类似Hystrix半开状态</strong>的。(Sentinei 1.8.0 已有半开状态)</p><ul><li>半开的状态系统自动去检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常则继续打开断路器不可用。</li><li>具体可以参考Hystrix的服务降级熔断限流概念初讲。</li></ul><h4 id="Sentinel降级-RT"><a href="#Sentinel降级-RT" class="headerlink" title="Sentinel降级-RT"></a>Sentinel降级-RT</h4><p>是什么？</p><blockquote><p>平均响应时间(DEGRADE_GRADE_RT)：当1s内持续进入5个请求，对应时刻的平均响应时间（秒级）均超过阈值（ count，以ms为单位），那么在接下的时间窗口（DegradeRule中的timeWindow，以s为单位）之内，对这个方法的调用都会自动地熔断(抛出DegradeException )。注意Sentinel 默认统计的RT上限是4900 ms，超出此阈值的都会算作4900ms，若需要变更此上限可以通过启动配置项-Dcsp.sentinel.statistic.max.rt&#x3D;xxx来配置。</p></blockquote><p><img src="/2022/07/13/SpringCloud/dcf85d4362c017e543173c76b7dcc2a8.png" alt="img"></p><p><strong>注意</strong>：Sentinel 1.7.0才有<strong>平均响应时间</strong>（<code>DEGRADE_GRADE_RT</code>），Sentinel 1.8.0的没有这项，取而代之的是<strong>慢调用比例</strong> (<code>SLOW_REQUEST_RATIO</code>)。</p><blockquote><p>慢调用比例 (SLOW_REQUEST_RATIO)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。<a href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7#%E7%86%94%E6%96%AD%E7%AD%96%E7%95%A5">link</a></p></blockquote><p>接下来讲解Sentinel 1.7.0的。</p><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowLimitController</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;testD 测试RT&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testD&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置</p><p>当1秒内每个请求（大于5个时）访问时，对应时刻的平均响应时间（秒级）均超过阈值（ 200ms），那么在接下的时间窗口（1s）之内，对这个方法的调用都会自动地熔断(抛出DegradeException异常 )。</p><p><img src="/2022/07/13/SpringCloud/3a608908cef3d557322967e6bc0e5696.png" alt="img"></p><p><img src="/2022/07/13/SpringCloud/1661582008115.png" alt="1661582008115"></p><p>jmeter压测</p><p><img src="/2022/07/13/SpringCloud/6dcaee9f62bfd3c8334560df34f6aaa6.png" alt="img"></p><p>结论</p><p>按照上述配置，永远一秒钟打进来10个线程（大于5个了）调用testD，我们希望200毫秒处理完本次任务，如果超过200毫秒还没处理完，在未来1秒钟的时间窗口内，断路器打开（保险丝跳闸）微服务不可用，保险丝跳闸断电了后续我停止jmeter，没有这么大的访问量了，断路器关闭（保险丝恢复），微服务恢复OK。</p><h4 id="Sentinel降级-异常比例"><a href="#Sentinel降级-异常比例" class="headerlink" title="Sentinel降级-异常比例"></a>Sentinel降级-异常比例</h4><p><strong>是什么？</strong></p><blockquote><p>异常比例(DEGRADE_GRADE_EXCEPTION_RATIO)：当资源的每秒请求量 &gt;&#x3D; 5，并且每秒异常总数占通过量的比值超过阈值（ DegradeRule中的 count）之后，资源进入降级状态，即在接下的时间窗口( DegradeRule中的timeWindow，以s为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是[0.0, 1.0]，代表0% -100%。</p></blockquote><p><img src="/2022/07/13/SpringCloud/b8f35b00fffd79ef68e8f744403b92f3.png" alt="img"></p><p><strong>注意</strong>，与Sentinel 1.8.0相比，有些不同（Sentinel 1.8.0才有的半开状态），Sentinel 1.8.0的如下：</p><blockquote><p>异常比例 (ERROR_RATIO)：当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。<br><a href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7#%E7%86%94%E6%96%AD%E7%AD%96%E7%95%A5">link</a></p></blockquote><p>接下来讲解Sentinel 1.7.0的。</p><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowLimitController</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testD</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;testD 异常比例&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testD&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置</p><p><img src="/2022/07/13/SpringCloud/ab66591ba085c32e9303d96be7b44f0d.png" alt="img"></p><p>jmeter-每秒20个请求</p><p><img src="/2022/07/13/SpringCloud/6b4fd3cb04118ae77181fe8bf2019176.png" alt="img"></p><p><em>结论</em></p><p>按照上述配置，单独访问一次，必然来一次报错一次(int age &#x3D; 10&#x2F;0)，调一次错一次。</p><p>开启jmeter后，直接高并发发送请求，多次调用达到我们的配置条件了。断路器开启(保险丝跳闸)，微服务不可用了，不再报错error而是服务降级了。</p><h4 id="Sentinel降级-异常数"><a href="#Sentinel降级-异常数" class="headerlink" title="Sentinel降级-异常数"></a>Sentinel降级-异常数</h4><p><strong>是什么？</strong></p><blockquote><p>异常数( <code>DEGRADE_GRADF_EXCEPTION_COUNT</code> )：当资源近1分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若<code>timeWindow</code>小于60s，则结束熔断状态后仍可能再进入熔断状态。</p></blockquote><p><strong>异常数是按照分钟统计的，时间窗口一定要大于等于60秒</strong>。</p><p><img src="/2022/07/13/SpringCloud/d92c6a9ae5ed514b52ddf43fdf0d5f0e.png" alt="img"></p><p><strong>注意</strong>，与Sentinel 1.8.0相比，有些不同（Sentinel 1.8.0才有的半开状态），Sentinel 1.8.0的如下：</p><blockquote><p>异常数 (<code>ERROR_COUNT</code>)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</p></blockquote><p>接下来讲解Sentinel 1.7.0的。</p><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowLimitController</span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testE&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testE</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        log.info(<span class="string">&quot;testE 测试异常数&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testE 测试异常数&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置</p><p><img src="/2022/07/13/SpringCloud/218fe52e19c07b30bbf4d994d05e6a8e.png" alt="img"></p><p>访问<a href="http://localhost:8401/testE%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE%E7%BB%9D%E5%AF%B9%E6%8A%A5%E9%94%99%EF%BC%8C%E5%9B%A0%E4%B8%BA%E9%99%A4%E6%95%B0%E4%B8%8D%E8%83%BD%E4%B8%BA%E9%9B%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E7%9C%8B%E5%88%B0error%E7%AA%97%E5%8F%A3%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BE%BE%E5%88%B05%E6%AC%A1%E6%8A%A5%E9%94%99%E5%90%8E%EF%BC%8C%E8%BF%9B%E5%85%A5%E7%86%94%E6%96%AD%E5%90%8E%E9%99%8D%E7%BA%A7%E3%80%82">http://localhost:8401/testE，第一次访问绝对报错，因为除数不能为零，我们看到error窗口，但是达到5次报错后，进入熔断后降级。</a></p><h3 id="Sentinel热点key限流"><a href="#Sentinel热点key限流" class="headerlink" title="Sentinel热点key限流"></a>Sentinel热点key限流</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><p><img src="/2022/07/13/SpringCloud/9d2aa6d777767b3233aa643330eb9cf4.png" alt="img"></p><p><strong>官网</strong></p><p><a href="https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81">官方文档</a></p><blockquote><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</p><ul><li>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</li><li>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</li></ul><p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。<br><img src="/2022/07/13/SpringCloud/16d2ddeff96b7cb68a064b6ec05bde25.png" alt="img"></p><p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。热点参数限流支持集群模式。<a href="https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81#overview">link</a></p></blockquote><p><strong>承上启下复习start</strong></p><p><strong>兜底方法，分为系统默认和客户自定义，两种</strong></p><p>之前的case，限流出问题后，都是用sentinel系统默认的提示: Blocked by Sentinel (flow limiting)</p><p>我们能不能自定？类似hystrix，某个方法出问题了，就找对应的兜底降级方法?</p><p>结论 - 从HystrixCommand到**@SentinelResource**</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h4><p>com.alibaba.csp.sentinel.slots.block.BlockException</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowLimitController</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testHotKey&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler/*兜底方法*/ = &quot;deal_testHotKey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testHotKey</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1,</span></span><br><span class="line"><span class="params">                             <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span> &#123;</span><br><span class="line">        <span class="comment">//int age = 10/0;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testHotKey&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*兜底方法*/</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deal_testHotKey</span> <span class="params">(String p1, String p2, BlockException exception)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------deal_testHotKey,o(╥﹏╥)o&quot;</span>;  <span class="comment">//sentinel系统默认的提示：Blocked by Sentinel (flow limiting)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><p><img src="/2022/07/13/SpringCloud/1661585287176.png" alt="1661585287176"></p><p>testHotKey方法中设置的，参数索引为0的时候就是p1，对p1进行限流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">testHotKey</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1,</span></span><br><span class="line"><span class="params">                         <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span> &#123;</span><br></pre></td></tr></table></figure><p><img src="/2022/07/13/SpringCloud/9620ee4e7e54d48ba7dda394fa1c8cd0.png" alt="img"></p><p>一</p><ul><li>@SentinelResource(value &#x3D; “testHotKey”)</li><li>异常打到了前台用户界面看到，不友好</li></ul><p>二</p><ul><li><p>@SentinelResource(value &#x3D; “testHotKey”, blockHandler &#x3D;”dealHandler_testHotKey”)</p></li><li><p>方法testHotKey里面第一个参数（设置的p1）只要QPS超过每秒1次，马上降级处理，p2不会被限流</p><p><img src="/2022/07/13/SpringCloud/1661585674430.png" alt="1661585674430"></p><p><img src="/2022/07/13/SpringCloud/1661585832501.png" alt="1661585832501"></p><p><img src="/2022/07/13/SpringCloud/1661585730471.png" alt="1661585730471"></p></li><li><p>异常用了我们自己定义的兜底方法</p></li></ul><p>测试</p><ul><li>error<br><a href="http://localhost:8401/testHotKey?p1=abc">http://localhost:8401/testHotKey?p1=abc</a><br><a href="http://localhost:8401/testHotKey?p1=abc&amp;p2=33">http://localhost:8401/testHotKey?p1=abc&amp;p2=33</a></li><li>right<br><a href="http://localhost:8401/testHotKey?p2=abc">http://localhost:8401/testHotKey?p2=abc</a></li></ul><p>上述案例演示了第一个参数p1，当QPS超过1秒1次点击后马上被限流。</p><h4 id="参数例外项"><a href="#参数例外项" class="headerlink" title="参数例外项"></a><strong>参数例外项</strong></h4><ul><li>普通 - 超过1秒钟一个后，达到阈值1后马上被限流</li><li><strong>我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样</strong></li><li>特例 - 假如当p1的值等于5时，它的阈值可以达到200</li></ul><p><strong>配置</strong></p><p><img src="/2022/07/13/SpringCloud/3aa08b15109cd346a6083f080a0468fa.png" alt="img"></p><p><strong>测试</strong></p><ul><li>right - <a href="http://localhost:8401/testHotKey?p1=5">http://localhost:8401/testHotKey?p1=5</a></li><li>error - <a href="http://localhost:8401/testHotKey?p1=3">http://localhost:8401/testHotKey?p1=3</a></li><li>当p1等于5的时候，阈值变为200</li><li>当p1不等于5的时候，阈值就是平常的1</li></ul><p><strong>前提条件</strong> - 热点参数的注意点，参数必须是基本类型或者String</p><p><img src="/2022/07/13/SpringCloud/1661586303934.png" alt="1661586303934"></p><p><strong>其它</strong></p><p>在方法体抛异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowLimitController</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testHotKey&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler/*兜底方法*/ = &quot;deal_testHotKey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testHotKey</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1,</span></span><br><span class="line"><span class="params">                             <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;<span class="comment">//&lt;----------------------------会抛异常的地方</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testHotKey&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*兜底方法*/</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deal_testHotKey</span> <span class="params">(String p1, String p2, BlockException exception)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------deal_testHotKey,o(╥﹏╥)o&quot;</span>;  <span class="comment">//sentinel系统默认的提示：Blocked by Sentinel (flow limiting)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将会抛出Spring Boot 2的默认异常页面，而不是兜底方法。</p><ul><li>@SentinelResource - 处理的是sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理;</li><li>RuntimeException int age &#x3D; 10&#x2F;0，这个是java运行时报出的运行时异常RunTimeException，@SentinelResource不管</li></ul><p>总结 - @SentinelResource主管配置出错，运行出错该走异常走异常</p><h3 id="Sentinel系统规则"><a href="#Sentinel系统规则" class="headerlink" title="Sentinel系统规则"></a>Sentinel系统规则</h3><p><a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">官方文档</a></p><blockquote><p>Sentinel 系统自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。<a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">link</a></p></blockquote><blockquote><p>系统规则</p><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><p>系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量（EntryType.IN），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p><p>系统规则支持以下的模式：</p><ul><li>Load 自适应（仅对 Linux&#x2F;Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。</li><li>CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li><li>平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li><li>并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li><li>入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。<br><a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81#%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%99">link</a></li></ul></blockquote><h3 id="SentinelResource配置"><a href="#SentinelResource配置" class="headerlink" title="SentinelResource配置"></a>SentinelResource配置</h3><h4 id="上"><a href="#上" class="headerlink" title="上"></a>上</h4><h5 id="按资源名称限流-后续处理"><a href="#按资源名称限流-后续处理" class="headerlink" title="按资源名称限流 + 后续处理"></a><em><strong>按资源名称限流 + 后续处理</strong></em></h5><p><strong>启动Nacos成功</strong></p><p><strong>启动Sentinel成功</strong></p><p><strong>Module - cloudalibaba-sentinel-service8401</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.annotation.SentinelResource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/byResource&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;handleException&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">byResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;按资源名称限流测试OK&quot;</span>,<span class="keyword">new</span> <span class="title class_">Payment</span>(<span class="number">2020L</span>,<span class="string">&quot;serial001&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">handleException</span><span class="params">(BlockException exception)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">444</span>,exception.getClass().getCanonicalName()+<span class="string">&quot;\t 服务不可用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置流控规则</strong></p><p>配置步骤</p><p><img src="/2022/07/13/SpringCloud/91aa0ac210011218db9557a2bfcfebd1.png" alt="img"></p><p>图形配置和代码关系</p><p>表示1秒钟内查询次数大于1，就跑到我们自定义的处流，限流</p><p><strong>测试</strong></p><p>1秒钟点击1下，OK</p><p>超过上述，疯狂点击，返回了自己定义的限流处理信息，限流发生</p><p><img src="/2022/07/13/SpringCloud/1661587846257.png" alt="1661587846257"></p><p><strong>额外问题</strong></p><p>此时关闭问服务8401 -&gt; Sentinel控制台，流控规则消失了——临时</p><hr><h5 id="按照Url地址限流-后续处理"><a href="#按照Url地址限流-后续处理" class="headerlink" title="按照Url地址限流 + 后续处理"></a><em>按照Url地址限流 + 后续处理</em></h5><p><strong>通过访问的URL来限流，会返回Sentinel自带默认的限流处理信息</strong></p><p><strong>业务类RateLimitController</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitController</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/rateLimit/byUrl&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;byUrl&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">byUrl</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;按url限流测试OK&quot;</span>,<span class="keyword">new</span> <span class="title class_">Payment</span>(<span class="number">2020L</span>,<span class="string">&quot;serial002&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Sentinel控制台配置</strong></p><p><img src="/2022/07/13/SpringCloud/d6a79b7cc3f2f9c8b6dcbe3f77f78c6b.png" alt="img"></p><p>测试</p><ul><li><p>快速点击<a href="http://localhost:8401/rateLimit/byUrl">http://localhost:8401/rateLimit/byUrl</a></p></li><li><p>结果 - 会返回Sentinel自带的限流处理结果 Blocked by Sentinel (flow limiting)</p><p><img src="/2022/07/13/SpringCloud/1661588212755.png" alt="1661588212755"></p></li></ul><p>上面兜底方案面临的问题</p><ul><li>系统默认的，没有体现我们自己的业务要求。</li><li>依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观。</li><li>每个业务方法都添加—个兜底的，那代码膨胀加剧。</li><li>全局统—的处理方法没有体现。</li></ul><h4 id="中"><a href="#中" class="headerlink" title="中"></a>中</h4><p>客户自定义限流处理逻辑</p><p>自定义限流处理类 - 创建CustomerBlockHandler类用于自定义限流处理逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.myhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.entities.CommonResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBlockHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> CommonResult <span class="title function_">handlerException</span><span class="params">(BlockException e)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">4444</span>,<span class="string">&quot;按客戶自定义,global handlerException----1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title function_">handlerException2</span><span class="params">(BlockException exception)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">4444</span>,<span class="string">&quot;按客戶自定义,global handlerException----2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>RateLimitController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitController</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/rateLimit/customerBlockHandler&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;customerBlockHandler&quot;,</span></span><br><span class="line"><span class="meta">            blockHandlerClass = CustomerBlockHandler.class,//&lt;-------- 自定义限流处理类</span></span><br><span class="line"><span class="meta">            blockHandler = &quot;handlerException2&quot;)</span><span class="comment">//&lt;-----------</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">customerBlockHandler</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;按客戶自定义&quot;</span>,<span class="keyword">new</span> <span class="title class_">Payment</span>(<span class="number">2020L</span>,<span class="string">&quot;serial003&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Sentinel控制台配置</p><p><img src="/2022/07/13/SpringCloud/44dccf4107a74fda56f0807d39fa53f1.png" alt="img"></p><p>启动微服务后先调用一次 - <a href="http://localhost:8401/rateLimit/customerBlockHandler%E3%80%82%E7%84%B6%E5%90%8E%EF%BC%8C%E5%A4%9A%E6%AC%A1%E5%BF%AB%E9%80%9F%E5%88%B7%E6%96%B0http://localhost:8401/rateLimit/customerBlockHandler%E3%80%82%E5%88%B7%E6%96%B0%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%9C%E5%BA%95%E6%96%B9%E6%B3%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%A1%E6%81%AF%E5%B0%B1%E8%BF%94%E5%9B%9E%E5%88%B0%E5%89%8D%E7%AB%AF%E3%80%82">http://localhost:8401/rateLimit/customerBlockHandler。然后，多次快速刷新http://localhost:8401/rateLimit/customerBlockHandler。刷新后，我们自定义兜底方法的字符串信息就返回到前端。</a></p><p><img src="/2022/07/13/SpringCloud/1661588838768.png" alt="1661588838768"></p><h4 id="下"><a href="#下" class="headerlink" title="下"></a>下</h4><blockquote><p><strong>@SentinelResource 注解</strong></p><p><strong>注意：注解方式埋点不支持 private 方法。</strong></p><p>@SentinelResource 用于定义资源，并提供可选的异常处理和 fallback 配置项。 @SentinelResource 注解包含以下属性：</p><ul><li><p>value：资源名称，必需项（不能为空）</p></li><li><p>entryType：entry 类型，可选项（默认为 EntryType.OUT）</p></li><li><p>blockHandler &#x2F; blockHandlerClass: blockHandler 对应处理 BlockException 的函数名称，可选项。blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定blockHandlerClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</p></li><li><p>fallback &#x2F;fallbackClass：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：</p><ul><li>返回值类型必须与原函数返回值类型一致；</li><li>方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。</li><li>fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</li></ul></li><li><p>defaultFallback（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：</p><ul><li>返回值类型必须与原函数返回值类型一致；</li><li>方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。</li><li>defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</li></ul></li><li><p>exceptionsToIgnore（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。</p><p><a href="https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81#sentinelresource-%E6%B3%A8%E8%A7%A3">link</a></p></li></ul></blockquote><p>Sentinel主要有三个核心Api：</p><ol><li><p>SphU定义资源</p><p><img src="/2022/07/13/SpringCloud/1661589485495.png" alt="1661589485495"></p></li><li><p>Tracer定义统计</p></li><li><p>ContextUtil定义了上下文</p></li></ol><h3 id="服务熔断功能"><a href="#服务熔断功能" class="headerlink" title="服务熔断功能"></a>服务熔断功能</h3><h4 id="sentinel整合ribbon-openFeign-fallback"><a href="#sentinel整合ribbon-openFeign-fallback" class="headerlink" title="sentinel整合ribbon+openFeign+fallback"></a>sentinel整合ribbon+openFeign+fallback</h4><h5 id="Ribbon系列"><a href="#Ribbon系列" class="headerlink" title="Ribbon系列"></a>Ribbon系列</h5><ul><li>启动nacos和sentinel</li><li>提供者9003&#x2F;9004</li><li>消费者84</li></ul><p><strong>提供者9003&#x2F;9004</strong></p><p>新建cloudalibaba-provider-payment9003&#x2F;9004，两个一样的做法</p><ul><li>POM</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloudalibaba-provider-payment9003&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br><span class="line">            &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- SpringBoot整合Web组件 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--日常通用jar包配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><ul><li>YML</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9003</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-payment-provider</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span> #配置Nacos地址</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>记得修改不同的端口号</strong></p><ul><li>主启动</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain9003</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain9003.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>业务类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.hua.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟数据库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Long, Payment&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        hashMap.put(<span class="number">1L</span>,<span class="keyword">new</span> <span class="title class_">Payment</span>(<span class="number">1L</span>,<span class="string">&quot;28a8c1e3bc2742d8848569891fb42181&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">2L</span>,<span class="keyword">new</span> <span class="title class_">Payment</span>(<span class="number">2L</span>,<span class="string">&quot;bba8c1e3bc2742d8848569891ac32182&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">3L</span>,<span class="keyword">new</span> <span class="title class_">Payment</span>(<span class="number">3L</span>,<span class="string">&quot;6ua8c1e3bc2742d8848569891xt92183&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> hashMap.get(id);</span><br><span class="line">        CommonResult&lt;Payment&gt; result = <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;from mysql,serverPort:  &quot;</span>+serverPort,payment);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>测试地址 - <a href="http://localhost:9003/paymentSQL/1">http://localhost:9003/paymentSQL/1</a></li></ul><hr><p><strong>消费者84</strong></p><p>新建cloudalibaba-consumer-nacos-order84</p><ul><li>POM</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloudalibaba-consumer-nacos-order84&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--SpringCloud ailibaba sentinel --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- SpringBoot整合Web组件 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--日常通用jar包配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-openfeign-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><ul><li>YML</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">84</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-order-consumer</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        #配置Sentinel dashboard地址</span><br><span class="line">        dashboard: localhost:<span class="number">8080</span></span><br><span class="line">        #默认<span class="number">8719</span>端口，假如被占用会自动从<span class="number">8719</span>开始依次+<span class="number">1</span>扫描,直至找到未被占用的端口</span><br><span class="line">        port: <span class="number">8719</span></span><br><span class="line"></span><br><span class="line">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span><br><span class="line">service-url:</span><br><span class="line">  nacos-user-service: http:<span class="comment">//nacos-payment-provider</span></span><br><span class="line"></span><br><span class="line"># 激活Sentinel对Feign的支持</span><br><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>主启动</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderNacosMain84</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderNacosMain84.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>业务类</p><ul><li>ApplicationContextConfig</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>CircleBreakerController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleBreakerController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVICE_URL</span> <span class="operator">=</span> <span class="string">&quot;http://nacos-payment-provider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;fallback&quot;)</span><span class="comment">//没有配置</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span> (<span class="string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span> (<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意：修改后请重启微服务</p><ul><li>热部署对java代码级生效及时</li><li>对@SentinelResource注解内属性，有时效果不好</li></ul></li><li><p>目的</p><ul><li>fallback管运行异常</li><li>blockHandler管配置违规</li></ul></li><li><p>测试地址 - <a href="http://localhost:84/consumer/fallback/1">http://localhost:84/consumer/fallback/1</a></p></li><li><p>没有任何配置——负载均衡正常运行</p><ul><li><p>Sentinel服务熔断无配置</p><p>没有任何配置 - <strong>给用户error页面，不友好</strong></p><p><img src="/2022/07/13/SpringCloud/1661592218040.png" alt="1661592218040"></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleBreakerController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVICE_URL</span> <span class="operator">=</span> <span class="string">&quot;http://nacos-payment-provider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;fallback&quot;)</span><span class="comment">//没有配置</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span> (<span class="string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span> (<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只配置fallback</p><ul><li><p>Sentinel服务熔断只配置fallback</p><p>fallback只负责业务异常</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleBreakerController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVICE_URL</span> <span class="operator">=</span> <span class="string">&quot;http://nacos-payment-provider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;)//没有配置</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;fallback&quot;, fallback = &quot;handlerFallback&quot;)</span> <span class="comment">//fallback只负责业务异常</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span> (<span class="string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span> (<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//本例是fallback</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">handlerFallback</span><span class="params">(<span class="meta">@PathVariable</span>  Long id,Throwable e)</span> &#123;</span><br><span class="line">        <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Payment</span>(id,<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>&lt;&gt;(<span class="number">444</span>,<span class="string">&quot;兜底异常handlerFallback,exception内容  &quot;</span>+e.getMessage(),payment);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>测试地址 - <a href="http://localhost:84/consumer/fallback/4">http://localhost:84/consumer/fallback/4</a></p><p>页面返回结果：</p></li></ul><p><img src="/2022/07/13/SpringCloud/1661592618366.png" alt="1661592618366"></p></li><li><p>只配置blockHandler</p><ul><li><p>Sentinel服务熔断只配置blockHandler</p><p>blockHandler只负责<strong>sentinel控制台配置违规</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleBreakerController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVICE_URL</span> <span class="operator">=</span> <span class="string">&quot;http://nacos-payment-provider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;) //没有配置</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;) //fallback只负责业务异常</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;)</span> <span class="comment">//blockHandler只负责sentinel控制台配置违规</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span> (<span class="string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span> (<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本例是fallback</span></span><br><span class="line"><span class="comment">/*    public CommonResult handlerFallback(@PathVariable  Long id,Throwable e) &#123;</span></span><br><span class="line"><span class="comment">        Payment payment = new Payment(id,&quot;null&quot;);</span></span><br><span class="line"><span class="comment">        return new CommonResult&lt;&gt;(444,&quot;兜底异常handlerFallback,exception内容  &quot;+e.getMessage(),payment);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//本例是blockHandler</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">blockHandler</span><span class="params">(<span class="meta">@PathVariable</span>  Long id,BlockException blockException)</span> &#123;</span><br><span class="line">        <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Payment</span>(id,<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>&lt;&gt;(<span class="number">445</span>,<span class="string">&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;</span>+blockException.getMessage(),payment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/07/13/SpringCloud/1661593200543.png" alt="1661593200543"></p><ul><li><p>测试地址 - <a href="http://localhost:84/consumer/fallback/4">http://localhost:84/consumer/fallback/4</a></p><p>一次报错，两次触发降级</p><p><img src="/2022/07/13/SpringCloud/1661593174387.png" alt="1661593174387"></p></li></ul></li><li><p>fallback和blockHandler都配置</p><ul><li>若blockHandler和fallback 都进行了配置，只抛出BlockException时运行时错误就进入fallback，sentinel配置如果被限流降级又抛出BlockException时只会进入blockHandler处理逻辑。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleBreakerController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVICE_URL</span> <span class="operator">=</span> <span class="string">&quot;http://nacos-payment-provider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;) //没有配置</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;) //fallback只负责业务异常</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;) //blockHandler只负责sentinel控制台配置违规</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span> (<span class="string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span> (<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本例是fallback</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">handlerFallback</span><span class="params">(<span class="meta">@PathVariable</span>  Long id,Throwable e)</span> &#123;</span><br><span class="line">        <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Payment</span>(id,<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>&lt;&gt;(<span class="number">444</span>,<span class="string">&quot;兜底异常handlerFallback,exception内容  &quot;</span>+e.getMessage(),payment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本例是blockHandler</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">blockHandler</span><span class="params">(<span class="meta">@PathVariable</span>  Long id,BlockException blockException)</span> &#123;</span><br><span class="line">        <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Payment</span>(id,<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>&lt;&gt;(<span class="number">445</span>,<span class="string">&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;</span>+blockException.getMessage(),payment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试——<a href="http://localhost:84/consumer/fallback/4">http://localhost:84/consumer/fallback/4</a></p></li><li><p>忽略属性</p><ul><li><p>exceptionsToIgnore，忽略指定异常，即这些异常不用兜底方法处理。</p><p><img src="/2022/07/13/SpringCloud/1661593790638.png" alt="1661593790638"></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleBreakerController</span>    </span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;,</span></span><br><span class="line"><span class="meta">            exceptionsToIgnore = &#123;IllegalArgumentException.class&#125;)</span><span class="comment">//&lt;-------------</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">//exceptionsToIgnore属性有IllegalArgumentException.class，</span></span><br><span class="line">            <span class="comment">//所以IllegalArgumentException不会跳入指定的兜底程序。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span> (<span class="string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span> (<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h5 id="Feign系列"><a href="#Feign系列" class="headerlink" title="Feign系列"></a>Feign系列</h5><ul><li><p><strong>修改84模块</strong></p></li><li><p>84消费者调用提供者9003</p></li><li><p>Feign组件一般是消费侧</p></li><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--SpringCloud openfeign --&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 激活Sentinel对Feign的支持</span><br><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>业务类</p><ul><li>带@Feignclient注解的业务接口，fallback &#x3D; PaymentFallbackService.class</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>PaymentFallbackService实现类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">paymentSQL</span><span class="params">(Long id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>&lt;&gt;(<span class="number">44444</span>,<span class="string">&quot;服务降级返回,---PaymentFallbackService&quot;</span>,<span class="keyword">new</span> <span class="title class_">Payment</span>(id,<span class="string">&quot;errorSerial&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Controller</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleBreakerController</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="comment">//==================OpenFeign</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> paymentService.paymentSQL(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span><span class="comment">//&lt;------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderNacosMain84</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderNacosMain84.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>测试 - <a href="http://localhost:84/consumer/paymentSQL/1">http://localhost:84/consumer/paymentSQL/1</a></p><p>测试84调用9003，此时故意关闭9003微服务提供者，<strong>84消费侧自动降级</strong>，不会被耗死。</p><p><img src="/2022/07/13/SpringCloud/1661669498497.png" alt="1661669498497"></p></li><li><p><strong>熔断框架比较</strong></p></li></ul><table><thead><tr><th>-</th><th>Sentinel</th><th>Hystrix</th><th>resilience4j</th></tr></thead><tbody><tr><td>隔离策略</td><td>信号量隔离（并发线程数限流）</td><td>线程池隔商&#x2F;信号量隔离</td><td>信号量隔离</td></tr><tr><td>熔断降级策略</td><td>基于响应时间、异常比率、异常数</td><td>基于异常比率</td><td>基于异常比率、响应时间</td></tr><tr><td>实时统计实现</td><td>滑动窗口（LeapArray）</td><td>滑动窗口（基于RxJava）</td><td>Ring Bit Buffer</td></tr><tr><td>动态规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td><td>有限支持</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td><td>接口的形式</td></tr><tr><td>基于注解的支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>限流</td><td>基于QPS，支持基于调用关系的限流</td><td>有限的支持</td><td>Rate Limiter</td></tr><tr><td>流量整形</td><td>支持预热模式匀速器模式、预热排队模式</td><td>不支持</td><td>简单的Rate Limiter模式</td></tr><tr><td>系统自适应保护</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>控制台</td><td>提供开箱即用的控制台，可配置规则、查看秒级监控，机器发观等</td><td>简单的监控查看</td><td>不提供控制台，可对接其它监控系统</td></tr></tbody></table><h3 id="Sentinel持久化规则"><a href="#Sentinel持久化规则" class="headerlink" title="Sentinel持久化规则"></a>Sentinel持久化规则</h3><p><strong>是什么</strong></p><p>一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化。</p><p><strong>怎么玩</strong></p><p>将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效。</p><p><strong>步骤</strong></p><p>修改cloudalibaba-sentinel-service8401</p><ul><li>POM</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>YML</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8401</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloudalibaba-sentinel-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span> #Nacos服务注册中心地址</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: localhost:<span class="number">8080</span> #配置Sentinel dashboard地址</span><br><span class="line">        port: <span class="number">8719</span></span><br><span class="line">      datasource: #&lt;---------------------------关注点，添加Nacos数据源配置</span><br><span class="line">        ds1:</span><br><span class="line">          nacos:</span><br><span class="line">            server-addr: localhost:<span class="number">8848</span></span><br><span class="line">            dataId: cloudalibaba-sentinel-service</span><br><span class="line">            groupId: DEFAULT_GROUP</span><br><span class="line">            data-type: json</span><br><span class="line">            rule-type: flow</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: <span class="literal">true</span> # 激活Sentinel对Feign的支持</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>添加Nacos业务规则配置</p><p><img src="/2022/07/13/SpringCloud/1661670234369.png" alt="1661670234369"></p></li><li><p>配置内容解析</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/rateLimit/byUrl&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;IimitApp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;strategy&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;controlBehavior&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clusterMode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>resource：资源名称；</li><li>limitApp：来源应用；</li><li>grade：阈值类型，0表示线程数, 1表示QPS；</li><li>count：单机阈值；</li><li>strategy：流控模式，0表示直接，1表示关联，2表示链路；</li><li>controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待；</li><li>clusterMode：是否集群。</li></ul></li><li><p>启动8401后刷新sentinel发现流控规则有了</p><p><img src="/2022/07/13/SpringCloud/1661670355447.png" alt="1661670355447"></p></li></ul><p>快速访问测试接口 - <a href="http://localhost:8401/rateLimit/byUrl">http://localhost:8401/rateLimit/byUrl</a> - 页面返回<code>Blocked by Sentinel (flow limiting)</code></p><ul><li><p>停止8401再看sentinel - 停机后发现流控规则没有了</p><p><img src="/2022/07/13/SpringCloud/1661670436347.png" alt="1661670436347"></p><p><img src="/2022/07/13/SpringCloud/1661670416577.png" alt="1661670416577"></p></li><li><p>重新启动8401再看sentinel</p><p><img src="/2022/07/13/SpringCloud/1661670470952.png" alt="1661670470952"></p><ul><li><p>乍一看还是没有，稍等一会儿</p><p><img src="/2022/07/13/SpringCloud/1661670493400.png" alt="1661670493400"></p></li><li><p>多次调用 - <a href="http://localhost:8401/rateLimit/byUrl">http://localhost:8401/rateLimit/byUrl</a></p></li><li><p>重新配置出现了，持久化验证通过</p><p><img src="/2022/07/13/SpringCloud/1661670522722.png" alt="1661670522722"></p></li></ul></li></ul><h2 id="SpringCloud-Alibaba-Seata处理分布式事务"><a href="#SpringCloud-Alibaba-Seata处理分布式事务" class="headerlink" title="SpringCloud Alibaba Seata处理分布式事务"></a>SpringCloud Alibaba Seata处理分布式事务</h2><h3 id="分布式事务问题由来"><a href="#分布式事务问题由来" class="headerlink" title="分布式事务问题由来"></a>分布式事务问题由来</h3><p>分布式前</p><ul><li>单机单库没这个问题</li><li>从1:1 -&gt; 1:N -&gt; N:N</li></ul><p>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用,分别使用三个独立的数据源，业务操作需要调用三三 个服务来完成。此时<strong>每个服务内部的数据一致性由本地事务来保证， 但是全局的数据一致性问题没法保证</strong>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9a619fb6a635ac96f2f17734bcda7967.png" alt="img"></p><p>一句话：<strong>一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题</strong>。</p><h3 id="Seata简介"><a href="#Seata简介" class="headerlink" title="Seata简介"></a>Seata简介</h3><p><strong>是什么</strong></p><p>Seata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</p><p><a href="http://seata.io/zh-cn/">官方网址</a></p><p><strong>能干嘛</strong></p><p>一个典型的分布式事务过程</p><p>分布式事务处理过程的一ID+三组件模型：</p><ul><li>Transaction ID XID 全局唯一的事务ID</li><li>三组件概念<ul><li>TC (Transaction Coordinator) - 事务协调者：维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚;</li><li>TM (Transaction Manager) - 事务管理器：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议;</li><li>RM (Resource Manager) - 资源管理器：控制分支事务，负责分支注册，状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚；</li></ul></li></ul><p>处理过程：</p><ol><li>TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID；</li><li>XID在微服务调用链路的上下文中传播；</li><li>RM向TC注册分支事务，将其纳入XID对应全局事务的管辖；</li><li>TM向TC发起针对XID的全局提交或回滚决议；</li><li>TC调度XID下管辖的全部分支事务完成提交或回滚请求。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/2d2c6aa29c3158413f66d4ef8c1000dc.png" alt="img"></p><p><strong>去哪下</strong></p><p>发布说明: <a href="https://github.com/seata/seata/releases">https://github.com/seata/seata/releases</a></p><p><strong>怎么玩</strong></p><p>本地@Transactional</p><p>全局@GlobalTransactional</p><p><strong>SEATA 的分布式交易解决方案</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/302377d33ddcd708e20b996bd9f2c7b8.png" alt="img"></p><p>我们只需要使用一个 <code>@GlobalTransactional</code> 注解在业务方法上:</p><h3 id="Seata-Server安装"><a href="#Seata-Server安装" class="headerlink" title="Seata-Server安装"></a>Seata-Server安装</h3><ul><li><p>官网地址 - <a href="http://seata.io/zh-cn/">http://seata.io/zh-cn/</a></p></li><li><p>下载版本 - 0.9.0</p></li><li><p>seata-server-0.9.0.zip解压到指定目录并修改conf目录下的file.conf配置文件</p><ul><li><p>先备份原始file.conf文件</p></li><li><p>主要修改:自定义事务组名称+事务日志存储模式为db +数据库连接信息</p></li><li><p>file.conf</p><ul><li>service模块</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service &#123;</span><br><span class="line">  #vgroup-&gt;rgroup</span><br><span class="line">  #fsp_tx_group是自定义的</span><br><span class="line">  vgroup_mapping.my_test_tx_group = <span class="string">&quot;fsp_tx_group&quot;</span></span><br><span class="line">  #only support single node</span><br><span class="line">  <span class="keyword">default</span>.grouplist = <span class="string">&quot;127.0.0.1:8091&quot;</span></span><br><span class="line">  #degrade current not <span class="type">support</span></span><br><span class="line">  <span class="variable">enableDegrade</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">  #<span class="type">disable</span></span><br><span class="line">  <span class="variable">disable</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, <span class="keyword">default</span> permanent</span><br><span class="line">  max.commit.retry.timeout = <span class="string">&quot;-1&quot;</span></span><br><span class="line">  max.rollback.retry.timeout = <span class="string">&quot;-1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>store模块</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## transaction log store</span><br><span class="line">store &#123;</span><br><span class="line">  ## store mode: file、db</span><br><span class="line">  ## 改成<span class="type">db</span></span><br><span class="line">  <span class="variable">mode</span> <span class="operator">=</span> <span class="string">&quot;db&quot;</span></span><br><span class="line"></span><br><span class="line">  ## file store</span><br><span class="line">  file &#123;</span><br><span class="line">    dir = <span class="string">&quot;sessionStore&quot;</span></span><br><span class="line"></span><br><span class="line">    # branch session size , <span class="keyword">if</span> exceeded first <span class="keyword">try</span> compress lockkey, still exceeded <span class="keyword">throws</span> exceptions</span><br><span class="line">    max-branch-session-size = <span class="number">16384</span></span><br><span class="line">    # globe session size , <span class="keyword">if</span> exceeded <span class="keyword">throws</span> exceptions</span><br><span class="line">    max-global-session-size = <span class="number">512</span></span><br><span class="line">    # file buffer size , <span class="keyword">if</span> exceeded allocate <span class="keyword">new</span> <span class="title class_">buffer</span></span><br><span class="line">    file-write-buffer-cache-size = <span class="number">16384</span></span><br><span class="line">    # when recover batch read size</span><br><span class="line">    session.reload.read_size = <span class="number">100</span></span><br><span class="line">    # async, sync</span><br><span class="line">    flush-disk-mode = async</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ## database store</span><br><span class="line">  db &#123;</span><br><span class="line">    ## the implement of javax.sql.DataSource, such as <span class="title function_">DruidDataSource</span><span class="params">(druid)</span>/BasicDataSource(dbcp) etc.</span><br><span class="line">    datasource = <span class="string">&quot;dbcp&quot;</span></span><br><span class="line">    ## mysql/oracle/h2/oceanbase etc.</span><br><span class="line">    ## 配置数据源</span><br><span class="line">    db-type = <span class="string">&quot;mysql&quot;</span></span><br><span class="line">    driver-class-name = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">    url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/seata&quot;</span></span><br><span class="line">    user = <span class="string">&quot;root&quot;</span></span><br><span class="line">    password = <span class="string">&quot;root&quot;</span></span><br><span class="line">    min-conn = <span class="number">1</span></span><br><span class="line">    max-conn = <span class="number">3</span></span><br><span class="line">    global.table = <span class="string">&quot;global_table&quot;</span></span><br><span class="line">    branch.table = <span class="string">&quot;branch_table&quot;</span></span><br><span class="line">    lock-table = <span class="string">&quot;lock_table&quot;</span></span><br><span class="line">    query-limit = <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>下载自己系统对应的mysql驱动java包，将里面的jar包拷贝到seata的依赖lib文件下去；删除原来的<code>mysql-connector-java-5.1.30.jar</code>，复制自己系统的mysql包。</p><p><img src="/2022/07/13/SpringCloud/1661672839411.png" alt="1661672839411"></p></li><li><p>mysql8.0数据库新建库seata，在seata库里建表</p></li><li><p>建表db_store.sql在\seata-server-0.9.0\seata\conf目录里面，直接复制建表。</p><p><img src="/2022/07/13/SpringCloud/1661673155545.png" alt="1661673155545"></p></li><li><p>修改seata-server-0.9.0\seata\conf目录下的registry.conf配置文件</p><p>目的是：指明注册中心为nacos，及修改nacos连接信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  # 改用为<span class="type">nacos</span></span><br><span class="line">  <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;nacos&quot;</span></span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">  ## 加端口号</span><br><span class="line">    serverAddr = <span class="string">&quot;localhost:8848&quot;</span></span><br><span class="line">    namespace = <span class="string">&quot;&quot;</span></span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>先启动Nacos端口号8848 nacos\bin\startup.cmd</p></li><li><p>再启动seata-server - seata-server-0.9.0\seata\bin\seata-server.bat</p><ul><li>set Path&#x3D;D:\Java\jdk1.8.0_202\bin</li><li>seata-server.bat</li></ul><p><img src="/2022/07/13/SpringCloud/1661675126273.png" alt="1661675126273"></p></li></ul><h3 id="Seata订单-x2F-库存-x2F-账户业务数据库准备"><a href="#Seata订单-x2F-库存-x2F-账户业务数据库准备" class="headerlink" title="Seata订单&#x2F;库存&#x2F;账户业务数据库准备"></a>Seata订单&#x2F;库存&#x2F;账户业务数据库准备</h3><ul><li><p>以下演示都需要先启动Nacos后启动Seata,保证两个都OK。</p></li><li><p>分布式事务业务说明</p><ul><li>这里我们会创建三个服务，一个订单服务，一个库存服务，一个账户服务。</li><li>当用户下单时,会在订单服务中创建一个订单, 然后通过远程调用库存服务来扣减下单商品的库存，再通过远程调用账户服务来扣减用户账户里面的余额，最后在订单服务中修改订单状态为已完成。</li><li>该操作跨越三个数据库，有两次远程调用，很明显会有分布式事务问题。</li><li>一言蔽之，下订单—&gt;扣库存—&gt;减账户(余额)。</li></ul></li><li><p>创建业务数据库</p><ul><li><p>seata_ order：存储订单的数据库;</p></li><li><p>seata_ storage：存储库存的数据库;</p></li><li><p>seata_ account：存储账户信息的数据库。</p></li><li><p>建库SQL</p><p><img src="/2022/07/13/SpringCloud/1661675234275.png" alt="1661675234275"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE seata_order;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE seata_storage;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE seata_account;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>按照上述3库分别建对应业务表</p><ul><li>seata_order库下建t_order表</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TABLE <span class="title function_">t_order</span> <span class="params">(</span></span><br><span class="line"><span class="params">    `id` BIGINT(<span class="number">11</span>)</span> NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    `user_id` BIGINT(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    `product_id` BIGINT(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;产品id&#x27;</span>,</span><br><span class="line">    `count` INT(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">    `money` DECIMAL(<span class="number">11</span>,<span class="number">0</span>) DEFAULT NULL COMMENT <span class="string">&#x27;金额&#x27;</span>,</span><br><span class="line">    `status` INT(<span class="number">1</span>) DEFAULT NULL COMMENT <span class="string">&#x27;订单状态: 0:创建中; 1:已完结&#x27;</span></span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=<span class="number">1</span> DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">SELECT * FROM t_order;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>seata_storage库下建t_storage表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_storage (</span><br><span class="line">`id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">`product_id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;产品id&#x27;</span>,</span><br><span class="line">`total` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;总库存&#x27;</span>,</span><br><span class="line">`used` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;已用库存&#x27;</span>,</span><br><span class="line">`residue` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;剩余库存&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> seata_storage.t_storage(`id`, `product_id`, `total`, `used`, `residue`)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;100&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_storage;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>seata_account库下建t_account表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_account(</span><br><span class="line">`id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">`user_id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">`total` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;总额度&#x27;</span>,</span><br><span class="line">`used` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;已用余额&#x27;</span>,</span><br><span class="line">`residue` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;剩余可用额度&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> seata_account.t_account(`id`, `user_id`, `total`, `used`, `residue`)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1000&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_account;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>按照上述3库分别建对应的回滚日志表</p><ul><li><p>订单-库存-账户3个库下<strong>都需要建各自的回滚日志表</strong></p></li><li><p>\seata-server-0.9.0\seata\conf目录下的db_ undo_ log.sql</p></li><li><p>建表SQL</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- the table to store seata xid data</span></span><br><span class="line"><span class="comment">-- 0.7.0+ add context</span></span><br><span class="line"><span class="comment">-- you must to init this sql for you business databese. the seata server not need it.</span></span><br><span class="line"><span class="comment">-- 此脚本必须初始化在你当前的业务数据库中，用于AT 模式XID记录。与server端无关（注：业务数据库）</span></span><br><span class="line"><span class="comment">-- 注意此处0.3.0+ 增加唯一索引 ux_undo_log</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> `undo_log`;<span class="operator">/</span><span class="operator">/</span> 没有这个表就删除这行（不然找不到这个表进行删除就会报错）</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Seata订单-x2F-库存-x2F-账户业务微服务准备"><a href="#Seata订单-x2F-库存-x2F-账户业务微服务准备" class="headerlink" title="Seata订单&#x2F;库存&#x2F;账户业务微服务准备"></a>Seata订单&#x2F;库存&#x2F;账户业务微服务准备</h3><h4 id="Seata之Order-Module订单配置搭建"><a href="#Seata之Order-Module订单配置搭建" class="headerlink" title="Seata之Order-Module订单配置搭建"></a>Seata之Order-Module订单配置搭建</h4><p>下订单 -&gt; 减库存 -&gt; 扣余额 -&gt; 改（订单）状态</p><ol><li><p>seata-order-service2001</p><p><img src="/2022/07/13/SpringCloud/1661681973818.png" alt="1661681973818"></p></li><li><p>POM</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;SpringCloud_demo1&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hua.study&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;seata-order-service2001&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--nacos--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--seata--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;artifactId&gt;seata-all&lt;/artifactId&gt;</span><br><span class="line">                    &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;seata-all&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">0.9</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--feign--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--web-actuator--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--mysql-druid-自己mysql版本--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">8.0</span><span class="number">.29</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.1</span><span class="number">.10</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">2001</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: seata-order-service</span><br><span class="line">  cloud:</span><br><span class="line">    alibaba:</span><br><span class="line">      seata:</span><br><span class="line">        #自定义事务组名称需要与seata-server中的对应</span><br><span class="line">        tx-service-group: fsp_tx_group</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/seata_order</span></span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line"></span><br><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    io:</span><br><span class="line">      seata: info</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapperLocations: classpath:mapper<span class="comment">/*.xml</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure></li><li><p>resources下新建file.conf</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">transport &#123;</span><br><span class="line">  # tcp udt unix-domain-<span class="type">socket</span></span><br><span class="line">  <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;TCP&quot;</span></span><br><span class="line">  #NIO <span class="type">NATIVE</span></span><br><span class="line">  <span class="variable">server</span> <span class="operator">=</span> <span class="string">&quot;NIO&quot;</span></span><br><span class="line">  #enable <span class="type">heartbeat</span></span><br><span class="line">  <span class="variable">heartbeat</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">  #thread factory <span class="keyword">for</span> netty</span><br><span class="line">  thread-factory &#123;</span><br><span class="line">    boss-thread-prefix = <span class="string">&quot;NettyBoss&quot;</span></span><br><span class="line">    worker-thread-prefix = <span class="string">&quot;NettyServerNIOWorker&quot;</span></span><br><span class="line">    server-executor-thread-prefix = <span class="string">&quot;NettyServerBizHandler&quot;</span></span><br><span class="line">    share-boss-worker = <span class="literal">false</span></span><br><span class="line">    client-selector-thread-prefix = <span class="string">&quot;NettyClientSelector&quot;</span></span><br><span class="line">    client-selector-thread-size = <span class="number">1</span></span><br><span class="line">    client-worker-thread-prefix = <span class="string">&quot;NettyClientWorkerThread&quot;</span></span><br><span class="line">    # netty boss thread size,will not be used <span class="keyword">for</span> UDT</span><br><span class="line">    boss-thread-size = <span class="number">1</span></span><br><span class="line">    #auto <span class="keyword">default</span> pin or <span class="number">8</span></span><br><span class="line">    worker-thread-size = <span class="number">8</span></span><br><span class="line">  &#125;</span><br><span class="line">  shutdown &#123;</span><br><span class="line">    # when destroy server, wait <span class="type">seconds</span></span><br><span class="line">    <span class="variable">wait</span> <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  serialization = <span class="string">&quot;seata&quot;</span></span><br><span class="line">  compressor = <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service &#123;</span><br><span class="line"></span><br><span class="line">  vgroup_mapping.fsp_tx_group = <span class="string">&quot;default&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>.grouplist = <span class="string">&quot;127.0.0.1:8091&quot;</span></span><br><span class="line">  enableDegrade = <span class="type">false</span></span><br><span class="line">  <span class="variable">disable</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">  max.commit.retry.timeout = <span class="string">&quot;-1&quot;</span></span><br><span class="line">  max.rollback.retry.timeout = <span class="string">&quot;-1&quot;</span></span><br><span class="line">  disableGlobalTransaction = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client &#123;</span><br><span class="line">  async.commit.buffer.limit = <span class="number">10000</span></span><br><span class="line">  lock &#123;</span><br><span class="line">    retry.internal = <span class="number">10</span></span><br><span class="line">    retry.times = <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  report.retry.count = <span class="number">5</span></span><br><span class="line">  tm.commit.retry.count = <span class="number">1</span></span><br><span class="line">  tm.rollback.retry.count = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## transaction log store</span><br><span class="line">store &#123;</span><br><span class="line">  ## store mode: file、<span class="type">db</span></span><br><span class="line">  <span class="variable">mode</span> <span class="operator">=</span> <span class="string">&quot;db&quot;</span></span><br><span class="line"></span><br><span class="line">  ## file store</span><br><span class="line">  file &#123;</span><br><span class="line">    dir = <span class="string">&quot;sessionStore&quot;</span></span><br><span class="line"></span><br><span class="line">    # branch session size , <span class="keyword">if</span> exceeded first <span class="keyword">try</span> compress lockkey, still exceeded <span class="keyword">throws</span> exceptions</span><br><span class="line">    max-branch-session-size = <span class="number">16384</span></span><br><span class="line">    # globe session size , <span class="keyword">if</span> exceeded <span class="keyword">throws</span> exceptions</span><br><span class="line">    max-global-session-size = <span class="number">512</span></span><br><span class="line">    # file buffer size , <span class="keyword">if</span> exceeded allocate <span class="keyword">new</span> <span class="title class_">buffer</span></span><br><span class="line">    file-write-buffer-cache-size = <span class="number">16384</span></span><br><span class="line">    # when recover batch read size</span><br><span class="line">    session.reload.read_size = <span class="number">100</span></span><br><span class="line">    # async, sync</span><br><span class="line">    flush-disk-mode = async</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ## database store</span><br><span class="line">  db &#123;</span><br><span class="line">    ## the implement of javax.sql.DataSource, such as <span class="title function_">DruidDataSource</span><span class="params">(druid)</span>/BasicDataSource(dbcp) etc.</span><br><span class="line">    datasource = <span class="string">&quot;dbcp&quot;</span></span><br><span class="line">    ## mysql/oracle/h2/oceanbase etc.</span><br><span class="line">    db-type = <span class="string">&quot;mysql&quot;</span></span><br><span class="line">    driver-class-name = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">    url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/seata&quot;</span></span><br><span class="line">    user = <span class="string">&quot;root&quot;</span></span><br><span class="line">    password = <span class="string">&quot;root&quot;</span></span><br><span class="line">    min-conn = <span class="number">1</span></span><br><span class="line">    max-conn = <span class="number">3</span></span><br><span class="line">    global.table = <span class="string">&quot;global_table&quot;</span></span><br><span class="line">    branch.table = <span class="string">&quot;branch_table&quot;</span></span><br><span class="line">    lock-table = <span class="string">&quot;lock_table&quot;</span></span><br><span class="line">    query-limit = <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">lock &#123;</span><br><span class="line">  ## the lock store mode: local、<span class="type">remote</span></span><br><span class="line">  <span class="variable">mode</span> <span class="operator">=</span> <span class="string">&quot;remote&quot;</span></span><br><span class="line"></span><br><span class="line">  local &#123;</span><br><span class="line">    ## store locks in user<span class="string">&#x27;s database</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  remote &#123;</span></span><br><span class="line"><span class="string">    ## store locks in the seata&#x27;</span>s server</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">recovery &#123;</span><br><span class="line">  #schedule committing retry period in milliseconds</span><br><span class="line">  committing-retry-period = <span class="number">1000</span></span><br><span class="line">  #schedule asyn committing retry period in milliseconds</span><br><span class="line">  asyn-committing-retry-period = <span class="number">1000</span></span><br><span class="line">  #schedule rollbacking retry period in milliseconds</span><br><span class="line">  rollbacking-retry-period = <span class="number">1000</span></span><br><span class="line">  #schedule timeout retry period in milliseconds</span><br><span class="line">  timeout-retry-period = <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transaction &#123;</span><br><span class="line">  undo.data.validation = <span class="literal">true</span></span><br><span class="line">  undo.log.serialization = <span class="string">&quot;jackson&quot;</span></span><br><span class="line">  undo.log.save.days = <span class="number">7</span></span><br><span class="line">  #schedule delete expired undo_log in milliseconds</span><br><span class="line">  undo.log.delete.period = <span class="number">86400000</span></span><br><span class="line">  undo.log.table = <span class="string">&quot;undo_log&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## metrics settings</span><br><span class="line">metrics &#123;</span><br><span class="line">  enabled = <span class="literal">false</span></span><br><span class="line">  registry-type = <span class="string">&quot;compact&quot;</span></span><br><span class="line">  # multi exporters use comma divided</span><br><span class="line">  exporter-list = <span class="string">&quot;prometheus&quot;</span></span><br><span class="line">  exporter-prometheus-port = <span class="number">9898</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">support &#123;</span><br><span class="line">  ## spring</span><br><span class="line">  spring &#123;</span><br><span class="line">    # auto proxy the DataSource bean</span><br><span class="line">    datasource.autoproxy = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>resources下新建registry.conf</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、<span class="type">sofa</span></span><br><span class="line">  <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;nacos&quot;</span></span><br><span class="line"> </span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;localhost:8848&quot;</span></span><br><span class="line">    namespace = <span class="string">&quot;&quot;</span></span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl = <span class="string">&quot;http://localhost:8761/eureka&quot;</span></span><br><span class="line">    application = <span class="string">&quot;default&quot;</span></span><br><span class="line">    weight = <span class="string">&quot;1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  redis &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;localhost:6379&quot;</span></span><br><span class="line">    db = <span class="string">&quot;0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:2181&quot;</span></span><br><span class="line">    session.timeout = <span class="number">6000</span></span><br><span class="line">    connect.timeout = <span class="number">2000</span></span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:8500&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;http://localhost:2379&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  sofa &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:9603&quot;</span></span><br><span class="line">    application = <span class="string">&quot;default&quot;</span></span><br><span class="line">    region = <span class="string">&quot;DEFAULT_ZONE&quot;</span></span><br><span class="line">    datacenter = <span class="string">&quot;DefaultDataCenter&quot;</span></span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    group = <span class="string">&quot;SEATA_GROUP&quot;</span></span><br><span class="line">    addressWaitTime = <span class="string">&quot;3000&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = <span class="string">&quot;file.conf&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">config &#123;</span><br><span class="line">  # file、nacos 、apollo、zk、consul、<span class="type">etcd3</span></span><br><span class="line">  <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;file&quot;</span></span><br><span class="line"> </span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">    namespace = <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:8500&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  apollo &#123;</span><br><span class="line">    app.id = <span class="string">&quot;seata-server&quot;</span></span><br><span class="line">    apollo.meta = <span class="string">&quot;http://192.168.1.204:8801&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:2181&quot;</span></span><br><span class="line">    session.timeout = <span class="number">6000</span></span><br><span class="line">    connect.timeout = <span class="number">2000</span></span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;http://localhost:2379&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = <span class="string">&quot;file.conf&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>domain</p><ul><li>CommonResult</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.domain;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonResult</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String  message;</span><br><span class="line">    <span class="keyword">private</span> T       data;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommonResult</span><span class="params">(Integer code, String message)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>(code,message,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Order</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.domain;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> BigDecimal money;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Integer status; <span class="comment">//订单状态：0：创建中；1：已完结</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Dao接口及实现</p><ul><li>OrderDao</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.domain.Order;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDao</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1 新建订单</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(Order order)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 修改订单状态，从零改为1</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId,<span class="meta">@Param(&quot;status&quot;)</span> Integer status)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>resources文件夹下新建mapper文件夹后添加OrderMapper.xml</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.hua.study.dao.OrderDao&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id=<span class="string">&quot;BaseResultMap&quot;</span> type=<span class="string">&quot;com.hua.study.domain.Order&quot;</span>&gt;</span><br><span class="line">        &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span> jdbcType=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;user_id&quot;</span> property=<span class="string">&quot;userId&quot;</span> jdbcType=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;product_id&quot;</span> property=<span class="string">&quot;productId&quot;</span> jdbcType=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;count&quot;</span> property=<span class="string">&quot;count&quot;</span> jdbcType=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;money&quot;</span> property=<span class="string">&quot;money&quot;</span> jdbcType=<span class="string">&quot;DECIMAL&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;status&quot;</span> property=<span class="string">&quot;status&quot;</span> jdbcType=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=<span class="string">&quot;create&quot;</span>&gt;</span><br><span class="line">        insert into <span class="title function_">t_order</span> <span class="params">(id,user_id,product_id,count,money,status)</span></span><br><span class="line">        values (<span class="literal">null</span>,#&#123;userId&#125;,#&#123;productId&#125;,#&#123;count&#125;,#&#123;money&#125;,<span class="number">0</span>);</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;update id=<span class="string">&quot;update&quot;</span>&gt;</span><br><span class="line">        update t_order <span class="type">set</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        where user_id=#&#123;userId&#125; <span class="type">and</span> <span class="variable">status</span> <span class="operator">=</span> #&#123;status&#125;;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li><li><p>Service接口及实现</p><ul><li><p>OrderService</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.domain.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>OrderServiceImpl</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.dao.OrderDao;</span><br><span class="line"><span class="keyword">import</span> com.hua.study.domain.Order;</span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.StorageService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderDao orderDao;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StorageService storageService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态</span></span><br><span class="line"><span class="comment">     * 简单说：下订单-&gt;扣库存-&gt;减余额-&gt;改状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//@GlobalTransactional(name = &quot;fsp-create-order&quot;,rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(Order order)</span></span><br><span class="line">    &#123;</span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;开始新建订单&quot;</span>);</span><br><span class="line">        <span class="comment">//1 新建订单</span></span><br><span class="line">        orderDao.create(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 扣减库存</span></span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;订单微服务开始调用库存，做扣减Count&quot;</span>);</span><br><span class="line">        storageService.decrease(order.getProductId(),order.getCount());</span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;订单微服务开始调用库存，做扣减end&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 扣减账户</span></span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;订单微服务开始调用账户，做扣减Money&quot;</span>);</span><br><span class="line">        accountService.decrease(order.getUserId(),order.getMoney());</span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;订单微服务开始调用账户，做扣减end&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4 修改订单状态，从零到1,1代表已经完成</span></span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;修改订单状态开始&quot;</span>);</span><br><span class="line">        orderDao.update(order.getUserId(),<span class="number">0</span>);</span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;修改订单状态结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;-----&gt;下订单结束了，O(∩_∩)O哈哈~&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>StorageService</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.domain.CommonResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;seata-storage-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/storage/decrease&quot;)</span></span><br><span class="line">    CommonResult <span class="title function_">decrease</span><span class="params">(<span class="meta">@RequestParam(&quot;productId&quot;)</span> Long productId,<span class="meta">@RequestParam(&quot;count&quot;)</span> Integer count)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>AccountService</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.domain.CommonResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;seata-account-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/account/decrease&quot;)</span></span><br><span class="line">    CommonResult <span class="title function_">decrease</span><span class="params">(<span class="meta">@RequestParam(&quot;userId&quot;)</span> Long userId, <span class="meta">@RequestParam(&quot;money&quot;)</span> BigDecimal money)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.domain.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.hua.study.domain.Order;</span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/order/create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">create</span><span class="params">(Order order)</span>&#123;</span><br><span class="line">        orderService.create(order);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;订单创建成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Config配置</p><ul><li>MyBatisConfig</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&#123;&quot;com.hua.study.dao&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>DataSourceProxyConfig</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.datasource.DataSourceProxy;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.transaction.SpringManagedTransactionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Seata对数据源进行代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProxyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mapperLocations;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">druidDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProxy <span class="title function_">dataSourceProxy</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProxy</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSourceProxy dataSourceProxy)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSourceProxy);</span><br><span class="line">        sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>().getResources(mapperLocations));</span><br><span class="line">        sqlSessionFactoryBean.setTransactionFactory(<span class="keyword">new</span> <span class="title class_">SpringManagedTransactionFactory</span>());</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="comment">//取消数据源的自动创建，而是使用自己定义的</span></span><br><span class="line"><span class="meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeataOrderMainApp2001</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(SeataOrderMainApp2001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="Seata之Storage-Module库存搭建"><a href="#Seata之Storage-Module库存搭建" class="headerlink" title="Seata之Storage-Module库存搭建"></a>Seata之Storage-Module库存搭建</h4><p>与seata-order-service2001模块大致相同</p><ol><li><p>seata-storage-service2002</p></li><li><p>POM与seata-order-service2001模块相同</p></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">2002</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: seata-storage-service</span><br><span class="line">  cloud:</span><br><span class="line">    alibaba:</span><br><span class="line">      seata:</span><br><span class="line">        #自定义事务组名称需要与seata-server中的对应</span><br><span class="line">        tx-service-group: fsp_tx_group</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/seata_storage</span></span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    io:</span><br><span class="line">      seata: info</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapperLocations: classpath:mapper<span class="comment">/*.xml</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure></li><li><p>file.conf与seata-order-service2001模块相同</p></li><li><p>registry.conf与seata-order-service2001模块相同</p></li><li><p>domain</p><ul><li><p>CommonResult与seata-order-service2001模块相同</p></li><li><p>Storage</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产品id</span></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总库存</span></span><br><span class="line">    <span class="keyword">private</span> Integer total;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//已用库存</span></span><br><span class="line">    <span class="keyword">private</span> Integer used;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//剩余库存</span></span><br><span class="line">    <span class="keyword">private</span> Integer residue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Dao接口及实现</p><ul><li>StorageDao</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StorageDao</span> &#123;</span><br><span class="line">    <span class="comment">//扣减库存信息</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(<span class="meta">@Param(&quot;productId&quot;)</span> Long productId, <span class="meta">@Param(&quot;count&quot;)</span> Integer count)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>resources文件夹下新建mapper文件夹后添加StorageMapper.xml</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.hua.study.dao.StorageDao&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id=<span class="string">&quot;BaseResultMap&quot;</span> type=<span class="string">&quot;com.hua.study.domain.Storage&quot;</span>&gt;</span><br><span class="line">        &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span> jdbcType=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;product_id&quot;</span> property=<span class="string">&quot;productId&quot;</span> jdbcType=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;total&quot;</span> property=<span class="string">&quot;total&quot;</span> jdbcType=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;used&quot;</span> property=<span class="string">&quot;used&quot;</span> jdbcType=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;residue&quot;</span> property=<span class="string">&quot;residue&quot;</span> jdbcType=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id=<span class="string">&quot;decrease&quot;</span>&gt;</span><br><span class="line">        UPDATE</span><br><span class="line">            t_storage</span><br><span class="line">        <span class="type">SET</span></span><br><span class="line">            <span class="variable">used</span> <span class="operator">=</span> used + #&#123;count&#125;,residue = residue - #&#123;count&#125;</span><br><span class="line">        <span class="type">WHERE</span></span><br><span class="line">            <span class="variable">product_id</span> <span class="operator">=</span> #&#123;productId&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li><li><p>Service接口及实现</p><ul><li><p>StorageService</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扣减库存</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(Long productId, Integer count)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>StorageServiceImpl</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.service.impl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.dao.StorageDao;</span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.StorageService;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(StorageServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StorageDao storageDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扣减库存</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(Long productId, Integer count)</span> &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;-------&gt;storage-service中扣减库存开始&quot;</span>);</span><br><span class="line">        storageDao.decrease(productId,count);</span><br><span class="line">        LOGGER.info(<span class="string">&quot;-------&gt;storage-service中扣减库存结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.domain.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.StorageService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StorageService storageService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//扣减库存</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/storage/decrease&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">decrease</span><span class="params">(Long productId, Integer count)</span> &#123;</span><br><span class="line">        storageService.decrease(productId, count);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;扣减库存成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Config配置</p><ul><li><p>MyBatisConfig与seata-order-service2001模块相同</p></li><li><p>DataSourceProxyConfig与seata-order-service2001模块相同</p></li></ul></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeataStorageServiceApplication2002</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(SeataStorageServiceApplication2002.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Seata之Account-Module账户搭建"><a href="#Seata之Account-Module账户搭建" class="headerlink" title="Seata之Account-Module账户搭建"></a>Seata之Account-Module账户搭建</h4><p>与seata-order-service2001模块大致相同</p><ol><li><p>seata-account-service2003</p></li><li><p>POM与seata-order-service2001模块相同</p></li><li><p>YML</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">2003</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: seata-account-service</span><br><span class="line">  cloud:</span><br><span class="line">    alibaba:</span><br><span class="line">      seata:</span><br><span class="line">        #自定义事务组名称需要与seata-server中的对应</span><br><span class="line">        tx-service-group: fsp_tx_group</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/seata_account</span></span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line"></span><br><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    io:</span><br><span class="line">      seata: info</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapperLocations: classpath:mapper<span class="comment">/*.xml</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure></li><li><p>file.conf与seata-order-service2001模块相同</p></li><li><p>registry.conf与seata-order-service2001模块相同</p></li><li><p>domain</p><ul><li><p>CommonResult与seata-order-service2001模块相同</p></li><li><p>Account</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总额度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已用额度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 剩余额度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal residue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Dao接口及实现</p><ul><li>AccountDao</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.dao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId, <span class="meta">@Param(&quot;money&quot;)</span> BigDecimal money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>resources文件夹下新建mapper文件夹后添加AccountMapper.xml</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.hua.study.dao.AccountDao&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id=<span class="string">&quot;BaseResultMap&quot;</span> type=<span class="string">&quot;com.hua.study.domain.Account&quot;</span>&gt;</span><br><span class="line">        &lt;id column=<span class="string">&quot;id&quot;</span> property=<span class="string">&quot;id&quot;</span> jdbcType=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;user_id&quot;</span> property=<span class="string">&quot;userId&quot;</span> jdbcType=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;total&quot;</span> property=<span class="string">&quot;total&quot;</span> jdbcType=<span class="string">&quot;DECIMAL&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;used&quot;</span> property=<span class="string">&quot;used&quot;</span> jdbcType=<span class="string">&quot;DECIMAL&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;residue&quot;</span> property=<span class="string">&quot;residue&quot;</span> jdbcType=<span class="string">&quot;DECIMAL&quot;</span>/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id=<span class="string">&quot;decrease&quot;</span>&gt;</span><br><span class="line">        UPDATE t_account</span><br><span class="line">        <span class="type">SET</span></span><br><span class="line">            <span class="variable">residue</span> <span class="operator">=</span> residue - #&#123;money&#125;,used = used + #&#123;money&#125;</span><br><span class="line">        <span class="type">WHERE</span></span><br><span class="line">            <span class="variable">user_id</span> <span class="operator">=</span> #&#123;userId&#125;;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li><li><p>Service接口及实现</p><ul><li><p>AccountService</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(<span class="meta">@RequestParam(&quot;userId&quot;)</span> Long userId, <span class="meta">@RequestParam(&quot;money&quot;)</span> BigDecimal money)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>AccountServiceImpl</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.service.impl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.dao.AccountDao;</span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户业务实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(AccountServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(Long userId, BigDecimal money)</span> &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;-------&gt;account-service中扣减账户余额开始&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">20</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="comment">//模拟超时异常，全局事务回滚</span></span><br><span class="line">        accountDao.decrease(userId,money);</span><br><span class="line">        LOGGER.info(<span class="string">&quot;-------&gt;account-service中扣减账户余额结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.domain.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.hua.study.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/account/decrease&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">decrease</span><span class="params">(<span class="meta">@RequestParam(&quot;userId&quot;)</span> Long userId, <span class="meta">@RequestParam(&quot;money&quot;)</span> BigDecimal money)</span>&#123;</span><br><span class="line">        accountService.decrease(userId,money);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>,<span class="string">&quot;扣减账户余额成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Config配置</p><ul><li><p>MyBatisConfig与seata-order-service2001模块相同</p></li><li><p>DataSourceProxyConfig与seata-order-service2001模块相同</p></li></ul></li><li><p>主启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeataAccountMainApp2003</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(SeataAccountMainApp2003.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Seata之-GlobalTransactional验证"><a href="#Seata之-GlobalTransactional验证" class="headerlink" title="Seata之@GlobalTransactional验证"></a>Seata之@GlobalTransactional验证</h3><p>下订单 -&gt; 减库存 -&gt; 扣余额 -&gt; 改（订单）状态</p><p>数据库初始情况：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e639c859e870eebd847d579347ed8755.png" alt="img"></p><p>正常下单 - <a href="http://localhost:2001/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100">http://localhost:2001/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100</a></p><p><img src="/2022/07/13/SpringCloud/1661684212775.png" alt="1661684212775"></p><p>数据库正常下单后状况：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/32401b689cf9a7d624fd0f2aea7ce414.png" alt="img"></p><hr><p><strong>超时异常，没加@GlobalTransactional</strong></p><p>模拟AccountServiceImpl添加超时</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(AccountServiceImpl.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(Long userId, BigDecimal money)</span> &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;-------&gt;account-service中扣减账户余额开始&quot;</span>);</span><br><span class="line">        <span class="comment">//模拟超时异常，全局事务回滚</span></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">20</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        accountDao.decrease(userId,money);</span><br><span class="line">        LOGGER.info(<span class="string">&quot;-------&gt;account-service中扣减账户余额结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，OpenFeign的调用默认时间是1s以内，所以最后会抛异常。</p><p><img src="/2022/07/13/SpringCloud/1661684616107.png" alt="1661684616107"></p><p>数据库情况</p><p><img src="https://img-blog.csdnimg.cn/img_convert/af40cc3756cef7179e58c813ed404db3.png" alt="img"></p><p><strong>故障情况</strong></p><ul><li>当库存和账户金额扣减后，订单状态并没有设置为已经完成，没有从零改为1</li><li>而且由于feign的重试机制，账户余额还有可能被多次扣减</li></ul><hr><p><strong>超时异常，加了@GlobalTransactional</strong></p><p>用@GlobalTransactional标注OrderServiceImpl的create()方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态</span></span><br><span class="line"><span class="comment">     * 简单说：下订单-&gt;扣库存-&gt;减余额-&gt;改状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//rollbackFor = Exception.class表示对任意异常都进行回滚</span></span><br><span class="line">    <span class="meta">@GlobalTransactional(name = &quot;fsp-create-order&quot;,rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(Order order)</span></span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是模拟AccountServiceImpl添加超时，下单后数据库数据并没有任何改变，记录都添加不进来，<strong>达到出异常，数据库回滚的效果</strong>。</p><h3 id="Seata之原理简介"><a href="#Seata之原理简介" class="headerlink" title="Seata之原理简介"></a>Seata之原理简介</h3><p>2019年1月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。</p><p>Simple Extensible Autonomous Transaction Architecture，简单可扩展自治事务框架。</p><p>2020起始，用1.0以后的版本。Alina Gingertail</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2d2c6aa29c3158413f66d4ef8c1000dc.png" alt="img"></p><p><img src="/2022/07/13/SpringCloud/1661685697017.png" alt="1661685697017"></p><p><strong>分布式事务的执行流程</strong></p><ul><li>TM开启分布式事务(TM向TC注册全局事务记录) ;</li><li>按业务场景，编排数据库、服务等事务内资源(RM向TC汇报资源准备状态) ;</li><li>TM结束分布式事务，事务一阶段结束(TM通知TC提交&#x2F;回滚分布式事务) ;</li><li>TC汇总事务信息，决定分布式事务是提交还是回滚；</li><li>TC通知所有RM提交&#x2F;回滚资源，事务二阶段结束。</li></ul><p><strong>AT模式如何做到对业务的无侵入</strong></p><ul><li>是什么</li></ul><blockquote><p><strong>前提</strong></p><ul><li>基于支持本地 ACID 事务的关系型数据库。</li><li>Java 应用，通过 JDBC 访问数据库。</li></ul><p><strong>整体机制</strong></p><p>两阶段提交协议的演变：</p><ul><li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</li><li>二阶段：<ul><li>提交异步化，非常快速地完成。</li><li>回滚通过一阶段的回滚日志进行反向补偿。</li></ul></li></ul><p><a href="http://seata.io/zh-cn/docs/overview/what-is-seata.html">link</a></p></blockquote><ul><li>一阶段加载</li></ul><p>在一阶段，Seata会拦截“业务SQL”</p><ol><li>解析SQL语义，找到“业务SQL” 要更新的业务数据，在业务数据被更新前，将其保存成”before image”</li><li>执行“业务SQL” 更新业务数据，在业务数据更新之后,</li><li>其保存成”after image”，最后生成行锁。</li></ol><p>以上操作全部在一个数据库事务内完成, 这样保证了一阶段操作的原子性。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/80a7bd6cacef78392b278af04d446562.png" alt="img"></p><ul><li>二阶段提交</li></ul><p>二阶段如果顺利提交的话，因为”业务SQL”在一阶段已经提交至数据库，所以Seata框架<strong>只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/a16483118166481bd7f9d06f91a28146.png" alt="img"></p><ul><li>二阶段回滚</li></ul><p>二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的 “业务SQL”，还原业务数据。</p><p>回滚方式便是用”before image”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和”after image”。</p><p>如果两份数据完全一致就说明没有脏写， 可以还原业务数据，如果不一致就说明有脏写, 出现脏写就需要转人工处理。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/828b79e4c7679ce5f09069e551c2a717.png" alt="img"></p><p>补充</p><p><img src="https://img-blog.csdnimg.cn/img_convert/21da4fdc4260008c3324574abc33f0ae.png" alt="img"></p><h2 id="大厂面试第三季预告片之雪花算法-上"><a href="#大厂面试第三季预告片之雪花算法-上" class="headerlink" title="大厂面试第三季预告片之雪花算法(上)"></a>大厂面试第三季预告片之雪花算法(上)</h2><h3 id="集群高并发情况下如何保证分布式唯一全局ID生成？"><a href="#集群高并发情况下如何保证分布式唯一全局ID生成？" class="headerlink" title="集群高并发情况下如何保证分布式唯一全局ID生成？"></a>集群高并发情况下如何保证分布式唯一全局ID生成？</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><strong>为什么需要分布式全局唯一ID以及分布式ID的业务需求？集群高并发情况下如何保证分布式唯一全局Id生成？</strong></p><p>在复杂分布式系统中，往往需婴对大量的数据和消息进行唯一标识，如在美团点评的金融、支付、餐饮、酒店，猫眼电影等产品的系统中数据日渐增长，对数据分库分表后需要有一个唯一ID来标识一条数据或消息。特别一点的如订单、骑手、优惠券也都雷要有唯一ID做标识。此时<strong>一个能够生成全局唯一ID的系统是非常必要的。</strong></p><p><strong>ID生成规则部分硬性要求</strong></p><ul><li>全局唯一：不能出现重复的ID号，既然是唯一-标识，这是最基本的要求</li><li>趋势递增：在MySQL的InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用Btree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</li><li>单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求</li><li>信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可。如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，需要ID无规则不规则，让竞争对手否好猜。</li><li>含时间戳：这样就能够在开发中快速了解这个分布式id的生成时间。</li></ul><p><strong>ID号生成系统的可用性要求</strong></p><ul><li><em>高可用</em>：发一个获取分布式ID的请求，服务器就要保证99.999%的情况下给我创建一个唯一分布式ID。</li><li><em>低延迟</em>：发一个获取分布式ID的请求，服务器就要快，极速。</li><li><em>高QPS</em>：假如并发一口气10万个创建分布式ID请求同时杀过来，服务器要顶的住且一下子成功创建10万个分布式ID。</li></ul><h4 id="一般通用方案"><a href="#一般通用方案" class="headerlink" title="一般通用方案"></a><strong>一般通用方案</strong></h4><h5 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a><strong>UUID</strong></h5><p>UUID(Universally Unique ldentifer)的标准型式包含32位16进制数字，以连了号分为五段，形式为8-4-4-4-12的36个字符， 示例：550e8400-e29b-41d4-a716-446655440000</p><p>性能非常高：本地生成，没有网络消耗</p><p>如果只是考虑唯一性，那就选用它吧</p><p>但是，入数据库性能差</p><p><strong>为什么无序的UUID会导致入库性能变差呢？</strong></p><ul><li><p><strong>无序，无法预测他的生成顺序，不能生成递增有序的数字</strong>。首先分布式ID一般都会作为主键， 但是MySQL官方推荐主键要尽量越短越好，UUID每一个都很长，所以不是很推荐。</p></li><li><p><strong>主键，ID作为主键时在特定的环境会存在一些问题。</strong>比如做DB主键的场景下，UUID就非常不适用，MySQL官方有明确的建议主键要尽量越短越好，36个字符长度的UUID不符合要求。</p></li><li><p><strong>索引，B＋树索引的分裂。</strong>既然分布式ID是主键，然后主键是包含索引的，然后MySQL的索引是通过B+树来实现的，每一次新的UUID数据的插入，为了查询的优化，都会对索引底层的B+树进行修改，因为UUID数据是无序的，所以每一次UUID数据的插入都会对主键的B+树进行很大的修改，这一点很不好。 插入完全无序，不但会导致一-些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能。</p></li></ul><blockquote><p>All indexes other than the clustered index are known as <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_secondary_index">secondary indexes</a>. In InnoDB, each record in a secondary index contains the primary key columns for the row, as well as the columns specified for the secondary index. InnoDB uses this primary key value to search for the row in the clustered index.</p><p>If the primary key is long, the secondary indexes use more space, so it is advantageous to have a short primary key.<br><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html">link</a></p></blockquote><h5 id="数据库自增主键"><a href="#数据库自增主键" class="headerlink" title="数据库自增主键"></a><strong>数据库自增主键</strong></h5><ul><li><strong>单机</strong></li></ul><p>在单机里面，数据库的自增ID机制的主要原理是：通过数据库自增ID和MySQL数据库的replace into实现的。</p><p><strong>REPLACE INTO的含义是插入一条记录，如果表中唯一索引的值遇到冲突，则替换老数据。</strong></p><p>这里的replace into跟inset功能类似，不同点在于：replace into首先尝试插入数据列表中，如果发现表中已经有此行数据（根据主键或唯一索引判断）则先删除，再插入。否则直接插入新数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_test(</span><br><span class="line">id <span class="type">BIGINT</span>(<span class="number">20</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">stub <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY stub(stub)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> FROMt_ test;</span><br><span class="line"></span><br><span class="line">REPLACE <span class="keyword">INTO</span> t_test (stub) <span class="keyword">VALUES</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> LAST_INSERT_ID();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>集群分布式</strong></li></ul><p>那数据库自增ID机制适合作分布式ID吗？<strong>答案是不太适合</strong></p><p>1：系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是1，2，3，4，5（步长是1），这个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，貌似还好，现在想象一下如果我们线上有100台机器，这个时候要扩容该怎么做？简直是噩梦，所以系统水平扩展方案复杂难以实现。</p><p>2：数据库压力还是很大，每次获取ID都得读写一次数据库， 非常影响性能，不符合分布式ID里面的低延迟和要高QPS的规则（在高并发下，如果都去数据库里面获取id，那是非常影响性能的）</p><h5 id="基于Redis生成全局ID策略"><a href="#基于Redis生成全局ID策略" class="headerlink" title="基于Redis生成全局ID策略"></a><strong>基于Redis生成全局ID策略</strong></h5><p>因为Redis是单线的天生保证原子性，可以使用原子操作INCR和INCRBY来实现</p><p>注意：在Redis集群情况下，同样和MySQL<strong>一样需要设置不同的增长步长</strong>，同时key一定要设置有效期可以使用Redis集群来获取更高的吞吐量。</p><p>假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。</p><p>各个Redis生成的ID为:</p><p>A：1, 6, 11, 16, 21<br>B：2, 7 , 12, 17, 22<br>C：3, 8, 13, 18, 23<br>D：4, 9, 14, 19, 24<br>E：5, 10, 15, 20, 25</p><h2 id="大厂面试第三季预告片之雪花算法-下"><a href="#大厂面试第三季预告片之雪花算法-下" class="headerlink" title="大厂面试第三季预告片之雪花算法(下)"></a>大厂面试第三季预告片之雪花算法(下)</h2><h3 id="Twitter的分布式自增ID算法snowflake"><a href="#Twitter的分布式自增ID算法snowflake" class="headerlink" title="Twitter的分布式自增ID算法snowflake"></a><strong>Twitter的分布式自增ID算法snowflake</strong></h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a><strong>概述</strong></h4><p>Twitter的snowflake解决了这种需求，最初Twitter把存储系统从MySQL迁移到Cassandra（由Facebook开发一套开源分布式NoSQL数据库系统）。因为Cassandra没有顺序ID生成机制，所以开发了这样一套全局唯一生成服务。</p><p>Twitter的分布式雪花算法SnowFlake ，经测试snowflake 每秒能够产生26万个自增可排序的ID</p><ul><li><p>Twitter的SnowFlake生成ID能够按照时间有序生成。</p></li><li><p>SnowFlake算法生成ID的结果是一个64bit大小的整数， 为一个Long型（转换成字符串后长度最多19）。</p></li><li><p>分布式系统内不会产生ID碰撞（由datacenter和workerld作区分）并且效率较高。</p></li></ul><p>分布式系统中，有一些需要使用全局唯一ID的场景， 生成ID的基本要求：</p><ul><li><p>在分布式的环境下必须全局且唯一 。</p></li><li><p>一般都需要单调递增，因为一般唯一ID都会存到数据库，而Innodb的特性就是将内容存储在主键索引树上的叶子节点而且是从左往右，递增的，所以考虑到数据库性能，一般生成的ID也最好是单调递增。 为了防止ID冲突可以使用36位的UUID，但是UUID有一些缺点， 首先他相对比较长， 另外UUID一般是无序的。</p></li><li><p>可能还会需要无规则，因为如果使用唯一ID作为订单号这种，为了不然别人知道一天的订单量是多少，就需要这个规则。</p></li></ul><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h4><p>雪花算法的几个核心组成部分：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/795b3d1fa01bbd15d8b7b85c2724bf42.png" alt="img"></p><p>号段解析：</p><p><strong>1bit：</strong></p><p><strong>不用</strong>，因为二进制中最高位是符号位，1表示负数，0表示正数。生成的id一般都是用整数，<strong>所以最高位固定为0</strong>。</p><p><strong>41bit - 时间戳，用来记录时间戳，毫秒级：</strong></p><ul><li>41位可以表示2^41-1个数字。</li><li>如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0至2^41-1，<strong>减1是因为可表示的数值范围是从0开始算的，而不是1</strong>。</li><li>也就是说41位可以表示2^41-1个毫秒的值，转化成单位年则是( 2 ^41 − 1 ) &#x2F; ( 1000 ∗ 60 ∗ 60 ∗ 24 ∗ 365 ) &#x3D; 69 (2^{41}-1)&#x2F; (1000 * 60 * 60 * 24 *365) &#x3D; 69年</li></ul><p><strong>10bit - 工作机器ID，用来记录工作机器ID：</strong></p><ul><li>可以部署在2 ^10 &#x3D; 1024个节点，包括5位DataCenterId和5位Workerld。</li><li>5位(bit) 可以表示的最大正整数是2 ^5 − 1 &#x3D;31,即可以用0、1、2、3、…31这32个数字，来表示不同的DataCenterld或Workerld。</li></ul><p><strong>12bit - 序列号，用来记录同毫秒内产生的不同id：</strong></p><ul><li>12位(bit) 可以表示的最大正整数是2 ^12 − 1 &#x3D; 4095， 即可以用0、1、2、 3、…4094这4095个数字，来表示同一机器同一时间截(毫秒)内产生的4095个ID序号。</li></ul><p>SnowFlake可以保证：</p><ul><li>所有生成的ID按时间趋势递增。</li><li>整个分布式系统内不会产生重复id（因为有DataCenterId和Workerld来做区分)</li></ul><p><strong>源码</strong></p><p>以下代码仅供学习：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Twitter_Snowflake</span></span><br><span class="line"><span class="comment"> * SnowFlake的结构如下(每部分用-分开):</span></span><br><span class="line"><span class="comment"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000</span></span><br><span class="line"><span class="comment"> * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0</span></span><br><span class="line"><span class="comment"> * 41位时间戳(毫秒级)，注意，41位时间戳不是存储当前时间的时间戳，而是存储时间戳的差值（当前时间戳 - 开始时间戳)</span></span><br><span class="line"><span class="comment"> * 得到的值），这里的的开始时间戳，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下面程序SnowflakeIdWorker类的startTime属性）。41位的时间戳，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69</span></span><br><span class="line"><span class="comment"> * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId</span></span><br><span class="line"><span class="comment"> * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间戳)产生4096个ID序号</span></span><br><span class="line"><span class="comment"> * 加起来刚好64位，为一个Long型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnowflakeIdWorker</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 工作机器ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> workerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据中心ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> datacenterId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 毫秒内序列(0~4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 上次生成ID的时间戳 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastTimestamp</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 开始时间戳 (2019-01-01) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">twepoch</span> <span class="operator">=</span> <span class="number">1420041600000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">datacenterIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxWorkerId</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大数据标识id，结果是31 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxDatacenterId</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 序列在id中占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceBits</span> <span class="operator">=</span> <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器ID向左移12位 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdShift</span> <span class="operator">=</span> sequenceBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id向左移17位(12+5) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">datacenterIdShift</span> <span class="operator">=</span> sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 时间戳向左移22位(5+5+12) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timestampLeftShift</span> <span class="operator">=</span> sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceMask</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//==============================Constructors=====================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId 工作ID (0~31)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心ID (0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SnowflakeIdWorker</span><span class="params">(<span class="type">long</span> workerId, <span class="type">long</span> datacenterId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.workerId = workerId;</span><br><span class="line">        <span class="built_in">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==============================Methods==========================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得下一个ID (该方法是线程安全的)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SnowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">//毫秒内序列溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//阻塞到下一个毫秒,获得新的时间戳</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//时间戳改变，毫秒内序列重置</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上次生成ID的时间戳</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移位并通过或运算拼到一起组成64位的ID</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="comment">//</span></span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) <span class="comment">//</span></span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) <span class="comment">//</span></span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上次生成ID的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="title function_">tilNextMillis</span><span class="params">(<span class="type">long</span> lastTimestamp)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回以毫秒为单位的当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="title function_">timeGen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 测试 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始：&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="type">SnowflakeIdWorker</span> <span class="variable">idWorker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SnowflakeIdWorker</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> idWorker.nextId();</span><br><span class="line">            System.out.println(id);</span><br><span class="line"><span class="comment">//            System.out.println(Long.toBinaryString(id));</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束：&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="工程落地经验"><a href="#工程落地经验" class="headerlink" title="工程落地经验"></a><strong>工程落地经验</strong></h4><p><a href="https://www.hutool.cn/docs/#/core/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%94%AF%E4%B8%80ID%E5%B7%A5%E5%85%B7-IdUtil?id=snowflake">Hutool的Snowflake文档</a></p><p>SpringBoot整合雪花算法</p><p>添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-captcha&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.6</span><span class="number">.8</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例程序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.lang.Snowflake;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.net.NetUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.IdUtil; </span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGeneratorSnowflake</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">workerId</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">datacenterId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Snowflake</span> <span class="variable">snowflake</span> <span class="operator">=</span> IdUtil.createSnowflake(workerId, datacenterId);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            workerId = NetUtil.ipv4ToLong(NetUtil.getLocalhostStr());</span><br><span class="line">            log.info(<span class="string">&quot;当前机器的workerId:&#123;&#125;&quot;</span>,workerId);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.warn(<span class="string">&quot;当前机器的workerId获取失败&quot;</span>,e);</span><br><span class="line">            workerId = NetUtil.getLocalhostStr().hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">snowflakeId</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> snowflake.nextId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">snowflakeId</span><span class="params">(<span class="type">long</span> workerId, <span class="type">long</span> datacenterId)</span>&#123;</span><br><span class="line"><span class="type">Snowflake</span> <span class="variable">snowflake</span> <span class="operator">=</span> IdUtil.createSnowflake(workerId, datacenterId);</span><br><span class="line"><span class="keyword">return</span> snowflake.nextId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">IdGeneratorSnowflake</span> <span class="variable">idGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGeneratorSnowflake</span>();</span><br><span class="line">System.out.println(idGenerator.snowflakeId());</span><br><span class="line">        </span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line">threadPool.submit(() -&gt; &#123;</span><br><span class="line">System.out.print1n(idGenerator.snowflakeId());</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p>优点：</p><p>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</p><p>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</p><p>可以根据自身业务特性分配bit位，非常灵活。</p><p>缺点：</p><p>依赖机器时钟，如果机器时钟回拨，会导致重复ID生成。</p><p>在单机上是递增的，但是由于设计到分布式环境，每台机器上的时钟不可能完全同步，有时候会出现不是全局递增的情况。</p><p>（此缺点可以认为无所谓，一般分布式ID只要求趋势递增，并不会严格要求递增，90%的需求都只要求趋势递增）</p><p><strong>其他补充</strong></p><p>百度开源的分布式唯一ID生成器UidGenerator</p><p>美团点评分布式ID生成系统Leaf</p><h2 id="Spring-Cloud组件总结"><a href="#Spring-Cloud组件总结" class="headerlink" title="Spring Cloud组件总结"></a>Spring Cloud组件总结</h2><table><thead><tr><th>组件</th><th>简介</th><th>分类</th><th>官网</th></tr></thead><tbody><tr><td>Eureka</td><td>Eureka is the Netflix Service Discovery Server and Client.</td><td>服务注册中心</td><td><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.7.RELEASE/reference/html/#service-discovery-eureka-clients">link</a></td></tr><tr><td>Zookeeper</td><td>ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services.</td><td>服务注册中心</td><td><a href="https://zookeeper.apache.org/">link</a></td></tr><tr><td>Consul</td><td>Consul is a service mesh solution providing a full featured control plane with service discovery, configuration, and segmentation functionality.</td><td>服务注册中心</td><td><a href="https://www.consul.io/">link</a></td></tr><tr><td>Ribbon</td><td>Ribbon is a client-side load balancer that gives you a lot of control over the behavior of HTTP and TCP clients.</td><td>服务调用</td><td><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.7.RELEASE/reference/html/#spring-cloud-ribbon">link</a></td></tr><tr><td>OpenFeign</td><td>Feign is a declarative web service client. It makes writing web service clients easier.</td><td>服务调用</td><td><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.7.RELEASE/reference/html/">link</a></td></tr><tr><td>Hystrix</td><td>Netflix has created a library called Hystrix that implements the circuit breaker pattern.</td><td>服务降级</td><td><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.7.RELEASE/reference/html/#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix">link</a></td></tr><tr><td>GateWay</td><td>Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring&#x2F;metrics, and resiliency.</td><td>服务网关</td><td><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.7.RELEASE/reference/html/">link</a></td></tr><tr><td>Config</td><td>Spring Cloud Config provides server-side and client-side support for externalized configuration in a distributed system.</td><td>服务配置</td><td><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.7.RELEASE/reference/html/">link</a></td></tr><tr><td>Bus</td><td>Spring Cloud Bus links nodes of a distributed system with a lightweight message broker.</td><td>服务总线</td><td><a href="https://docs.spring.io/spring-cloud-bus/docs/2.2.3.RELEASE/reference/html/">link</a></td></tr><tr><td>Stream</td><td>Spring Cloud Stream is a framework for building message-driven microservice applications.</td><td>消息驱动</td><td><a href="https://docs.spring.io/spring-cloud-stream/docs/3.0.10.RELEASE/reference/html/spring-cloud-stream.html#spring-cloud-stream-overview-introducing">link</a></td></tr><tr><td>Sleuth</td><td>Spring Cloud Sleuth implements a distributed tracing solution for Spring Cloud.</td><td>服务跟踪</td><td><a href="https://docs.spring.io/spring-cloud-sleuth/docs/2.2.7.RELEASE/reference/html/">link</a></td></tr><tr><td>Nacos</td><td>Nacos致力于帮助您发现、配置和管理微服务。</td><td>服务注册中心、服务配置、服务总线</td><td><a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">link</a></td></tr><tr><td>Sentinel</td><td>Sentinel是面向分布式服务架构的流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助您保障微服务的稳定性。</td><td>服务降级</td><td><a href="https://sentinelguard.io/zh-cn/docs/introduction.html">link</a></td></tr><tr><td>Seata</td><td>Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</td><td>分布式事务</td><td><a href="https://seata.io/zh-cn/">link</a></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2022/04/03/RabbitMQ/"/>
      <url>/2022/04/03/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="MQ-的相关概念"><a href="#MQ-的相关概念" class="headerlink" title="MQ 的相关概念"></a>MQ 的相关概念</h3><h4 id="什么是-MQ"><a href="#什么是-MQ" class="headerlink" title="什么是 MQ"></a>什么是 MQ</h4><p>MQ (message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦 + 物理解耦” 的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p><h4 id="为什么要用-MQ"><a href="#为什么要用-MQ" class="headerlink" title="为什么要用 MQ"></a>为什么要用 MQ</h4><h5 id="流量消峰"><a href="#流量消峰" class="headerlink" title="流量消峰"></a>流量消峰</h5><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p><h5 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h5><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/image.1ddl4r0fiusg.webp" alt="image"></p><h5 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h5><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。</p><p>以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。</p><p>使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作，A 服务还能及时的得到异步处理成功的消息。</p><p><img src="/2022/04/03/RabbitMQ/1661862780613.png" alt="1661862780613"></p><h4 id="MQ的分类"><a href="#MQ的分类" class="headerlink" title="MQ的分类"></a>MQ的分类</h4><ul><li><p><strong>ActiveMQ</strong></p><p>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据（很少丢失消息）。</p><p>缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</p></li><li><p><strong>Kafka</strong></p><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<strong>大数据而生</strong>的消息中间件，以其<strong>百万级 TPS 的吞吐量</strong>名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber，Twitter，Netflix 等大公司所采纳。</p><p>优点: 性能卓越，单机写入 TPS 约在百万条&#x2F;秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次；有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能 较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。</p><p>缺点：Kafka 单机超过 64 个队列&#x2F;分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢。</p></li><li><p><strong>RocketMQ</strong></p><p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p><p>优点：<strong>单机吞吐量十万级，可用性非常高</strong>，分布式架构,<strong>消息可以做到 0 丢失</strong>,MQ 功能较为完善，还是分布式的，扩展性好,<strong>支持 10 亿级别的消息堆积</strong>，不会因为堆积导致性能下降，源码是 java 我们可以自己阅读源码，定制自己公司的 MQ。</p><p>缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟；社区活跃度一般,没有在 MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码。</p></li><li><p><strong>RabbitMQ</strong></p><p>2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p><p>优点：由于 erlang 语言的<strong>高并发特性</strong>，性能较好；<strong>吞吐量到万级</strong>，MQ 功能比较完备,健壮、稳定、易用、跨平台、<strong>支持多种语言</strong> 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高。<a href="https://www.rabbitmq.com/news.html">官网</a></p><p>缺点：商业版需要收费,学习成本较高。</p></li></ul><h4 id="MQ的选择"><a href="#MQ的选择" class="headerlink" title="MQ的选择"></a>MQ的选择</h4><ul><li><p><strong>Kafka</strong></p><p>Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，<strong>适合产生大量数据</strong>的互联网服务的数据收集业务。<strong>大型公司</strong>建议可以选用，如果有<strong>日志采集</strong>功能，肯定是首选 kafka 了。</p></li><li><p><strong>RocketMQ</strong></p><p>天生为<strong>金融互联网</strong>领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p></li><li><p><strong>RabbitMQ</strong></p><p>结合 erlang 语言本身的并发优势，性能好<strong>时效性微秒级，社区活跃度也比较高</strong>，管理界面用起来十分 方便，如果你的<strong>数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ。</p></li></ul><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="RabbitMQ的概念"><a href="#RabbitMQ的概念" class="headerlink" title="RabbitMQ的概念"></a>RabbitMQ的概念</h4><p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p><h4 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h4><ul><li>生产者：产生数据发送消息的程序</li><li>交换机：是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息<strong>推送到特定队列还是推送到多个队列</strong>，亦或者是把消息丢弃，这个得有交换机类型决定</li><li>队列：是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</li><li>消费者：消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</li></ul><h4 id="RabbitMQ核心部分"><a href="#RabbitMQ核心部分" class="headerlink" title="RabbitMQ核心部分"></a>RabbitMQ核心部分</h4><ol><li>简单模式</li><li>工作模式</li><li>发布&#x2F;订阅模式</li><li>路由模式</li><li>主题模式</li><li>发布确认模式</li></ol><p><img src="/2022/04/03/RabbitMQ/1661864017086.png" alt="1661864017086"></p><h4 id="各个名词介绍"><a href="#各个名词介绍" class="headerlink" title="各个名词介绍"></a>各个名词介绍</h4><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/image.15tq7c46aeyk.webp" alt="image"></p><ul><li><code>Producer</code>：生产者</li><li><code>Consumer</code>：消费者</li><li><code>Broker</code>：消息实体，接收和分发消息的应用，RabbitMQ Server 就是 Message Broker。</li><li><code>Virtual host</code>：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，就是在同一个消息实体，<strong>可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</strong>。</li><li><code>Connection</code>：publisher／consumer 和 broker 之间的 TCP 连接。</li><li><code>Channel</code>：信道（发消息的通道），如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销。</strong></li><li><code>Exchange</code>：交换机，message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point)，topic (publish-subscribe) and fanout (multicast)。</li><li><code>Queue</code>：队列，消息最终被送到这里等待 consumer 取走。</li><li><code>Binding</code>：绑定，<strong>exchange 和 queue 之间的虚拟连接</strong>，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据。</li></ul><h4 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h4><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p><a href="https://github.com/rabbitmq/rabbitmq-server/releases">RabbitMQ最新版下载地址</a></p><p>选择以 <code>noarch.rpm</code> 结尾的安装包</p><p><img src="/2022/04/03/RabbitMQ/1661865027511.png" alt="1661865027511"></p><p>RabbitMQ 是采用 Erlang 语言开发的，所以系统环境必须提供 Erlang 环境，需要先安装 Erlang。</p><p><code>Erlang</code> 和 <code>RabbitMQ</code> 版本对照：<a href="https://www.rabbitmq.com/which-erlang.html">点击跳转</a></p><p>这里安装的是 3.8.8 版本的 RabbitMQ，需要的 Erlang 版本依然是21.3。</p><p><a href="https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.16-1.el7.x86_64.rpm">Erlang 21.3下载地址</a></p><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/image.44zjpnbpbyo0.webp" alt="image"></p><blockquote><p>版本选择</p><p>CentOs 7.x 版本需要e17。</p><p>CentOs 8.x 版本需要e18。包括 Red Hat 8,modern Fedora 版本。</p></blockquote><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p><img src="/2022/04/03/RabbitMQ/1661867221067.png" alt="1661867221067"></p><p>上传到 &#x2F;usr&#x2F;local&#x2F;rabbitmq目录下 (如果没有 rabbitmq需要自己创建)（windows上传路径为英文比较好）</p><p><img src="/2022/04/03/RabbitMQ/1661867287795.png" alt="1661867287795"></p><p>安装Erlang</p><p>进入 <code>/usr/local/rabbitmq</code> 目录，解压安装 Erlang</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/rabbitmq</span><br><span class="line">rpm -ivh erlang-21.3-1.el7.x86_64.rpm</span><br><span class="line">######################################</span><br><span class="line">i 代表 install</span><br><span class="line">vh 代表显示安装进度过程</span><br></pre></td></tr></table></figure><p><img src="/2022/04/03/RabbitMQ/1661867710712.png" alt="1661867710712"></p><p> 安装RabbitMQ</p><p>在 <code>RabiitMQ</code> 安装过程中需要依赖 <code>socat</code> 插件，首先安装该插件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install socat -y</span><br></pre></td></tr></table></figure><p>解压 <code>RabbitMQ</code> 安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p><img src="/2022/04/03/RabbitMQ/1661867899782.png" alt="1661867899782"></p><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动服务</span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line"># 查看服务状态</span><br><span class="line">systemctl status rabbitmq-server</span><br><span class="line"># 开机自启动</span><br><span class="line">systemctl enable rabbitmq-server</span><br><span class="line"># 停止服务</span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line"># 重启服务</span><br><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><p>启动 <code>RabbitMQ</code> 服务后，查看该服务状态，显示绿色的 <code>active</code> 则表示服务安装并启动成功。</p><p><img src="/2022/04/03/RabbitMQ/1661868173122.png" alt="1661868173122"></p><h5 id="管理界面及授权操作"><a href="#管理界面及授权操作" class="headerlink" title="管理界面及授权操作"></a>管理界面及授权操作</h5><blockquote><p>默认端口</p><p>RabbitMQ 的默认访问端口是 15672</p><p>如果 Linux 有防火墙，记得开放 15672 端口，否则 Windows 无法访问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看防火墙状态</span><br><span class="line">systemctl status firewalld</span><br><span class="line">#关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">#下次启动自动关闭</span><br><span class="line">systemctl enable firewalld</span><br></pre></td></tr></table></figure></blockquote><p>先关闭rabbitmq服务在安装——systemctl stop rabbitmq-server</p><p>默认情况下，RabbiMQ 没有安装 Web 端的客户端软件，需要安装才可以生效。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p>安装完毕以后，启动服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start rabbitmq-server</span><br></pre></td></tr></table></figure><p>通过 <code>http://ip:15672</code> 访问，ip 为 Linux 的 ip，(<a href="http://192.168.182.128:15672/)%EF%BC%8C%60rabbitmq%60">http://192.168.182.128:15672/)，`rabbitmq`</a> 有一个默认的账号密码 <code>guest</code>，但是登录该账号密码会出现权限问题。默认情况只能在 localhost 本机下访问，所以需要添加一个远程登录的用户。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建账号和密码</span><br><span class="line">rabbitmqctl add_user admin 123456</span><br><span class="line"></span><br><span class="line"># 设置用户角色</span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"></span><br><span class="line"># 为用户添加资源权限，添加配置、写、读权限</span><br><span class="line"># set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">#当前用户和角色</span><br><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure><p>角色固定有四种级别：</p><ul><li><code>administrator</code>：可以登录控制台、查看所有信息、并对rabbitmq进行管理</li><li><code>monToring</code>：监控者；登录控制台，查看所有信息</li><li><code>policymaker</code>：策略制定者；登录控制台指定策略</li><li><code>managment</code>：普通管理员；登录控制</li></ul><p>添加用户和权限后，再次访问 <code>http://ip:15672</code> 登录，输入添加好的用户名和密码，即可进入后台(<a href="http://192.168.182.128:15672/">http://192.168.182.128:15672/</a>)</p><p><img src="/2022/04/03/RabbitMQ/1661868976660.png" alt="1661868976660"></p><p>其他命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#关闭应用的命令</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">#清除的命令</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">#重新启动命令</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"># 修改密码</span><br><span class="line">rabbitmqctl change_ password 用户名 新密码</span><br><span class="line"># 删除用户</span><br><span class="line">rabbitmqctl delete_user 用户名</span><br></pre></td></tr></table></figure><h2 id="Hello-RabbitMQ"><a href="#Hello-RabbitMQ" class="headerlink" title="Hello RabbitMQ"></a>Hello RabbitMQ</h2><p>用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者</p><p>在下图中，“ P” 是我们的生产者，“ C” 是我们的消费者。中间的框是一个队列 RabbitMQ 代表使用者保留的消息缓冲区</p><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/image.53zsdpm4hbk0.webp" alt="image"></p><blockquote><p>注意</p><p>Java 进行连接的时候，需要 Linux 开放 5672 端口，否则会连接超时</p><p>访问 Web 界面的端口是 15672，连接服务器的端口是 5672</p></blockquote><p>步骤图：</p><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/image.5zalz3u39nk0.webp" alt="image"></p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>先创建好 Maven 工程，pom.xml 添入依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--rabbitmq 依赖客户端--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">5.8</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--操作文件流的一个依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.6</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--指定 jdk 编译版本--&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;source&gt;<span class="number">8</span>&lt;/source&gt;</span><br><span class="line">                &lt;target&gt;<span class="number">8</span>&lt;/target&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><p>创建一个类作为生产者，最终生产消息到 RabbitMQ 的队列里</p><p>步骤：</p><ol><li>创建 RabbitMQ 连接工厂</li><li>进行 RabbitMQ 工厂配置信息</li><li>创建 RabbitMQ 连接</li><li>创建 RabbitMQ 信道</li><li>生成一个队列</li><li>发送一个消息到交换机，交换机发送到队列。”” 代表默认交换机</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/8/31 21:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//工厂IP 连接RabbitMQ的队列</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.182.128&quot;</span>);</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.队列名称</span></span><br><span class="line"><span class="comment">         *  2.队列里面的消息是否持久化（存储在磁盘中持久化），默认情况消息存储在内存中（非持久化false）</span></span><br><span class="line"><span class="comment">         *  3.该队列是否只供一个消费者进行消费，是否进行消息共享，true可以多个消费者消费，默认为false</span></span><br><span class="line"><span class="comment">         *  4.是否自动删除，最后一个消费者断开连接后，是否自动删除，true自动删除，false不自动删除</span></span><br><span class="line"><span class="comment">         *  5.其他参数</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消息</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.发送到那个交换机</span></span><br><span class="line"><span class="comment">         *  2.路由的Key值（本次是队列的名称）</span></span><br><span class="line"><span class="comment">         *  3.其他参数</span></span><br><span class="line"><span class="comment">         *  4.发送消息的消息体</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        System.out.printf(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><p><img src="/2022/04/03/RabbitMQ/1661955780328.png" alt="1661955780328"></p><p><img src="/2022/04/03/RabbitMQ/1661955750218.png" alt="1661955750218"></p><h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>创建一个类作为消费者，消费 RabbitMQ 队列的消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/8/31 22:26</span></span><br><span class="line"><span class="comment"> * 消息消费者    接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称 接收此队列的消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.182.128&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者消费消息</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.消费哪个队列</span></span><br><span class="line"><span class="comment">         *  2.消费成功之后是否要自动应答， false代表手动应答</span></span><br><span class="line"><span class="comment">         *  3.当一个消息发送过来后的回调接口</span></span><br><span class="line"><span class="comment">         *  4.当一个消费者取消订阅时的回调接口，消费者取消消费的回调</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//接收消息成功的回调</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag,message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息接收失败的回调</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">false</span>,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><p><img src="/2022/04/03/RabbitMQ/1661957754113.png" alt="1661957754113"></p><p>值得一提的是，<code>basicConsume</code> 的参数中，第三个和第四个参数都是接口，所以需要实现该接口的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicConsume(队列名字/String, 是否自动签收/<span class="type">boolean</span>, 消费时的回调/接口类, 无法消费的回调/接口类);</span><br></pre></td></tr></table></figure><h2 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h2><p>Work Queues 是工作队列（又称任务队列）的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程（消费者）时，这些<strong>工作线程将一起处理这些任务</strong>。</p><h3 id="轮询消费"><a href="#轮询消费" class="headerlink" title="轮询消费"></a>轮询消费</h3><p>轮询消费消息指的是轮流消费消息，即每个工作队列都会获取一个消息进行消费，并且获取的次数按照顺序依次往下轮流。</p><p>案例中生产者叫做 Task，一个消费者就是一个工作队列，启动两个工作队列消费消息，这个两个工作队列会以轮询的方式消费消息。</p><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/image.3iwquz975vw0.webp" alt="image"></p><h3 id="轮询案例"><a href="#轮询案例" class="headerlink" title="轮询案例"></a>轮询案例</h3><ul><li>首先把 RabbitMQ 的配置参数封装为一个工具类：<code>RabbitMQUtils</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 20:02</span></span><br><span class="line"><span class="comment"> * rabbitmq连接工厂创建信道的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;19.168.182.128&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建两个工作队列，并且启动</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.two;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.utils.RabbitMQUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Delivery;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 20:11</span></span><br><span class="line"><span class="comment"> * 这是一个工作线程，相当于消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;</span><br><span class="line">    <span class="comment">//队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息的接收成功执行</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息接收失败执行</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息者取消消费消息回调逻辑：&quot;</span>+consumerTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;C1等待接收消息......&quot;</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建好一个工作队列，只需要以多线程方式启动两次该 main 函数即可，以 first、second 区别消息队列。</p><p>要开启多线程功能，首先启动该消息队列，然后如图开启多线程：</p><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/1658588553672.629xpapm6wg0.webp" alt="1658588553672"></p><p>两次main启动之后：</p><p><img src="/2022/04/03/RabbitMQ/1662037029891.png" alt="1662037029891"></p><ul><li>创建一个生产者，发送消息进程</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.two;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.utils.RabbitMQUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 20:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task01</span>&#123;</span><br><span class="line">    <span class="comment">//队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//队列的声明</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从控制台接收消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,next.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息成功：&quot;</span>+next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果演示</li></ul><p>通过程序执行发现生产者总共发送 4 个消息，消费者 first 和消费者 second 分别分得两个消息，并且是按照有序的一个接收一次消息</p><p><img src="/2022/04/03/RabbitMQ/1662037164828.png" alt="1662037164828"></p><h3 id="Web页面添加队列"><a href="#Web页面添加队列" class="headerlink" title="Web页面添加队列"></a>Web页面添加队列</h3><p>进入自己的 RabbitMQ Web 页面，点击 Queues 菜单</p><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/image.701dj3uqk400.webp" alt="image"></p><ol><li>点击 <code>Queues</code> 菜单</li><li>点击 <code>Add a new queue</code>，弹出下拉菜单</li><li>下方的很多参数可以进行选择（旁边有 ？的参数），如优先级（<code>Lazy mode</code>）、绑定死信队列（<code>Dead letter exchange/routing key</code>）</li><li>执行步骤 3 后，在 <code>Arguments</code> 的第一个文本框弹出对应的参数，类似于 Map 的 key</li><li>第二个文本框填写参数，类似于 Map 的 value</li><li>第三个是下拉菜单，选择 value 类型</li><li>点击 <code>Add queue</code>，添加队列</li></ol><p>旁边有 ？的参数，就是 <code>channel.queueDeclare(队列名/String, 持久化/boolean, 共享消费/boolean, 自动删除/boolean, 配置参数/Map);</code> 或者 <code>channel.basicPublish(交换机名/String, 队列名/String, 配置参数/Map, 消息/String);</code> 的参数：配置参数&#x2F;Map 的 key</p><h3 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h3><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ <strong>一旦向消费者传递了一条消息，便立即将该消息标记为删除</strong>。在这种情况下，突然有个消费者挂掉了，我们将<strong>丢失正在处理的消息</strong>。以及后续发送给该消费者的消息，因为它无法接收到。</p><p>为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：<strong>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong></p><h4 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h4><p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，<strong>所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。</strong></p><h4 id="手动消息应答的方法"><a href="#手动消息应答的方法" class="headerlink" title="手动消息应答的方法"></a>手动消息应答的方法</h4><ul><li><code>Channel.basicAck</code> (肯定确认应答)：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">basicAck(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple);</span><br></pre></td></tr></table></figure><p>第一个参数是消息的标记，第二个参数表示是否应用于多消息，RabbitMQ 已知道该消息被处理并且成功的处理消息，可以将其丢弃了</p><ul><li><code>Channel.basicReject</code> (否定确认应答)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">basicReject(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> requeue);</span><br></pre></td></tr></table></figure><p>第一个参数表示拒绝 <code>deliveryTag</code> 对应的消息，第二个参数表示是否 <code>requeue</code>：true 则重新入队列，false 则丢弃或者进入死信队列。</p><p>该方法 reject 后，该消费者还是会消费到该条被 reject 的消息。</p><ul><li><code>Channel.basicNack</code> (用于否定确认)：示己拒绝处理该消息，可以将其丢弃了</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">basicNack(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple, <span class="type">boolean</span> requeue);</span><br></pre></td></tr></table></figure><p>第一个参数表示拒绝 <code>deliveryTag</code> 对应的消息，第二个参数是表示否应用于多消息，第三个参数表示是否 <code>requeue</code>，与 basicReject 区别就是同时支持多个消息，可以 拒绝签收 该消费者先前接收未 ack 的所有消息。拒绝签收后的消息也会被自己消费到。</p><ul><li><code>Channel.basicRecover</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">basicRecover(<span class="type">boolean</span> requeue);</span><br></pre></td></tr></table></figure><p>是否恢复消息到队列，参数是是否 <code>requeue</code>，true 则重新入队列，并且尽可能的将之前 <code>recover</code> 的消息投递给其他消费者消费，而不是自己再次消费。false 则消息会重新被投递给自己。</p><p><strong>Multiple 的解释：</strong></p><p>手动应答的好处是可以批量应答并且减少网络拥堵</p><ul><li><p>true 代表批量应答 channel 上未应答的消息（批量应答可能丢失消息）</p><p>比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答</p></li><li><p>false 同上面相比只会应答 tag&#x3D;8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</p></li></ul><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220724/image.3vspi8fu4v20.webp" alt="image"></p><h4 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h4><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220724/image.4hplocbhsdk0.webp" alt="image"></p><h4 id="手动应答案例"><a href="#手动应答案例" class="headerlink" title="手动应答案例"></a>手动应答案例</h4><p>默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答。</p><p>消费者启用两个线程，消费 1 一秒消费一个消息，消费者 2 十秒消费一个消息，然后在消费者 2 消费消息的时候，停止运行，这时正在消费的消息是否会重新进入队列，而后给消费者 1 消费呢？</p><ul><li>工具类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> second)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>*second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>消息生产者</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.utils.RabbitMQUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 21:41</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从控制台输入消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME,<span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发送消息：&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>消费者 1</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.utils.RabbitMQUtils;</span><br><span class="line"><span class="keyword">import</span> com.hua.study.utils.SleepUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 21:49</span></span><br><span class="line"><span class="comment"> * 消息在手动应答时不丢失，并且放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1等待接收消息，处理时间较短&quot;</span>);</span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">//沉睡1秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 手动应答</span></span><br><span class="line"><span class="comment">             * params:</span></span><br><span class="line"><span class="comment">             *  1.消息的标记 表示应答的是哪个消息</span></span><br><span class="line"><span class="comment">             *  2.是否批量应答 false:不批量应答信道中的消息</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者取消消费回调：&quot;</span>+consumerTag);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>消费者 2</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.utils.RabbitMQUtils;</span><br><span class="line"><span class="keyword">import</span> com.hua.study.utils.SleepUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 21:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker02</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C2等待接收消息，处理时间较长&quot;</span>);</span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">//沉睡1秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 手动应答</span></span><br><span class="line"><span class="comment">             * params:</span></span><br><span class="line"><span class="comment">             *  1.消息的标记 表示应答的是哪个消息</span></span><br><span class="line"><span class="comment">             *  2.是否批量应答 false:不批量应答信道中的消息</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者取消消费回调：&quot;</span>+consumerTag);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 效果演示</p><p>正常情况下消息生产者发送两个消息， first 和 second 分别接收到消息并进行处理</p><p><img src="/2022/04/03/RabbitMQ/1662042056767.png" alt="1662042056767"></p><p>当发送者发送消息 DD 到队列，此时是 second 来消费该消息，但是由于它处理时间较长，在还未处理完时间里停止运行，也就是说 second 还没有执行到 ack 代码的时候，second 被停掉了，此时会看到消息被 first 接收到了，说明消息 DD 被重新入队，然后分配给能处理消息的 first 处理了</p><p><img src="/2022/04/03/RabbitMQ/1662042127268.png" alt="1662042127268"></p><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220724/image.3mng0kiqphi0.webp" alt="image"></p><h4 id="RabbitMQ-持久化"><a href="#RabbitMQ-持久化" class="headerlink" title="RabbitMQ 持久化"></a>RabbitMQ 持久化</h4><p>当 RabbitMQ 服务停掉以后，让消息生产者发送过来的消息不丢失，要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它会忽视队列和消息（丢失掉），除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化。</strong></p><h5 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h5><p>之前我们创建的队列都是非持久化的，RabbitMQ 如果重启的话，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为true，代表开启持久化</p><p>在<strong>消息生产者</strong>开启持久化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 21:41</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        <span class="comment">//是否队列持久化</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME,durable,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从控制台输入消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="comment">//设置生产者发送消息为持久化消息（保存在磁盘上）MessageProperties.PERSISTENT_TEXT_PLAIN</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发送消息：&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列</p></blockquote><p>不然就会出现如下错误：</p><p><img src="/2022/04/03/RabbitMQ/image.4nf70nwh0j60.webp" alt="image"></p><p>队列持久化的显示结果：</p><p><img src="/2022/04/03/RabbitMQ/image.5tlb9m3bfh00.webp" alt="image"></p><h5 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h5><p>需要在<strong>消息生产者</strong>发布消息的时候，开启消息的持久化</p><p>在 basicPublish 方法的第二个参数添加这个属性： <code>MessageProperties.PERSISTENT_TEXT_PLAIN</code></p><p><img src="/2022/04/03/RabbitMQ/image-20220904173448701.png" alt="image-20220904173448701"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 21:41</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        <span class="comment">//是否队列持久化</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME,durable,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从控制台输入消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="comment">//设置生产者发送消息为持久化消息（保存在磁盘上）MessageProperties.PERSISTENT_TEXT_PLAIN</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发送消息：&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 ，但还没有存储完，消息还在缓存的一个间隔点，此时并没 有真正写入磁盘，如果此时RabbitMQ或者消息发送者宕掉，也可能造成消息丢失。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p><h5 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h5><p><strong>介绍</strong></p><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个<strong>消费者 1</strong> 处理任务的速度非常快，而另外一个<strong>消费者 2</strong> 处理速度却很慢，这个时候我们还是采用轮询分发的话，这个处理速度快的消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况，它依然很公平的进行分发。</p><p>为了避免这种情况，<strong>在消费者中消费消息之前</strong>（每个消费者都要设置），设置参数 <code>channel.basicQos(1);</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 21:49</span></span><br><span class="line"><span class="comment"> * 消息在手动应答时不丢失，并且放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1等待接收消息，处理时间较短&quot;</span>);</span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">//沉睡1秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 手动应答</span></span><br><span class="line"><span class="comment">             * params:</span></span><br><span class="line"><span class="comment">             *  1.消息的标记 表示应答的是哪个消息</span></span><br><span class="line"><span class="comment">             *  2.是否批量应答 false:不批量应答信道中的消息</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//设置不公平分发(默认为0:公平分发 1:不公平分发 其他的为预取值如2，3，4...)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        channel.basicQos(prefetchCount);</span><br><span class="line">        <span class="comment">//手动应答</span></span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者取消消费回调：&quot;</span>+consumerTag);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启成功，会看到如下结果：</p><p><img src="/2022/04/03/RabbitMQ/image.lhxynhnktlc.webp" alt="image"></p><p>不公平分发思想：如果一个工作队列还没有处理完或者没有应答签收一个消息，则拒绝 RabbitMQ 分配新的消息到该工作队列。此时 RabbitMQ 会优先分配给其他已经处理完消息或者空闲的工作队列。如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker (工作队列)或者改变其他存储任务的策略。</p><p><strong>效果演示</strong></p><p>生产者生产多个消息，两个消费者的消费时间不同，则消费消息的次数也不同</p><p><img src="/2022/04/03/RabbitMQ/image-20220904174604270.png" alt="image-20220904174604270"></p><h5 id="预取值分发"><a href="#预取值分发" class="headerlink" title="预取值分发"></a>预取值分发</h5><p><strong>介绍</strong></p><p>带权的消息分发</p><p>默认消息的发送是异步发送的，所以在任何时候，channel 上不止只有一个消息来自消费者的手动确认，所以本质上是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小</strong>，<strong>以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过使用 <code>basic.qos</code> 方法设置「预取计数」值来完成的。</p><p>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。</p><p>通常，增加预取将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p><p>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p><p><img src="/2022/04/03/RabbitMQ/image.2anljpf3y134.webp" alt="image"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 21:49</span></span><br><span class="line"><span class="comment"> * 消息在手动应答时不丢失，并且放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1等待接收消息，处理时间较短&quot;</span>);</span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">//沉睡1秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 手动应答</span></span><br><span class="line"><span class="comment">             * params:</span></span><br><span class="line"><span class="comment">             *  1.消息的标记 表示应答的是哪个消息</span></span><br><span class="line"><span class="comment">             *  2.是否批量应答 false:不批量应答信道中的消息</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//设置不公平分发(默认为0:公平分发 1:不公平分发 其他的为预取值如2，3，4...)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        channel.basicQos(prefetchCount);</span><br><span class="line">        <span class="comment">//手动应答</span></span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者取消消费回调：&quot;</span>+consumerTag);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>笔记</p><p>不公平分发和预取值分发都用到 <code>basic.qos</code> 方法，如果取值为0(默认)，公平分发，取值为 1，代表不公平分发，取值不为1，代表预取值分发</p></blockquote><p><strong>效果演示</strong></p><p><img src="/2022/04/03/RabbitMQ/image-20220904175606886.png" alt="image-20220904175606886"></p><p>worker2预设值为5，信道中存在5条消息，worker1不在接收，消息全在worker2信道当中</p><p><img src="/2022/04/03/RabbitMQ/image-20220904175553228.png" alt="image-20220904175553228"></p><p>worker2接收消息接收为5条,worker1不变</p><p><img src="/2022/04/03/RabbitMQ/image-20220904175714414.png" alt="image-20220904175714414"></p><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>​生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会 发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了， 如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产 者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>​ confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道 返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方 法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><p><strong>确认发布指的是成功发送到了队列，并不是消费者消费了消息</strong></p><h3 id="发布确认的策略"><a href="#发布确认的策略" class="headerlink" title="发布确认的策略"></a><strong>发布确认的策略</strong></h3><h4 id="开启发布确认的方法"><a href="#开启发布确认的方法" class="headerlink" title="开启发布确认的方法"></a>开启发布确认的方法</h4><p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure><h4 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h4><p>这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，<code>waitForConfirmsOrDie(long)</code> 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p><p>这种确认方式有一个最大的缺点就是：<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/5 19:58</span></span><br><span class="line"><span class="comment"> * 发布确认模式：</span></span><br><span class="line"><span class="comment"> *  1.单个确认</span></span><br><span class="line"><span class="comment"> *  2.批量确认</span></span><br><span class="line"><span class="comment"> *  3.异步批量确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量发消息的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_COUNT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//单个确认</span></span><br><span class="line">        publishMessageIndividually();<span class="comment">//发布1000个单个确认消息，耗时：617ms</span></span><br><span class="line">        <span class="comment">//批量确认</span></span><br><span class="line">        <span class="comment">//publishMessageBatch();//发布1000个批量确认消息，耗时：127ms</span></span><br><span class="line">        <span class="comment">//异步批量确认</span></span><br><span class="line">        <span class="comment">//publishMessageAsync();//发布1000个异步发布确认消息，耗时：17ms</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个发布确认</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageIndividually</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//队列的声明</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量发送消息——单个发布确认</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            <span class="comment">//发布确认</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span>+ MESSAGE_COUNT + <span class="string">&quot;个单个确认消息，耗时：&quot;</span>+ (end-begin)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h4><p>单个确认发布方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/5 19:58</span></span><br><span class="line"><span class="comment"> * 发布确认模式：</span></span><br><span class="line"><span class="comment"> *  1.单个确认</span></span><br><span class="line"><span class="comment"> *  2.批量确认</span></span><br><span class="line"><span class="comment"> *  3.异步批量确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量发消息的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_COUNT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//单个确认</span></span><br><span class="line">        <span class="comment">//publishMessageIndividually();//发布1000个单个确认消息，耗时：617ms</span></span><br><span class="line">        <span class="comment">//批量确认</span></span><br><span class="line">        publishMessageBatch();<span class="comment">//发布1000个批量确认消息，耗时：127ms</span></span><br><span class="line">        <span class="comment">//异步批量确认</span></span><br><span class="line">        <span class="comment">//publishMessageAsync();//发布1000个异步发布确认消息，耗时：17ms</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量发布确认</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量确认个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//批量发布消息——批量发布确认</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            <span class="comment">//达到100条时批量确认一次</span></span><br><span class="line">            <span class="keyword">if</span> ((i+<span class="number">1</span>)%batchSize == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//发布确认</span></span><br><span class="line">                channel.waitForConfirms();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span>+ MESSAGE_COUNT + <span class="string">&quot;个批量确认消息，耗时：&quot;</span>+ (end-begin)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h4><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都很好，利用了回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功，下面详细讲解异步确认是怎么实现的。</p><p><img src="/2022/04/03/RabbitMQ/image.73gul8cwoq00.webp" alt="image"></p><p>添加回调函数，在回调函数里进行确认发布。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/5 19:58</span></span><br><span class="line"><span class="comment"> * 发布确认模式：</span></span><br><span class="line"><span class="comment"> *  1.单个确认</span></span><br><span class="line"><span class="comment"> *  2.批量确认</span></span><br><span class="line"><span class="comment"> *  3.异步批量确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量发消息的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_COUNT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//单个确认</span></span><br><span class="line">        <span class="comment">//publishMessageIndividually();//发布1000个单个确认消息，耗时：617ms</span></span><br><span class="line">        <span class="comment">//批量确认</span></span><br><span class="line">        <span class="comment">//publishMessageBatch();//发布1000个批量确认消息，耗时：127ms</span></span><br><span class="line">        <span class="comment">//异步批量确认</span></span><br><span class="line">        publishMessageAsync();<span class="comment">//发布1000个异步发布确认消息，耗时：17ms</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步发布确认</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//队列的声明</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息确认成功 回调失败</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.消息的标记</span></span><br><span class="line"><span class="comment">         *  2.是否为批量确认</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span>  ( deliveryTag,  multiple) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认的消息：&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息确认失败 回调失败</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.消息的标记</span></span><br><span class="line"><span class="comment">         *  2.是否为批量确认</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> ( deliveryTag,  multiple) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息：&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息的监听器 监听哪些消息成功，哪些消息失败</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.监听哪些消息成功了</span></span><br><span class="line"><span class="comment">         *  2.监听哪些消息失败了</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        channel.addConfirmListener(ackCallback,nackCallback);</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量发布消息——异步确认发布</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span>+ MESSAGE_COUNT + <span class="string">&quot;个异步发布确认消息，耗时：&quot;</span>+ (end-begin)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际案例里，将发布的消息存入 Map 里，方便获取。<code>headMap</code> 方法用于将已确认的消息存入新的 Map 缓存区里，然后清除该新缓存区的内容。因为 <code>headMap</code> 方法是浅拷贝，所以清除了缓存区，相当于清除了内容的地址，也就清除了队列的确认的消息。</p><h4 id="如何处理异步未确认消息"><a href="#如何处理异步未确认消息" class="headerlink" title="如何处理异步未确认消息?"></a><strong>如何处理异步未确认消息?</strong></h4><p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 <code>ConcurrentLinkedQueue</code> 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/5 19:58</span></span><br><span class="line"><span class="comment"> * 发布确认模式：</span></span><br><span class="line"><span class="comment"> *  1.单个确认</span></span><br><span class="line"><span class="comment"> *  2.批量确认</span></span><br><span class="line"><span class="comment"> *  3.异步批量确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量发消息的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_COUNT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//单个确认</span></span><br><span class="line">        <span class="comment">//publishMessageIndividually();//发布1000个单个确认消息，耗时：617ms</span></span><br><span class="line">        <span class="comment">//批量确认</span></span><br><span class="line">        <span class="comment">//publishMessageBatch();//发布1000个批量确认消息，耗时：127ms</span></span><br><span class="line">        <span class="comment">//异步批量确认</span></span><br><span class="line">        publishMessageAsync();<span class="comment">//发布1000个异步发布确认消息，耗时：17ms</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步发布确认</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//队列的声明</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程安全有序的一个哈希表 适用于高并发情况</span></span><br><span class="line"><span class="comment">         * 1.可以轻松的将序号和消息进行关联</span></span><br><span class="line"><span class="comment">         * 2.通过序号批量删除消息</span></span><br><span class="line"><span class="comment">         * 3.支持高并发（多线程）</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long,String&gt; outstandingConfirms =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息确认成功 回调失败</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.消息的标记</span></span><br><span class="line"><span class="comment">         *  2.是否为批量确认</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span>  ( deliveryTag,  multiple) -&gt; &#123;</span><br><span class="line">            <span class="comment">//判断是否为批量确认</span></span><br><span class="line">            <span class="keyword">if</span> (multiple)&#123;</span><br><span class="line">                <span class="comment">//2.删除已经确认的消息 剩下的为未确认的消息</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(deliveryTag);</span><br><span class="line">                confirmed.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                outstandingConfirms.remove(deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认的消息：&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息确认失败 回调失败</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.消息的标记</span></span><br><span class="line"><span class="comment">         *  2.是否为批量确认</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> ( deliveryTag,  multiple) -&gt; &#123;</span><br><span class="line">            <span class="comment">//3.打印未确认的消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> outstandingConfirms.get(deliveryTag);</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息：&quot;</span> + deliveryTag +<span class="string">&quot;&amp;&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息的监听器 监听哪些消息成功，哪些消息失败</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.监听哪些消息成功了</span></span><br><span class="line"><span class="comment">         *  2.监听哪些消息失败了</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        channel.addConfirmListener(ackCallback,nackCallback);</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量发布消息——异步确认发布</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            <span class="comment">//1.记录所有要发送的消息 消息的总和</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(),message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span>+ MESSAGE_COUNT + <span class="string">&quot;个异步发布确认消息，耗时：&quot;</span>+ (end-begin)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="以上-3-种发布确认速度对比"><a href="#以上-3-种发布确认速度对比" class="headerlink" title="以上 3 种发布确认速度对比:"></a><strong>以上 3 种发布确认速度对比:</strong></h4><ul><li><p>单独发布消息</p><p>同步等待确认，简单，但吞吐量非常有限。</p></li><li><p>批量发布消息</p><p>批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。</p></li><li><p>异步处理</p><p>最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</p></li></ul><h4 id="应答和发布区别"><a href="#应答和发布区别" class="headerlink" title="应答和发布区别"></a>应答和发布区别</h4><p>应答功能属于消费者，消费完消息告诉 RabbitMQ 已经消费成功。</p><p>发布功能属于生产者，生产消息到 RabbitMQ，RabbitMQ 需要告诉生产者已经收到消息。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>之前模式只有一个队列，只能被消费一次。</p><p><img src="/2022/04/03/RabbitMQ/image-20220906200649744.png" alt="image-20220906200649744"></p><p>通过交换机发送到多个队列，每个队列进行一次消费，实现了消息的多次消费。</p><p><img src="/2022/04/03/RabbitMQ/image-20220906200704206.png" alt="image-20220906200704206"></p><p>​在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消 费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布&#x2F;订阅”。</p><p>​为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘， 另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者。</p><h3 id="Exchanges"><a href="#Exchanges" class="headerlink" title="Exchanges"></a>Exchanges</h3><h4 id="Exchanges-概念"><a href="#Exchanges-概念" class="headerlink" title="Exchanges 概念"></a>Exchanges 概念</h4><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p><p>相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们放到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><p><img src="/2022/04/03/RabbitMQ/image.54tzwxwrqco.webp" alt="image"></p><h4 id="Exchanges的类型"><a href="#Exchanges的类型" class="headerlink" title="Exchanges的类型"></a>Exchanges的类型</h4><ul><li><p>**直接(direct)**：处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上设置的路由键为 abc ，则只有被标记为 abc 的消息才被转发，不会转发 abc.def，也不会转发 dog.ghi，只会转发 abc。</p></li><li><p>**主题(topic)*<em>：将路由键和某模式进行匹配。此时队列需要绑定一个模式上。符号“#”匹配一个或多个词，符号 * 匹配不多不少一个词。因此 abc.# 能够匹配到 abc.def.ghi，但是 abc.</em> 只会匹配到 abc.def。</p></li><li><p><strong>标题(headers)<strong>：不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。在绑定 Queue 与 Exchange 时指定一组键值对；当消息发送到RabbitMQ 时会取到该消息的 headers 与 Exchange 绑定时指定的</strong>键值对进行匹配</strong>；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 属性是一个键值对，可以是 Hashtable，键值对的值可以是任何类型。而 fanout，direct，topic 的路由键都需要<strong>字符串形式</strong>的。</p><p>匹配规则 x-match 有下列两种类型：</p><p>x-match &#x3D; all ：表示所有的键值对都匹配才能接受到消息</p><p>x-match &#x3D; any ：表示只要有键值对匹配就能接受到消息</p></li><li><p>**扇出(fanout)**：不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout 交换机转发消息是最快的。</p></li></ul><h4 id="无名exchange（默认exchange）"><a href="#无名exchange（默认exchange）" class="headerlink" title="无名exchange（默认exchange）"></a>无名exchange（默认exchange）</h4><p>在本教程的前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过<strong>空字符串(“”)进行标识</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure><p>第一个参数是交换机的名称。空字符串 表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey) 绑定指定的 key。</p><p><img src="/2022/04/03/RabbitMQ/image-20220906213000176.png" alt="image-20220906213000176"></p><h3 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h3><p>之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们来说至关重要，我们需要指定我们的消费者去消费哪个队列的消息。</p><p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有<strong>随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次<strong>一旦我们断开了消费者的连接，队列将被自动删除。</strong></p><p>创建临时队列的方式如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure><p><img src="/2022/04/03/RabbitMQ/image.56c9qj8lnyo0.webp" alt="image"></p><h3 id="绑定-bindings"><a href="#绑定-bindings" class="headerlink" title="绑定(bindings)"></a>绑定(bindings)</h3><p>什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定。</p><p><img src="/2022/04/03/RabbitMQ/image.1ryp1eu9xtnk.webp" alt="image"></p><p><img src="/2022/04/03/RabbitMQ/image.2z1b1g3ou5e0.webp" alt="image"></p><h3 id="Fanout-扇出（发布订阅模式）"><a href="#Fanout-扇出（发布订阅模式）" class="headerlink" title="Fanout 扇出（发布订阅模式）"></a>Fanout 扇出（发布订阅模式）</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的所有队列中。系统中有默认的exchange 类型。</p><p><img src="/2022/04/03/RabbitMQ/image-20220906213331507.png" alt="image-20220906213331507"></p><h4 id="Fanout-实战"><a href="#Fanout-实战" class="headerlink" title="Fanout 实战"></a>Fanout 实战</h4><p>为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘。</p><p><img src="/2022/04/03/RabbitMQ/image.2mdbijsttri0.webp" alt="image"></p><p>Logs 和临时队列的绑定关系如下图：</p><p><img src="/2022/04/03/RabbitMQ/image-20220906213612013.png" alt="image-20220906213612013"></p><p>ReceiveLogs01 将接收到的消息打印在控制台：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/6 20:40</span></span><br><span class="line"><span class="comment"> * 消息的接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs01</span> &#123;</span><br><span class="line">    <span class="comment">//交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明一个交换机-扇出（发布订阅模式）</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 声明一个 临时队列</span></span><br><span class="line"><span class="comment">         * 队列名称是随机的</span></span><br><span class="line"><span class="comment">         * 当消费者断开与队列连接时 队列就自动删除</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queue</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//绑定交换机与队列</span></span><br><span class="line">        channel.queueBind(queue,EXCHANGE_NAME,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息，接收到的消息打印在屏幕上……&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> ( consumerTag,  message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queue,<span class="literal">true</span>,deliverCallback, (CancelCallback) <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReceiveLogs02 将接收到的消息存储在磁盘</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/6 20:40</span></span><br><span class="line"><span class="comment"> * 消息的接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs02</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">queue</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        channel.queueBind(queue,EXCHANGE_NAME,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息2，接收到的消息打印在屏幕上……&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> ( consumerTag,  delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span> + message);</span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\work\\rabbitmq_info.txt&quot;</span>);</span><br><span class="line">            FileUtils.writeStringToFile(file,message,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;数据写入文件成功&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queue,<span class="literal">true</span>,deliverCallback, cancelCallback -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EmitLog 发送消息给两个消费者接收:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/6 21:08</span></span><br><span class="line"><span class="comment"> * 发送消息给交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLog</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (input.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> input.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,<span class="string">&quot;&quot;</span>,<span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/04/03/RabbitMQ/image-20220906214222168.png" alt="image-20220906214222168"></p><h3 id="Direct-exchange-直接交换机（路由交换）"><a href="#Direct-exchange-直接交换机（路由交换）" class="headerlink" title="Direct exchange 直接交换机（路由交换）"></a>Direct exchange 直接交换机（路由交换）</h3><p>在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能——让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</p><p>我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： <strong>队列只对它绑定的交换机的消息感兴趣</strong>。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);</p><p>绑定之后的意义由其交换类型决定。</p><h4 id="Direct介绍"><a href="#Direct介绍" class="headerlink" title="Direct介绍"></a>Direct介绍</h4><p>上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。</p><p><img src="/2022/04/03/RabbitMQ/image.gi5bzb0sygo.webp" alt="image"></p><p>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列 Q1 绑定键为 orange， 队列 Q2 绑定键有两个：一个绑定键为 black，另一个绑定键为 green.</p><p>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p><h4 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a>多重绑定</h4><p><img src="/2022/04/03/RabbitMQ/image.6m5o5nqwvlw0.webp" alt="image"></p><p>当然如果 exchange 的绑定类型是direct，<strong>但是它绑定的多个队列的 key 如果都相同</strong>，在这种情况下虽然绑定类型是 direct <strong>但是它表现的就和 fanout 有点类似了</strong>，就跟广播差不多，如上图所示。</p><h4 id="Direct实战"><a href="#Direct实战" class="headerlink" title="Direct实战"></a>Direct实战</h4><p><img src="/2022/04/03/RabbitMQ/image.18f9o7wxc5uo.webp" alt="image"></p><p>项目结构：一个交换机+两个队列+三个Routing key</p><p><img src="/2022/04/03/RabbitMQ/image.5x5pk7emz0k0.webp" alt="image"></p><p>C1 消费者：绑定 console 队列，routingKey 为 info、warning</p><p>C2 消费者：绑定 disk 队列，routingKey 为 error</p><p>当生产者生产消息到 <code>direct_logs</code> 交换机里，该交换机会检测消息的 routingKey 条件，然后分配到满足条件的队列里，最后由消费者从队列消费消息。</p><p><strong>消费者1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/6 22:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明一个直接交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;console&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//进行绑定</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;console&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;console&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;warning&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息1：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;console&quot;</span>,<span class="literal">true</span>,deliverCallback, cancelCallback -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>消费者2</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/6 22:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明一个直接交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;disk&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//进行绑定</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;disk&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息2：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;disk&quot;</span>,<span class="literal">true</span>,deliverCallback, cancelCallback -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/6 22:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectLogs</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        String[] direct = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;info&quot;</span>,<span class="string">&quot;warning&quot;</span>,<span class="string">&quot;error&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (input.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> input.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,direct[i], <span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：随机分配</p><p><img src="/2022/04/03/RabbitMQ/image-20220906225040227.png" alt="image-20220906225040227"></p><h3 id="Topics-主题交换机"><a href="#Topics-主题交换机" class="headerlink" title="Topics 主题交换机"></a>Topics 主题交换机</h3><p>在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而能实现有选择性地接收日志。</p><p>尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性——比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 <strong>topic</strong> 类型。</p><h4 id="Topic-的要求"><a href="#Topic-的要求" class="headerlink" title="Topic 的要求"></a><strong>Topic 的要求</strong></h4><p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是<strong>一个单词列表</strong>，<strong>以点号分隔开</strong>。这些单词可以是任意单词</p><p>比如说：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit” 这种类型的。</p><p>当然这个单词列表最多不能超过 255 个字节。</p><p>在这个规则列表中，其中有两个替换符是大家需要注意的：</p><ul><li>***(星号)可以代替一个位置**</li><li><strong>#(井号)可以替代零个或多个位置</strong></li></ul><h4 id="Topic匹配案例"><a href="#Topic匹配案例" class="headerlink" title="Topic匹配案例"></a>Topic匹配案例</h4><p>下图绑定关系如下</p><p><img src="/2022/04/03/RabbitMQ/image.6a89pabmhtg0.webp" alt="image"></p><ul><li>Q1–&gt;绑定的是<ul><li>中间带 orange 带 3 个单词的字符串 <code>(*.orange.*)</code></li></ul></li><li>Q2–&gt;绑定的是<ul><li>最后一个单词是 rabbit 的 3 个单词 <code>(*.*.rabbit)</code></li><li>第一个单词是 lazy 的多个单词 <code>(lazy.#)</code></li></ul></li></ul><p>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的</p><table><thead><tr><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>quick.orange.rabbit</td><td>被队列 Q1Q2 接收到</td></tr><tr><td>azy.orange.elephant</td><td>被队列 Q1Q2 接收到</td></tr><tr><td>quick.orange.fox</td><td>被队列 Q1 接收到</td></tr><tr><td>lazy.brown.fox</td><td>被队列 Q2 接收到</td></tr><tr><td>lazy.pink.rabbit</td><td>虽然满足两个绑定但只被队列 Q2 接收一次</td></tr><tr><td>quick.brown.fox</td><td>不匹配任何绑定不会被任何队列接收到会被丢弃</td></tr><tr><td>quick.orange.male.rabbit</td><td>是四个单词不匹配任何绑定会被丢弃</td></tr><tr><td>lazy.orange.male.rabbit</td><td>是四个单词但匹配 Q2</td></tr></tbody></table><blockquote><p><strong>当一个队列绑定键是 #，那么这个队列将接收所有数据，就有点像 fanout 了。</strong></p><p><strong>如果队列绑定键当中没有 # 和 * 出现，那么该队列绑定类型就是 direct 了。</strong></p></blockquote><h4 id="Topic实战"><a href="#Topic实战" class="headerlink" title="Topic实战"></a>Topic实战</h4><p><img src="/2022/04/03/RabbitMQ/image.5kvwh1z1ixk0.webp" alt="image"></p><p>生产多个消息到交换机，交换机按照通配符分配消息到不同的队列中，队列由消费者进行消费</p><ul><li><strong>生产者 EmitLogTopic</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 21:014</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogTopic</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Q1--&gt;绑定的是</span></span><br><span class="line"><span class="comment">         *      中间带 orange 带 3 个单词的字符串(*.orange.*)</span></span><br><span class="line"><span class="comment">         * Q2--&gt;绑定的是</span></span><br><span class="line"><span class="comment">         *      最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)</span></span><br><span class="line"><span class="comment">         *      第一个单词是 lazy 的多个单词(lazy.#)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        HashMap&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>, <span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>, <span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.fox&quot;</span>, <span class="string">&quot;被队列 Q1 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.brown.fox&quot;</span>, <span class="string">&quot;被队列 Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>, <span class="string">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>, <span class="string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词但匹配 Q2&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,String&gt; bindingKeyEntry : bindingKeyMap.entrySet())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,routingKey,<span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发送消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>消费者C1</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 20:39</span></span><br><span class="line"><span class="comment"> * 声明主题交换机及相关队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 消费者C1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic01</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Q1&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//进行绑定</span></span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息……&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收的消息Q1：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;接收队列：&quot;</span>+queueName+<span class="string">&quot;，绑定键：&quot;</span>+message.getEnvelope().getRoutingKey() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,deliverCallback ,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>消费者C2</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 20:39</span></span><br><span class="line"><span class="comment"> * 声明主题交换机及相关队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 消费者C2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic02</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Q2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//进行绑定</span></span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息……&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收的消息Q2：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;接收队列：&quot;</span>+queueName+<span class="string">&quot;，绑定键：&quot;</span>+message.getEnvelope().getRoutingKey() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,deliverCallback ,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果</li></ul><p><img src="/2022/04/03/RabbitMQ/image-20220907212138882.png" alt="image-20220907212138882"></p><h2 id="RabbitMQ-死信队列"><a href="#RabbitMQ-死信队列" class="headerlink" title="RabbitMQ 死信队列"></a>RabbitMQ 死信队列</h2><h3 id="死信的概念"><a href="#死信的概念" class="headerlink" title="死信的概念"></a>死信的概念</h3><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因<strong>导致 queue 中的某些消息无法被消费</strong>，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p><p>应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。</p><h3 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h3><ul><li><p>消息 TTL 过期</p><p>TTL是 Time To Live 的缩写, 也就是生存时间</p></li><li><p>队列达到最大长度</p><p>队列满了，无法再添加数据到 MQ 中</p></li><li><p>消息被拒绝</p><p>(basic.reject 或 basic.nack) 并且 requeue &#x3D; false</p></li></ul><h3 id="死信实战"><a href="#死信实战" class="headerlink" title="死信实战"></a>死信实战</h3><p>俩个交换机类型是 direct，两个消费者，一个生产者，两个队列：消息队列和死信队列</p><p><img src="/2022/04/03/RabbitMQ/image.691xh9mh3yk0.webp" alt="image"></p><h4 id="消息TTL-过期"><a href="#消息TTL-过期" class="headerlink" title="消息TTL 过期"></a>消息TTL 过期</h4><ul><li><strong>生产者代码</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 22:04</span></span><br><span class="line"><span class="comment"> *  死信队列</span></span><br><span class="line"><span class="comment"> *  生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//发送死信消息 设置TTL time to live 10s</span></span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties()</span><br><span class="line">                .builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>,properties,message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>消费者 C1 代码</strong>(启动之后关闭该消费者 模拟其接收不到消息)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 21:37</span></span><br><span class="line"><span class="comment"> *  死信队列</span></span><br><span class="line"><span class="comment"> *  消费者C1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信交换机名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明普通和死信交换机</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通队列</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//过期时间10s</span></span><br><span class="line">        <span class="comment">//arguments.put(&quot;x-message-tt&quot;,10000);</span></span><br><span class="line">        <span class="comment">//正常队列设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,arguments);</span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//绑定普通交换机和队列</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//绑定死信交换机和队列</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息……&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者1接收的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE,<span class="literal">true</span>,deliverCallback,cancelCallback -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动消费者 C1，创建出队列，然后停止该 C1 的运行，则 C1 将无法收到队列的消息，无法收到的消息 10 秒后进入死信队列。启动生产者 producer 生产消息</p><p><strong>生产者未发送消息</strong></p><p><img src="/2022/04/03/RabbitMQ/image.5ldx5kffws00.webp" alt="image"></p><p><strong>生产者发送了10条消息，此时正常消息队列有10条未消费消息</strong></p><p><img src="/2022/04/03/RabbitMQ/image.4k5fjvtukpe0.webp" alt="image"></p><p><strong>时间过去10秒，正常队列里面的消息由于没有被消费，消息进入死信队列</strong></p><p><img src="/2022/04/03/RabbitMQ/image.5g2svti1sec0.webp" alt="image"></p><ul><li><strong>消费者 C2 代码</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 21:37</span></span><br><span class="line"><span class="comment"> *  死信队列</span></span><br><span class="line"><span class="comment"> *  消费者C2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer02</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收死信消息……&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者2接收的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(DEAD_QUEUE,<span class="literal">true</span>,deliverCallback,cancelCallback -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>效果演示</strong></li></ul><p><img src="/2022/04/03/RabbitMQ/image.3a1tkaqx5jm0.webp" alt="image"></p><p>死信队列里面的消息被C2消费掉</p><p><img src="/2022/04/03/RabbitMQ/image-20220908200651208.png" alt="image-20220908200651208"></p><h4 id="队列达到最大长度"><a href="#队列达到最大长度" class="headerlink" title="队列达到最大长度"></a>队列达到最大长度</h4><ul><li>消息生产者代码去掉 TTL 属性，<code>basicPublish</code> 的第三个参数改为 null</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 22:04</span></span><br><span class="line"><span class="comment"> *  死信队列</span></span><br><span class="line"><span class="comment"> *  生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//发送死信消息 设置TTL time to live 10s</span></span><br><span class="line">       <span class="comment">/*AMQP.BasicProperties properties = new AMQP.BasicProperties()</span></span><br><span class="line"><span class="comment">                .builder().expiration(&quot;10000&quot;).build();*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C1 消费者修改以下代码(<strong>启动之后关闭该消费者 模拟其接收不到消息</strong>)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 21:37</span></span><br><span class="line"><span class="comment"> *  死信队列</span></span><br><span class="line"><span class="comment"> *  消费者C1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信交换机名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明普通和死信交换机</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通队列</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//过期时间10s</span></span><br><span class="line">        <span class="comment">//arguments.put(&quot;x-message-tt&quot;,10000);</span></span><br><span class="line">        <span class="comment">//正常队列设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//设置正常队列的长度限制</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-max-length&quot;</span>,<span class="number">6</span>);</span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,arguments);</span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//绑定普通交换机和队列</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//绑定死信交换机和队列</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息……&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者1接收的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE,<span class="literal">true</span>,deliverCallback,cancelCallback -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>因为参数改变了，所以需要把原先队列删除</p></blockquote><ul><li>C2 消费者代码不变</li><li>启动消费者C1，创建出队列，然后停止该 C1 的运行，启动生产者</li></ul><p><img src="/2022/04/03/RabbitMQ/image.6nv41w7ky0o0.webp" alt="image"></p><ul><li>启动 C2 消费者</li></ul><p><img src="/2022/04/03/RabbitMQ/image.3mg5ph9jr020.webp" alt="image"></p><ul><li>控制台</li></ul><p><img src="/2022/04/03/RabbitMQ/image.664h3njwl6w0.webp" alt="image"></p><h4 id="消息被拒"><a href="#消息被拒" class="headerlink" title="消息被拒"></a>消息被拒</h4><ol><li>消息生产者代码同上生产者一致</li><li>需求：消费者 C1 拒收消息 “info5”，开启手动应答</li></ol><p><strong>消费者C1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 21:37</span></span><br><span class="line"><span class="comment"> *  死信队列</span></span><br><span class="line"><span class="comment"> *  消费者C1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信交换机名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明普通和死信交换机</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通队列</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//过期时间10s</span></span><br><span class="line">        <span class="comment">//arguments.put(&quot;x-message-tt&quot;,10000);</span></span><br><span class="line">        <span class="comment">//正常队列设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//设置正常队列的长度限制</span></span><br><span class="line">        <span class="comment">//arguments.put(&quot;x-max-length&quot;,6);</span></span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,arguments);</span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//绑定普通交换机和队列</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//绑定死信交换机和队列</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息……&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(msg.equals(<span class="string">&quot;info5&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01接受的消息是：&quot;</span>+msg+<span class="string">&quot;： 此消息是被C1拒绝的&quot;</span>);</span><br><span class="line">                <span class="comment">//requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span></span><br><span class="line">                channel.basicReject(message.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1接收的消息：&quot;</span> + msg);</span><br><span class="line">                channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//关闭自动应答 开启手动应答</span></span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE,<span class="literal">false</span>,deliverCallback,cancelCallback -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>开启消费者C1，创建出队列，然后停止该 C1 的运行，启动生产者</li></ul><p><img src="/2022/04/03/RabbitMQ/image.ncokzmns2t.webp" alt="image"></p><ul><li>再启动消费者 C2</li></ul><p><img src="/2022/04/03/RabbitMQ/image.1xxchsmgsgdc.webp" alt="image"></p><ul><li>控制台</li></ul><p><img src="/2022/04/03/RabbitMQ/image-20220908204825740.png" alt="image-20220908204825740"></p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><h3 id="延迟队列介绍"><a href="#延迟队列介绍" class="headerlink" title="延迟队列介绍"></a>延迟队列介绍</h3><h4 id="延迟队列概念："><a href="#延迟队列概念：" class="headerlink" title="延迟队列概念："></a><strong>延迟队列概念：</strong></h4><p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p><h4 id="延迟队列使用场景："><a href="#延迟队列使用场景：" class="headerlink" title="延迟队列使用场景："></a><strong>延迟队列使用场景：</strong></h4><ol><li>订单在十分钟之内未支付则自动取消</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li></ol><p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？</p><p>如果数据量比较少，确实可以这样做，比如：对于「如果账单一周内未支付则进行自动结算」这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：「订单十分钟内未支付则关闭」，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p><p><img src="/2022/04/03/RabbitMQ/image.21tyby27zrog.webp" alt="image"></p><h3 id="RabbitMQ-中的-TTL"><a href="#RabbitMQ-中的-TTL" class="headerlink" title="RabbitMQ 中的 TTL"></a>RabbitMQ 中的 TTL</h3><p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。</p><p>换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为「死信」。如果同时配置了队列的 TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p><h4 id="队列设置-TTL"><a href="#队列设置-TTL" class="headerlink" title="队列设置 TTL"></a><strong>队列设置 TTL</strong></h4><p>在创建队列的时候设置队列的 x-message-ttl 属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">params.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">5000</span>);</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;QA&quot;</span>).withArguments(args).build(); <span class="comment">// QA 队列的最大存活时间位 5000 毫秒</span></span><br></pre></td></tr></table></figure><h4 id="消息设置-TTL"><a href="#消息设置-TTL" class="headerlink" title="消息设置 TTL"></a><strong>消息设置 TTL</strong></h4><p>针对每条消息设置 TTL</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitTemplate.converAndSend(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XC&quot;</span>,message,correlationData -&gt; &#123;</span><br><span class="line">    correlationData.getMessageProperties().setExpiration(<span class="string">&quot;5000&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a><strong>两者区别</strong></h4><p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间，具体看下方案例。</p><p>另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p><h3 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h3><p>前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。</p><ol><li>创建一个 Maven 工程或者 Spring Boot工程</li><li>添加依赖，这里的 Spring Boot 是2.5.6 版本</li></ol><p>比如下面版本组合是兼容的</p><table><thead><tr><th>Spring Boot版本</th><th>Swagger 版本</th></tr></thead><tbody><tr><td>2.5.6</td><td>2.9.2</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--RabbitMQ 依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.2</span><span class="number">.47</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--swagger--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--RabbitMQ 测试依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>​3.创建 <code>application.properties</code> 文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.rabbitmq.host=<span class="number">192.168</span><span class="number">.182</span><span class="number">.128</span></span><br><span class="line">spring.rabbitmq.port=<span class="number">5672</span></span><br><span class="line">spring.rabbitmq.username=admin</span><br><span class="line">spring.rabbitmq.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure><ol start="4"><li>添加Swagger 配置类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/8 21:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">webApiConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">webApiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;hua&quot;</span>,<span class="string">&quot;http://atguigu.com&quot;</span>,<span class="string">&quot;2164277973@qq.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​5.新建主启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootRabbitmqApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootRabbitmqApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列TTL"><a href="#队列TTL" class="headerlink" title="队列TTL"></a>队列TTL</h3><h4 id="代码架构图"><a href="#代码架构图" class="headerlink" title="代码架构图"></a><strong>代码架构图</strong></h4><p>创建两个队列 QA 和 QB，两个队列的 TTL 分别设置为 10S 和 40S，然后再创建一个交换机 X 和死信交换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：</p><p><img src="/2022/04/03/RabbitMQ/image.6ipia9redgw0.webp" alt="image"></p><p>原先配置队列信息，写在了生产者和消费者代码中，现在可写在配置类中，生产者只发消息，消费者只接受消息。</p><h4 id="配置文件类代码"><a href="#配置文件类代码" class="headerlink" title="配置文件类代码"></a>配置文件类代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/8 21:29</span></span><br><span class="line"><span class="comment"> *  TTL队列 配置文件类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TTLQueueConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">X_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信交换机名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_A</span> <span class="operator">=</span> <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_B</span> <span class="operator">=</span> <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;QD&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明Exchange</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">xExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//路由交换机</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(X_EXCHANGE,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">yExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//路由交换机</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(Y_DEAD_LETTER_EXCHANGE,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span>&#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//设置TTL</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//设置TTL</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueD</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//死信队列</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DEAD_LETTER_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机队列绑定</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueABindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueDBindingY</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,<span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="消息生产者代码"><a href="#消息生产者代码" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h4><p><strong>Controller 层代码，获取消息，放到 RabbitMQ</strong> 里</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/8 21:57</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  生产者 发送延迟消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sendMsgController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始发消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，发送一个消息给两个TTL队列：&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>().toString(),message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XA&quot;</span>,<span class="string">&quot;消息来自ttl为10s的队列：&quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XB&quot;</span>,<span class="string">&quot;消息来自ttl为40s的队列：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息消费者代码"><a href="#消息消费者代码" class="headerlink" title="消息消费者代码"></a>消息消费者代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.rabbitmq.springboot_rabbitmq.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/8 22:07</span></span><br><span class="line"><span class="comment"> *  队列TTL   消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterQueueConsumer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收消息</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，收到死信队列的消息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>().toString(),msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起一个请求：<a href="http://localhost:8888/ttl/sendMsg/%E5%98%BB%E5%98%BB%E5%98%BB">http://localhost:8080/ttl/sendMsg/嘻嘻嘻(opens new window)</a></p><p><img src="/2022/04/03/RabbitMQ/image-20220908230222702.png" alt="image-20220908230222702"></p><p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。</p><p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p><h3 id="延时队列优化"><a href="#延时队列优化" class="headerlink" title="延时队列优化"></a>延时队列优化</h3><p>在这里新增了一个队列 QC，该队列不设置 TTL 时间，根据前端的请求确定 TTL 时间，绑定关系如下：</p><p><img src="/2022/04/03/RabbitMQ/image.267zky9xj8dc.webp" alt="image"></p><h4 id="配置类代码"><a href="#配置类代码" class="headerlink" title="配置类代码"></a><strong>配置类代码</strong></h4><p>新增一个配置文件类，用于新增队列 QC，也可以放在上方的配置文件类里</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgTtlQueueConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_C</span> <span class="operator">=</span> <span class="string">&quot;QC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死信交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Y_DEAD_LETTER_EXCHANGE=<span class="string">&quot;Y&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明QC</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">QueueC</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明队列 QC 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueCBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span>DirectExchange xExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生产者</strong></p><p><strong>Controller 新增方法</strong></p><p>该方法接收的请求要带有 TTL 时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.rabbitmq.springboot_rabbitmq.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.rabbitmq.springboot_rabbitmq.config.DelayedQueueConfig;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/8 21:57</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  生产者 发送延迟消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sendMsgController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始发消息和TTL</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> String ttlTime)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，发送一个时长&#123;&#125;毫秒TTL消息给QC队列：&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>().toString(),ttlTime,message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XC&quot;</span>,message,msg -&gt; &#123;</span><br><span class="line">            <span class="comment">//设置延迟时间</span></span><br><span class="line">            msg.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启下面，发送请求：</p><p><a href="https://frxcat.fun/middleware/RabbitMQ/RabbitMQ_Delay_queue/">http://localhost:8080/ttl/sendExpirationMsg/你好1/20000</a></p><p><a href="https://frxcat.fun/middleware/RabbitMQ/RabbitMQ_Delay_queue/">http://localhost:8080/ttl/sendExpirationMsg/你好2/2000</a></p><blockquote><p><strong>出现问题</strong>:</p><p><img src="/2022/04/03/RabbitMQ/1658765665496.39yyrmljat80.webp" alt="1658765665496"></p></blockquote><p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时「死亡」</p><blockquote><p><strong>因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行</strong></p></blockquote><p>这也就是为什么如图的时间：你好 2 延时 2 秒，却后执行，还要等待你好 1 消费后再执行你好2</p><h3 id="Rabbitmq插件实现延迟队列"><a href="#Rabbitmq插件实现延迟队列" class="headerlink" title="Rabbitmq插件实现延迟队列"></a>Rabbitmq插件实现延迟队列</h3><p>上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的 TTL 时间及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。</p><p><strong>安装延时队列插件</strong></p><p>可去<a href="https://www.rabbitmq.com/community-plugins.html">官网下载 (opens new window)</a>找到 <strong>rabbitmq_delayed_message_exchange</strong> 插件，放置到 RabbitMQ 的插件目录。</p><p>因为官网也是跳转去该插件的 GitHub 地址进行下载：<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases">点击跳转(opens new window)</a>，然后解压放置到 RabbitMQ 的插件目录。 进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 复制到plgins目录下</span><br><span class="line">cp rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins/</span><br><span class="line"># 进行plgins目录</span><br><span class="line">cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins/</span><br></pre></td></tr></table></figure><p>其中我的版本是 <code>/rabbitmq_server-3.8.0</code></p><p>进入目录后执行下面命令让该插件生效，然后重启 RabbitMQ</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br><span class="line"># 重启服务</span><br><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@master plugins]# rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br><span class="line">Enabling plugins on node rabbit@master:</span><br><span class="line">rabbitmq_delayed_message_exchange</span><br><span class="line">The following plugins have been configured:</span><br><span class="line">  rabbitmq_delayed_message_exchange</span><br><span class="line">  rabbitmq_management</span><br><span class="line">  rabbitmq_management_agent</span><br><span class="line">  rabbitmq_web_dispatch</span><br><span class="line">Applying plugin configuration to rabbit@master...</span><br><span class="line">The following plugins have been enabled:</span><br><span class="line">  rabbitmq_delayed_message_exchange</span><br><span class="line"></span><br><span class="line">started 1 plugins.</span><br><span class="line">[root@master plugins]# systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><blockquote><p>解释</p><p>安装命令不能出现插件版本和后缀，如 <code>rabbitmq-plugins enable rabbitmq_delayed_message_exchange-3.8.0.ez</code> 会报错</p><p>必须是 <code>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</code>，后面不允许填入版本和文件后缀</p></blockquote><p>打开 Web 界面，查看交换机的新增功能列表，如果多出了如图所示，代表成功添加插件</p><p><img src="/2022/04/03/RabbitMQ/image.3nqc69j0pws0.webp" alt="image"></p><h4 id="代码架构图-1"><a href="#代码架构图-1" class="headerlink" title="代码架构图"></a>代码架构图</h4><p>在这里新增了一个队列 delayed.queue，一个自定义交换机 delayed.exchange，绑定关系如下:</p><p><img src="/2022/04/03/RabbitMQ/image.1tla4z5g4yps.webp" alt="image"></p><h4 id="配置类代码-1"><a href="#配置类代码-1" class="headerlink" title="配置类代码"></a>配置类代码</h4><p>新增一个配置类 <code>DelayedQueueConfig</code>，也可以放在原来的配置文件里，代码里使用了 <code>CustomExchange</code> 类，通过参数来自定义一个类型(direct、topic等)</p><p>在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/9 20:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayedQueueConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * routingKey</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingKey&quot;</span>;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机 基于插件的</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">delayedExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-delayed-type&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.交换机名称</span></span><br><span class="line"><span class="comment">         *  2.交换机的类型</span></span><br><span class="line"><span class="comment">         *  3.是否持久化</span></span><br><span class="line"><span class="comment">         *  4.是否自动删除</span></span><br><span class="line"><span class="comment">         *  5.其他参数</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME,<span class="string">&quot;x-delayed-message&quot;</span>,<span class="literal">true</span>,<span class="literal">true</span>,arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding  <span class="title function_">delayedQueueBindingDelayedExchange</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue delayedQueue,</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange</span></span><br><span class="line"><span class="params">    )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a><strong>生产者代码</strong></h4><p>在 controller 里新增一个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.rabbitmq.springboot_rabbitmq.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.rabbitmq.springboot_rabbitmq.config.DelayedQueueConfig;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/8 21:57</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  生产者 发送延迟消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sendMsgController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    ........</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于插件 开始发消息及延迟时间</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> Integer delayTime)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，发送一个时长&#123;&#125;毫秒消息给延迟队列delayed.queue：&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>().toString(),delayTime,message);</span><br><span class="line">        rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME</span><br><span class="line">        ,DelayedQueueConfig.DELAYED_ROUTING_KEY,message,msg -&gt; &#123;</span><br><span class="line">            <span class="comment">//发送消息的延迟时间 ms</span></span><br><span class="line">            msg.getMessageProperties().setDelay(delayTime);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a><strong>消费者代码</strong></h4><p>监听延时队列，如果有消息进入该队列，则打印到控制台</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/9 20:56</span></span><br><span class="line"><span class="comment"> * 消费者 基于插件的延迟消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueueConsumer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听消息</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDelayQueue</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，收到延迟队列的消息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>().toString(),msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><a href="http://localhost:8888/ttl/sendDelayMsg/hello1/20000">http://localhost:8080/ttl/sendDelayMsg/hello1/20000(opens new window)</a></p><p><a href="http://localhost:8888/ttl/sendDelayMsg/hello2/2000">http://localhost:8080/ttl/sendDelayMsg/hello2/2000(opens new window)</a></p><p><img src="/2022/04/03/RabbitMQ/image.17h77dwilchs.webp" alt="image"></p><p>可以看到哪怕 hello1 需要20秒再进入延时队列，hello2 2 秒后直接进入延时队列，无需等待 hello1被消费。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。</p><p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景。</p><h2 id="RabbitMQ-发布确认高级"><a href="#RabbitMQ-发布确认高级" class="headerlink" title="RabbitMQ 发布确认高级"></a>RabbitMQ 发布确认高级</h2><p>在生产环境中由于一些不明原因，导致 RabbitMQ 重启，在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">应 用 [xxx] 在 [08-<span class="number">1516</span>:<span class="number">36</span>:<span class="number">04</span>] 发 生 [ 错 误 日 志 异 常 ] ， alertId=[xxx] 。 由</span><br><span class="line">[org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:<span class="number">620</span>] 触 发 。</span><br><span class="line">应用 xxx 可能原因如下</span><br><span class="line">服 务 名 为 ：</span><br><span class="line">异 常 为 ： org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:<span class="number">620</span>,</span><br><span class="line">产 生 原 因 如 下 :<span class="number">1.</span>org.springframework.amqp.rabbit.listener.QueuesNotAvailableException:</span><br><span class="line">Cannot prepare queue <span class="keyword">for</span> listener. Either the queue doesn<span class="string">&#x27;t exist or the broker will not</span></span><br><span class="line"><span class="string">allow us to use it.||Consumer received fatal=false exception on startup:</span></span><br></pre></td></tr></table></figure><h3 id="发布确认SpringBoot版本"><a href="#发布确认SpringBoot版本" class="headerlink" title="发布确认SpringBoot版本"></a>发布确认SpringBoot版本</h3><p>简单的发布确认机制在应答与签收已经介绍，本内容将介绍整合了 SpringBoot 的发布确认机制。</p><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>首先发布消息后进行备份在缓存里，如果消息成功发布确认到交换机，则从缓存里删除该消息，如果没有成功发布，则设置一个定时任务，重新从缓存里获取消息发布到交换机，直到成功发布到交换机。</p><p>确认机制图例：</p><p><img src="/2022/04/03/RabbitMQ/image.7c8btl8ibwo0.webp" alt="image"></p><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>一个交换机：confirm.exchange，一个队列：confirm.queue，一个消费者：confirm.consumer</p><p>其中交换机类型时 direct，与队列关联的 routingKey 是 key1</p><p>代码架构图：</p><p><img src="/2022/04/03/RabbitMQ/image.7ddz8ceuxk40.webp" alt="image"></p><p>在配置文件当中需要添加：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">192.168.182.128</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure><ul><li><code>NONE</code> 值是禁用发布确认模式，是默认值</li><li><code>CORRELATED</code> 值是发布消息成功到交换器后会触发回调方法</li><li><code>SIMPLE</code> 值经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后会使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker（相当于单个或者批量确认模式）;</li></ul><h4 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h4><p>声明交换机和队列，并且将交换机和队列进行绑定</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 13:54</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 配置类 发布确认高级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备份交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * routingKey</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;key1&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"><span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBindingExchange</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange,</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue</span></span><br><span class="line"><span class="params">    )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息生产者-1"><a href="#消息生产者-1" class="headerlink" title="消息生产者"></a><strong>消息生产者</strong></h4><p>也可以说是 Controller 层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 14:05</span></span><br><span class="line"><span class="comment"> *  发布确认高级 测试确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发消息</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">        <span class="comment">//指定消息 id 为 1</span></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                ConfirmConfig.CONFIRM_ROUTING_KEY,message+<span class="string">&quot;key1&quot;</span>,correlationData1);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息内容:&#123;&#125;&quot;</span>,message+<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息 id 为 2</span></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;key2&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                CONFIRM_ROUTING_KEY,message+<span class="string">&quot;key2&quot;</span>,correlationData2);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息内容:&#123;&#125;&quot;</span>,message+<span class="string">&quot;key2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息消费者-1"><a href="#消息消费者-1" class="headerlink" title="消息消费者"></a><strong>消息消费者</strong></h4><p>监听 <code>confirm.queue</code> 队列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 14:11</span></span><br><span class="line"><span class="comment"> *  发布确认高级 接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConsumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.CONFIRM_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfirmMessage</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接收到Confirm.queue的消息：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="消息生产者发布消息后的回调接口"><a href="#消息生产者发布消息后的回调接口" class="headerlink" title="消息生产者发布消息后的回调接口"></a><strong>消息生产者发布消息后的回调接口</strong></h4><p>只要生产者发布消息，交换机不管是否收到消息，都会调用该类的 <code>confirm</code> 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 14:25</span></span><br><span class="line"><span class="comment"> *  发布确认高级 回调接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将该方法注入到RabbitTemplate内部接口中</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机确认回调方法</span></span><br><span class="line"><span class="comment">     *  1.发消息 交换机成功接收 回调</span></span><br><span class="line"><span class="comment">     *      1.1 correlationData 保存回调消息的ID及相关消息</span></span><br><span class="line"><span class="comment">     *      1.2 ack = true  交换机收到消息</span></span><br><span class="line"><span class="comment">     *      1.3 cause = null  失败原因</span></span><br><span class="line"><span class="comment">     *  2.发消息 交换机接收失败 回调</span></span><br><span class="line"><span class="comment">     *      2.1 correlationData 保存回调消息的ID及相关消息</span></span><br><span class="line"><span class="comment">     *      2.2 ack = false  交换机未收到消息</span></span><br><span class="line"><span class="comment">     *      2.3 cause  失败原因</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> b, String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span>? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (b)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机收到ID为：&#123;&#125;的消息&quot;</span>,id);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机未收到ID为：&#123;&#125;的消息,失败原因为：&#123;&#125;&quot;</span>,id,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><a href="http://localhost:8888/confirm/sendMessage/%E5%A4%A7%E5%AE%B6%E5%A5%BD1">http://localhost:8888/confirm/sendMessage/大家好1</a></p><h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p><img src="/2022/04/03/RabbitMQ/image.5cpvzjf8zb40.webp" alt="image"></p><p>可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为 “key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。</p><p>丢弃的消息交换机是不知道的，所以生产者也不知道，需要解决告诉生产者消息传送失败。</p><h3 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h3><p>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。</p><p>那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>获取回退的消息，首先在配置文件开启该功能，然后需要自定义类实现 <code>RabbitTemplate.ReturnsCallback</code> 接口，并且初始化时，使用该自定义类作为回退消息的处理类，同时开启 <code>Mandatory</code>，设置为 true</p><p>在启动开启 Mandatory，或者在代码里手动开启 Mandatory 参数，或者都开启</p><p>配置类文件开启：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.template.mandatory</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>代码中开启:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h4><h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">192.168.182.128</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.mandatory</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h5 id="修改回调接口"><a href="#修改回调接口" class="headerlink" title="修改回调接口"></a>修改回调接口</h5><p>实现 <code>RabbitTemplate.ReturnsCallback</code> 接口，并实现方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 14:25</span></span><br><span class="line"><span class="comment"> *  发布确认高级 回调接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback, RabbitTemplate.ReturnsCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将该方法注入到RabbitTemplate内部接口中</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">* true：</span></span><br><span class="line"><span class="comment">* 交换机无法将消息进行路由时，会将该消息返回给生产者</span></span><br><span class="line"><span class="comment">* false：</span></span><br><span class="line"><span class="comment">* 如果发现消息无法进行路由，则直接丢弃</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//rabbitTemplate.setMandatory(true);</span></span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机确认回调方法</span></span><br><span class="line"><span class="comment">     *  1.发消息 交换机成功接收 回调</span></span><br><span class="line"><span class="comment">     *      1.1 correlationData 保存回调消息的ID及相关消息</span></span><br><span class="line"><span class="comment">     *      1.2 ack = true  交换机收到消息</span></span><br><span class="line"><span class="comment">     *      1.3 cause = null  失败原因</span></span><br><span class="line"><span class="comment">     *  2.发消息 交换机接收失败 回调</span></span><br><span class="line"><span class="comment">     *      2.1 correlationData 保存回调消息的ID及相关消息</span></span><br><span class="line"><span class="comment">     *      2.2 ack = false  交换机未收到消息</span></span><br><span class="line"><span class="comment">     *      2.3 cause  失败原因</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> b, String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span>? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (b)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机收到ID为：&#123;&#125;的消息&quot;</span>,id);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机未收到ID为：&#123;&#125;的消息,失败原因为：&#123;&#125;&quot;</span>,id,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以在当消息传递过程中不可达目的地时将消息返回给生产者</span></span><br><span class="line"><span class="comment">     *  只有不可达目的地的时候 才进行回退</span></span><br><span class="line"><span class="comment">     * 当消息无法路由的时候的回调方法</span></span><br><span class="line"><span class="comment">     *  message      消息</span></span><br><span class="line"><span class="comment">     *  replyCode    编码</span></span><br><span class="line"><span class="comment">     *  replyText    退回原因</span></span><br><span class="line"><span class="comment">     *  exchange     从哪个交换机退回</span></span><br><span class="line"><span class="comment">     *  routingKey   通过哪个路由 key 退回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息&#123;&#125;,被交换机&#123;&#125;退回，退回原因:&#123;&#125;,路由key:&#123;&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>(returnedMessage.getMessage().getBody()),returnedMessage.getExchange(),</span><br><span class="line">                returnedMessage.getReplyText(),returnedMessage.getRoutingKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开浏览器访问地址：<a href="http://localhost:8888/confirm/sendMessage/%E5%A4%A7%E5%AE%B6%E5%A5%BD1">http://localhost:8080/confirm/sendMessage/大家好1(opens new window)</a></p><p><img src="/2022/04/03/RabbitMQ/image.6ag1qfe3xws0.webp" alt="image"></p><h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？</p><p>前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。</p><p>什么是备份交换机呢？备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，<strong>当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</strong></p><h4 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h4><p>需要一个备份交换机 <code>backup.exchange</code>，类型为 <code>fanout</code>，该交换机发送消息到队列 <code>backup.queue</code> 和 <code>warning.queue</code></p><p>代码结构图:</p><p><img src="/2022/04/03/RabbitMQ/image.109ugczigfdc.webp" alt="image"></p><h5 id="修改高级确认发布-配置类"><a href="#修改高级确认发布-配置类" class="headerlink" title="修改高级确认发布 配置类"></a><strong>修改高级确认发布 配置类</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 13:54</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 配置类 发布确认高级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备份交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备份队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 报警队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WARNING_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;warning_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * routingKey</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;key1&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME).durable(<span class="literal">true</span>)</span><br><span class="line">                .withArgument(<span class="string">&quot;alternate-exchange&quot;</span>,BACKUP_EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">backupExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(BACKUP_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;backupQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">backupQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">warningQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBindingExchange</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange,</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue</span></span><br><span class="line"><span class="params">    )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">backupQueueBindingBackupExchange</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange,</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;backupQueue&quot;)</span> Queue backupQueue</span></span><br><span class="line"><span class="params">    )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(backupQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">waringQueueBindingBackupExchange</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange,</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue warningQueue</span></span><br><span class="line"><span class="params">    )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(warningQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="报警消费者"><a href="#报警消费者" class="headerlink" title="报警消费者"></a>报警消费者</h5><p>备份队列相同，由于备份交换机是fanout模式，全部绑定队列都可以接收到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 16:13</span></span><br><span class="line"><span class="comment"> * 备份交换机 报警消息 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarningConsumer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收报警消息</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.WARNING_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveWarningMsg</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.error(<span class="string">&quot;报警发现不可路由的消息：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于之前写过 <code>confirm.exchange</code> 交换机，当更改配置了，需要删掉，不然会报错</p><p>打开浏览器访问地址：<a href="http://localhost:8888/confirm/sendMessage/%E5%A4%A7%E5%AE%B6%E5%A5%BD1">http://localhost:8080/confirm/sendMessage/大家好1(opens new window)</a></p><p><img src="/2022/04/03/RabbitMQ/image.42foi4mawzq0.webp" alt="image"></p><p>Mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是<strong>备份交换机优先级高</strong>。</p><h2 id="RabbitMQ-其他知识点"><a href="#RabbitMQ-其他知识点" class="headerlink" title="RabbitMQ 其他知识点"></a>RabbitMQ 其他知识点</h2><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等。</p><p>可以理解为验证码，只能输入一次，再次重新输入会刷新验证码，原来的验证码失效。</p><h4 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h4><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过。</p><h4 id="消费端的幂等性保障"><a href="#消费端的幂等性保障" class="headerlink" title="消费端的幂等性保障"></a>消费端的幂等性保障</h4><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性，这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。</p><p>业界主流的幂等性有两种操作：</p><ul><li>唯一 ID+ 指纹码机制,利用数据库主键去重</li></ul><p>指纹码：我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p><ul><li>Redis 的原子性</li></ul><p>利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费。</p><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧。</p><p>但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>Web页面添加</li></ul><p><img src="/2022/04/03/RabbitMQ/image.2xm08z870l40.webp" alt="image"></p><ol><li>进入 Web 页面，点击 Queue 菜单，然后点击 <code>Add a new queue</code></li><li>点击下方的 <code>Maximum priority</code></li><li>执行第二步，则会自动在 <code>Argument</code> 生成 <code>x-max-priority</code> 字符串</li><li>点击 <code>Add queue</code> 即可添加优先级队列成功</li></ol><ul><li>声明队列的时候添加优先级</li></ul><p><strong>设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU，值越大的优先级越高；</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">// 优先级为 10</span></span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意事项</p><p>队列实现优先级需要做的事情有如下：队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费，因为这样才有机会对消息进行排序</p></blockquote><h4 id="实战-3"><a href="#实战-3" class="headerlink" title="实战"></a>实战</h4><p>生产者发送十个消息，如果消息为 <code>info5</code>，则优先级是最高的，当消费者从队列获取消息的时候，优先获取 <code>info5</code> 消息</p><h5 id="生产者代码-1"><a href="#生产者代码-1" class="headerlink" title="生产者代码"></a>生产者代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 16:13</span></span><br><span class="line"><span class="comment"> * desc:优先级 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;priority_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给消息赋予一个priority属性</span></span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">1</span>).priority(<span class="number">10</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,properties,message.getBytes());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送完成：&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消费者代码-1"><a href="#消费者代码-1" class="headerlink" title="消费者代码"></a>消费者代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 16:13</span></span><br><span class="line"><span class="comment"> * desc:优先级 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;priority_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置队列的最大优先级 最大可以设置到255 官网推荐1-10 如果设置太高比较吃内存和CPU</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        params.put(<span class="string">&quot;x-max-priority&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,params);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//推送消息如何进行消费的接口回调</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt;&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;消费的消息: &quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a><strong>效果演示</strong></h5><p>info 5 的优先级为 10，优先级最高。消费者消费信息效果如图：</p><p><img src="/2022/04/03/RabbitMQ/image.3vjjukfu3r00.webp" alt="image"></p><h3 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h3><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。<strong>惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中</strong>，它的一个重要的设计目标是<strong>能够支持更长的队列，即支持更多的消息存储。</strong>当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p><p>默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。</p><h4 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h4><p>队列具备两种模式：default 和 lazy。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 <code>channel.queueDeclare</code> 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p><p>在队列声明的时候可以通过 <code>x-queue-mode</code> 参数来设置队列的模式，取值为 default 和 lazy。下面示例中演示了一个惰性队列的声明细节：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br></pre></td></tr></table></figure><p>也可以在 Web 页面添加队列时，选择 <code>Lazy mode</code></p><p><img src="/2022/04/03/RabbitMQ/image.m9m0vrilbw0.webp" alt="image"></p><h4 id="内存开销对比"><a href="#内存开销对比" class="headerlink" title="内存开销对比"></a>内存开销对比</h4><p><img src="/2022/04/03/RabbitMQ/image.18hc40o0ctcw.webp" alt="image"></p><p>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅占用 1.5MB</p><h2 id="RabbitMQ-集群"><a href="#RabbitMQ-集群" class="headerlink" title="RabbitMQ 集群"></a>RabbitMQ 集群</h2><h3 id="clustering"><a href="#clustering" class="headerlink" title="clustering"></a>clustering</h3><h4 id="使用集群的原因"><a href="#使用集群的原因" class="headerlink" title="使用集群的原因"></a>使用集群的原因</h4><p>最开始我们介绍了如何安装及运行 RabbitMQ 服务，不过这些是单机版的，无法满足目前真实应用的 要求。如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ 服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要 RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是 解决实际问题的关键。</p><h4 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><ul><li>克隆三个虚拟机，分别代表不同RabbitMQ主机机器</li></ul><p><img src="/2022/04/03/RabbitMQ/image-20220911132605357.png" alt="image-20220911132605357"></p><p><img src="/2022/04/03/RabbitMQ/image-20220911133334009.png" alt="image-20220911133334009"></p><ul><li>修改 3 台机器的主机名称 <code>vim /etc/hostname</code>，然后重启<code>reboot</code></li></ul><p><img src="/2022/04/03/RabbitMQ/image-20220911134601724.png" alt="image-20220911134601724"></p><ul><li>配置各个节点的 hosts 文件，让各个节点都能互相识别对方<code>vim /etc/hosts</code></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.182.128 node1</span><br><span class="line">192.168.182.130 node2</span><br><span class="line">192.168.182.131 node3</span><br></pre></td></tr></table></figure><p><img src="/2022/04/03/RabbitMQ/image-20220911135414547.png" alt="image-20220911135414547"></p><ul><li>以确保各个节点的 cookie 文件使用的是同一个值 <strong>在 node1 上执行远程操作命令</strong></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cookie</span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/.erlang.cookie</span><br></pre></td></tr></table></figure><p><img src="/2022/04/03/RabbitMQ/image-20220911135921495.png" alt="image-20220911135921495"></p><ul><li>启动 RabbitMQ 服务,顺带启动 Erlang 虚拟机和 RbbitMQ 应用服务(在三台节点上分别执行以 下命令) <code>rabbitmq-server -detached</code></li><li>在节点2  node2上执行</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重置</span></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入到node1节点中</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@node1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">rabbitmqctl start_app(只启动应用服务)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]# rabbitmq-server -detached</span><br><span class="line">[root@node2 ~]# rabbitmqctl stop_app</span><br><span class="line">Stopping rabbit application on node rabbit@node2 ...</span><br><span class="line">[root@node2 ~]# rabbitmqctl reset</span><br><span class="line">Resetting node rabbit@node2 ...</span><br><span class="line">[root@node2 ~]# rabbitmqctl join_cluster rabbit@node1</span><br><span class="line">Clustering node rabbit@node2 with rabbit@node1</span><br><span class="line">[root@node2 ~]# rabbitmqctl start_app</span><br><span class="line">Starting node rabbit@node2 ...</span><br><span class="line">[root@node2 ~]# </span><br></pre></td></tr></table></figure><ul><li>在节点3  node3上执行</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重置</span></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入到node1节点中</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@node2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">rabbitmqctl start_app(只启动应用服务)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node3 ~]# rabbitmqctl stop_app</span><br><span class="line">Stopping rabbit application on node rabbit@node3 ...</span><br><span class="line">[root@node3 ~]# rabbitmqctl reset</span><br><span class="line">Resetting node rabbit@node3 ...</span><br><span class="line">[root@node3 ~]# rabbitmqctl join_cluster rabbit@node2</span><br><span class="line">Clustering node rabbit@node3 with rabbit@node2</span><br><span class="line">[root@node3 ~]# rabbitmqctl start_app</span><br><span class="line">Starting node rabbit@node3 ...</span><br><span class="line">[root@node3 ~]# </span><br></pre></td></tr></table></figure><ul><li>查看集群状态（随便一个节点运行） <code>rabbitmqctl cluster_status</code></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># rabbitmqctl cluster_status</span></span><br><span class="line">Cluster status of node rabbit@node1 ...</span><br><span class="line">Basics</span><br><span class="line"></span><br><span class="line">Cluster name: rabbit@node1</span><br><span class="line"></span><br><span class="line">Disk Nodes</span><br><span class="line"></span><br><span class="line">rabbit@node1</span><br><span class="line">rabbit@node2</span><br><span class="line">rabbit@node3</span><br><span class="line"></span><br><span class="line">Running Nodes</span><br><span class="line"></span><br><span class="line">rabbit@node1</span><br><span class="line">rabbit@node2</span><br><span class="line">rabbit@node3</span><br><span class="line"></span><br><span class="line">Versions</span><br><span class="line"></span><br><span class="line">rabbit@node1: RabbitMQ 3.8.8 on Erlang 21.3</span><br><span class="line">rabbit@node2: RabbitMQ 3.8.8 on Erlang 21.3</span><br><span class="line">rabbit@node3: RabbitMQ 3.8.8 on Erlang 21.3</span><br><span class="line"></span><br><span class="line">Maintenance status</span><br><span class="line"></span><br><span class="line">Node: rabbit@node1, status: not under maintenance</span><br><span class="line">Node: rabbit@node2, status: not under maintenance</span><br><span class="line">Node: rabbit@node3, status: not under maintenance</span><br><span class="line"></span><br><span class="line">Alarms</span><br><span class="line"></span><br><span class="line">(none)</span><br><span class="line"></span><br><span class="line">Network Partitions</span><br><span class="line"></span><br><span class="line">(none)</span><br><span class="line"></span><br><span class="line">Listeners</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Feature flags</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">[root@node1 ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure><ul><li>需要重新设置用户（随便一个节点运行）</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建账号</span> </span><br><span class="line">rabbitmqctl add_user admin 123456</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置用户角色</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置用户权限</span></span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><ul><li>登录查看<a href="http://192.168.182.128:15672/#/%E6%88%96%E8%80%85http://192.168.182.130:15672/#/%E6%88%96%E8%80%85http://192.168.182.131:15672/#/%E9%9A%8F%E4%BE%BF%E4%B8%80%E4%B8%AA%E5%B0%B1%E5%8F%AF%E4%BB%A5">http://192.168.182.128:15672/#/或者http://192.168.182.130:15672/#/或者http://192.168.182.131:15672/#/随便一个就可以</a></li></ul><p><img src="/2022/04/03/RabbitMQ/image-20220911141520537.png" alt="image-20220911141520537"></p><ul><li>解除集群节点(node2 和 node3 机器分别执行)</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在node2和node3上执行</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app rabbitmqctl cluster_status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在node1机器上执行</span></span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@node2</span><br></pre></td></tr></table></figure><h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><h4 id="使用镜像的原因"><a href="#使用镜像的原因" class="headerlink" title="使用镜像的原因"></a>使用镜像的原因</h4><p>如果 RabbitMQ 集群中只有一个 Broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并 且也可能会导致消息的丢失。可以将所有消息都设置为持久化，并且对应队列的durable属性也设置为true，但 是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘时执行刷盘动作之间存在一 个短暂却可能会产生问题的时间窗。通过 publisherconfirm 机制能够确保客户端知道哪些消息己经存入磁盘，尽 管如此，一般不希望遇到因单点故障导致的服务不可用。</p><p>引入镜像队列(Mirror Queue)的机制，可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中 的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。</p><h4 id="搭建步骤-1"><a href="#搭建步骤-1" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><p>​1.启动三台集群节点</p><p>​2.添加 policy</p><p><img src="/2022/04/03/RabbitMQ/image-20220911144013368.png" alt="image-20220911144013368"></p><p><img src="/2022/04/03/RabbitMQ/image-20220911150353066.png" alt="image-20220911150353066"></p><p>从界面上可以非常直观的看到一个Policy需要的元素：</p><ul><li>Name: 这个Policy的名称</li><li>Pattern: Policy根据正则表达式去匹配Queues&#x2F;Exchanges名称</li><li>Apply to: 这个Policy对Queue还是对Exchange生效，或者两者都适用</li><li>Priority: 优先级。</li><li>Definition: 添加的args，KV键值对。</li></ul><p>Definition 可添加的args参考以下文档：</p><ul><li><a href="https://www.rabbitmq.com/queues.html#properties">Queue Properties</a></li><li><a href="https://www.rabbitmq.com/dlx.html">Dead Letter Exchanges</a></li><li><a href="https://www.rabbitmq.com/parameters.html#policies">Parameters and Policies</a></li></ul><p>​3.添加成功</p><p><img src="/2022/04/03/RabbitMQ/image-20220911150518540.png" alt="image-20220911150518540"></p><p>​4.在 node1 上创建一个队列发送一条消息，队列存在镜像队列</p><p><img src="/2022/04/03/RabbitMQ/image-20220911150609715.png" alt="image-20220911150609715"></p><p><img src="/2022/04/03/RabbitMQ/image-20220911150634235.png" alt="image-20220911150634235"></p><p>​5.停掉 node1 之后发现 node2 成为镜像队列<code>rabbitmqctl stop_app</code></p><p><img src="/2022/04/03/RabbitMQ/image-20220911150805804.png" alt="image-20220911150805804"></p><p><img src="/2022/04/03/RabbitMQ/image-20220911150826100.png" alt="image-20220911150826100"></p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>就算整个集群只剩下一台机器了，依然能消费队列里面的消息，说明队列里面的消息被镜像队列传递到相应机器里面了。</p><h3 id="Haproxy-Keepalive-实现高可用负载均衡"><a href="#Haproxy-Keepalive-实现高可用负载均衡" class="headerlink" title="Haproxy+Keepalive 实现高可用负载均衡"></a>Haproxy+Keepalive 实现高可用负载均衡</h3><h4 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h4><p><img src="/2022/04/03/RabbitMQ/image-20220911164140367.png" alt="image-20220911164140367"></p><h4 id="Haproxy-实现负载均衡"><a href="#Haproxy-实现负载均衡" class="headerlink" title="Haproxy 实现负载均衡"></a>Haproxy 实现负载均衡</h4><p>HAProxy 提供高可用性、负载均衡及基于TCPHTTP 应用的代理，支持虚拟主机，它是免费、快速并 且可靠的一种解决方案，包括 Twitter,Reddit,StackOverflow,GitHub 在内的多家知名互联网公司在使用。 HAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数。 </p><p>扩展 nginx,lvs,haproxy 之间的区别: <a href="http://www.ha97.com/5646.html">http://www.ha97.com/5646.html</a></p><h5 id="搭建步骤-2"><a href="#搭建步骤-2" class="headerlink" title="搭建步骤"></a>搭建步骤</h5><ol><li>下载 haproxy(在 node1 和 node2)<code>yum -y install haproxy</code></li><li>修改 node1 和 node2 的 haproxy.cfg</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/haproxy/haproxy.cfg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line">        server  rabbitmq_node1 192.168.182.128:5672 check inter 5000 rise 2 fall 3 weight 1</span><br><span class="line">    server  rabbitmq_node2 192.168.182.130:5672 check inter 5000 rise 2 fall 3 weight 1</span><br><span class="line">    server  rabbitmq_node3 192.168.182.131:5672 check inter 5000 rise 2 fall 3 weight 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>3. 在两台节点启动 haproxy</code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">haproxy -f /etc/haproxy/haproxy.cfg</span><br><span class="line">ps -ef | grep haproxy</span><br></pre></td></tr></table></figure><pre><code>4. 访问地址http://192.168.182.128:8888/stats</code></pre><h4 id="Keepalived-实现双机-主备-热备"><a href="#Keepalived-实现双机-主备-热备" class="headerlink" title="Keepalived 实现双机(主备)热备"></a>Keepalived 实现双机(主备)热备</h4><p>试想如果前面配置的 HAProxy 主机突然宕机或者网卡失效，那么虽然 RbbitMQ 集群没有任何故障但是 对于外界的客户端来说所有的连接都会被断开结果将是灾难性的为了确保负载均衡服务的可靠性同样显得 十分重要，这里就要引入 Keepalived 它能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现 故障转移。</p><h5 id="搭建步骤-3"><a href="#搭建步骤-3" class="headerlink" title="搭建步骤"></a>搭建步骤</h5><ol><li>下载 keepalived<code>yum -y install keepalived</code></li><li>节点 node1 配置文件 <ol><li><code>vim /etc/keepalived/keepalived.conf </code>把资料里面的 keepalived.conf 修改之后替换</li></ol></li><li>节点 node2 配置文件 <ol><li>需要修改global_defs 的 router_id,如:nodeB </li><li>其次要修改 vrrp_instance_VI 中 state 为”BACKUP”； </li><li>最后要将priority 设置为小于 100 的值</li></ol></li><li>添加 haproxy_chk.sh (为了防止 HAProxy 服务挂掉之后 Keepalived 还在正常工作而没有切换到 Backup 上，所以这里需要编写一个脚本来检测 HAProxy 务的状态,当 HAProxy 服务挂掉之后该脚本会自动重启 HAProxy 的服务，如果不成功则关闭 Keepalived 服务，这样便可以切换到 Backup 继续工作)</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/keepalived/haproxy_chk.sh(可以直接上传文件)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改权限</span> </span><br><span class="line">chmod 777 /etc/keepalived/haproxy_chk.sh</span><br></pre></td></tr></table></figure><ol start="5"><li><p>启动 keepalive 命令(node1 和 node2 启动)</p><p><code>systemctl start keepalived</code></p></li><li><p>观察 Keepalived 的日志</p><p><code>tail -f /var/log/messages -n 200</code></p></li><li><p>观察最新添加的 vip</p><p><code>ip add show</code></p></li><li><p>node1 模拟 keepalived 关闭状态</p><p><code>systemctl stop keepalived</code></p></li></ol><p>​9. 使用 vip 地址来访问 rabbitmq 集群</p><h3 id="Federation-Exchange（联邦交换机）"><a href="#Federation-Exchange（联邦交换机）" class="headerlink" title="Federation Exchange（联邦交换机）"></a>Federation Exchange（联邦交换机）</h3><h4 id="使用它的原因"><a href="#使用它的原因" class="headerlink" title="使用它的原因"></a>使用它的原因</h4><p>​(broker 北京)，(broker 深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题。有一个在北京 的业务(Client 北京) 需要连接(broker 北京)，向其中的交换器 exchangeA 发送消息，此时的网络延迟很小， (Client 北京)可以迅速将消息发送至 exchangeA 中，就算在开启了 publisherconfirm 机制或者事务机制的情 况下，也可以迅速收到确认信息。此时又有个在深圳的业务(Client 深圳)需要向 exchangeA 发送消息， 那 么(Client 深圳) (broker 北京)之间有很大的网络延迟，(Client 深圳) 将发送消息至 exchangeA 会经历一定 的延迟，尤其是在开启了 publisherconfirm 机制或者事务机制的情况下，(Client 深圳) 会等待很长的延迟 时间来接收(broker 北京)的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的阻 塞。</p><p>​ 将业务(Client 深圳)部署到北京的机房可以解决这个问题，但是如果业务(Client 深圳)调用的另些服务又部署在深圳，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？ 这里 使用 Federation 插件就可以很好地解决这个问题。</p><p><img src="/2022/04/03/RabbitMQ/image-20220911152414312.png" alt="image-20220911152414312"></p><h4 id="搭建步骤-4"><a href="#搭建步骤-4" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><ol><li><p>需要保证每台节点单独运行</p></li><li><p>在每台机器上开启 federation 相关插件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_federation</span><br><span class="line">rabbitmq-plugins enable rabbitmq_federation_management</span><br></pre></td></tr></table></figure></li><li><p>原理图(先运行 consumer 在 node2 创建 fed_exchange)</p><p>通过把node1节点（上游）数据同步到node2（下游），下游必须拥有一个交换机才可以进行同步。</p><p><img src="/2022/04/03/RabbitMQ/image-20220911152539898.png" alt="image-20220911152539898"></p><p>在node2上声明一个路由交换机，绑定一个队列</p><p><img src="/2022/04/03/RabbitMQ/image-20220911155943875.png" alt="image-20220911155943875"></p></li><li><p>在 downstream(下游节点node2)配置 upstream(上游节点node1)地址</p></li></ol><p><img src="/2022/04/03/RabbitMQ/image-20220911161415498.png" alt="image-20220911161415498"></p><pre><code>5. 添加 polic</code></pre><p><img src="/2022/04/03/RabbitMQ/image-20220911160344287.png" alt="image-20220911160344287"></p><pre><code>6. 成功</code></pre><p><img src="/2022/04/03/RabbitMQ/image-20220911160506465.png" alt="image-20220911160506465"></p><p><img src="/2022/04/03/RabbitMQ/image-20220911160625495.png" alt="image-20220911160625495"></p><h3 id="Federation-Queue（联邦队列）"><a href="#Federation-Queue（联邦队列）" class="headerlink" title="Federation Queue（联邦队列）"></a>Federation Queue（联邦队列）</h3><h4 id="使用它的原因-1"><a href="#使用它的原因-1" class="headerlink" title="使用它的原因"></a>使用它的原因</h4><p>联邦队列可以在多个 Broker 节点(或者集群)之间为单个队列提供均衡负载的功能。一个联邦队列可以 连接一个或者多个上游队列(upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息 的需求。</p><h4 id="搭建步骤-5"><a href="#搭建步骤-5" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><ol><li>原理图</li></ol><p><img src="/2022/04/03/RabbitMQ/image-20220911162153372.png" alt="image-20220911162153372"></p><pre><code>2. 添加 upstream(同上)2. 添加 policy</code></pre><p><img src="/2022/04/03/RabbitMQ/image-20220911162258179.png" alt="image-20220911162258179"></p><pre><code>4. 结果</code></pre><p><img src="/2022/04/03/RabbitMQ/image-20220911162338673.png" alt="image-20220911162338673"></p><h3 id="Shovel"><a href="#Shovel" class="headerlink" title="Shovel"></a>Shovel</h3><h4 id="使用它的原因-2"><a href="#使用它的原因-2" class="headerlink" title="使用它的原因"></a>使用它的原因</h4><p>Federation 具备的数据转发功能类似，Shovel 够可靠、持续地从一个 Broker 中的队列(作为源端，即 source)拉取数据并转发至另一个 Broker 中的交换器(作为目的端，即 destination)。作为源端的队列和作为 目的端的交换器可以同时位于同一个 Broker，也可以位于不同的 Broker 上。Shovel 可以翻译为”铲子”，是 一种比较形象的比喻，这个”铲子”可以将消息从一方”铲子”另一方。Shovel 行为就像优秀的客户端应用程 序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。</p><h4 id="搭建步骤-6"><a href="#搭建步骤-6" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><ol><li>开启插件(需要的机器都开启)</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_shovel</span><br><span class="line">rabbitmq-plugins enable rabbitmq_shovel_management</span><br></pre></td></tr></table></figure><pre><code>2. 原理图(在源头发送的消息直接回进入到目的地队列)</code></pre><p><img src="/2022/04/03/RabbitMQ/image-20220911162451227.png" alt="image-20220911162451227"></p><ol start="3"><li><p>添加 shovel 源和目的地</p><p>将Q1（源端）数据同步到Q2（目的端）</p></li></ol><p><img src="/2022/04/03/RabbitMQ/image-20220911163757452.png" alt="image-20220911163757452"></p><pre><code>4. 成功</code></pre><p><img src="/2022/04/03/RabbitMQ/image-20220911164019286.png" alt="image-20220911164019286"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2022/03/07/redis/"/>
      <url>/2022/03/07/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="NoSQL数据库简介"><a href="#NoSQL数据库简介" class="headerlink" title="NoSQL数据库简介"></a>NoSQL数据库简介</h2><h3 id="技术的发展"><a href="#技术的发展" class="headerlink" title="技术的发展"></a>技术的发展</h3><p><img src="/2022/03/07/redis/1657174853444.jpg" alt="1657174853444"></p><h4 id="解决CPU和内存"><a href="#解决CPU和内存" class="headerlink" title="解决CPU和内存"></a>解决CPU和内存</h4><p><img src="/2022/03/07/redis/1657175933991.jpg" alt="1657175933991"></p><h4 id="减少IO压力"><a href="#减少IO压力" class="headerlink" title="减少IO压力"></a>减少IO压力</h4><p><img src="/2022/03/07/redis/1657176255948.jpg" alt="1657176255948"></p><h3 id="NoSQL数据库概述"><a href="#NoSQL数据库概述" class="headerlink" title="NoSQL数据库概述"></a>NoSQL数据库概述</h3><p><img src="/2022/03/07/redis/1657176449654.jpg" alt="1657176449654"></p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>对数据高并发的读写</li><li>海量数据的读写</li><li>对数据高可扩展性的</li></ul><h3 id="常见数据库"><a href="#常见数据库" class="headerlink" title="常见数据库"></a>常见数据库</h3><h4 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h4><p><img src="/2022/03/07/redis/1657176764334.jpg" alt="1657176764334"></p><h4 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h4><p><img src="/2022/03/07/redis/1657176817643.jpg" alt="1657176817643"></p><h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><p><img src="/2022/03/07/redis/1657176860593.jpg" alt="1657176860593"></p><h3 id="行式存储数据库（大数据时代）"><a href="#行式存储数据库（大数据时代）" class="headerlink" title="行式存储数据库（大数据时代）"></a>行式存储数据库（大数据时代）</h3><h4 id="行式数据库"><a href="#行式数据库" class="headerlink" title="行式数据库"></a>行式数据库</h4><p><img src="/2022/03/07/redis/1657177074951.jpg" alt="1657177074951"></p><h4 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h4><p><img src="/2022/03/07/redis/1657177121445.jpg" alt="1657177121445"></p><h2 id="Redis-概述"><a href="#Redis-概述" class="headerlink" title="Redis 概述"></a>Redis 概述</h2><h3 id="Redis-介绍"><a href="#Redis-介绍" class="headerlink" title="Redis 介绍"></a>Redis 介绍</h3><ul><li>Redis 是一个开源的 key-value 存储系统。</li><li>和 Memcached 类似，它支持存储的 value 类型相对更多，包括 string (字符串)、list (链表)、set (集合)、zset (sorted set –有序集合) 和 hash（哈希类型）。</li><li>这些数据类型都支持 push&#x2F;pop、add&#x2F;remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li><li>在此基础上，Redis 支持各种不同方式的排序。</li><li>与 memcached 一样，为了保证效率，数据都是缓存在内存中。</li><li>区别的是 Redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</li><li>并且在此基础上实现了 master-slave (主从) 同步。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="配合关系型数据库做高速缓存"><a href="#配合关系型数据库做高速缓存" class="headerlink" title="配合关系型数据库做高速缓存"></a>配合关系型数据库做高速缓存</h4><ul><li><p>高频次，热门访问的数据，降低数据库 IO。</p></li><li><p>分布式架构，做 session 共享。</p><p><img src="/2022/03/07/redis/image-20210618160003509.jpg" alt="image-20210618160003509"></p></li></ul><h4 id="多样的数据结构存储持久化数据"><a href="#多样的数据结构存储持久化数据" class="headerlink" title="多样的数据结构存储持久化数据"></a>多样的数据结构存储持久化数据</h4><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210618160101040.jpg" alt="image-20210618160101040"></p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ul><li><p>官网下载Redis压缩包</p></li><li><p>复制到Linux系统中（如CenOS7）</p></li><li><p><img src="/2022/03/07/redis/1657178006389.jpg" alt="1657178006389"></p></li><li><p>下载gcc编译环境（yum install gcc）</p></li><li><p>加入文件，用make命令进行编译</p><ul><li><p>发生以下错误：检查gcc是否安装成功（gcc –version）；make distclean；make。</p><p><img src="/2022/03/07/redis/1657178265646.jpg" alt="1657178265646"></p></li></ul></li><li><p>make install进行安装，安装目录为&#x2F;usr&#x2F;local&#x2F;bin</p><p><img src="/2022/03/07/redis/1657178967469.jpg" alt="1657178967469"></p></li><li><p><img src="/2022/03/07/redis/1657179060240.jpg" alt="1657179060240"></p></li></ul><h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><h4 id="前台启动（不推荐）"><a href="#前台启动（不推荐）" class="headerlink" title="前台启动（不推荐）"></a>前台启动（不推荐）</h4><ul><li><p>redis-server命令（界面不能进行其他操作，不能关闭）</p><p><img src="/2022/03/07/redis/1657179347546.jpg" alt="1657179347546"></p></li></ul><h4 id="后台启动（推荐）"><a href="#后台启动（推荐）" class="headerlink" title="后台启动（推荐）"></a>后台启动（推荐）</h4><ul><li><p>进入redis目录，拷贝redis.conf到etc中</p><p><img src="/2022/03/07/redis/1657179826095.jpg" alt="1657179826095"></p></li><li><p>在etc文件中进入redis.conf将后台启动设置daemonize no改为yes（vi redis.conf；esc+&#x2F;进行查找；i键进行修改；shift+: wq!保存退出）</p></li><li><p>进入&#x2F;usr&#x2F;local&#x2F;bin下运行redis-server &#x2F;etc&#x2F;redis.conf</p><p><img src="/2022/03/07/redis/1657180827921.jpg" alt="1657180827921"></p></li><li><p>ps -ef | grep redis查看端口为127.0.0.1:6379</p><p><img src="/2022/03/07/redis/1657180934974.jpg" alt="1657180934974"></p></li><li><p><img src="/2022/03/07/redis/1657181083173.jpg" alt="1657181083173"></p></li><li><p><img src="/2022/03/07/redis/1657181192969.jpg" alt="1657181192969"></p></li></ul><h3 id="Redis相关知识"><a href="#Redis相关知识" class="headerlink" title="Redis相关知识"></a>Redis相关知识</h3><p><img src="/2022/03/07/redis/1657181475933.jpg" alt="1657181475933"></p><h4 id="Redis-使用的是单线程-多路-IO-复用技术："><a href="#Redis-使用的是单线程-多路-IO-复用技术：" class="headerlink" title="Redis 使用的是单线程 + 多路 IO 复用技术："></a>Redis 使用的是单线程 + 多路 IO 复用技术：</h4><p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用 select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p><p><img src="/2022/03/07/redis/1657182139417.jpg" alt="1657182139417"></p><p>** 串行 vs 多线程 + 锁（memcached） vs 单线程 + 多路 IO 复用 (Redis)**（与 Memcache 三点不同：支持多数据类型，支持持久化，单线程 + 多路 IO 复用） 。</p><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><h3 id="Redis键（key）"><a href="#Redis键（key）" class="headerlink" title="Redis键（key）"></a>Redis键（key）</h3><ul><li>keys * 查看当前库所有key（匹配：key *1）</li><li>exists key 判断某个key是否存在</li><li>type key 查看你的key是什么类型</li><li>del key 删除指定的key数据</li><li>unlink key 根据value选择非阻塞删除（仅将key从keyspace元数据中删除，真正的删除会在后续异步操作）</li><li>expire key 10 10秒钟：为给点的key设置过期时间</li><li>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li><li>select命令切换数据库</li><li>dbsize查看当前数据库的key的数量</li><li>flushdb清空当前库</li><li>flushall通杀全部库</li></ul><h3 id="Redis-字符串-String"><a href="#Redis-字符串-String" class="headerlink" title="Redis 字符串 (String)"></a>Redis 字符串 (String)</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li><p>String 是 Redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p></li><li><p>String 类型是二进制安全的。意味着 Redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。</p></li><li><p>String 类型是 Redis 最基本的数据类型，一个 Redis 中字符串 value 最多可以是 512M。</p></li></ul><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><p>set key value 添加键值对mset key value key value  同时设置多个值</p><p><img src="/2022/03/07/redis/1657183465154.jpg" alt="1657183465154"></p></li><li><p>get key 查看key的值     mget key key  同时获取多个值</p></li><li><p>append key value 追加内容</p></li><li><p>strlen key 获取长度</p></li><li><p>setnx key value  只有key不存在时，才添加数据     setnx key value key value</p></li><li><p>incr key 储存的数字加一</p></li><li><p>decr key 储存的数字减一</p></li><li><p>incrby（原子性）&#x2F;decrby key 长度  储存的数字加上长度</p></li><li><p>getrange key 起始位置 结束位置   获取范围内的值</p></li><li><p>setrange key 起始位置 value 覆盖从起始位置开始的值</p></li><li><p>setex key 过期时间 value  设置值同时设置过期时间</p></li><li><p>getset key value  设置新值同时获得旧值</p></li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>String 的数据结构为简单动态字符串 (Simple Dynamic String, 缩写 SDS)，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p><p><img src="/2022/03/07/redis/1657185047661.jpg" alt="1657185047661"></p><p>如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p><h3 id="Redis-列表（List"><a href="#Redis-列表（List" class="headerlink" title="Redis 列表（List)"></a>Redis 列表（List)</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>单键多值：Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><p><img src="/2022/03/07/redis/1657185177487.jpg" alt="1657185177487"></p><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>lpush&#x2F;rpush key value value   从左边或右边插入多个值</li><li>lpop&#x2F;rpop key   从左边或右边吐出一个值（值在键在，值完键亡）</li><li>rpoplpush key key 从key1列表右边吐出一个值，插入到key2列表的左边</li><li>lrange key start stop  按照索引下标获得元素（从左到右，0(左边第一个) -1(右边第一个)表示取所有值）</li><li>lindex key index 按照索引下标获取元素（从左到右）</li><li>llen key 获取列表长度</li><li>linsert key before&#x2F;after value newvalue  在value的之前&#x2F;之后加入新值</li><li>lrem key n value 从左边删除n个value值</li><li>lset key index value  将列表key下标为index的值替换为value</li></ul><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p>List 的数据结构为快速链表 quickList。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表。</p><p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p><p>当数据量比较多的时候才会改成 quicklist。</p><p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next。</p><p><img src="/2022/03/07/redis/1657186636918.jpg" alt="1657186636918"><br>Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h3 id="Redis-集合（Set）"><a href="#Redis-集合（Set）" class="headerlink" title="Redis 集合（Set）"></a>Redis 集合（Set）</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>Redis set 对外提供的功能与 list 类似，是一个列表的功能，特殊之处在于 set 是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。</p><p>Redis 的 Set 是 string 类型的无序集合。它底层其实是一个 value 为 null 的 hash 表，所以添加，删除，查找的 ** 复杂度都是 O (1)**。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是 O (1)，数据增加，查找数据的时间不变。</p><h4 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>sadd key value value  添加元素(member)，重复元素只添加一次</li><li>smembers key 取出该集合的所有值</li><li>sismember key value 判断集合key是否含有该value值</li><li>scard key 返回集合元素个数</li><li>srem key value value 删除元素</li><li>spop key 随机吐出一个值</li><li>srandmember key n 随机取出n个值，不会删除</li><li>smove source destination value  把source集合中的一个值移动到另一个destination 集合</li><li>sinter key key  返回俩个集合的交集元素</li><li>sunion key key 返回俩个集合的并集元素</li><li>sdiff key1 key2 返回俩个集合的差集元素（key1中的，不包含key2中的）</li></ul><h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><p>Set 数据结构是 dict 字典，字典是用哈希表实现的。<br>Java 中 HashSet 的内部实现使用的是 HashMap，只不过所有的 value 都指向同一个对象。Redis 的 set 结构也是一样，它的内部也使用 hash 结构，所有的 value 都指向同一个内部值。</p><h3 id="Redis-哈希（Hash）"><a href="#Redis-哈希（Hash）" class="headerlink" title="Redis 哈希（Hash）"></a>Redis 哈希（Hash）</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ul><li><p>Redis hash 是一个键值对集合。</p></li><li><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。类似 Java 里面的 Map&lt;String,Object&gt;。</p></li><li><p>用户 ID 为查找的 key，存储的 value 用户对象包含姓名，年龄，生日等信息，如果用普通的 key&#x2F;value 结构来存储，主要有以下 2 种存储方式：</p><p><img src="/2022/03/07/redis/1657196329468.jpg" alt="1657196329468"></p><ul><li>​方法一：每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。</li></ul><p><img src="/2022/03/07/redis/image-20210618203434868-1657195804960.jpg" alt="image-20210618203434868"></p><ul><li>​方法二：用户 ID 数据冗余。</li></ul><p><img src="/2022/03/07/redis/image-20210618203449210-1657195851309.jpg" alt="image-20210618203449210"></p><p>通过 key (用户 ID) + field (属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。</p><p><img src="/2022/03/07/redis/image-20210618203718979.jpg" alt="image-20210618203718979"></p></li></ul><h4 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>hset key field value 给field赋值value</li><li>hget key1 field 从集合中取field的value</li><li>hmset key1 field1 value1 field2 value2  批量设置hash的值</li><li>hexists key1 field 查看哈希表key中，field是否存在</li><li>hkeys key 所有的field</li><li>hvals key 所有的value</li><li>hincrby key field increment 为哈希表key中的field的值加上增量 increment </li><li>hsetnx key field value 当field不存在时，将哈希表key中的域field值设置为value</li></ul><h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><p>Hash 类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当 field-value 长度较短且个数较少时，使用 ziplist，否则使用 hashtable。</p><h3 id="Redis-有序集合-Zset（Sorted-set）"><a href="#Redis-有序集合-Zset（Sorted-set）" class="headerlink" title="Redis 有序集合 Zset（Sorted set）"></a>Redis 有序集合 Zset（Sorted set）</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><ul><li><p>Redis 有序集合 zset 与普通集合 set 非常相似，是一个没有重复元素的字符串集合。</p></li><li><p>不同之处是有序集合的每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p></li><li><p>因为元素是有序的，所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p></li><li><p>访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复成员的智能列表。</p></li></ul><h4 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><p>zadd key score value score value  添加数据</p></li><li><p>zrange key start stop [WITHSCORES]   返回下标在start，stop之间的元素，带WITHSCORES让分数和值一起返回</p></li><li><p>zrangebyscore key min max [WITHSCORES] [limit offset count]  返回min和max之间的值，按score值递增排序（从小到大）</p></li><li><p>zrevrangebyscore key max min [withscores] [limit offset count]  同上，改为从大到小排序</p></li><li><p>zincrby key increment value  为value的score加上增量increment</p></li><li><p>zrem key value 删除指定value</p></li><li><p>acount key min max  统计该集合区间内元素个数</p></li><li><p>zrank key value 返回该值在集合中的排名，从0开始</p><p><img src="/2022/03/07/redis/1657198860494.jpg" alt="1657198860494"></p></li></ul><h4 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h4><p>SortedSet (zset) 是 Redis 提供的一个非常特别的数据结构，一方面它等价于 Java 的数据结构 Map&lt;String, Double&gt;，可以给每一个元素 value 赋予一个权重 score，另一方面它又类似于 TreeSet，内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过 score 的范围来获取元素的列表。</p><p>zset 底层使用了两个数据结构：</p><ul><li><p>hash，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。</p></li><li><p>跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。</p></li></ul><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis 采用的是跳跃表，跳跃表效率堪比红黑树，实现远比红黑树简单。</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>对比有序链表和跳跃表，从链表中查询出 51：</p><ul><li><p>有序链表</p><p><img src="/2022/03/07/redis/image-20210618205641992.jpg" alt="image-20210618205641992"></p><p> 要查找值为 51 的元素，需要从第一个元素开始依次查找、比较才能找到。共需要 6 次比较。</p></li><li><p>跳跃表</p><p><img src="/2022/03/07/redis/image-20210618205920332.jpg" alt="image-20210618205920332"></p><ul><li>从第 2 层开始，1 节点比 51 节点小，向后比较；</li><li>21 节点比 51 节点小，继续向后比较，后面就是 NULL 了，所以从 21 节点向下到第 1 层；</li><li>在第 1 层，41 节点比 51 节点小，继续向后，61 节点比 51 节点大，所以从 41 向下；</li><li>在第 0 层，51 节点为要查找的节点，节点被找到，共查找 4 次。</li></ul></li></ul><p>从此可以看出跳跃表比有序链表效率要高。</p><h3 id="Redis-Bitmaps"><a href="#Redis-Bitmaps" class="headerlink" title="Redis Bitmaps"></a>Redis Bitmaps</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><img src="/2022/03/07/redis/1657262513534.jpg" alt="1657262513534"></p><p>Redis 提供了 Bitmaps 这个 “数据类型” 可以实现对位的操作：</p><ul><li><p>Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</p></li><li><p>Bitmaps 单独提供了一套命令， 所以在 Redis 中使用 Bitmaps 和使用字符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组， 数组的每个单元只能存储 0 和 1， 数组的下标在 Bitmaps 中叫做偏移量。</p><p><img src="/2022/03/07/redis/1657262396741.jpg" alt="1657262396741"></p></li></ul><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ul><li><p>setbit key offset value  设置BItmaps中某个偏移量offset的值（0或1）</p><p><img src="/2022/03/07/redis/1657262674768.jpg" alt="1657262674768"></p></li><li><p>gitbit key offset  获取BItmaps中某个偏移量的值</p></li><li><p>btcount key [start  end]  统计start到end之间字符串设置为1的bit数（-1表示最后一位，-2表示倒数第二位）</p><p><img src="/2022/03/07/redis/1657263227467.jpg" alt="1657263227467"></p></li><li><p>bittop and(or&#x2F;not&#x2F;xor) destkey [key…]   将多个Bitmaps的and（交集）、or（并集）、not（非）、xor（异或）操作结果保存在destkey中</p></li></ul><h4 id="Bitmaps-与-set-对比"><a href="#Bitmaps-与-set-对比" class="headerlink" title="Bitmaps 与 set 对比"></a>Bitmaps 与 set 对比</h4><p>假设网站有 1 亿用户， 每天独立访问的用户有 5 千万， 如果每天用集合类型和 Bitmaps 分别存储活跃用户可以得到表：</p><table><thead><tr><th>set 和 Bitmaps 存储一天活跃用户对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>每个用户 id 占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合</td><td>64位</td><td>50000000</td><td>64 位 * 50000000 &#x3D; 400MB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1 位 * 100000000 &#x3D; 12.5MB</td></tr></tbody></table><p>很明显， 这种情况下使用 Bitmaps 能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的。</p><table><thead><tr><th>set 和 Bitmaps 存储独立用户空间对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>一天</td><td>一个月</td><td>一年</td></tr><tr><td>集合</td><td>400MB</td><td>12GB</td><td>144GB</td></tr><tr><td>Bitmaps</td><td>12.5MB</td><td>375MB</td><td>4.5GB</td></tr></tbody></table><p>但 Bitmaps 并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有 10 万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用 Bitmaps 就不太合适了， 因为基本上大部分位都是 0。</p><table><thead><tr><th>set 和 Bitmaps 存储一天活跃用户对比（独立用户比较少）</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>每个 userid 占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合</td><td>64 位</td><td>100000</td><td>64 位 * 100000 &#x3D; 800KB</td></tr><tr><td>Bitmaps</td><td>1 位</td><td>100000000</td><td>1 位 * 100000000 &#x3D; 12.5MB</td></tr></tbody></table><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV（PageView 页面访问量），可以使用 Redis 的 incr、incrby 轻松实现。但像 UV（UniqueVisitor 独立访客）、独立 IP 数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p><p>解决基数问题有很多种方案：</p><ul><li><p>数据存储在 MySQL 表中，使用 distinct count 计算不重复个数。</p></li><li><p>使用 Redis 提供的 hash、set、bitmaps 等数据结构来处理。</p></li></ul><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p><p>能否能够降低一定的精度来平衡存储空间？Redis 推出了 HyperLogLog。</p><ul><li><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p></li><li><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p></li><li><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p></li></ul><p>什么是基数？</p><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}，那么这个数据集的基数集为 {1, 3, 5 ,7, 8}，基数个数(不重复元素) 为 5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><ul><li>pfadd key element [element…]   添加元素到HYperLogLog中</li><li>pfcount key [key…]  计算HLL的基数数量，可以计算多个HLL，如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</li><li>pfmerge destkey sourcekey [sourcekey]   将一个或多个HLL合并后的结果存储在另一个HLL（destkey ）中</li></ul><h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>Redis 3.2 中增加了对 GEO 类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的 2 维坐标，在地图上就是经纬度。redis 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度 Hash 等常见操作。</p><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><ul><li>geoadd key longitude latitude member [longitude latitude member]   添加地理位置（经度，纬度，名称）</li><li>geopos key member [member…]     获取地区的坐标值</li><li>geodist key member1 member2 [m|km|ft（英尺）|mi（英里）]  获取两个位置之间的直线距离（默认为米）</li><li>georadius key longitude(经度) latitude(纬度) radius m|km|ft|mi    以给点的经纬度为中心，找出某一半径内的元素</li></ul><h2 id="Redis配置文件介绍"><a href="#Redis配置文件介绍" class="headerlink" title="Redis配置文件介绍"></a>Redis配置文件介绍</h2><h3 id="Units单位"><a href="#Units单位" class="headerlink" title="Units单位"></a>Units单位</h3><p>配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit，大小写不敏感</p><h3 id="Includes包含"><a href="#Includes包含" class="headerlink" title="Includes包含"></a>Includes包含</h3><p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p><h3 id="网络相关配置"><a href="#网络相关配置" class="headerlink" title="网络相关配置"></a>网络相关配置</h3><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>默认情况bind&#x3D;127.0.0.1只能接受本机的访问请求</p><p>不写的情况下，无限制接受任何ip地址的访问</p><h4 id="protected-mode"><a href="#protected-mode" class="headerlink" title="protected-mode"></a>protected-mode</h4><p>本机访问保护模式设置no，支持远程访问</p><p>如果开启了protected-mode（yes），那么在没有设定bind ip且没有设密码的情况下，Redis只接受本机的访问</p><h4 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h4><p>端口号，默认为6379</p><h4 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h4><p>默认为511。</p><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和&#x3D;未完成三次握手队列+已经完成三次握手队列。</p><p>在高并发环境下需要一个高backlog值来避免慢客服端连接问题。</p><h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>默认为0（永不超时）。</p><h4 id="tcp-keepalive"><a href="#tcp-keepalive" class="headerlink" title="tcp-keepalive"></a>tcp-keepalive</h4><p>默认为300。检测心跳。</p><h3 id="GENERAL通用"><a href="#GENERAL通用" class="headerlink" title="GENERAL通用"></a>GENERAL通用</h3><h4 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a>daemonize</h4><p>是否为后台程序</p><h4 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a>pidfile</h4><p>存放pid文件的位置，每个实例会产生一个不同的pid文件</p><h4 id="loglevel"><a href="#loglevel" class="headerlink" title="loglevel"></a>loglevel</h4><p>日志级别：debug，verbose，notice，warning</p><h4 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a>logfile</h4><p>日志输出路径</p><h4 id="databases-16"><a href="#databases-16" class="headerlink" title="databases 16"></a>databases 16</h4><p>设定库的数量默认16，默认数据库为0</p><h3 id="SECURITY安全"><a href="#SECURITY安全" class="headerlink" title="SECURITY安全"></a>SECURITY安全</h3><h4 id="设置密码（requirepass）"><a href="#设置密码（requirepass）" class="headerlink" title="设置密码（requirepass）"></a>设置密码（requirepass）</h4><p>访问密码的查看（config get requirepass）、设置和取消。</p><p>在命令中设置密码（config set requirepass “123456” ，auth 123456），只是临时的，重启redis服务器，密码就还原了。</p><p>永久设置，需要在配置文件中设置</p><h3 id="LIMITS限制"><a href="#LIMITS限制" class="headerlink" title="LIMITS限制"></a>LIMITS限制</h3><h4 id="maxclients"><a href="#maxclients" class="headerlink" title="maxclients"></a>maxclients</h4><p>设置redis同时可以与多少个客服端进行连接。</p><p>默认为10000个客服端。</p><h4 id="maxmemory"><a href="#maxmemory" class="headerlink" title="maxmemory"></a>maxmemory</h4><p>设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-pokicy来指定。</p><h4 id="maxmemory-samples"><a href="#maxmemory-samples" class="headerlink" title="maxmemory-samples"></a>maxmemory-samples</h4><p>设置样本数量。</p><p>一般设置3到7的数字，数值越小样本越不准确，但性能消耗较小。</p><h2 id="Redis-的发布和订阅"><a href="#Redis-的发布和订阅" class="headerlink" title="Redis 的发布和订阅"></a>Redis 的发布和订阅</h2><h3 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a>什么是发布和订阅</h3><ul><li><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p></li><li><p>Redis 客户端可以订阅任意数量的频道。</p></li></ul><h3 id="Redis-的发布和订阅-1"><a href="#Redis-的发布和订阅-1" class="headerlink" title="Redis 的发布和订阅"></a>Redis 的发布和订阅</h3><ul><li><p>客户端可以订阅频道如下图：</p><p><img src="/2022/03/07/redis/image-20210618211300027-1657261647170.jpg" alt="image-20210618211300027"></p></li><li><p>当给这个频道发布消息后，消息就会发送给订阅的客户端：</p><p><img src="/2022/03/07/redis/image-20210618211401669.jpg" alt="image-20210618211401669"></p></li></ul><h3 id="发布订阅命令行实现"><a href="#发布订阅命令行实现" class="headerlink" title="发布订阅命令行实现"></a>发布订阅命令行实现</h3><ul><li><p>打开一个客户端订阅 channel1：</p><p><img src="/2022/03/07/redis/image-20210618211907299.jpg" alt="image-20210618211907299"></p></li><li><p>打开另一个客户端，给 channel1 发布消息 hello：返回的1是订阅者数量</p><p><img src="/2022/03/07/redis/image-20210618212029799.jpg" alt="image-20210618212029799"></p></li><li><p>打开第一个客户端可以看到发送的消息：</p><p><img src="/2022/03/07/redis/image-20210618211941020.jpg" alt="image-20210618211941020"></p></li></ul><h2 id="Jedis操作Redis6"><a href="#Jedis操作Redis6" class="headerlink" title="Jedis操作Redis6"></a>Jedis操作Redis6</h2><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="连接Redis"><a href="#连接Redis" class="headerlink" title="连接Redis"></a>连接Redis</h4><ul><li><p>创建一个maven项目</p></li><li><p>导入Jedis所需依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">4.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>将redis.conf文件中bing注释掉和改为protected-mode no</p></li><li><p>需要把Liunx防火墙进行关闭</p><p><img src="/2022/03/07/redis/1657268242460.jpg" alt="1657268242460"></p></li><li><p>进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个jedis对象</span></span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.237.128&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ping</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">    System.out.println(ping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Redis相关数据类型的测试——如String操作"><a href="#Redis相关数据类型的测试——如String操作" class="headerlink" title="Redis相关数据类型的测试——如String操作"></a>Redis相关数据类型的测试——如String操作</h4><p>参上数据类型命令</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.237.128&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="comment">//添加--key操作</span></span><br><span class="line">    jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="comment">//获取</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="comment">//添加多个</span></span><br><span class="line">    jedis.mset(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;v2&quot;</span>);</span><br><span class="line">    List&lt;String&gt; mget = jedis.mget(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>);</span><br><span class="line">    System.out.println(mget);</span><br><span class="line">    <span class="comment">//获取所有</span></span><br><span class="line">    Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key:keys)&#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>要求：</p><ol><li>输入手机号，点击发送后随机生成6位数字码，2分钟有效</li><li>输入验证码，点击验证，返回成功或失败</li><li>每个手机号每天只能输入3次</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">telphoneTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        verifyCode(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成验证码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rand</span> <span class="operator">=</span> random.nextInt();;</span><br><span class="line">            code+=rand;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否超过三次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">verifyCode</span><span class="params">(String phone)</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.237.128&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//发送次数key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">count</span> <span class="operator">=</span> phone+<span class="string">&quot;:count&quot;</span>;</span><br><span class="line">        <span class="comment">//验证码key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">codeKey</span> <span class="operator">=</span> phone+<span class="string">&quot;:code&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> jedis.get(count);</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">null</span>)&#123;</span><br><span class="line">            jedis.setex(count,<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Integer.parseInt(s)&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            jedis.incr(count);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送次数已经超过三次&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.setex(codeKey,<span class="number">120</span>,getCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//校验验证码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getRedis</span><span class="params">(String phone,String code)</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.237.128&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">codeKey</span> <span class="operator">=</span> phone+<span class="string">&quot;:code&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> jedis.get(codeKey);</span><br><span class="line">        <span class="keyword">if</span>(code.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h2><ul><li><p>创建一个SpringBoot项目，导入依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--redis--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--spring2.X集合redis 所需common-pool2--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>application.yml设置相关配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    #Redis服务器地址</span><br><span class="line">    host: <span class="number">192.168</span><span class="number">.237</span><span class="number">.128</span></span><br><span class="line">    #Redis服务器连接端口</span><br><span class="line">    port: <span class="number">6379</span></span><br><span class="line">    #Redis数据库索引（默认为<span class="number">0</span>）</span><br><span class="line">    database: <span class="number">0</span></span><br><span class="line">    #连接超时时间（毫秒）</span><br><span class="line">    timeout: <span class="number">1800000</span></span><br><span class="line">    lettuce:</span><br><span class="line">      pool:</span><br><span class="line">        #连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">        max-active: <span class="number">20</span></span><br><span class="line">        #最大阻塞等待时间（负数表示没限制）</span><br><span class="line">        max-wait: -<span class="number">1</span></span><br><span class="line">        #连接池中的最大空闲连接</span><br><span class="line">        max-idle: <span class="number">5</span></span><br><span class="line">        #连接池中的最小空闲连接</span><br><span class="line">        min-idle: <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>添加redis配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot_redis.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启Redis操作（开启缓存）</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// 在使用注解@Bean返回RedisTemplate的时候，同时配置hashKey与hashValue的序列化方式。</span></span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(redisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);</span><br><span class="line">        <span class="comment">//解决查询缓存转移异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">//配置序列化（解决乱码）,过期时间600秒</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>添加测试方法(RedisTemplate中要添加类型)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot_redis.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">redisTest</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        System.out.println(test);</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Redis-事务、锁机制"><a href="#Redis-事务、锁机制" class="headerlink" title="Redis 事务、锁机制"></a>Redis 事务、锁机制</h2><h3 id="Redis-事务定义"><a href="#Redis-事务定义" class="headerlink" title="Redis 事务定义"></a>Redis 事务定义</h3><p>Redis 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>Redis 事务的主要作用就是串联多个命令防止别的命令插队。</p><h3 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a>Multi、Exec、discard</h3><p>Redis 事务中有 Multi、Exec 和 discard 三个指令，在 Redis 中，从输入 Multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 Exec 后，Redis 会将之前的命令队列中的命令依次执行。而组队的过程中可以通过 discard 来放弃组队。</p><p><img src="/2022/03/07/redis/image-20210619093306171-1657343075079.jpg" alt="image-20210619093306171"></p><h4 id="案例说明："><a href="#案例说明：" class="headerlink" title="案例说明："></a>案例说明：</h4><p><img src="/2022/03/07/redis/image-20210619093617872.jpg" alt="image-20210619093617872"><br>组队成功，提交成功。</p><p><img src="/2022/03/07/redis/image-20210619093741383.jpg" alt="image-20210619093741383"><br>组队阶段报错，提交失败。</p><p><img src="/2022/03/07/redis/image-20210619093941172.jpg" alt="image-20210619093941172"><br>组队成功，提交有成功有失败情况。</p><h4 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h4><p>如果<strong>组队阶段</strong>中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p><p><img src="/2022/03/07/redis/image-20210619094058710.jpg" alt="image-20210619094058710"><br>如果<strong>执行阶段</strong>某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p><p><img src="/2022/03/07/redis/image-20210619094201203.jpg" alt="image-20210619094201203"></p><h3 id="为什么要做成事务"><a href="#为什么要做成事务" class="headerlink" title="为什么要做成事务"></a>为什么要做成事务</h3><p>想想一个场景：有很多人有你的账户，同时去参加双十一抢购。</p><h3 id="事务冲突的问题"><a href="#事务冲突的问题" class="headerlink" title="事务冲突的问题"></a>事务冲突的问题</h3><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>一个请求想给金额减 8000；</p><p>一个请求想给金额减 5000；</p><p>一个请求想给金额减 1000。</p><p><img src="/2022/03/07/redis/image-20210619094341090.jpg" alt="image-20210619094341090"></p><p>最终我们可以发现，总共金额是 10000，如果请求全部执行，那最后的金额变为 - 4000，很明显不合理。</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p><img src="/2022/03/07/redis/image-20210619094633896.jpg" alt="image-20210619094633896"><br>悲观锁 (Pessimistic Lock)，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p><img src="/2022/03/07/redis/image-20210619094741479.jpg" alt="image-20210619094741479"><br>乐观锁 (Optimistic Lock)，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis 就是利用这种 check-and-set 机制实现事务的。</p><h4 id="WATCH-key-key-…"><a href="#WATCH-key-key-…" class="headerlink" title="WATCH key [key …]"></a>WATCH key [key …]</h4><p>在执行 multi 之前，先执行 watch key1 [key2]，可以监视一个 (或多个) key ，如果在事务执行之前这个 (或这些) key 被其他命令所改动，那么事务将被打断。</p><p><img src="/2022/03/07/redis/image-20210619095200164.jpg" alt="image-20210619095200164"></p><h4 id="unwatch"><a href="#unwatch" class="headerlink" title="unwatch"></a>unwatch</h4><p>取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后，EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。</p><h3 id="Redis-事务三特性"><a href="#Redis-事务三特性" class="headerlink" title="Redis 事务三特性"></a>Redis 事务三特性</h3><ul><li><p>单独的隔离操作 ：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p></li><li><p>没有隔离级别的概念 ：队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p></li><li><p>不保证原子性 ：事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 。</p></li></ul><h3 id="Redis-事务秒杀案例"><a href="#Redis-事务秒杀案例" class="headerlink" title="Redis_事务秒杀案例"></a>Redis_事务秒杀案例</h3><h4 id="解决计数器和人员记录的事务操作"><a href="#解决计数器和人员记录的事务操作" class="headerlink" title="解决计数器和人员记录的事务操作"></a>解决计数器和人员记录的事务操作</h4><p><img src="/2022/03/07/redis/image-20210619095633057.jpg" alt="image-20210619095633057"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot_redis.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeckillServer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSeckill</span><span class="params">(String userid, String proid)</span> &#123;</span><br><span class="line">        <span class="comment">//判断uid和perid是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(userid == <span class="literal">null</span> || proid == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;用户为空或商品ID为空&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//库存key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">kcKey</span> <span class="operator">=</span> <span class="string">&quot;sk:&quot;</span>+proid+<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line">        <span class="comment">//成功秒杀用户key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;sk:&quot;</span>+proid+<span class="string">&quot;:user&quot;</span>;</span><br><span class="line">        <span class="comment">//获取商品库存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">kc</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(kcKey);</span><br><span class="line">        <span class="keyword">if</span>(kc == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;秒杀还未开始&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Integer.parseInt(kc) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;秒杀已经结束&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断用户是否重复秒杀</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">user</span> <span class="operator">=</span> redisTemplate.opsForSet().isMember(userKey,userid);</span><br><span class="line">        <span class="keyword">if</span>(user)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;已参与秒杀，不能重复秒杀&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//库存-1(只有使用StringRedisSerializer序列化器才能使用incrment方法)</span></span><br><span class="line">        redisTemplate.opsForValue().decrement(kcKey);</span><br><span class="line">        <span class="comment">//加入成功秒杀用户</span></span><br><span class="line">        redisTemplate.opsForSet().add(userKey,userid);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;秒杀成功了&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Redis-事务-—-秒杀并发模拟"><a href="#Redis-事务-—-秒杀并发模拟" class="headerlink" title="Redis 事务 — 秒杀并发模拟"></a>Redis 事务 — 秒杀并发模拟</h4><p>使用工具 ab 模拟测试：</p><ul><li><p>CentOS6 默认安装</p></li><li><p>CentOS7 需要手动安装</p><ul><li>联网：yum install httpd-tools</li><li>无网络：<ul><li>进入cd &#x2F;run&#x2F;media&#x2F;root&#x2F;CenOS 7 x86_64&#x2F;Packages（路径跟cenos6不同）</li><li>顺序安装：apr-1.4.8-3.e17.x87_64.rpm     apr-util-1.5.2-6.e17.x86_64.rpm     httpd-tools-2.4.6-67.e17.centos.x86_64.rpm</li></ul></li></ul></li></ul><h5 id="通过-ab-测试"><a href="#通过-ab-测试" class="headerlink" title="通过 ab 测试"></a>通过 ab 测试</h5><p>vim postfile 模拟表单提交参数， 以 &amp; 符号结尾，存放当前目录。</p><p>内容：proid&#x3D;1&amp;</p><p>执行：ab -n 1000 -c 100 -k -p ~&#x2F;postfile -T application&#x2F;x-www-form-urlencoded <a href="http://192.168.204.1:8080/seckill">http://192.168.204.1:8080/seckill</a></p><p><img src="/2022/03/07/redis/1657358059072.jpg" alt="1657358059072"></p><p><img src="/2022/03/07/redis/1657358089741.jpg" alt="1657358089741"></p><h4 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h4><p><img src="/2022/03/07/redis/image-20210619100303067.jpg" alt="image-20210619100303067"><br>利用乐观锁淘汰用户，解决超卖问题。</p><p><img src="/2022/03/07/redis/image-20210619100339429.jpg" alt="image-20210619100339429"></p><h4 id="继续增加并发测试"><a href="#继续增加并发测试" class="headerlink" title="继续增加并发测试"></a>继续增加并发测试</h4><h5 id="连接有限制"><a href="#连接有限制" class="headerlink" title="连接有限制"></a>连接有限制</h5><p>增加 - r 参数，-r Don’t exit on socket receive errors。</p><h5 id="连接超时，通过连接池解决"><a href="#连接超时，通过连接池解决" class="headerlink" title="连接超时，通过连接池解决"></a>连接超时，通过连接池解决</h5><p>节省每次连接 redis 服务带来的消耗，把连接好的实例反复利用。通过参数管理连接的行为，代码见项目中：</p><p>连接池参数：</p><ul><li><p>MaxTotal：控制一个 pool 可分配多少个 jedis 实例，通过 pool.getResource () 来获取；如果赋值为 - 1，则表示不限制；如果 pool 已经分配了 MaxTotal 个 jedis 实例，则此时 pool 的状态为 exhausted。</p></li><li><p>maxIdle：控制一个 pool 最多有多少个状态为 idle (空闲) 的 jedis 实例；</p></li><li><p>MaxWaitMillis：表示当 borrow 一个 jedis 实例时，最大的等待毫秒数，如果超过等待时间，则直接抛 JedisConnectionException；</p></li><li><p>testOnBorrow：获得一个 jedis 实例的时候是否检查连接可用性（ping ()）；如果为 true，则得到的 jedis 实例均是可用的。</p></li></ul><p>Jedis连接池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot_redis.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisPoolUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JedisPoolUtil</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title function_">getJedisPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == jedisPool)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (JedisPoolUtil.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">null</span> == jedisPool)&#123;</span><br><span class="line">                    <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">                    poolConfig.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">                    poolConfig.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">                    poolConfig.setMaxWaitMillis(<span class="number">100</span>*<span class="number">100</span>);</span><br><span class="line">                    poolConfig.setBlockWhenExhausted(<span class="literal">true</span>);</span><br><span class="line">                    poolConfig.setTestOnBorrow(<span class="literal">true</span>);<span class="comment">//ping PONG</span></span><br><span class="line">                    jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,<span class="string">&quot;192.168.237.128&quot;</span>,<span class="number">6379</span>,<span class="number">60000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(JedisPool jedisPool, Jedis jedis)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != jedis)&#123;</span><br><span class="line">            jedisPool.returnResource(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上问题最终实现代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.237.128&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">System.out.println(jedis.ping());</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//秒杀过程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">doSecKill</span><span class="params">(String uid,String prodid)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//1 uid和prodid非空判断</span></span><br><span class="line"><span class="keyword">if</span>(uid == <span class="literal">null</span> || prodid == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 连接redis</span></span><br><span class="line"><span class="comment">//Jedis jedis = new Jedis(&quot;192.168.44.168&quot;,6379);</span></span><br><span class="line"><span class="comment">//通过连接池得到jedis对象</span></span><br><span class="line"><span class="type">JedisPool</span> <span class="variable">jedisPoolInstance</span> <span class="operator">=</span> JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPoolInstance.getResource();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 拼接key</span></span><br><span class="line"><span class="comment">// 3.1 库存key</span></span><br><span class="line"><span class="type">String</span> <span class="variable">kcKey</span> <span class="operator">=</span> <span class="string">&quot;sk:&quot;</span>+prodid+<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line"><span class="comment">// 3.2 秒杀成功用户key</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;sk:&quot;</span>+prodid+<span class="string">&quot;:user&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加乐观锁(监视库存)</span></span><br><span class="line">jedis.watch(kcKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 获取库存，如果库存null，秒杀还没有开始</span></span><br><span class="line"><span class="type">String</span> <span class="variable">kc</span> <span class="operator">=</span> jedis.get(kcKey);</span><br><span class="line"><span class="keyword">if</span>(kc == <span class="literal">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀还没有开始，请等待&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 判断用户是否重复秒杀操作</span></span><br><span class="line"><span class="keyword">if</span>(jedis.sismember(userKey, uid)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;已经秒杀成功了，不能重复秒杀&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6 判断如果商品数量，库存数量小于1，秒杀结束</span></span><br><span class="line"><span class="keyword">if</span>(Integer.parseInt(kc)&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀已经结束了&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7 秒杀过程</span></span><br><span class="line"><span class="comment">//使用事务</span></span><br><span class="line"><span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line"></span><br><span class="line"><span class="comment">//组队操作</span></span><br><span class="line">multi.decr(kcKey);</span><br><span class="line">multi.sadd(userKey,uid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">List&lt;Object&gt; results = multi.exec();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(results == <span class="literal">null</span> || results.size()==<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀失败了....&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.1 库存-1</span></span><br><span class="line"><span class="comment">//jedis.decr(kcKey);</span></span><br><span class="line"><span class="comment">//7.2 把秒杀成功用户添加清单里面</span></span><br><span class="line"><span class="comment">//jedis.sadd(userKey,uid);</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;秒杀成功了..&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决库存遗留问题"><a href="#解决库存遗留问题" class="headerlink" title="解决库存遗留问题"></a>解决库存遗留问题</h4><h5 id="已经秒光，可是还有库存"><a href="#已经秒光，可是还有库存" class="headerlink" title="已经秒光，可是还有库存"></a>已经秒光，可是还有库存</h5><p>已经秒光，可是还有库存。原因：乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。</p><p><img src="/2022/03/07/redis/image-20210619101322601-1657366322111.jpg" alt="image-20210619101322601"></p><h5 id="LUA-脚本在-Redis-中的优势"><a href="#LUA-脚本在-Redis-中的优势" class="headerlink" title="LUA 脚本在 Redis 中的优势"></a>LUA 脚本在 Redis 中的优势</h5><ul><li><p>将复杂的或者多步的 redis 操作，写为一个脚本，一次提交给 redis 执行，减少反复连接 redis 的次数，提升性能。</p></li><li><p>LUA 脚本是类似 redis 事务，有一定的原子性，不会被其他命令插队，可以完成一些 redis 事务性的操作。</p></li><li><p>但是注意 redis 的 lua 脚本功能，只有在 Redis 2.6 以上的版本才可以使用。</p></li><li><p>利用 lua 脚本淘汰用户，解决超卖问题。</p></li><li><p>redis 2.6 版本以后，通过 lua 脚本解决争抢问题，实际上是 redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题。</p></li></ul><p><img src="/2022/03/07/redis/image-20210619101853376.jpg" alt="image-20210619101853376"></p><h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><h6 id="SecKill-redisByScript-java代码"><a href="#SecKill-redisByScript-java代码" class="headerlink" title="SecKill_redisByScript.java代码"></a>SecKill_redisByScript.java代码</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local usrid=KEYS[1];</span><br><span class="line">local proid=KEYS[2];</span><br><span class="line">local qtkey=&quot;sk:&quot;..proid.&quot;:qt&quot;;</span><br><span class="line">local userKey=&quot;sk:&quot;..proid.&quot;user&quot;;</span><br><span class="line">local userExists=redis.call(&quot;sismember&quot;,userKey,userid);</span><br><span class="line">if tonumber(userExists)==1 then</span><br><span class="line">return 2;</span><br><span class="line">end</span><br><span class="line">local num=redis.call(&quot;get&quot;,qtkey);</span><br><span class="line">if tonumber(num)&lt;=0 then</span><br><span class="line">return 0;</span><br><span class="line">else</span><br><span class="line">redis.call(&quot;decr&quot;,qtkey);</span><br><span class="line">redis.call(&quot;sadd&quot;,userKey,userid);</span><br><span class="line">end</span><br><span class="line">retyurn 1;</span><br></pre></td></tr></table></figure><p><img src="/2022/03/07/redis/1657367440463.jpg" alt="1657367440463"></p><p><img src="/2022/03/07/redis/1657367515219.jpg" alt="1657367515219"></p><p><img src="/2022/03/07/redis/1657367544059.jpg" alt="1657367544059"></p><h6 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h6><p><img src="/2022/03/07/redis/1657367891201.jpg" alt="1657367891201"></p><h2 id="Redis-持久化之-RDB"><a href="#Redis-持久化之-RDB" class="headerlink" title="Redis 持久化之 RDB"></a>Redis 持久化之 RDB</h2><h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h3><p>官网介绍：<a href="http://www.redis.io/">http://www.redis.io</a></p><p>Redis 提供了 2 个不同形式的持久化方式：</p><p>RDB（Redis DataBase）</p><p>AOF（Append Of File）</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的 Snapshot 快照，它恢复时是将快照文件直接读到内存里。</p><h4 id="备份是如何执行的"><a href="#备份是如何执行的" class="headerlink" title="备份是如何执行的"></a>备份是如何执行的</h4><p>Redis 会单独创建（fork）一个子进程来进行持久化，首先会将数据写入到一个<strong>临时文件</strong>中，待持久化过程都结束了，再用这个临时文件<strong>替换上次持久化好的文件</strong>。整个过程中，主进程是不进行任何 IO 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。<strong>RDB 的缺点是最后一次持久化后的数据可能丢失</strong>。</p><h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><ul><li><p>Fork 的作用是复制一个与当前进程<strong>一样的进程</strong>。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，<strong>并作为原进程的子进程</strong>。</p></li><li><p>在 Linux 程序中，fork () 会产生一个和父进程完全相同的子进程，但子进程在此后多会 exec 系统调用，出于效率考虑，Linux 中引入了 “<strong>写时复制技术</strong>”。</p></li><li><p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p></li></ul><h4 id="RDB-持久化流程"><a href="#RDB-持久化流程" class="headerlink" title="RDB 持久化流程"></a>RDB 持久化流程</h4><p><img src="/2022/03/07/redis/image-20210619103155712.jpg" alt="image-20210619103155712"></p><h4 id="dump-rdb-文件"><a href="#dump-rdb-文件" class="headerlink" title="dump.rdb 文件"></a>dump.rdb 文件</h4><p>在 redis.conf 中配置文件名称，默认为 dump.rdb。</p><p><img src="/2022/03/07/redis/1657368952756.jpg" alt="1657368952756"></p><h4 id="配置位置"><a href="#配置位置" class="headerlink" title="配置位置"></a>配置位置</h4><p>rdb 文件的保存路径，也可以修改。默认为 Redis 启动时命令行所在的目录下 “dir .&#x2F;”。</p><p><img src="/2022/03/07/redis/1657368990445.jpg" alt="1657368990445"></p><h3 id="如何触发-RDB-快照；保持策略"><a href="#如何触发-RDB-快照；保持策略" class="headerlink" title="如何触发 RDB 快照；保持策略"></a>如何触发 RDB 快照；保持策略</h3><h4 id="配置文件中默认的快照配置"><a href="#配置文件中默认的快照配置" class="headerlink" title="配置文件中默认的快照配置"></a>配置文件中默认的快照配置</h4><p><img src="/2022/03/07/redis/image-20210619103558260.jpg" alt="image-20210619103558260"></p><h4 id="命令-save-VS-bgsave"><a href="#命令-save-VS-bgsave" class="headerlink" title="命令 save VS bgsave"></a>命令 save VS bgsave</h4><p>save ：save 时只管保存，其它不管，全部阻塞。手动保存，不建议。</p><p><strong>bgsave：Redis 会在后台异步进行快照操作， 快照同时还可以响应客户端请求。</strong></p><p>可以通过 <strong>lastsave</strong> 命令获取最后一次成功执行快照的时间。</p><h4 id="flushall-命令"><a href="#flushall-命令" class="headerlink" title="flushall 命令"></a>flushall 命令</h4><p>执行 flushall 命令，也会产生 dump.rdb 文件，但里面是空的，无意义。</p><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>格式：save秒钟 写操作次数</p><p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，<strong>默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次</strong>。</p><p>禁用</p><p>不设置save指令，或者给save传入空字符串</p><h4 id="stop-writer-on-bgsave-error"><a href="#stop-writer-on-bgsave-error" class="headerlink" title="stop-writer-on-bgsave-error"></a>stop-writer-on-bgsave-error</h4><p>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes。</p><h4 id="rdbcompression压缩文件"><a href="#rdbcompression压缩文件" class="headerlink" title="rdbcompression压缩文件"></a>rdbcompression压缩文件</h4><p>对于储存到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。</p><p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭。推荐yes.</p><h4 id="rdbchecksum检查完整性"><a href="#rdbchecksum检查完整性" class="headerlink" title="rdbchecksum检查完整性"></a>rdbchecksum检查完整性</h4><p>在存储快照后，还可以让redis使用CRC64算法来进行数据校验。推荐yes。</p><h4 id="rdb的备份"><a href="#rdb的备份" class="headerlink" title="rdb的备份"></a>rdb的备份</h4><p>先通过config get dir 查询rdb文件的目录（进入&#x2F;usr&#x2F;local&#x2F;bin目录），将*.rdb文件拷贝到别的地方cp dump.rdb dump2.rdb</p><p>rdb的恢复</p><ul><li>关闭redis</li><li>先把备份的文件拷贝到工作目录下cp dump2.rdb dump.rdb</li><li>启动redis（redis-cli），备份数据会直接加载dump.rdb文件</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>适合大规模的数据恢复</p></li><li><p>对数据完整性和一致性要求不高更适合使用</p></li><li><p>节省磁盘空间</p></li><li><p>恢复速度快</p><p><img src="/2022/03/07/redis/image-20210619104039665.jpg" alt="image-20210619104039665"></p></li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li><p>Fork 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑。</p></li><li><p>虽然 Redis 在 fork 时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能。</p></li><li><p>在备份周期在一定间隔时间做一次备份，所以如果 Redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。</p></li></ul><h3 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h3><p>动态停止 RDB：redis-cli config set save “”#save 后给空值，表示禁用保存策略。</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619104309571.jpg" alt="image-20210619104309571"></p><h2 id="Redis-持久化之-AOF"><a href="#Redis-持久化之-AOF" class="headerlink" title="Redis 持久化之 AOF"></a>Redis 持久化之 AOF</h2><h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><p><strong>以日志的形式来记录每个写操作（增量保存）</strong>，将 Redis 执行过的所有写指令记录下来 (<strong>读操作不记录)， 只许追加文件但不可以改写文件</strong>，redis 启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><h4 id="AOF-持久化流程"><a href="#AOF-持久化流程" class="headerlink" title="AOF 持久化流程"></a>AOF 持久化流程</h4><ul><li><p>客户端的请求写命令会被 append 追加到 AOF 缓冲区内；</p></li><li><p>AOF 缓冲区根据 AOF 持久化策略 [always,everysec,no] 将操作 sync 同步到磁盘的 AOF 文件中；</p></li><li><p>AOF 文件大小超过重写策略或手动重写时，会对 AOF 文件 rewrite 重写，压缩 AOF 文件容量；</p></li><li><p>Redis 服务重启时，会重新 load 加载 AOF 文件中的写操作达到数据恢复的目的。</p><p><img src="/2022/03/07/redis/image-20210619104813563.jpg" alt="image-20210619104813563"></p></li></ul><h4 id="AOF-默认不开启"><a href="#AOF-默认不开启" class="headerlink" title="AOF 默认不开启"></a>AOF 默认不开启</h4><p>可以在 redis.conf 中,将 appendonly no改为yes,配置文件名称默认为 appendonly.aof</p><p>AOF 文件的保存路径，同 RDB 的路径一致。</p><h4 id="AOF-和-RDB-同时开启，redis-听谁的？"><a href="#AOF-和-RDB-同时开启，redis-听谁的？" class="headerlink" title="AOF 和 RDB 同时开启，redis 听谁的？"></a>AOF 和 RDB 同时开启，redis 听谁的？</h4><p>AOF 和 RDB 同时开启，系统默认取 AOF 的数据（数据不会存在丢失）。</p><h4 id="AOF-启动、修复、恢复"><a href="#AOF-启动、修复、恢复" class="headerlink" title="AOF 启动、修复、恢复"></a>AOF 启动、修复、恢复</h4><ul><li><p>AOF 的备份机制和性能虽然和 RDB 不同，但是备份和恢复的操作同 RDB 一样，都是拷贝备份文件，需要恢复时再拷贝到 Redis 工作目录下，启动系统即加载。</p></li><li><p>正常恢复</p><ul><li>修改默认的 appendonly no，改为 yes。</li><li>将有数据的 aof 文件复制一份保存到对应目录&#x2F;usr&#x2F;local&#x2F;bin (查看目录：config get dir)。</li><li>恢复：重启 redis 然后重新加载。</li></ul></li><li><p>异常恢复</p><ul><li>修改默认的 appendonly no，改为 yes。</li><li>如遇到 AOF 文件损坏，通过进入&#x2F;usr&#x2F;local&#x2F;bin中运行命令redis-check-aof –fix appendonly.aof 进行恢复。</li><li>备份被写坏的 AOF 文件。</li><li>恢复：重启 redis，然后重新加载。</li></ul></li></ul><h4 id="AOF-同步频率设置"><a href="#AOF-同步频率设置" class="headerlink" title="AOF 同步频率设置"></a>AOF 同步频率设置</h4><ul><li><p>appendfsync always：始终同步，每次 Redis 的写入都会立刻记入日志；性能较差但数据完整性比较好。</p></li><li><p>appendfsync everysec：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p></li><li><p>appendfsync no：redis 不主动进行同步，把同步时机交给操作系统。</p></li></ul><h4 id="Rewrite-压缩"><a href="#Rewrite-压缩" class="headerlink" title="Rewrite 压缩"></a>Rewrite 压缩</h4><h5 id="Rewrite-压缩是什么"><a href="#Rewrite-压缩是什么" class="headerlink" title="Rewrite 压缩是什么"></a>Rewrite 压缩是什么</h5><p>AOF 采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当 AOF 文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令 bgrewriteaof。</p><h5 id="重写原理，如何实现重写"><a href="#重写原理，如何实现重写" class="headerlink" title="重写原理，如何实现重写"></a>重写原理，如何实现重写</h5><p>AOF 文件持续增长而过大时，会 fork 出一条新进程来将文件重写 (也是先写临时文件最后再 rename)，<strong>redis4.0 版本后的重写，是指把 rdb 的快照，以二进制的形式附在新的 aof 头部，作为已有的历史数据，替换掉原来的流水账操作</strong>。</p><h5 id="no-appendfsync-on-rewrite："><a href="#no-appendfsync-on-rewrite：" class="headerlink" title="no-appendfsync-on-rewrite："></a>no-appendfsync-on-rewrite：</h5><ul><li><p>如果 no-appendfsync-on-rewrite&#x3D;yes ，不写入 aof 文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</p></li><li><p>如果 no-appendfsync-on-rewrite&#x3D;no，还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p></li></ul><h5 id="触发机制，何时重写"><a href="#触发机制，何时重写" class="headerlink" title="触发机制，何时重写"></a>触发机制，何时重写</h5><p>Redis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍且文件大于 64M 时触发。</p><p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定 Redis 要满足一定条件才会进行重写。</p><ul><li><p>auto-aof-rewrite-percentage：设置重写的基准值，文件达到 100% 时开始重写（文件是原来重写后文件的 2 倍时触发）。</p></li><li><p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件 64MB。达到这个值开始重写。</p></li><li><p>系统载入时或者上次重写完毕时，Redis 会记录此时 AOF 大小，设为 base_size,</p></li><li><p>如果 Redis 的 <strong>AOF 当前大小 &gt;&#x3D; base_size +base_size*100% (默认) 且当前大小 &gt;&#x3D;64mb (默认)</strong> 的情况下，Redis 会对 AOF 进行重写。</p></li></ul><p>例如：文件达到 70MB 开始重写，降到 50MB，下次什么时候开始重写？100MB</p><h5 id="重写流程"><a href="#重写流程" class="headerlink" title="重写流程"></a>重写流程</h5><ul><li><p>bgrewriteaof 触发重写，判断是否当前有 bgsave 或 bgrewriteaof 在运行，如果有，则等待该命令结束后再继续执行；</p></li><li><p>主进程 fork 出子进程执行重写操作，保证主进程不会阻塞；</p></li><li><p>子进程遍历 redis 内存中数据到临时文件，客户端的写请求同时写入 aof_buf 缓冲区和 aof_rewrite_buf 重写缓冲区，保证原 AOF 文件完整以及新 AOF 文件生成期间的新的数据修改动作不会丢失；</p></li><li><p>子进程写完新的 AOF 文件后，向主进程发信号，父进程更新统计信息。主进程把 aof_rewrite_buf 中的数据写入到新的 AOF 文件；</p></li><li><p>使用新的 AOF 文件覆盖旧的 AOF 文件，完成 AOF 重写。</p><p><img src="/2022/03/07/redis/image-20210619110418254.jpg" alt="image-20210619110418254"></p></li></ul><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><p><img src="/2022/03/07/redis/1657439390398.jpg" alt="1657439390398"></p><ul><li><p>备份机制更稳健，丢失数据概率更低。</p></li><li><p>可读的日志文本，通过操作 AOF 稳健，可以处理误操作。</p></li></ul><h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ul><li><p>比起 RDB 占用更多的磁盘空间。</p></li><li><p>恢复备份速度要慢。</p></li><li><p>每次读写都同步的话，有一定的性能压力。</p></li><li><p>存在个别 Bug，造成恢复不能。</p></li></ul><h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><p><img src="/2022/03/07/redis/1657439566943.jpg" alt="1657439566943"></p><h3 id="总结-Which-one"><a href="#总结-Which-one" class="headerlink" title="总结 (Which one)"></a>总结 (Which one)</h3><h4 id="用哪个好"><a href="#用哪个好" class="headerlink" title="用哪个好"></a>用哪个好</h4><p>官方推荐两个都启用：</p><p>如果对数据不敏感，可以选单独用 RDB。</p><p>不建议单独用 AOF，因为可能会出现 Bug。</p><p>如果只是做纯内存缓存，可以都不用。</p><h4 id="官网建议"><a href="#官网建议" class="headerlink" title="官网建议"></a>官网建议</h4><ul><li><p>RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储。</p></li><li><p>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF 命令以 redis 协议追加保存每次写的操作到文件末尾。</p></li><li><p>Redis 还能对 AOF 文件进行后台重写，使得 AOF 文件的体积不至于过大。</p></li><li><p>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</p></li><li><p>同时开启两种持久化方式：在这种情况下，当 redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</p></li><li><p>RDB 的数据不实时，同时使用两者时服务器重启也只会找 AOF 文件。那要不要只使用 AOF 呢？建议不要，因为 RDB 更适合用于备份数据库 (AOF 在不断变化不好备份)，快速重启，而且不会有 AOF 可能潜在的 bug，留着作为一个万一的手段。</p></li></ul><h5 id="性能建议："><a href="#性能建议：" class="headerlink" title="性能建议："></a>性能建议：</h5><ul><li>因为 RDB 文件只用作后备用途，建议只在 Slave 上持久化 RDB 文件，而且只要 15 分钟备份一次就够了，只保留 save 9001 这条规则。</li><li>如果使用 AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单，只 load 自己的 AOF 文件就可以了。</li><li>aof 代价：一是带来了持续的 IO，二是 AOF rewrite 的最后，将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</li><li>只要硬盘许可，应该尽量减少 AOF rewrite 的频率，AOF 重写的基础大小默认值 64M 太小了，可以设到 5G 以上。默认超过原大小 100% 大小时重写可以改到适当的数值。</li></ul><h2 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h2><p>主机数据更新后根据配置和策略， 自动同步到备机的 master&#x2F;slave 机制，<strong>Master 以写为主，Slave 以读为主，主从复制节点间数据是全量的。</strong></p><p>作用：</p><ul><li><p>读写分离，性能扩展</p></li><li><p>容灾快速恢复（当其中一个从服务器挂掉后，可以切换到其他从服务器）</p></li></ul><p><img src="/2022/03/07/redis/1657439888454.jpg" alt="1657439888454"></p><h3 id="主从复制配置"><a href="#主从复制配置" class="headerlink" title="主从复制配置"></a>主从复制配置</h3><p><img src="/2022/03/07/redis/1657444112594.jpg" alt="1657444112594"></p><ul><li>拷贝多个redis.conf文件，conf文件开启daemonize yes，appendonly no 关掉或者换名字</li><li>拷贝文件配置：<ul><li>include path进行引入(写绝对路径)</li><li>pid文件名称 pidfile</li><li>指定端口port</li><li>Log文件名称</li><li>dump.rdb 名称 dbfilename</li></ul></li></ul><h4 id="新建redis6379-conf，填写以下内容"><a href="#新建redis6379-conf，填写以下内容" class="headerlink" title="新建redis6379.conf，填写以下内容"></a>新建redis6379.conf，填写以下内容</h4><ul><li><p>在myredis目录中创建vi redis6379.conf</p></li><li><p>写入以下配置</p><ul><li><p>include &#x2F;myredis&#x2F;redis.confpidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pidport 6379dbfilename dump6379.rdb</p><p><img src="/2022/03/07/redis/1657442642014.jpg" alt="1657442642014"></p></li></ul></li></ul><h4 id="新建redis6380-conf，填写以下内容"><a href="#新建redis6380-conf，填写以下内容" class="headerlink" title="新建redis6380.conf，填写以下内容"></a>新建redis6380.conf，填写以下内容</h4><p><img src="/2022/03/07/redis/1657442521586.jpg" alt="1657442521586"></p><h4 id="新建redis6381-conf，填写以下内容"><a href="#新建redis6381-conf，填写以下内容" class="headerlink" title="新建redis6381.conf，填写以下内容"></a>新建redis6381.conf，填写以下内容</h4><p><img src="/2022/03/07/redis/1657442590216.jpg" alt="1657442590216"></p><h4 id="启动三台redis服务器"><a href="#启动三台redis服务器" class="headerlink" title="启动三台redis服务器"></a>启动三台redis服务器</h4><p><img src="/2022/03/07/redis/1657442763276.jpg" alt="1657442763276"></p><h4 id="查看系统进程，看看三台服务器是否启动"><a href="#查看系统进程，看看三台服务器是否启动" class="headerlink" title="查看系统进程，看看三台服务器是否启动"></a>查看系统进程，看看三台服务器是否启动</h4><p><img src="/2022/03/07/redis/1657442837721.jpg" alt="1657442837721"></p><h4 id="查看三台主机运行情况"><a href="#查看三台主机运行情况" class="headerlink" title="查看三台主机运行情况"></a>查看三台主机运行情况</h4><p>info replication  打印主从复制的相关信息</p><p><img src="/2022/03/07/redis/1657443233457.jpg" alt="1657443233457"></p><p><img src="/2022/03/07/redis/1657443283426.jpg" alt="1657443283426"></p><p><img src="/2022/03/07/redis/1657443306196.jpg" alt="1657443306196"></p><h4 id="配从（库）不配主（库）"><a href="#配从（库）不配主（库）" class="headerlink" title="配从（库）不配主（库）"></a>配从（库）不配主（库）</h4><p>slaveof ip port 成为某个实例的从服务器</p><ul><li><p>在6380和6381上执行：slaveof  127.0.0.1 6379</p><p><img src="/2022/03/07/redis/1657443530033.jpg" alt="1657443530033"></p><p><img src="/2022/03/07/redis/1657443575741.jpg" alt="1657443575741"></p></li></ul><ol><li><p>在主机上写，在从机上可以读取数据</p><p>在从机上写数据报错（从机只能读）</p><p><img src="/2022/03/07/redis/1657443939270.jpg" alt="1657443939270"></p></li><li><p>主机挂掉，进行重启，一切如初。</p></li><li><p>从机重启需重设：slaveof 12.0.0.1 6379</p></li><li><p>可以将配置写入到文件中，永久生效。</p><p><img src="/2022/03/07/redis/1657444075254.jpg" alt="1657444075254"></p></li></ol><h3 id="常用三招"><a href="#常用三招" class="headerlink" title="常用三招"></a>常用三招</h3><h4 id="一主一仆"><a href="#一主一仆" class="headerlink" title="一主一仆"></a>一主一仆</h4><p>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制？比如从k4进来，那之前的k1、k2、k3是否也可以复制？</p><p>当slave挂掉之后，master添加的数据（k1,k2,k3），slave再添加为从机，依然有之前添加是数据（k1,k2,k3）,相当于从头开始复制。</p><p>从机是否可以写？不可以。</p><p>主机shutdown后情况如何？从机上位还是原地待令？从机原地待命，重新连接后还是主机。</p><h4 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h4><p>上一个slave（从机）可以是下一个slave的master(主机)，slave同样可以接收其他slave的连接和同步请求，那么该slave作为链条中下一个的master，可以有效减轻master的写压力。</p><ul><li>用slaveof ip port将从机变为另一台从机的主机（如在6381中运行slave 127.0.0.1 6380）；中途变更转向：会清除之前的数据，重新拷贝最新的</li><li>风险是一旦某个slave挂掉，后面的slave都无法备份</li><li>主机挂了，从机（假主机）还是从机，无法写数据了。</li></ul><h4 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h4><p>当一个master挂掉后，后面的slave<strong>用slaveof no one 将从机变为主机</strong>可以立刻升为master，其后面的slave不用做任何修改。</p><h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><p><img src="/2022/03/07/redis/1657450737991.jpg" alt="1657450737991"></p><ul><li><p>Slave 启动成功连接到 master 后会发送一个 sync 命令；</p></li><li><p>Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master 将传送整个数据文件到 slave，以完成一次完全同步。</p></li><li><p>全量复制：slave 服务器在接收到数据库文件数据后，将其存盘并加载到内存中。</p></li><li><p>增量复制：Master 继续将新的所有收集到的修改命令依次传给 slave，完成同步。</p></li><li><p>但是只要是重新连接 master，一次完全同步（全量复制) 将被自动执行。</p></li></ul><p><img src="/2022/03/07/redis/image-20210619112440704.jpg" alt="image-20210619112440704"></p><h3 id="哨兵模式-sentinel-（反客为主的自动版）"><a href="#哨兵模式-sentinel-（反客为主的自动版）" class="headerlink" title="哨兵模式 (sentinel)（反客为主的自动版）"></a>哨兵模式 (sentinel)（反客为主的自动版）</h3><p>反客为主：当一个 master 宕机后，后面的 slave 可以立刻升为 master，其后面的 slave 不用做任何修改。用 slaveof no one 指令将从机变为主机。而<strong>哨兵模式是反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</strong></p><p><img src="/2022/03/07/redis/image-20210619154258222.jpg" alt="image-20210619154258222"></p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul><li><p>同上一主二仆模式</p></li><li><p>在自定义的&#x2F;myredis目录下新建sentinel.conf文件，名字不能出错。</p></li><li><p>在sentinel.conf文件中填写内容  sentinel monitor mymaster 127.0.0.1 6379 1（mymaster为监控对象起的服务器名称，1为至少有多少个哨兵同意迁移的数量）</p><p><img src="/2022/03/07/redis/1657452165244.jpg" alt="1657452165244"></p></li><li><p>redis-sentinel &#x2F;myredis&#x2F;sentinel.conf 进行启动</p><p><img src="/2022/03/07/redis/1657454171110.jpg" alt="1657454171110"></p></li><li><p>当主机挂掉，从机选举产生新的主机；哪个从机会被选举为主机呢？根据优先级别：slave-priority（replica-priority） 。</p></li><li><p>原主机重启后会变为从机。</p></li></ul><h4 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h4><p>由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问题更加严重。</p><h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><p><img src="/2022/03/07/redis/image-20210619154850009.jpg" alt="image-20210619154850009"><br>优先级：在 redis.conf 中默认 slave-priority 100（replica-priority 100），值越小优先级越高。</p><p>偏移量：指获得原主机数据最全的概率。</p><p>runid：每个 redis 实例启动后都会随机生成一个 40 位的 runid。</p><h4 id="主从复刻"><a href="#主从复刻" class="headerlink" title="主从复刻"></a>主从复刻</h4><p><img src="/2022/03/07/redis/1657455169125.jpg" alt="1657455169125"></p><h2 id="Redis-集群（cluster-模式）"><a href="#Redis-集群（cluster-模式）" class="headerlink" title="Redis 集群（cluster 模式）"></a>Redis 集群（cluster 模式）</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>容量不够，redis 如何进行扩容？</p><p>并发写操作， redis 如何分摊？</p><p>另外，主从模式，薪火相传模式，主机宕机，导致 ip 地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p><p>之前通过代理主机来解决，但是 redis3.0 中提供了解决方案。就是<strong>无中心化集群配置</strong>（任何一台服务器都可以作为集群的入口，集群内部服务器可以互相访问）。</p><h3 id="什么是集群"><a href="#什么是集群" class="headerlink" title="什么是集群"></a>什么是集群</h3><p>Redis 集群（包括很多小集群）实现了对 Redis 的水平扩容，即启动 N 个 redis 节点，将整个数据库分布存储在这 N 个节点中，每个节点存储总数据的 1&#x2F;N，即一个小集群存储 1&#x2F;N 的数据，每个小集群里面维护好自己的 1&#x2F;N 的数据。</p><p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><p>该模式的 redis 集群特点是：分治、分片。</p><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><p>同上，主从复制的搭建步骤，搭建三台主机和三台从机</p><h4 id="redis-cluster-配置修改"><a href="#redis-cluster-配置修改" class="headerlink" title="redis cluster 配置修改"></a>redis cluster 配置修改</h4><ul><li>cluster-enabled yes   打开集群模式cluster-config-file nodes-6379.conf    设定节点配置文件名cluster-node-timeout 15000    设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换</li></ul><p><img src="/2022/03/07/redis/1657520819160.jpg" alt="1657520819160"></p><ul><li><p>其他拷贝文件进行替换，如在redis6380.conf文件中，命令%s&#x2F;6379&#x2F;6380</p></li><li><p>启动6个redis服务</p></li></ul><p><img src="/2022/03/07/redis/1657521662004.jpg" alt="1657521662004"></p><h4 id="将六个节点合成一个集群"><a href="#将六个节点合成一个集群" class="headerlink" title="将六个节点合成一个集群"></a>将六个节点合成一个集群</h4><ul><li><p>组合之前，请确保所有redis实例启动后，node-xxxx.conf文件都生成正常。</p><p><img src="/2022/03/07/redis/1657522058446.jpg" alt="1657522058446"></p></li><li><p>进行合体：进入redis安装的目录cd &#x2F;redis-6.2.7&#x2F;src；运行命令：redis-cli –cluster create –cluster-replicas 1 192.168.237.128:6379  192.168.237.128:6380 192.168.237.128:6381 192.168.237.128:6389 192.168.237.128:6390 192.168.237.128:6391（此处不要用127.0.0.1，请用真实IP地址 ；–cluster-replicas 1 表示采用最简单的方式配置集群，一台主机，一台从机，正好三组；M表示主机，S表示从机）</p><p><img src="/2022/03/07/redis/1657523499539.jpg" alt="1657523499539"></p></li><li><p>集群连接</p><ul><li>普通方式登录：redis-cli -p 6379 可能直接进入读主机，存储数据时，会出现 MOVED 重定向操作，所以，应该以集群方式登录。</li><li>集群登录：<strong>redis-cli -c -p 6379</strong> 采用集群策略连接，设置数据会自动切换到相应的写主机.</li></ul></li><li><p>通过 cluster nodes 命令查看集群信息（查看主从关系）</p><p><img src="/2022/03/07/redis/1657524061841.jpg" alt="1657524061841"></p></li></ul><h3 id="redis-cluster-如何分配这六个节点？"><a href="#redis-cluster-如何分配这六个节点？" class="headerlink" title="redis cluster 如何分配这六个节点？"></a>redis cluster 如何分配这六个节点？</h3><p>一个集群至少要有<strong>三个主节点</strong>。<br>选项 –cluster-replicas 1 ：表示我们希望为集群中的每个主节点创建一个从节点。<br>分配原则尽量保证每个主数据库运行在不同的 IP 地址，每个从库和主库不在一个 IP 地址上。</p><h3 id="什么是-slots"><a href="#什么是-slots" class="headerlink" title="什么是 slots"></a>什么是 slots</h3><p><img src="/2022/03/07/redis/1657528492737.jpg" alt="1657528492737"></p><p>一个 Redis 集群包含 16384 个插槽（hash slot），数据库中的每个键都属于这 16384 个插槽的其中一个。集群使用公式 CRC16 (key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16 (key) 语句用于计算键 key 的 CRC16 校验和 。</p><p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：</p><p>节点 A 负责处理 0 号至 5460 号插槽。<br>节点 B 负责处理 5461 号至 10922 号插槽。<br>节点 C 负责处理 10923 号至 16383 号插槽。</p><h3 id="在集群中录入值"><a href="#在集群中录入值" class="headerlink" title="在集群中录入值"></a>在集群中录入值</h3><p>在 redis-cli 每次录入、查询键值，redis 都会计算出该 key 应该送往的插槽，如果不是该客户端对应服务器的插槽，redis 会报错，并告知应前往的 redis 实例地址和端口。</p><p><img src="/2022/03/07/redis/1657529090731.jpg" alt="1657529090731"></p><p>redis-cli 客户端提供了 <strong>–c 参数实现自动重定向</strong>。如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。</p><p>不在一个 slot 下的键值，是<strong>不能使用 mget,mset 等多键操作</strong>。</p><p><img src="/2022/03/07/redis/1657529044574.jpg" alt="1657529044574"></p><p>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。</p><p><img src="/2022/03/07/redis/1657529156195.jpg" alt="1657529156195"></p><h3 id="查询集群中的值"><a href="#查询集群中的值" class="headerlink" title="查询集群中的值"></a>查询集群中的值</h3><p>cluster keyslot key  返回key的槽值</p><p>cluster countkeysinslot  slot 返回自己主机slot槽中键的数量</p><p>cluster getkeysinslot slot count  返回count个slot槽中的键。</p><p><img src="/2022/03/07/redis/1657529732257.jpg" alt="1657529732257"></p><h3 id="故障恢复-1"><a href="#故障恢复-1" class="headerlink" title="故障恢复"></a>故障恢复</h3><ul><li><p>如果主节点下线？从节点能否自动升为主节点？注意：<strong>15 秒超时</strong></p></li><li><p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p></li><li><p>如果所有某一段插槽的主从节点都宕掉，redis 服务是否还能继续？</p><ul><li>如果某一段插槽的主从都挂掉，而 cluster-require-full-coverage 为 yes ，那么整个集群都挂掉。</li><li>如果某一段插槽的主从都挂掉，而 cluster-require-full-coverage 为 no ，那么，该插槽数据全都不能使用，也无法存储。</li><li>redis.conf中的参数 cluster-require-full-coverage</li></ul></li></ul><h3 id="集群的Jedis开发"><a href="#集群的Jedis开发" class="headerlink" title="集群的Jedis开发"></a>集群的Jedis开发</h3><p>即使连接的不是主机，集群会自动切换主机存储。主机写、从机读。</p><p>无中心化主从集群。无论从哪台主机写的数据，其他主机都能读到数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.HostAndPort;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisCluster;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *演示redis集群操作</span></span><br><span class="line"><span class="comment"> *需要关闭防火墙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClusterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">HostAndPort</span> <span class="variable">hostAndPort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.237.128&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(hostAndPort);</span><br><span class="line">        <span class="comment">//进行操作</span></span><br><span class="line">        jedisCluster.set(<span class="string">&quot;hua&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedisCluster.get(<span class="string">&quot;hua&quot;</span>);</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        jedisCluster.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis-集群优点"><a href="#Redis-集群优点" class="headerlink" title="Redis 集群优点"></a>Redis 集群优点</h3><ul><li><p>实现扩容</p></li><li><p>分摊压力</p></li><li><p>无中心配置相对简单</p></li></ul><h3 id="Redis-集群不足"><a href="#Redis-集群不足" class="headerlink" title="Redis 集群不足"></a>Redis 集群不足</h3><ul><li><p>多键操作是不被支持的。</p></li><li><p>多键的 Redis 事务是不被支持的，lua 脚本不被支持。</p></li><li><p>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至 redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p></li></ul><h2 id="Redis-应用问题解决"><a href="#Redis-应用问题解决" class="headerlink" title="Redis 应用问题解决"></a>Redis 应用问题解决</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>key 对应的数据在数据源并不存在，每次针对此 key 的请求从缓存获取不到，请求都会压到数据源（数据库），从而可能压垮数据源。比如</p><p>用一个不存在的用户 id 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><h5 id="缓存穿透发生的条件："><a href="#缓存穿透发生的条件：" class="headerlink" title="缓存穿透发生的条件："></a>缓存穿透发生的条件：</h5><ul><li>应用服务器压力变大</li><li>redis 命中率降低</li><li>一直查询数据库，使得数据库压力太大而压垮</li><li>其实 redis 在这个过程中一直平稳运行，崩溃的是我们的数据库（如 MySQL）。</li></ul><p>缓存穿透发生的原因：黑客或者其他非正常用户频繁进行很多非正常的 url 访问，使得 redis 查询不到数据库。</p><p><img src="/2022/03/07/redis/1657605773815.jpg" alt="1657605773815"></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p><ul><li><p><strong>对空值缓存</strong>：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</p></li><li><p><strong>设置可访问的名单（白名单</strong>）：使用 bitmaps 类型定义一个可以访问的名单，名单 id 作为 bitmaps 的偏移量，每次访问和 bitmap 里面的 id 进行比较，如果访问 id 不在 bitmaps 里面，进行拦截，不允许访问。</p></li><li><p><strong>采用布隆过滤器</strong>：布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量 (位图) 和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p></li><li><p><strong>进行实时监控</strong>：当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p></li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>key 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。</p><h4 id="缓存击穿的现象："><a href="#缓存击穿的现象：" class="headerlink" title="缓存击穿的现象："></a>缓存击穿的现象：</h4><ul><li>数据库访问压力瞬时增加，数据库崩溃</li><li>redis 里面没有出现大量 key 过期</li><li>redis 正常运行</li></ul><p>缓存击穿发生的原因：redis 某个 key 过期了，大量访问使用这个 key（热门 key）。</p><p><img src="/2022/03/07/redis/1657606631718.jpg" alt="1657606631718"></p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>key 可能会在某些时间点被超高并发地访问，是一种非常 “热点” 的数据。这个时候，需要考虑一个问题：缓存被”击穿”的问题。</p><ul><li><p>预先设置热门数据：在 redis 高峰访问之前，把一些热门数据提前存入到 redis 里面，加大这些热门数据 key 的时长。</p></li><li><p>实时调整：现场监控哪些数据热门，实时调整 key 的过期时长。</p></li><li><p>使用锁：</p><ul><li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db。</li><li>先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX）去 set 一个 mutex key。</li><li>当操作返回成功时，再进行 load db 的操作，并回设缓存，最后删除 mutex key；</li><li>当操作返回失败，证明有线程在 load db，当前线程睡眠一段时间再重试整个 get 缓存的方法。</li></ul></li></ul><p><img src="/2022/03/07/redis/image-20210619165505113.jpg" alt="image-20210619165505113"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>key 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期，一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。</p><p><strong>缓存雪崩与缓存击穿的区别在于这里针对很多 key 缓存，前者则是某一个 key 正常访问，不同请求查询的大量key过期；后者是大量请求的同一个key过期。</strong></p><p><img src="/2022/03/07/redis/image-20210619170416116.jpg" alt="image-20210619170416116"><br>缓存失效瞬间：</p><p><img src="/2022/03/07/redis/1657607481833.jpg" alt="1657607481833"></p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li><p>构建多级缓存架构：nginx 缓存 + redis 缓存 + 其他缓存（ehcache 等）。</p></li><li><p>使用锁或队列：用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上，该方法不适用高并发情况。</p></li><li><p>设置过期标志更新缓存：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 key 的缓存。</p></li><li><p>将缓存失效时间分散开：比如可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p></li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程的特点以及分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的 Java API 并不能提供分布式锁的能力。为了解决这个问题就需要一种跨 JVM 的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p><p>分布式锁主流的实现方案：</p><ul><li><p>基于数据库实现分布式锁</p></li><li><p>基于缓存（Redis 等）</p></li><li><p>基于 Zookeeper</p></li></ul><p>根据实现方式，分布式锁还可以分为类 CAS 自旋式分布式锁以及 event 事件类型分布式锁：</p><ul><li>类 CAS 自旋式分布式锁：询问的方式，类似 java 并发编程中的线程获询问的方式尝试加锁，如 mysql、redis。</li><li>另外一类是 event 事件通知进程后续锁的变化，轮询向外的过程，如 zookeeper、etcd。</li></ul><p>每一种分布式锁解决方案都有各自的优缺点：</p><p>性能：redis 最高</p><p>可靠性：zookeeper 最高</p><h4 id="解决方案：使用-redis-实现分布式锁"><a href="#解决方案：使用-redis-实现分布式锁" class="headerlink" title="解决方案：使用 redis 实现分布式锁"></a>解决方案：使用 redis 实现分布式锁</h4><p><img src="/2022/03/07/redis/image-20210619213926122.jpg" alt="image-20210619213926122"></p><p>setnx：通过该命令尝试获得锁，没有获得锁的线程会不断等待尝试。</p><p>redis命令：set user 10 NX PX 10000</p><p>EX second：设置键的过期时间为second秒。set ket value EX second等同于setex key second value。</p><p>PX millisecond：设置键的过期时间为millisecond毫秒。set key value PX millisecond等同于psetex key millisecond value。</p><p>NX：当键不存在时，才对键进行设置操作。set key value NX等同于setnx key value。</p><p>XX：只在键已经存在是，才对键进行设置</p><ul><li><p>set key ex 3000 nx：设置过期时间，自动释放锁，解决当某一个业务异常而导致锁无法释放的问题。但是当业务运行超过过期时间时，开辟监控线程增加该业务的运行时间，直到运行结束，释放锁。</p><p><img src="/2022/03/07/redis/1657610042480.jpg" alt="1657610042480"></p></li><li><p>uuid：设置 uuid，释放前获取这个值，判断是否自己的锁，防止误删锁，造成没锁的情况。</p><p><img src="/2022/03/07/redis/1657611698936.jpg" alt="1657611698936"></p></li><li><p>lua脚本实现原子操作（判断uuid然后删除）</p><p><img src="/2022/03/07/redis/1657612491134.jpg" alt="1657612491134"></p></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/testLock&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//设置uuid</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">       <span class="comment">//获取锁，setne</span></span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>,uuid,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">       <span class="comment">//获取锁成功、查询num的值</span></span><br><span class="line">       <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">           <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);<span class="comment">//需要在redis服务器中设置set num 0</span></span><br><span class="line">           <span class="comment">//判断num为空return</span></span><br><span class="line">           <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//有值就转成int</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">           <span class="comment">//把redis的num加一</span></span><br><span class="line">           redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>,++num);</span><br><span class="line">           <span class="comment">//释放锁del</span></span><br><span class="line">           <span class="comment">//判断uuid是否一样</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">lock1</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span>(lock1.equals(uuid))&#123;</span><br><span class="line">               redisTemplate.delete(<span class="string">&quot;lick&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//获取锁失败，每隔0.1秒在获取</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">100</span>);</span><br><span class="line">               testLock();</span><br><span class="line">           &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2022/03/07/redis/1657612620881.jpg" alt="1657612620881"></p><h3 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h3><p>Redlock 是一种算法，Redlock 也就是 Redis Distributed Lock，可用实现多节点 redis 的分布式锁。RedLock 官方推荐，Redisson 完成了对 Redlock 算法封装。</p><p>此种方式具有以下特性：</p><ul><li>互斥访问：即永远只有一个 client 能拿到锁。</li><li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使锁定资源的服务崩溃或者分区，仍然能释放锁。</li><li>容错性：只要大部分 Redis 节点存活（一半以上），就可以正常提供服务</li></ul><p>RedLock 原理（了解）</p><ul><li>获取当前 Unix 时间，以毫秒为单位。</li><li>依次尝试从 N 个实例，使用相同的 key 和随机值获取锁。在步骤 2，当向 Redis 设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以避免服务器端 Redis 已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个 Redis 实例。</li><li>客户端使用当前时间减去开始获取锁时间（步骤 1 记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是 3 个节点）的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li><li>如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。</li><li>如果因为某些原因，获取锁失败（没有在至少 N&#x2F;2+1 个 Redis 实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁（即便某些 Redis 实例根本就没有加锁成功）。</li></ul><h2 id="Redis6-新功能"><a href="#Redis6-新功能" class="headerlink" title="Redis6 新功能"></a>Redis6 新功能</h2><h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p>Redis ACL是Access Control LIst（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。</p><p>在Redis 5之前，Redis安全规则只有密码控制还有通过rename来调整高危命令比如fiushdb，keys *，shutdown等。Redis 6则根据ACL的功能对用户进行更细粒度的权限控制。</p><ol><li>接入权限：用户名和密码。</li><li>可以执行的命令。</li><li>可以操作的key。</li></ol><h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><ol><li><p>使用acl list命令展现用户权限列表。</p><p><img src="/2022/03/07/redis/1657613231561.jpg" alt="1657613231561"></p></li><li><p>使用acl cat命令：查看添加权限指令类别；acl cat String ：加参数类型名可以查看类型下具体命令。</p></li><li><p>使用acl whoami命令查看当前用户。</p></li><li><p>使用acl set user命令创建和编辑用户ACL</p><ol><li><p>ACL规则</p><p><img src="/2022/03/07/redis/1657613955543.jpg" alt="1657613955543"></p><p><img src="/2022/03/07/redis/1657613936741.jpg" alt="1657613936741"></p></li><li><p>命令acl setuser user1：创建新用户默认权限</p></li><li><p>acl setuser user2 on &gt;password ~cached:* +get：创建用户名、密码、ACL权限、启用的用户</p></li><li><p>author name password：切换用户</p></li></ol></li></ol><h3 id="Redis-IO-多线程"><a href="#Redis-IO-多线程" class="headerlink" title="Redis IO 多线程"></a>Redis IO 多线程</h3><h4 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h4><p>Redis6 终于支撑多线程了，告别单线程了吗？</p><p>IO 多线程其实指客户端交互部分的网络 IO 交互处理模块 多线程，而非执行命令多线程。Redis6 执行命令依然是单线程。</p><h4 id="原理架构"><a href="#原理架构" class="headerlink" title="原理架构"></a>原理架构</h4><p>Redis 6 加入多线程，但跟 Memcached 这种从 IO 处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发问题。整体的设计大体如下:</p><p><img src="/2022/03/07/redis/image-20210619215600452.jpg" alt="image-20210619215600452"><br>另外，多线程 IO 默认也是不开启的，需要再配置文件redis.conf中配置：</p><ul><li><p>io-threads-do-reads yes</p></li><li><p>io-threads 4</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>npm切换安装源</title>
      <link href="/2021/12/12/npm%E5%88%87%E6%8D%A2%E5%AE%89%E8%A3%85%E6%BA%90/"/>
      <url>/2021/12/12/npm%E5%88%87%E6%8D%A2%E5%AE%89%E8%A3%85%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>问题：</p><p>在基于vue create app创建的vue项目中，安装饿了么使用命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm i element-ui -S</span><br></pre></td></tr></table></figure><p>安装时遇见下面的报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deprecate element-ui@2.15.9 › async-validator@1.8.5 › babel-runtime@6.26.0 › core-js@^2.4.0 core-js@&lt;3.23.3 is no longer maintained and not recommended for usage due to the number of issues. Because of the V8 engine whims, feature detection in old core-js versions could cause a slowdown up to 100x even if nothing is polyfilled. Some versions have web compatibility issues. Please, upgrade your dependencies to the actual version of core-js.</span><br></pre></td></tr></table></figure><p>解决方案：</p><p>执行下面的命令（前提已经安装了nrm）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g nrm</span><br></pre></td></tr></table></figure><p>nrm ls   &#x3D;&gt;查看当前可用源（*号在哪里表示现在使用哪个源）<br>nrm use taobao   &#x3D;&gt;切换到taobao源<br>npm install element-ui –save   &#x3D;&gt;使用npm命令安装（此时的源是基于taobao镜像，而不是纯的npm镜像）</p><p>分析：</p><p>可能是因为使用npm源的镜像太老旧，所以出现了core-js版本老旧无法安装成功的问题。</p><p>总结：</p><p>对于某些安装不成功的模块，不妨试试不同的安装源！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3.0项目搭建</title>
      <link href="/2021/12/06/Vue3-0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/12/06/Vue3-0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="vue3-0项目的搭建"><a href="#vue3-0项目的搭建" class="headerlink" title="vue3.0项目的搭建"></a>vue3.0项目的搭建</h1><p>[官网地址]: <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a>“官网地址”</p><ol><li><p>在要创建项目的文件夹下边同时按shift键与鼠标右键，选择在此处打开powershell窗口</p></li><li><p>卸载之前的vue版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall vue-cli -g</span><br></pre></td></tr></table></figure></li><li><p>全局安装脚手架</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure></li><li><p>查看版本号（大写V）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue -V</span><br></pre></td></tr></table></figure></li><li><p>在<a href="https://so.csdn.net/so/search?q=%E5%91%BD%E4%BB%A4%E8%A1%8C&spm=1001.2101.3001.7020">命令行</a>安装pnpm@6的版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i pnpm@6 -g</span><br></pre></td></tr></table></figure></li><li><p>搭建一个项目名称为project的项目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue create project</span><br></pre></td></tr></table></figure></li><li><p>根据项目提示进行相应的配置，选择最后一项为手动配置</p><blockquote><p>Default ([Vue 3] babel, eslint)：默认预设配置，会快速创建一个Vue3.0项目，提供了babel和eslint支持</p><p>Default ([Vue 2] babel, eslint)：默认预设配置，会快速创建一个Vue2.0项目，提供了babel和eslint支持</p><p>Manually select features：手动配置项目，可根据项目的需要选择合适的选项，具备更多的选择性</p></blockquote><p><img src="/2021/12/06/Vue3-0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/1659576763626.png" alt="1659576763626"></p></li><li><p>移动上下箭头选择要配置的东西，按空格键表示选中（括号内会出现星标）</p><blockquote><p>Babel：使用Babel将源码进行转码（把ES6&#x3D;&gt;ES5）<br>TypeScript：使用TypeScript进行源码编写。使用TypeScript可以编写强类型JavaScript<br>Progressive Web App (PWA) Support：使用渐进式Web应用程序<br>Router：使用Vue路由<br>Vuex：使用Vuex状态管理器<br>CSS Pre-processors：CSS 预处理器（如：less、sass）<br>Linter &#x2F; Formatter：使用代码风格检查和格式化（如：ESlint）<br>Unit Testing：使用单元测试（unit tests）<br>E2E Testing：使用E2E（end to end）黑盒测试</p></blockquote><p><img src="/2021/12/06/Vue3-0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/1659576799892.png" alt="1659576799892"></p></li><li><p>全部选好之后按回车键开始进行相应的配置</p><ul><li><p>选择Vue的版本为3.0        </p><p><img src="/2021/12/06/Vue3-0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/1659576843879.png" alt="1659576843879"></p></li><li><p>选择路由采用历史模式</p><p><img src="/2021/12/06/Vue3-0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/1659576897375.png" alt="1659576897375"></p></li><li><p>选择css预处理器的语言：主要为css解决浏览器兼容、简化CSS代码等</p><p><img src="/2021/12/06/Vue3-0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/1659576936048.png" alt="1659576936048"></p></li><li><p>选择Eslint代码规范（javascript代码检测工具）    </p><blockquote><p>  TSLint: ts格式检验⼯具<br>  ESLint with error prevention only: ESLint 只会进⾏错误提醒<br>  ESLint + Airbnb config: ESLint Airbnb标准<br>  ESLint + Standard config: ESLint Standard 标准<br>  ESLint + Prettier: ESLint（代码质量检测）+ Prettier（代码格式化⼯具）</p></blockquote><p><img src="/2021/12/06/Vue3-0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/1659576969476.png" alt="1659576969476"></p></li><li><p>选择何时检测</p><blockquote><p>代码检查⽅式: 保存时检查 &#x2F; 提交时检查;  我一般习惯保存时检查</p></blockquote><p><img src="/2021/12/06/Vue3-0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/1659577006352.png" alt="1659577006352"></p></li><li><p>选择单元测试的解决方案</p><p><img src="/2021/12/06/Vue3-0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/1659577042741.png" alt="1659577042741"></p></li><li><p>选择配置文件存放的位置</p><p><img src="/2021/12/06/Vue3-0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/1659577071182.png" alt="1659577071182"></p></li><li><p>是否保存当前配置作为下次创建项目的模板（我选择y，选择n则不用起名）</p><p><img src="/2021/12/06/Vue3-0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/1659577110448.png" alt="1659577110448"></p></li></ul></li><li><p>选择配置文件存放的位置（我选择单独保存在各自的配置文件中）</p></li><li><p>是否保存当前配置作为下次创建项目的模板（我选择y，选择n则不用起名）</p></li><li><p>搭建完成，根据提示进入文件夹</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd competition_qt</span><br></pre></td></tr></table></figure></li><li><p>启动项目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-Plus</title>
      <link href="/2021/11/13/MyBatis-Plus/"/>
      <url>/2021/11/13/MyBatis-Plus/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h1><h2 id="MyBatis-Plus-简介"><a href="#MyBatis-Plus-简介" class="headerlink" title="MyBatis-Plus 简介"></a>MyBatis-Plus 简介</h2><h3 id="简介MyBatis-Plus-v3-5-1"><a href="#简介MyBatis-Plus-v3-5-1" class="headerlink" title="简介MyBatis-Plus(v3.5.1)"></a>简介MyBatis-Plus(v3.5.1)</h3><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus (opens new window)</a>（简称 MP）是一个 MyBatis 的增强工具，在 <a href="https://www.mybatis.org/mybatis-3/">MyBatis (opens new window)</a>的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>愿景</p><p>我们的愿景是成为 MyBatis 最好的搭档，就像 <a href="https://baomidou.com/img/contra.jpg">魂斗罗 (opens new window)</a>中的 1P、2P，基友搭配，效率翻倍。</p><p><img src="/2021/11/13/MyBatis-Plus/01.png" alt="01"></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h3 id="支持数据库"><a href="#支持数据库" class="headerlink" title="支持数据库"></a>支持数据库</h3><blockquote><p>任何能使用MyBatis进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下</p></blockquote><ul><li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb</li><li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库</li></ul><h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3><p><img src="/2021/11/13/MyBatis-Plus/02.png" alt="02"></p><h3 id="代码及文档地址"><a href="#代码及文档地址" class="headerlink" title="代码及文档地址"></a>代码及文档地址</h3><p>官方地址: <a href="http://mp.baomidou.com/">http://mp.baomidou.com</a></p><p>代码发布地址:</p><p>Github: <a href="https://github.com/baomidou/mybatis-plus">https://github.com/baomidou/mybatis-plus</a></p><p>Gitee: <a href="https://gitee.com/baomidou/mybatis-plus">https://gitee.com/baomidou/mybatis-plus</a></p><p>文档发布地址: <a href="https://baomidou.com/pages/24112f">https://baomidou.com/pages/24112f</a></p><h2 id="MyBatis-Plus-入门案例"><a href="#MyBatis-Plus-入门案例" class="headerlink" title="MyBatis-Plus 入门案例"></a>MyBatis-Plus 入门案例</h2><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>IDE：idea 2022.2</p><p>JDK：JDK8+</p><p>构建工具：maven 3.</p><p>MySQL版本：MySQL 8.0</p><p>Spring Boot：2.7.3</p><p>MyBatis-Plus：3.5.1</p><h3 id="创建数据库及表"><a href="#创建数据库及表" class="headerlink" title="创建数据库及表"></a>创建数据库及表</h3><blockquote><p>注：默认使用雪花算法来生成id</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `mybatis_plus` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>;</span><br><span class="line">use `mybatis_plus`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">`name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">`age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">`email` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="创建SpringBoot工程"><a href="#创建SpringBoot工程" class="headerlink" title="创建SpringBoot工程"></a>创建SpringBoot工程</h3><ol><li>初始化工程</li><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!--mybatis-plus启动器--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--用于简化实体类开发--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​3. idea中安装lombok插件  </p><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><h4 id="配置application-yml"><a href="#配置application-yml" class="headerlink" title="配置application.yml"></a>配置application.yml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 配置数据源信息</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment"># 配置数据源类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="comment"># 配置连接数据库信息</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><blockquote><p>1、驱动类driver-class-name</p><p>spring boot 2.0（内置jdbc5驱动），驱动类使用：</p><p>driver-class-name: com.mysql.jdbc.Driver</p><p>spring boot 2.1及以上（内置jdbc8驱动），驱动类使用：</p><p>driver-class-name: com.mysql.cj.jdbc.Driver</p><p>否则运行测试用例的时候会有 WARN 信息</p><p>2、连接地址url</p><p>MySQL5.7版本的url：</p><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis_plus?characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;false</p><p>MySQL8.0版本的url：</p><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis_plus?<strong>serverTimezone&#x3D;GMT%2B8</strong>&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;false</p><p>否则运行测试用例报告如下错误：</p><p>java.sql.SQLException: The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’ is unrecognized or represents more</p></blockquote><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span> <span class="comment">//lombok注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加mapper"><a href="#添加mapper" class="headerlink" title="添加mapper"></a>添加mapper</h4><blockquote><p>BaseMapper是MyBatis-Plus提供的模板mapper，其中包含了基本的CRUD方法，泛型为操作的实体类型</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><blockquote><p><strong>在Spring Boot启动类中添加@MapperScan注解，扫描mapper包，就相当于在mapper包下每个接口添加一个@Mapper注解</strong></p><p><strong>@Mapper注解的作用：自动生成该接口的实现类并注入到bean容器中，就是这个接口在编译时会生成相应的实现类</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com.hua.study.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisplusApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MybatisplusApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MybatisplusApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//通过条件构造器查询一个list集合，若没有条件，则可以设置null为参数</span></span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">17.614</span>  INFO <span class="number">12320</span> --- [           main] c.f.m.MybatisplusApplicationTests        : Started MybatisplusApplicationTests in <span class="number">3.14</span> seconds (JVM running <span class="keyword">for</span> <span class="number">4.738</span>)</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">18.182</span>  INFO <span class="number">12320</span> --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Starting...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">19.002</span>  INFO <span class="number">12320</span> --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Start completed.</span><br><span class="line">User(id=<span class="number">1</span>, name=Jone, age=<span class="number">18</span>, email=test1<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">2</span>, name=Jack, age=<span class="number">20</span>, email=test2<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">3</span>, name=Tom, age=<span class="number">28</span>, email=test3<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">4</span>, name=Sandy, age=<span class="number">21</span>, email=test4<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">5</span>, name=Billie, age=<span class="number">24</span>, email=test5<span class="meta">@baomidou</span>.com)</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">19.292</span>  INFO <span class="number">12320</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">19.328</span>  INFO <span class="number">12320</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><blockquote><p><strong>IDEA在 userMapper 处报错，因为找不到注入的对象，因为类是动态创建的，但是程序可以正确的执行。</strong></p><p><strong>为了避免报错，可以在mapper接口上添加 @Repository 注解</strong></p></blockquote><h4 id="添加日志"><a href="#添加日志" class="headerlink" title="添加日志"></a>添加日志</h4><p>在application.yml中配置日志输出，查看执行的sql等详情</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置mybatis日志</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><h5 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: SELECT id,name,age,email FROM user</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: id, name, age, email</span><br><span class="line">&lt;==        Row: <span class="number">1</span>, Jone, <span class="number">18</span>, test1<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==        Row: <span class="number">2</span>, Jack, <span class="number">20</span>, test2<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==        Row: <span class="number">3</span>, Tom, <span class="number">28</span>, test3<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==        Row: <span class="number">4</span>, Sandy, <span class="number">21</span>, test4<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==        Row: <span class="number">5</span>, Billie, <span class="number">24</span>, test5<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==      Total: <span class="number">5</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4acb2510]</span><br><span class="line">User(id=<span class="number">1</span>, name=Jone, age=<span class="number">18</span>, email=test1<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">2</span>, name=Jack, age=<span class="number">20</span>, email=test2<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">3</span>, name=Tom, age=<span class="number">28</span>, email=test3<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">4</span>, name=Sandy, age=<span class="number">21</span>, email=test4<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">5</span>, name=Billie, age=<span class="number">24</span>, email=test5<span class="meta">@baomidou</span>.com)</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">33</span>:<span class="number">15.080</span>  INFO <span class="number">13252</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">12</span> <span class="number">15</span>:<span class="number">33</span>:<span class="number">15.099</span>  INFO <span class="number">13252</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="基本CRUD"><a href="#基本CRUD" class="headerlink" title="基本CRUD"></a>基本CRUD</h2><h3 id="BaseMapper"><a href="#BaseMapper" class="headerlink" title="BaseMapper"></a>BaseMapper</h3><p>MyBatis-Plus中的基本CRUD在内置的BaseMapper中都已得到了实现，我们可以直接使用，接口如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseMapper</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 主键ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据实体(ID)删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.4.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMap 表字段 map 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除（根据ID或实体 批量删除）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idList 主键ID列表或实体列表(不能为 null 以及 empty)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;?&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 修改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 whereEntity 条件，更新记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity        实体对象 (set 条件值,可以为 null)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 主键ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据ID 批量查询）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idList 主键ID列表(不能为 null 以及 empty)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据 columnMap 条件）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMap 表字段 map 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，查询一条记录</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;查询一条记录，例如 qw.last(&quot;limit 1&quot;) 限制取一条记录, 注意：多条数据会报异常&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        List&lt;T&gt; ts = <span class="built_in">this</span>.selectList(queryWrapper);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(ts)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ts.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ExceptionUtils.mpe(<span class="string">&quot;One record is expected, but the query result is multiple records&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ts.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，判断是否存在记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.selectCount(queryWrapper);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> != count &amp;&amp; count &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Long <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;注意： 只返回第一个字段的值&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         分页查询条件（可以为 RowBounds.DEFAULT）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;P <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; P <span class="title function_">selectPage</span><span class="params">(P page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         分页查询条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;P <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; P <span class="title function_">selectMapsPage</span><span class="params">(P page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">23</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;zhangsan@atschool.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span>+user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: INSERT INTO <span class="title function_">user</span> <span class="params">( id, name, age, email )</span> VALUES ( ?, ?, ?, ? )</span><br><span class="line">==&gt; Parameters: <span class="number">1514632107652923393</span>(Long), 张三(String), <span class="number">23</span>(Integer), zhangsan<span class="meta">@atschool</span>.com(String)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7e00ed0f]</span><br><span class="line">result:<span class="number">1</span></span><br><span class="line">id:<span class="number">1514632107652923393</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">14</span> <span class="number">23</span>:<span class="number">50</span>:<span class="number">10.135</span>  INFO <span class="number">23036</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">14</span> <span class="number">23</span>:<span class="number">50</span>:<span class="number">10.155</span>  INFO <span class="number">23036</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>最终执行的结果，所获取的id为1514632107652923393</p><p>这是因为MyBatis-Plus在实现插入数据时，会默认基于<a href="https://frxcat.fun/pages/acce37/#%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95">雪花算法</a>的策略生成id</p></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="通过ID删除记录"><a href="#通过ID删除记录" class="headerlink" title="通过ID删除记录"></a>通过ID删除记录</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//通过id删除用户信息</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">1514558344269680641L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: DELETE FROM user WHERE id=?</span><br><span class="line">==&gt; Parameters: 1514558344269680641(Long)</span><br><span class="line">&lt;==    Updates: 1</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7e00ed0f]</span><br><span class="line">result:1</span><br><span class="line">2022-04-14 23:47:52.921  INFO 3000 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...</span><br><span class="line">2022-04-14 23:47:52.962  INFO 3000 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h4 id="通过ID批量删除记录"><a href="#通过ID批量删除记录" class="headerlink" title="通过ID批量删除记录"></a>通过ID批量删除记录</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Long&gt; list = Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteBatchIds(list);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: DELETE FROM user WHERE id <span class="title function_">IN</span> <span class="params">( ? , ? , ? )</span></span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(Long), <span class="number">2</span>(Long), <span class="number">3</span>(Long)</span><br><span class="line">&lt;==    Updates: <span class="number">3</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@62db0521]</span><br><span class="line">result:<span class="number">3</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">56.260</span>  INFO <span class="number">9828</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">56.270</span>  INFO <span class="number">9828</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="通过Map集合删除记录"><a href="#通过Map集合删除记录" class="headerlink" title="通过Map集合删除记录"></a>通过Map集合删除记录</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">testDeleteByMap</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//删除name为张三，年龄为23的所有用户</span></span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: DELETE FROM user <span class="type">WHERE</span> <span class="variable">name</span> <span class="operator">=</span> ? <span class="type">AND</span> <span class="variable">age</span> <span class="operator">=</span> ?</span><br><span class="line">==&gt; Parameters: 张三(String), <span class="number">23</span>(Integer)</span><br><span class="line">&lt;==    Updates: <span class="number">0</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@65f2f9b0]</span><br><span class="line">result:<span class="number">0</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">24.693</span>  INFO <span class="number">23248</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">24.713</span>  INFO <span class="number">23248</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><h4 id="通过ID修改记录"><a href="#通过ID修改记录" class="headerlink" title="通过ID修改记录"></a>通过ID修改记录</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">4L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;李四&quot;</span>);<span class="comment">//修改name</span></span><br><span class="line">    user.setEmail(<span class="string">&quot;lisi@atSchool.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.updateById(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: UPDATE user SET name=?, email=? WHERE id=?</span><br><span class="line">==&gt; Parameters: 李四(String), lisi<span class="meta">@atSchool</span>.com(String), <span class="number">4</span>(Long)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@62db0521]</span><br><span class="line">result:<span class="number">1</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">05</span>:<span class="number">46.724</span>  INFO <span class="number">7772</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">05</span>:<span class="number">46.774</span>  INFO <span class="number">7772</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: UPDATE user SET name=?, email=? WHERE id=?</span><br><span class="line">==&gt; Parameters: 李四(String), lisi<span class="meta">@atSchool</span>.com(String), <span class="number">4</span>(Long)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@62db0521]</span><br><span class="line">result:<span class="number">1</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">05</span>:<span class="number">46.724</span>  INFO <span class="number">7772</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">05</span>:<span class="number">46.774</span>  INFO <span class="number">7772</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="根据ID查询数据"><a href="#根据ID查询数据" class="headerlink" title="根据ID查询数据"></a>根据ID查询数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//通过Id查询用户信息</span></span><br><span class="line">     <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">     System.out.println(user);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: SELECT id,name,age,email FROM user WHERE id=?</span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(Long)</span><br><span class="line">&lt;==    Columns: id, name, age, email</span><br><span class="line">&lt;==        Row: <span class="number">1</span>, Jone, <span class="number">18</span>, test1<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3964d79]</span><br><span class="line">User(id=<span class="number">1</span>, name=Jone, age=<span class="number">18</span>, email=test1<span class="meta">@baomidou</span>.com)</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">50.204</span>  INFO <span class="number">11976</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">50.219</span>  INFO <span class="number">11976</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="根据多个ID查询数据"><a href="#根据多个ID查询数据" class="headerlink" title="根据多个ID查询数据"></a>根据多个ID查询数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//根据多个id查询多个用户信息</span></span><br><span class="line">     List&lt;Long&gt; list = Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>);</span><br><span class="line">     List&lt;User&gt; users = userMapper.selectBatchIds(list);</span><br><span class="line">     users.forEach(System.out :: println);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">=&gt;  Preparing: SELECT id,name,age,email FROM user WHERE id <span class="title function_">IN</span> <span class="params">( ? , ? , ? )</span></span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(Long), <span class="number">2</span>(Long), <span class="number">3</span>(Long)</span><br><span class="line">&lt;==    Columns: id, name, age, email</span><br><span class="line">&lt;==        Row: <span class="number">1</span>, Jone, <span class="number">18</span>, test1<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==        Row: <span class="number">2</span>, Jack, <span class="number">20</span>, test2<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==        Row: <span class="number">3</span>, Tom, <span class="number">28</span>, test3<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==      Total: <span class="number">3</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@<span class="number">65753040</span>]</span><br><span class="line">User(id=<span class="number">1</span>, name=Jone, age=<span class="number">18</span>, email=test1<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">2</span>, name=Jack, age=<span class="number">20</span>, email=test2<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">3</span>, name=Tom, age=<span class="number">28</span>, email=test3<span class="meta">@baomidou</span>.com)</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">16</span>:<span class="number">56.186</span>  INFO <span class="number">19452</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">16</span>:<span class="number">56.202</span>  INFO <span class="number">19452</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="通过Map集合查询数据"><a href="#通过Map集合查询数据" class="headerlink" title="通过Map集合查询数据"></a>通过Map集合查询数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByMap</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//通过map条件查询用户信息</span></span><br><span class="line">    Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out :: println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: SELECT id,name,age,email FROM user <span class="type">WHERE</span> <span class="variable">name</span> <span class="operator">=</span> ? <span class="type">AND</span> <span class="variable">age</span> <span class="operator">=</span> ?</span><br><span class="line">==&gt; Parameters: Jack(String), <span class="number">20</span>(Integer)</span><br><span class="line">&lt;==    Columns: id, name, age, email</span><br><span class="line">&lt;==        Row: <span class="number">2</span>, Jack, <span class="number">20</span>, test2<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4acb2510]</span><br><span class="line">User(id=<span class="number">2</span>, name=Jack, age=<span class="number">20</span>, email=test2<span class="meta">@baomidou</span>.com)</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">20</span>:<span class="number">34.390</span>  INFO <span class="number">20808</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">20</span>:<span class="number">34.404</span>  INFO <span class="number">20808</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="查询所有数据"><a href="#查询所有数据" class="headerlink" title="查询所有数据"></a>查询所有数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//通过条件构造器查询一个list集合，若没有条件，则可以设置null为参数</span></span><br><span class="line">     List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">     users.forEach(System.out::println);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过观察BaseMapper中的方法，大多方法中都有Wrapper类型的形参，此为条件构造器，可针对于SQL语句设置不同的条件，若没有条件，则可以为该形参赋值null，即查询（删除&#x2F;修改）所有数据</p></blockquote><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: SELECT id,name,age,email FROM user</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: id, name, age, email</span><br><span class="line">&lt;==        Row: <span class="number">1</span>, Jone, <span class="number">18</span>, test1<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==        Row: <span class="number">2</span>, Jack, <span class="number">20</span>, test2<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==        Row: <span class="number">3</span>, Tom, <span class="number">28</span>, test3<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==        Row: <span class="number">4</span>, 李四, <span class="number">21</span>, lisi<span class="meta">@atSchool</span>.com</span><br><span class="line">&lt;==        Row: <span class="number">5</span>, Billie, <span class="number">24</span>, test5<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==        Row: <span class="number">6</span>, Sandy, <span class="number">21</span>, test4<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==        Row: <span class="number">7</span>, Billie, <span class="number">24</span>, test5<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==      Total: <span class="number">7</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@<span class="number">65753040</span>]</span><br><span class="line">User(id=<span class="number">1</span>, name=Jone, age=<span class="number">18</span>, email=test1<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">2</span>, name=Jack, age=<span class="number">20</span>, email=test2<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">3</span>, name=Tom, age=<span class="number">28</span>, email=test3<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">4</span>, name=李四, age=<span class="number">21</span>, email=lisi<span class="meta">@atSchool</span>.com)</span><br><span class="line">User(id=<span class="number">5</span>, name=Billie, age=<span class="number">24</span>, email=test5<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">6</span>, name=Sandy, age=<span class="number">21</span>, email=test4<span class="meta">@baomidou</span>.com)</span><br><span class="line">User(id=<span class="number">7</span>, name=Billie, age=<span class="number">24</span>, email=test5<span class="meta">@baomidou</span>.com)</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">23</span>:<span class="number">56.531</span>  INFO <span class="number">19052</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">23</span>:<span class="number">56.548</span>  INFO <span class="number">19052</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h3><p><strong><code>UserMapper.java</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id用户信息为map集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;String,Object&gt; <span class="title function_">selectMapById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>UserMapper.xml</code></strong></p><p>mapper配置文件默认地址</p><p><img src="/2021/11/13/MyBatis-Plus/image-20220916214957727.png" alt="image-20220916214957727"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.hua,study.mapper.UserMapper&quot;</span>&gt;</span><br><span class="line">    &lt;!--Map&lt;String,Object&gt; <span class="title function_">selectMapById</span><span class="params">(<span class="type">long</span> id)</span>;--&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;selectMapById&quot;</span> resultType=<span class="string">&quot;map&quot;</span>&gt;</span><br><span class="line">        select id,name,age,email from user where id=#&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectMapById</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = userMapper.selectMapById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: select id,name,age,email from user where id=?</span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(Long)</span><br><span class="line">&lt;==    Columns: id, name, age, email</span><br><span class="line">&lt;==        Row: <span class="number">1</span>, Jone, <span class="number">18</span>, test1<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7a904f32]</span><br><span class="line">&#123;name=Jone, id=<span class="number">1</span>, age=<span class="number">18</span>, email=test1<span class="meta">@baomidou</span>.com&#125;</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">53</span>:<span class="number">53.503</span>  INFO <span class="number">18756</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">00</span>:<span class="number">53</span>:<span class="number">53.516</span>  INFO <span class="number">18756</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="通用Service"><a href="#通用Service" class="headerlink" title="通用Service"></a>通用Service</h3><blockquote><p>说明:</p><ul><li><p>通用 Service CRUD 封装<a href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/service/IService.java">IService (opens new window)</a>接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆</p></li><li><p>泛型 <code>T</code> 为任意实体对象</p></li><li><p>建议如果存在自定义通用 Service 方法的可能，请创建自己的 <code>IBaseService</code> 继承 <code>Mybatis-Plus</code> 提供的基类</p></li><li><p>对象 <code>Wrapper</code> 为 <a href="https://baomidou.com/01.%E6%8C%87%E5%8D%97/02.%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/wrapper.html">条件构造器(opens new window)</a></p></li><li><p>官网地址：<a href="https://baomidou.com/pages/49cc81/#service-crud-%E6%8E%A5%E5%8F%">https://baomidou.com/pages/49cc81/#service-crud-%E6%8E%A5%E5%8F%</a> A3</p></li></ul></blockquote><h4 id="IService"><a href="#IService" class="headerlink" title="IService"></a>IService</h4><p>MyBatis-Plus中有一个接口 IService和其实现类 ServiceImpl，封装了常见的业务层逻辑</p><p>详情查看源码IService和ServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顶级 Service</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hubin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018-06-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IService</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认批次提交数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">DEFAULT_BATCH_SIZE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().insert(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入（批量）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> saveBatch(entityList, DEFAULT_BATCH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入（批量）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize  插入批次数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量修改插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> saveOrUpdateBatch(entityList, DEFAULT_BATCH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量修改插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize  每次的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 主键ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().deleteById(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id      主键(类型必须与实体类型字段保持一致)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> useFill 是否启用填充(为true的情况,会将入参转换实体进行delete删除)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id, <span class="type">boolean</span> useFill)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持的方法!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据实体(ID)删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.4.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().deleteById(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMap 表字段 map 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span> &#123;</span><br><span class="line">        Assert.notEmpty(columnMap, <span class="string">&quot;error: columnMap must not be empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().deleteByMap(columnMap));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体包装类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().delete(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 主键ID或实体列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;?&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().deleteBatchIds(list));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list    主键ID或实体列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> useFill 是否填充(为true的情况,会将入参转换实体进行delete删除)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;?&gt; list, <span class="type">boolean</span> useFill)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (useFill) &#123;</span><br><span class="line">            <span class="keyword">return</span> removeBatchByIds(list, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().deleteBatchIds(list));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除(jdbc批量提交)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 主键ID或实体列表(主键ID类型必须与实体类型字段保持一致)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeBatchByIds</span><span class="params">(Collection&lt;?&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeBatchByIds(list, DEFAULT_BATCH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除(jdbc批量提交)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list    主键ID或实体列表(主键ID类型必须与实体类型字段保持一致)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> useFill 是否启用填充(为true的情况,会将入参转换实体进行delete删除)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeBatchByIds</span><span class="params">(Collection&lt;?&gt; list, <span class="type">boolean</span> useFill)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeBatchByIds(list, DEFAULT_BATCH_SIZE, useFill);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除(jdbc批量提交)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list      主键ID或实体列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize 批次大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeBatchByIds</span><span class="params">(Collection&lt;?&gt; list, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持的方法!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除(jdbc批量提交)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list      主键ID或实体列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize 批次大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> useFill   是否启用填充(为true的情况,会将入参转换实体进行delete删除)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeBatchByIds</span><span class="params">(Collection&lt;?&gt; list, <span class="type">int</span> batchSize, <span class="type">boolean</span> useFill)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持的方法!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 选择修改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().updateById(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 whereEntity 条件，更新记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity        实体对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().update(entity, updateWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID 批量更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> updateBatchById(entityList, DEFAULT_BATCH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID 批量更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize  更新批次数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 主键ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> T <span class="title function_">getById</span><span class="params">(Serializable id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据ID 批量查询）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idList 主键ID列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectBatchIds(idList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据 columnMap 条件）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMap 表字段 map 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectByMap(columnMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper，查询一条记录 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getOne(queryWrapper, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwEx      有多个 result 是否抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapper       转换函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询总记录数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count(Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retCount(getBaseMapper().selectCount(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectList(queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list(Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻页查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         翻页对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; E <span class="title function_">page</span><span class="params">(E page, Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectPage(page, queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无条件翻页查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page 翻页对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; E <span class="title function_">page</span><span class="params">(E page)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> page(page, Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectMaps(queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listMaps(Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询全部记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listObjs(Function.identity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapper 转换函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listObjs(Wrappers.emptyWrapper(), mapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listObjs(queryWrapper, Function.identity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapper       转换函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectObjs(queryWrapper).stream().filter(Objects::nonNull).map(mapper).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻页查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         翻页对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; E <span class="title function_">pageMaps</span><span class="params">(E page, Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectMapsPage(page, queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无条件翻页查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page 翻页对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; E <span class="title function_">pageMaps</span><span class="params">(E page)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pageMaps(page, Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取对应 entity 的 BaseMapper</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> BaseMapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BaseMapper&lt;T&gt; <span class="title function_">getBaseMapper</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 entity 的 class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Class&lt;T&gt;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;T&gt; <span class="title function_">getEntityClass</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下的方法使用介绍:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 一. 名称介绍</span></span><br><span class="line"><span class="comment">     * 1. 方法名带有 query 的为对数据的查询操作, 方法名带有 update 的为对数据的修改操作</span></span><br><span class="line"><span class="comment">     * 2. 方法名带有 lambda 的为内部方法入参 column 支持函数式的</span></span><br><span class="line"><span class="comment">     * 二. 支持介绍</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 方法名带有 query 的支持以 &#123;<span class="doctag">@link</span> ChainQuery&#125; 内部的方法名结尾进行数据查询操作</span></span><br><span class="line"><span class="comment">     * 2. 方法名带有 update 的支持以 &#123;<span class="doctag">@link</span> ChainUpdate&#125; 内部的方法名为结尾进行数据修改操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 三. 使用示例,只用不带 lambda 的方法各展示一个例子,其他类推</span></span><br><span class="line"><span class="comment">     * 1. 根据条件获取一条数据: `query().eq(&quot;column&quot;, value).one()`</span></span><br><span class="line"><span class="comment">     * 2. 根据条件删除一条数据: `update().eq(&quot;column&quot;, value).remove()`</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式查询 普通</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> QueryWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> QueryChainWrapper&lt;T&gt; <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.queryChain(getBaseMapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式查询 lambda 式</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;注意：不支持 Kotlin &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LambdaQueryWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> LambdaQueryChainWrapper&lt;T&gt; <span class="title function_">lambdaQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.lambdaQueryChain(getBaseMapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式查询 lambda 式</span></span><br><span class="line"><span class="comment">     * kotlin 使用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> KtQueryWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> KtQueryChainWrapper&lt;T&gt; <span class="title function_">ktQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.ktQueryChain(getBaseMapper(), getEntityClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式查询 lambda 式</span></span><br><span class="line"><span class="comment">     * kotlin 使用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> KtQueryWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> KtUpdateChainWrapper&lt;T&gt; <span class="title function_">ktUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.ktUpdateChain(getBaseMapper(), getEntityClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式更改 普通</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> UpdateWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> UpdateChainWrapper&lt;T&gt; <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.updateChain(getBaseMapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式更改 lambda 式</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;注意：不支持 Kotlin &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LambdaUpdateWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> LambdaUpdateChainWrapper&lt;T&gt; <span class="title function_">lambdaUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.lambdaUpdateChain(getBaseMapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="comment">     * 此次修改主要是减少了此项业务代码的代码量（存在性验证之后的saveOrUpdate操作）</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> update(entity, updateWrapper) || saveOrUpdate(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="创建Service接口和实现类"><a href="#创建Service接口和实现类" class="headerlink" title="创建Service接口和实现类"></a>创建Service接口和实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserService继承IService模板提供的基础功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServiceImpl实现了IService，提供了IService中基础功能的实现</span></span><br><span class="line"><span class="comment"> * 若ServiceImpl无法满足业务需求，则可以使用自定的UserService定义方法，并在实现类中实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试查询记录数"><a href="#测试查询记录数" class="headerlink" title="测试查询记录数"></a>测试查询记录数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userService.count();</span><br><span class="line">        System.out.println(<span class="string">&quot;总记录数:&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: SELECT <span class="title function_">COUNT</span><span class="params">( * )</span> FROM user</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: COUNT( * )</span><br><span class="line">&lt;==        Row: <span class="number">7</span></span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@59901c4d]</span><br><span class="line">总记录数:<span class="number">7</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">01</span>:<span class="number">12</span>:<span class="number">23.828</span>  INFO <span class="number">1048</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">01</span>:<span class="number">12</span>:<span class="number">23.843</span>  INFO <span class="number">1048</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="测试批量插入"><a href="#测试批量插入" class="headerlink" title="测试批量插入"></a>测试批量插入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertMore</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">// SQL长度有限制，海量数据插入，单条SQL无法实现，</span></span><br><span class="line"><span class="comment">// 因此MP将批量插入放在了通用Service中实现，而不是通用Mapper</span></span><br><span class="line">      List&lt;User&gt; list =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span> ; i++) &#123;</span><br><span class="line">          <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">          user.setName(<span class="string">&quot;frx&quot;</span>+i);</span><br><span class="line">          user.setAge(<span class="number">20</span>+i);</span><br><span class="line">          list.add(user);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> userService.saveBatch(list);</span><br><span class="line">      System.out.println(b==<span class="literal">true</span>?<span class="string">&quot;操作成功&quot;</span>:<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: INSERT INTO <span class="title function_">user</span> <span class="params">( id, name, age )</span> VALUES ( ?, ?, ? )</span><br><span class="line">==&gt; Parameters: <span class="number">1514654840059076610</span>(Long), frx1(String), <span class="number">21</span>(Integer)</span><br><span class="line">==&gt; Parameters: <span class="number">1514654840226848770</span>(Long), frx2(String), <span class="number">22</span>(Integer)</span><br><span class="line">==&gt; Parameters: <span class="number">1514654840226848771</span>(Long), frx3(String), <span class="number">23</span>(Integer)</span><br><span class="line">==&gt; Parameters: <span class="number">1514654840268791810</span>(Long), frx4(String), <span class="number">24</span>(Integer)</span><br><span class="line">==&gt; Parameters: <span class="number">1514654840268791811</span>(Long), frx5(String), <span class="number">25</span>(Integer)</span><br><span class="line">==&gt; Parameters: <span class="number">1514654840268791812</span>(Long), frx6(String), <span class="number">26</span>(Integer)</span><br><span class="line">==&gt; Parameters: <span class="number">1514654840268791813</span>(Long), frx7(String), <span class="number">27</span>(Integer)</span><br><span class="line">==&gt; Parameters: <span class="number">1514654840268791814</span>(Long), frx8(String), <span class="number">28</span>(Integer)</span><br><span class="line">==&gt; Parameters: <span class="number">1514654840268791815</span>(Long), frx9(String), <span class="number">29</span>(Integer)</span><br><span class="line">==&gt; Parameters: <span class="number">1514654840268791816</span>(Long), frx10(String), <span class="number">30</span>(Integer)</span><br><span class="line">操作成功</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">01</span>:<span class="number">20</span>:<span class="number">29.833</span>  INFO <span class="number">22624</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">01</span>:<span class="number">20</span>:<span class="number">29.843</span>  INFO <span class="number">22624</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><blockquote><p>经过测试，在使用MyBatis-Plus实现基本的CRUD时，我们并没有指定要操作的表，只是在Mapper接口继承BaseMapper时，设置了<code>泛型User</code>，而操作的表为user表</p><p>由此得出结论，<code>MyBatis-Plus在确定操作的表</code>时，由<code>BaseMapper的泛型</code>决定，即<code>实体类型决定</code>，且默认操作的表名和实体类型的类名一致</p></blockquote><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote><p>若实体类类型的类名和要操作的表的表名不一致，会出现什么问题？</p><p>我们将表user更名为t_user，测试查询功能</p><p>程序抛出异常，Table ‘mybatis_plus.user’ doesn’t exist，因为现在的表名为t_user，而默认操作的表名和实体类型的类名一致，即user表</p></blockquote><p><img src="/2021/11/13/MyBatis-Plus/01-166323734166612.png" alt="01"></p><h4 id="通过-TableName解决问题"><a href="#通过-TableName解决问题" class="headerlink" title="通过@TableName解决问题"></a>通过@TableName解决问题</h4><blockquote><p>在实体类类型上添加@TableName(“t_user”)，标识实体类对应的表，即可成功执行SQL语句</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置实体类所对应的表名</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: INSERT INTO <span class="title function_">t_user</span> <span class="params">( id, name, age, email )</span> VALUES ( ?, ?, ?, ? )</span><br><span class="line">==&gt; Parameters: <span class="number">1514954860712968193</span>(Long), 张三(String), <span class="number">23</span>(Integer), zhangsan<span class="meta">@atschool</span>.com(String)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3e1a3801]</span><br><span class="line">result:<span class="number">1</span></span><br><span class="line">id:<span class="number">1514954860712968193</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">40.432</span>  INFO <span class="number">21548</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">40.439</span>  INFO <span class="number">21548</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="通过全局配置解决问题"><a href="#通过全局配置解决问题" class="headerlink" title="通过全局配置解决问题"></a>通过全局配置解决问题</h4><blockquote><p>在开发的过程中，我们经常遇到以上的问题，即实体类所对应的表都有固定的前缀，例如t_或tbl_</p><p>此时，可以使用MyBatis-Plus提供的全局配置，为实体类所对应的表名设置默认的前缀，那么就 不需要在每个实体类上通过@TableName标识实体类对应的表</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#配置mybatis日志</span><br><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">  #设置mybatis-plus的全局配置</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      #设置实体类表的统一前缀</span><br><span class="line">      table-prefix: t_</span><br></pre></td></tr></table></figure><h3 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@TableId</h3><blockquote><p>经过测试，MyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id</p></blockquote><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><blockquote><p>若实体类和表中表示主键的不是id，而是其他字段，例如uid，MyBatis-Plus会自动识别uid为主键列吗？</p><p>我们实体类中的属性id改为uid，将表中的字段id也改为uid，测试添加功能</p><p>程序抛出异常，Field ‘uid’ doesn’t have a default value，说明MyBatis-Plus没有将uid作为主键赋值</p></blockquote><p><img src="/2021/11/13/MyBatis-Plus/02-16632373243279.png" alt="01"></p><h4 id="通过-TableId解决问题"><a href="#通过-TableId解决问题" class="headerlink" title="通过@TableId解决问题"></a>通过@TableId解决问题</h4><blockquote><p>在实体类中uid属性上通过@TableId将其标识为主键，即可成功执行SQL语句</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long uid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: INSERT INTO <span class="title function_">t_user</span> <span class="params">( uid, name, age, email )</span> VALUES ( ?, ?, ?, ? )</span><br><span class="line">==&gt; Parameters: <span class="number">1514961328925437954</span>(Long), 张三(String), <span class="number">23</span>(Integer), zhangsan<span class="meta">@atschool</span>.com(String)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@54f4a7f0]</span><br><span class="line">result:<span class="number">1</span></span><br><span class="line">id:<span class="number">1514961328925437954</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">21</span>:<span class="number">38</span>:<span class="number">22.589</span>  INFO <span class="number">23732</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">21</span>:<span class="number">38</span>:<span class="number">22.708</span>  INFO <span class="number">23732</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="TableId的value属性"><a href="#TableId的value属性" class="headerlink" title="@TableId的value属性"></a>@TableId的value属性</h4><blockquote><p>若实体类中主键对应的属性为id，而表中表示主键的字段为uid，此时若只在属性id上添加注解@TableId，则抛出异常Unknown column ‘id’ in ‘field list’，即MyBatis-Plus仍然会将id作为表的主键操作，而表中表示主键的是字段uid</p><p>此时需要通过@TableId注解的value属性，指定表中的主键字段，<code>@TableId(&quot;uid&quot;)</code>或<code>@TableId(value=&quot;uid&quot;)</code></p></blockquote><p><img src="/2021/11/13/MyBatis-Plus/03-166323746951715.png" alt="01"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将属性所对应的字段指定为主键</span></span><br><span class="line">    <span class="comment">//@Table注解的value属性用于指定主键的字段</span></span><br><span class="line">    <span class="meta">@TableId(&quot;uid&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TableId的type属性"><a href="#TableId的type属性" class="headerlink" title="@TableId的type属性"></a>@TableId的type属性</h4><blockquote><p><strong>type属性用来定义主键策略</strong></p></blockquote><p>常用的主键策略：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>IdType.ASSIGN_ID（默认）</td><td>基于雪花算法的策略生成数据id，与数据库id是否设置自增无关</td></tr><tr><td>IdType.AUTO</td><td>使用数据库的自增策略，注意，<code>该类型请确保数据库设置了id自增</code>，否则无效</td></tr></tbody></table><h5 id="单个实体类配置主键策略"><a href="#单个实体类配置主键策略" class="headerlink" title="单个实体类配置主键策略"></a>单个实体类配置主键策略</h5><p>修改表为自动递增</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_user MODIFY uid <span class="type">BIGINT</span> AUTO_INCREMENT</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将属性所对应的字段指定为主键</span></span><br><span class="line">    <span class="comment">//@Table注解的value属性用于指定主键的字段</span></span><br><span class="line">    <span class="meta">@TableId(value = &quot;uid&quot;,type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置全局主键策略"><a href="#配置全局主键策略" class="headerlink" title="配置全局主键策略"></a>配置全局主键策略</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#配置mybatis日志</span><br><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">  #设置mybatis-plus的全局配置</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      # 配置MyBatis-Plus操作表的默认前缀</span><br><span class="line">      table-prefix: t_</span><br><span class="line">      # 配置MyBatis-Plus的主键策略</span><br><span class="line">      id-type: auto</span><br></pre></td></tr></table></figure><h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><ul><li>背景</li></ul><p>需要选择合适的方案去应对数据规模的增长，以应对逐渐增长的访问压力和数据量。</p><p>数据库的扩展方式主要包括：<strong>业务分库、主从复制，数据库分表</strong>。</p><ul><li>数据库分表</li></ul><p>将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据，如果全部存放在一台数据库服务器的一张表中，肯定是无法满足性能要求的，此时就需要对单表数据进行拆分。</p><p>单表数据拆分有两种方式：<strong>垂直分表和水平分表。</strong>示意图如下：</p><p><img src="/2021/11/13/MyBatis-Plus/04.png" alt="01"></p><ul><li><strong>垂直分表</strong></li></ul><p>垂直分表适合将表中某些不常用且占了大量空间的列拆分出去。</p><p>例如，前面示意图中的 nickname 和 description 字段，假设我们是一个婚恋网站，用户在筛选其他用户的时候，主要是用 age 和 sex 两个字段进行查询，而 nickname 和 description 两个字段主要用于展示，一般不会在业务查询中用到。description 本身又比较长，因此我们可以将这两个字段独立到另外一张表中，这样在查询 age 和 sex 时，就能带来一定的性能提升。</p><ul><li><strong>水平分表</strong></li></ul><p>水平分表适合表行数特别大的表，有的公司要求单表行数超过 5000 万就必须进行分表，这个数字可以作为参考，但并不是绝对标准，关键还是要看表的访问性能。对于一些比较复杂的表，可能超过 1000万就要分表了；而对于一些简单的表，即使存储数据超过 1 亿行，也可以不分表。</p><p>但不管怎样，当看到表的数据量达到千万级别时，作为架构师就要警觉起来，因为这很可能是架构的性能瓶颈或者隐患。</p><p>水平分表相比垂直分表，会引入更多的复杂性，例如要求全局唯一的数据id该如何处理</p><blockquote><p><strong>主键自增</strong></p></blockquote><ol><li>以最常见的用户 ID 为例，可以按照 1000000 的范围大小进行分段，1 ~ 999999 放到表 1中，1000000 ~ 1999999 放到表2中，以此类推。</li><li>复杂点：分段大小的选取。分段太小会导致切分后子表数量过多，增加维护复杂度；分段太大可能会导致单表依然存在性能问题，一般建议分段大小在 100 万至 2000 万之间，具体需要根据业务选取合适的分段大小。</li><li>优点：可以随着数据的增加平滑地扩充新的表。例如，现在的用户是 100 万，如果增加到 1000 万，只需要增加新的表就可以了，原有的数据不需要动。</li><li>缺点：分布不均匀。假如按照 1000 万来进行分表，有可能某个分段实际存储的数据量只有 1 条，而另外一个分段实际存储的数据量有 1000 万条。</li></ol><blockquote><p><strong>取模</strong></p></blockquote><ol><li>同样以用户 ID 为例，假如我们一开始就规划了 10 个数据库表，可以简单地用 user_id % 10 的值来表示数据所属的数据库表编号，ID 为 985 的用户放到编号为 5 的子表中，ID 为 10086 的用户放到编号为 6 的子中。</li><li>复杂点：初始表数量的确定。表数量太多维护比较麻烦，表数量太少又可能导致单表性能存在问题。</li><li>优点：表分布比较均匀。</li><li>缺点：扩充新的表很麻烦，所有数据都要重分布。</li></ol><blockquote><p><strong>雪花算法</strong></p></blockquote><p>雪花算法是由Twitter公布的分布式主键生成算法，它能够保证不同表的主键的不重复性，以及相同表的主键的有序性。</p><ul><li>核心思想：</li></ul><p>长度共64bit（一个long型）。</p><p>首先是一个符号位，1bit标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0。</p><p>41bit时间截(毫秒级)，存储的是时间截的差值（当前时间截 - 开始时间截)，结果约等于69.73年。</p><p>10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID，可以部署在1024个节点）。</p><p>12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）。</p><p><img src="/2021/11/13/MyBatis-Plus/05-16632372459433.png" alt="01"></p><ul><li>优点：</li></ul><p>整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高。</p><h3 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a>@TableField</h3><blockquote><p>经过以上的测试，我们可以发现，MyBatis-Plus在执行SQL语句时，要保证实体类中的属性名和表中的字段名一致</p><p>如果实体类中的属性名和字段名不一致的情况，会出现什么问题呢？</p></blockquote><h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><blockquote><p>若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格</p><p>例如实体类属性userName，表中字段user_name</p><p>此时MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格</p><p>相当于在MyBatis中配置</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TableId(&quot;uid&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: INSERT INTO <span class="title function_">t_user</span> <span class="params">( user_name, age, email )</span> VALUES ( ?, ?, ? )</span><br><span class="line">==&gt; Parameters: 张三(String), <span class="number">23</span>(Integer), zhangsan<span class="meta">@atschool</span>.com(String)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7d199c68]</span><br><span class="line">result:<span class="number">1</span></span><br><span class="line">id:<span class="number">9</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">52.711</span>  INFO <span class="number">22932</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">52.750</span>  INFO <span class="number">22932</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h4><blockquote><p>若实体类中的属性和表中的字段不满足情况1</p><p>例如实体类属性name，表中字段username</p><p>此时需要在实体类属性上使用<code>@TableField(&quot;username&quot;)</code>设置属性所对应的字段名</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId(&quot;uid&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//指定属性所对应的字段名</span></span><br><span class="line">    <span class="meta">@TableField(&quot;user_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: INSERT INTO <span class="title function_">t_user</span> <span class="params">( user_name, age, email )</span> VALUES ( ?, ?, ? )</span><br><span class="line">==&gt; Parameters: 张三(String), <span class="number">23</span>(Integer), zhangsan<span class="meta">@atschool</span>.com(String)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@<span class="number">63411512</span>]</span><br><span class="line">result:<span class="number">1</span></span><br><span class="line">id:<span class="number">10</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">22</span>:<span class="number">59</span>:<span class="number">14.481</span>  INFO <span class="number">24940</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">22</span>:<span class="number">59</span>:<span class="number">14.489</span>  INFO <span class="number">24940</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="TableLogic"><a href="#TableLogic" class="headerlink" title="@TableLogic"></a>@TableLogic</h3><h4 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h4><ul><li>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</li><li>逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库 中仍旧能看到此条数据记录</li><li>使用场景：可以进行数据恢复</li></ul><h4 id="实现逻辑删除"><a href="#实现逻辑删除" class="headerlink" title="实现逻辑删除"></a>实现逻辑删除</h4><ol><li>数据库中创建逻辑删除状态列，设置默认值为0</li><li>实体类中添加逻辑删除属性</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId(&quot;uid&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//指定属性所对应的字段名</span></span><br><span class="line">    <span class="meta">@TableField(&quot;user_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer isDeleted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​3. 测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Long&gt; list = Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteBatchIds(list);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">删除变成了修改,将is_deleted属性修改为<span class="number">1</span></span><br><span class="line">==&gt;  Preparing: UPDATE t_user SET is_deleted=<span class="number">1</span> WHERE uid <span class="title function_">IN</span> <span class="params">( ? , ? , ? )</span> AND is_deleted=<span class="number">0</span></span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(Long), <span class="number">2</span>(Long), <span class="number">3</span>(Long)</span><br><span class="line">&lt;==    Updates: <span class="number">3</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@35764bef]</span><br><span class="line">result:<span class="number">3</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">23</span>:09:<span class="number">25.702</span>  INFO <span class="number">21568</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">15</span> <span class="number">23</span>:09:<span class="number">25.715</span>  INFO <span class="number">21568</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="条件构造器和常用接口"><a href="#条件构造器和常用接口" class="headerlink" title="条件构造器和常用接口"></a>条件构造器和常用接口</h2><h3 id="wapper介绍"><a href="#wapper介绍" class="headerlink" title="wapper介绍"></a>wapper介绍</h3><p><img src="/2021/11/13/MyBatis-Plus/01-16632372925776.png" alt="01"></p><ul><li>Wrapper ： 条件构造抽象类，最顶端父类<ul><li>AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件<ul><li>QueryWrapper ： 查询条件封装</li><li>UpdateWrapper ： Update 条件封装</li><li>AbstractLambdaWrapper ： 使用Lambda 语法<ul><li>LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper</li><li>LambdaUpdateWrapper ： Lambda 更新封装Wrapper</li></ul></li></ul></li></ul></li></ul><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h3><blockquote><p><strong>方法参数中的<code>String column</code>，要写数据库中的字段名</strong></p></blockquote><h4 id="组装查询条件"><a href="#组装查询条件" class="headerlink" title="组装查询条件"></a>组装查询条件</h4><blockquote><p>查询用户名包含a,年龄在20到30之间，邮箱信息不为null的用户信息</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper=<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.like(<span class="string">&quot;user_name&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">                .between(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>,<span class="number">30</span>)</span><br><span class="line">                .isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">        List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">        list.forEach(System.out :: println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=<span class="number">0</span> AND (user_name LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)<span class="comment">//未删除状态的数据</span></span><br><span class="line">==&gt; Parameters: %a%(String), <span class="number">20</span>(Integer), <span class="number">30</span>(Integer)</span><br><span class="line">&lt;==    Columns: id, name, age, email, is_deleted</span><br><span class="line">&lt;==        Row: <span class="number">6</span>, Sandy, <span class="number">21</span>, test4<span class="meta">@baomidou</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7a7cc52c]</span><br><span class="line">User(id=<span class="number">6</span>, name=Sandy, age=<span class="number">21</span>, email=test4<span class="meta">@baomidou</span>.com, isDeleted=<span class="number">0</span>)</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">23</span>:<span class="number">31.912</span>  INFO <span class="number">24952</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">23</span>:<span class="number">31.933</span>  INFO <span class="number">24952</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="组装排序条件"><a href="#组装排序条件" class="headerlink" title="组装排序条件"></a>组装排序条件</h4><blockquote><p>查询用户信息，按照年龄的降序排序，若年龄相同，则按照Id升序排序</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">       QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">       queryWrapper.orderByDesc(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">               .orderByAsc(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">       List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">       list.forEach(System.out :: println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=<span class="number">0</span> ORDER BY age DESC,uid ASC</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: id, name, age, email, is_deleted</span><br><span class="line">&lt;==        Row: <span class="number">7</span>, Billie, <span class="number">24</span>, test5<span class="meta">@baomidou</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">8</span>, 张三, <span class="number">23</span>, zhangsan<span class="meta">@atschool</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">9</span>, 张三, <span class="number">23</span>, zhangsan<span class="meta">@atschool</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">10</span>, 张三, <span class="number">23</span>, zhangsan<span class="meta">@atschool</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">6</span>, Sandy, <span class="number">21</span>, test4<span class="meta">@baomidou</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==      Total: <span class="number">5</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@<span class="number">69228e85</span>]</span><br><span class="line">User(id=<span class="number">7</span>, name=Billie, age=<span class="number">24</span>, email=test5<span class="meta">@baomidou</span>.com, isDeleted=<span class="number">0</span>)</span><br><span class="line">User(id=<span class="number">8</span>, name=张三, age=<span class="number">23</span>, email=zhangsan<span class="meta">@atschool</span>.com, isDeleted=<span class="number">0</span>)</span><br><span class="line">User(id=<span class="number">9</span>, name=张三, age=<span class="number">23</span>, email=zhangsan<span class="meta">@atschool</span>.com, isDeleted=<span class="number">0</span>)</span><br><span class="line">User(id=<span class="number">10</span>, name=张三, age=<span class="number">23</span>, email=zhangsan<span class="meta">@atschool</span>.com, isDeleted=<span class="number">0</span>)</span><br><span class="line">User(id=<span class="number">6</span>, name=Sandy, age=<span class="number">21</span>, email=test4<span class="meta">@baomidou</span>.com, isDeleted=<span class="number">0</span>)</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">37</span>:<span class="number">32.032</span>  INFO <span class="number">15980</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">37</span>:<span class="number">32.067</span>  INFO <span class="number">15980</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="组装删除条件"><a href="#组装删除条件" class="headerlink" title="组装删除条件"></a>组装删除条件</h4><blockquote><p>删除邮箱地址为null的用户信息</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//删除邮箱地址为null的用户信息</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span>  <span class="operator">=</span> userMapper.delete(queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响行数:&quot;</span>+result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE t_user SET is_deleted=<span class="number">1</span> WHERE is_deleted=<span class="number">0</span> AND (email IS NULL)逻辑删除</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7139bd31]</span><br><span class="line">受影响行数:<span class="number">1</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">47</span>:<span class="number">28.182</span>  INFO <span class="number">14044</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">47</span>:<span class="number">28.414</span>  INFO <span class="number">14044</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="条件的优先级"><a href="#条件的优先级" class="headerlink" title="条件的优先级"></a>条件的优先级</h4><blockquote><p>将（年龄大于20并且用户名中包含有a）或邮箱为null的用户信息修改</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">       QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">       queryWrapper.gt(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>)</span><br><span class="line">               .like(<span class="string">&quot;user_name&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">               .or()</span><br><span class="line">               .isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">       user.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">       user.setEmail(<span class="string">&quot;test@atSchool.com&quot;</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, queryWrapper);</span><br><span class="line">       System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: UPDATE t_user SET user_name=?, email=? WHERE is_deleted=<span class="number">0</span> AND (age &gt; ? AND user_name LIKE ? OR email IS NULL)</span><br><span class="line">==&gt; Parameters: 小明(String), test<span class="meta">@atSchool</span>.com(String), <span class="number">20</span>(Integer), %a%(String)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@150ede8b]</span><br><span class="line">result:<span class="number">1</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">58</span>:<span class="number">17.434</span>  INFO <span class="number">12304</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">58</span>:<span class="number">17.447</span>  INFO <span class="number">12304</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//lambda表达式内的逻辑优先运算</span></span><br><span class="line">    queryWrapper.like(<span class="string">&quot;user_name&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">            .and(i-&gt;i.gt(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>)</span><br><span class="line">                    .or()</span><br><span class="line">                    .isNull(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;test@atSchool.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: UPDATE t_user SET user_name=?, email=? WHERE is_deleted=<span class="number">0</span> AND (user_name LIKE ? AND (age &gt; ? OR email IS NULL))</span><br><span class="line">==&gt; Parameters: 小红(String), test<span class="meta">@atSchool</span>.com(String), %a%(String), <span class="number">20</span>(Integer)</span><br><span class="line">&lt;==    Updates: <span class="number">0</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4e1ce44]</span><br><span class="line">result:<span class="number">0</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">22</span>:<span class="number">15</span>:<span class="number">10.654</span>  INFO <span class="number">4324</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">22</span>:<span class="number">15</span>:<span class="number">10.707</span>  INFO <span class="number">4324</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="组装select子句"><a href="#组装select子句" class="headerlink" title="组装select子句"></a>组装select子句</h4><blockquote><p>查询用户信息的username，age和email字段</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.select(<span class="string">&quot;user_name&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);</span><br><span class="line">    maps.forEach(System.out :: println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: SELECT user_name,age,email FROM t_user WHERE is_deleted=<span class="number">0</span></span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: user_name, age, email</span><br><span class="line">&lt;==        Row: 小明, <span class="number">21</span>, test<span class="meta">@atSchool</span>.com</span><br><span class="line">&lt;==        Row: Billie, <span class="number">24</span>, test5<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==        Row: 张三, <span class="number">23</span>, zhangsan<span class="meta">@atschool</span>.com</span><br><span class="line">&lt;==        Row: 张三, <span class="number">23</span>, zhangsan<span class="meta">@atschool</span>.com</span><br><span class="line">&lt;==        Row: 张三, <span class="number">23</span>, zhangsan<span class="meta">@atschool</span>.com</span><br><span class="line">&lt;==      Total: <span class="number">5</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@602ae7b6]</span><br><span class="line">&#123;user_name=小明, age=<span class="number">21</span>, email=test<span class="meta">@atSchool</span>.com&#125;</span><br><span class="line">&#123;user_name=Billie, age=<span class="number">24</span>, email=test5<span class="meta">@baomidou</span>.com&#125;</span><br><span class="line">&#123;user_name=张三, age=<span class="number">23</span>, email=zhangsan<span class="meta">@atschool</span>.com&#125;</span><br><span class="line">&#123;user_name=张三, age=<span class="number">23</span>, email=zhangsan<span class="meta">@atschool</span>.com&#125;</span><br><span class="line">&#123;user_name=张三, age=<span class="number">23</span>, email=zhangsan<span class="meta">@atschool</span>.com&#125;</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">22</span>:<span class="number">31</span>:<span class="number">19.068</span>  INFO <span class="number">25564</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">22</span>:<span class="number">31</span>:<span class="number">19.251</span>  INFO <span class="number">25564</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="实现子查询"><a href="#实现子查询" class="headerlink" title="实现子查询"></a>实现子查询</h4><blockquote><p>查询id小于等于4的用户信息</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.inSql(<span class="string">&quot;uid&quot;</span>,<span class="string">&quot;select uid from t_user where uid&lt;=4&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out :: println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=<span class="number">0</span> AND (uid <span class="title function_">IN</span> <span class="params">(select uid from t_user where uid&lt;=<span class="number">4</span>)</span>)</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==      Total: <span class="number">0</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3e15bb06]</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">12.244</span>  INFO <span class="number">25816</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">12.331</span>  INFO <span class="number">25816</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h3><blockquote><p>将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span>&#123;</span><br><span class="line">    UpdateWrapper&lt;User&gt; userUpdateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    userUpdateWrapper.like(<span class="string">&quot;user_name&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">            .and(i-&gt;i.gt(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>)</span><br><span class="line">            .or()</span><br><span class="line">            .isNull(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">    userUpdateWrapper.set(<span class="string">&quot;user_name&quot;</span>,<span class="string">&quot;小黑&quot;</span>)</span><br><span class="line">            .set(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;abc@atSchool.com&quot;</span>); <span class="comment">//不需要创建user对象</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, userUpdateWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: UPDATE t_user SET user_name=?,email=? WHERE is_deleted=<span class="number">0</span> AND (user_name LIKE ? AND (age &gt; ? OR email IS NULL))</span><br><span class="line">==&gt; Parameters: 小黑(String), abc<span class="meta">@atSchool</span>.com(String), %a%(String), <span class="number">20</span>(Integer)</span><br><span class="line">&lt;==    Updates: <span class="number">0</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2f61d591]</span><br><span class="line">result:<span class="number">0</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">22</span>:<span class="number">50</span>:<span class="number">23.079</span>  INFO <span class="number">24852</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">22</span>:<span class="number">50</span>:<span class="number">23.125</span>  INFO <span class="number">24852</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h3><blockquote><p>在真正开发的过程中，组装条件是常见的功能，而这些条件数据来源于用户输入，是可选的，因此我们在组装这些条件时，必须先判断用户是否选择了这些条件，若选择则需要组装该条件，若没有选择则一定不能组装，以免影响SQL执行的结果</p></blockquote><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//定义查询条件，有可能为null（用户未输入或未选择）</span></span><br><span class="line">       String username=<span class="string">&quot;&quot;</span>;</span><br><span class="line">       Integer ageBegin=<span class="number">20</span>;</span><br><span class="line">       Integer ageEnd=<span class="number">30</span>;</span><br><span class="line">       QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(StringUtils.isNotBlank(username))&#123;</span><br><span class="line">           <span class="comment">//isNotBlank 判断某个字符串是否不为空字符串、不为null、不为空白符</span></span><br><span class="line">           queryWrapper.like(<span class="string">&quot;user_name&quot;</span>,username);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(ageBegin!=<span class="literal">null</span>)&#123;</span><br><span class="line">           queryWrapper.ge(<span class="string">&quot;age&quot;</span>,ageBegin);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(ageEnd!=<span class="literal">null</span>)&#123;</span><br><span class="line">           queryWrapper.le(<span class="string">&quot;age&quot;</span>,ageEnd);</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">       list.forEach(System.out :: println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=<span class="number">0</span> AND (age &gt;= ? AND age &lt;= ?)</span><br><span class="line">==&gt; Parameters: <span class="number">20</span>(Integer), <span class="number">30</span>(Integer)</span><br><span class="line">&lt;==    Columns: id, name, age, email, is_deleted</span><br><span class="line">&lt;==        Row: <span class="number">6</span>, 小明, <span class="number">21</span>, test<span class="meta">@atSchool</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">7</span>, Billie, <span class="number">24</span>, test5<span class="meta">@baomidou</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">8</span>, 张三, <span class="number">23</span>, zhangsan<span class="meta">@atschool</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">9</span>, 张三, <span class="number">23</span>, zhangsan<span class="meta">@atschool</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">10</span>, 张三, <span class="number">23</span>, zhangsan<span class="meta">@atschool</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==      Total: <span class="number">5</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2f61d591]</span><br><span class="line">User(id=<span class="number">6</span>, name=小明, age=<span class="number">21</span>, email=test<span class="meta">@atSchool</span>.com, isDeleted=<span class="number">0</span>)</span><br><span class="line">User(id=<span class="number">7</span>, name=Billie, age=<span class="number">24</span>, email=test5<span class="meta">@baomidou</span>.com, isDeleted=<span class="number">0</span>)</span><br><span class="line">User(id=<span class="number">8</span>, name=张三, age=<span class="number">23</span>, email=zhangsan<span class="meta">@atschool</span>.com, isDeleted=<span class="number">0</span>)</span><br><span class="line">User(id=<span class="number">9</span>, name=张三, age=<span class="number">23</span>, email=zhangsan<span class="meta">@atschool</span>.com, isDeleted=<span class="number">0</span>)</span><br><span class="line">User(id=<span class="number">10</span>, name=张三, age=<span class="number">23</span>, email=zhangsan<span class="meta">@atschool</span>.com, isDeleted=<span class="number">0</span>)</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">23</span>:<span class="number">01</span>:<span class="number">59.138</span>  INFO <span class="number">23772</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">23</span>:<span class="number">01</span>:<span class="number">59.163</span>  INFO <span class="number">23772</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><blockquote><p>上面的实现方案没有问题，但是代码比较复杂，我们可以使用带condition参数的重载方法构建查询条件，简化代码的编写</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span>&#123;</span><br><span class="line">    String username=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">    Integer ageBegin=<span class="literal">null</span>;</span><br><span class="line">    Integer ageEnd=<span class="number">30</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(StringUtils.isNotBlank(username),<span class="string">&quot;user_name&quot;</span>,username)</span><br><span class="line">            .ge(ageBegin!=<span class="literal">null</span>,<span class="string">&quot;age&quot;</span>,ageBegin)</span><br><span class="line">            .le(ageEnd!=<span class="literal">null</span>,<span class="string">&quot;age&quot;</span>,ageEnd);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=<span class="number">0</span> AND (user_name LIKE ? AND age &lt;= ?)</span><br><span class="line">==&gt; Parameters: %a%(String), <span class="number">30</span>(Integer)</span><br><span class="line">&lt;==      Total: <span class="number">0</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@524a2ffb]</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">23</span>:<span class="number">13</span>:<span class="number">16.331</span>  INFO <span class="number">26596</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">23</span>:<span class="number">13</span>:<span class="number">16.370</span>  INFO <span class="number">26596</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="LambdaQueryWrapper"><a href="#LambdaQueryWrapper" class="headerlink" title="LambdaQueryWrapper"></a>LambdaQueryWrapper</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//定义查询条件，有可能为null（用户未输入）</span></span><br><span class="line">    String username=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">    Integer ageBegin=<span class="literal">null</span>;</span><br><span class="line">    Integer ageEnd=<span class="number">30</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; userLambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//避免使用字符串表示字段，防止运行时错误</span></span><br><span class="line">    userLambdaQueryWrapper.like(StringUtils.isNotBlank(username),</span><br><span class="line">            User::getName,username)</span><br><span class="line">            .ge(ageBegin!=<span class="literal">null</span>,User::getAge,ageBegin)</span><br><span class="line">            .le(ageEnd!=<span class="literal">null</span>,User::getAge,ageEnd);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(userLambdaQueryWrapper);</span><br><span class="line">    list.forEach(System.out :: println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=<span class="number">0</span> AND (user_name LIKE ? AND age &lt;= ?)</span><br><span class="line">==&gt; Parameters: %a%(String), <span class="number">30</span>(Integer)</span><br><span class="line">&lt;==      Total: <span class="number">0</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@75361cf6]</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">23</span>:<span class="number">21</span>:<span class="number">28.345</span>  INFO <span class="number">5168</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">23</span>:<span class="number">21</span>:<span class="number">28.371</span>  INFO <span class="number">5168</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="LambdaUpdateWrapper"><a href="#LambdaUpdateWrapper" class="headerlink" title="LambdaUpdateWrapper"></a>LambdaUpdateWrapper</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test12</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//组装set子句</span></span><br><span class="line">    LambdaUpdateWrapper&lt;User&gt; userLambdaUpdateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    userLambdaUpdateWrapper.like(User :: getName,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">            .and(i-&gt;i.gt(User::getAge,<span class="number">20</span>)</span><br><span class="line">                    .or().isNull(User::getEmail));</span><br><span class="line">    userLambdaUpdateWrapper.set(User::getName,<span class="string">&quot;小黑&quot;</span>)</span><br><span class="line">            .set(User ::getEmail,<span class="string">&quot;abc@atSchool.com&quot;</span>);<span class="comment">//lambda表达式内的逻辑优先运算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, userLambdaUpdateWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: UPDATE t_user SET user_name=?,email=? WHERE is_deleted=<span class="number">0</span> AND (user_name LIKE ? AND (age &gt; ? OR email IS NULL))</span><br><span class="line">==&gt; Parameters: 小黑(String), abc<span class="meta">@atSchool</span>.com(String), %a%(String), <span class="number">20</span>(Integer)</span><br><span class="line">&lt;==    Updates: <span class="number">0</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6d303498]</span><br><span class="line">result:<span class="number">0</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">23</span>:<span class="number">35</span>:<span class="number">34.607</span>  INFO <span class="number">22852</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">17</span> <span class="number">23</span>:<span class="number">35</span>:<span class="number">34.710</span>  INFO <span class="number">22852</span> --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><blockquote><p>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能</p></blockquote><h4 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com.hua.study.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusPluginsTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pluginsTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//显示第2页，每页三条数据</span></span><br><span class="line">        Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;User&gt;(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        userMapper.selectPage(page,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(page);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前页：&quot;</span>+page.getCurrent());</span><br><span class="line">        System.out.println(<span class="string">&quot;获取当前页数据:&quot;</span>+page.getRecords());</span><br><span class="line">        System.out.println(<span class="string">&quot;获取总页数:&quot;</span>+page.getPages());</span><br><span class="line">        System.out.println(<span class="string">&quot;获取总记录数:&quot;</span>+page.getTotal());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否有上一页：&quot;</span>+page.hasPrevious());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否有下一页：&quot;</span>+page.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span>-09-<span class="number">15</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">01.793</span>  INFO <span class="number">3268</span> --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Start completed.</span><br><span class="line">JDBC Connection [HikariProxyConnection@<span class="number">1377212248</span> wrapping com.mysql.cj.jdbc.ConnectionImpl@3eda0aeb] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: SELECT <span class="title function_">COUNT</span><span class="params">(*)</span> AS total FROM t_user <span class="type">WHERE</span> <span class="variable">is_delete</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: total</span><br><span class="line">&lt;==        Row: <span class="number">6</span></span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">==&gt;  Preparing: SELECT uid AS id,user_name AS name,age,email,is_delete FROM t_user WHERE is_delete=<span class="number">0</span> LIMIT ?,?</span><br><span class="line">==&gt; Parameters: <span class="number">3</span>(Long), <span class="number">3</span>(Long)</span><br><span class="line">&lt;==    Columns: id, name, age, email, is_delete</span><br><span class="line">&lt;==        Row: <span class="number">4</span>, lisi, <span class="number">21</span>, mybatis<span class="meta">@java</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">5</span>, Billie, <span class="number">24</span>, test5<span class="meta">@baomidou</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">1570043604863307777</span>, zhangsan, <span class="number">15</span>, mybatis@<span class="number">163.</span>com, <span class="number">0</span></span><br><span class="line">&lt;==      Total: <span class="number">3</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2b329bbd]</span><br><span class="line">com.baomidou.mybatisplus.extension.plugins.pagination.Page@36cc9385</span><br><span class="line">当前页：<span class="number">2</span></span><br><span class="line">获取当前页数据:[User(id=<span class="number">4</span>, name=lisi, age=<span class="number">21</span>, email=mybatis<span class="meta">@java</span>.com, isDelete=<span class="number">0</span>), User(id=<span class="number">5</span>, name=Billie, age=<span class="number">24</span>, email=test5<span class="meta">@baomidou</span>.com, isDelete=<span class="number">0</span>), User(id=<span class="number">1570043604863307777</span>, name=zhangsan, age=<span class="number">15</span>, email=mybatis@<span class="number">163.</span>com, isDelete=<span class="number">0</span>)]</span><br><span class="line">获取总页数:<span class="number">2</span></span><br><span class="line">获取总记录数:<span class="number">6</span></span><br><span class="line">是否有上一页：<span class="literal">true</span></span><br><span class="line">是否有下一页：<span class="literal">false</span></span><br><span class="line"><span class="number">2022</span>-09-<span class="number">15</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">01.855</span>  INFO <span class="number">3268</span> --- [extShutdownHook] com.zaxxer.hikari.HikariDataSource  </span><br></pre></td></tr></table></figure><h3 id="xml自定义分页"><a href="#xml自定义分页" class="headerlink" title="xml自定义分页"></a>xml自定义分页</h3><h4 id="UserMapper中定义接口方法"><a href="#UserMapper中定义接口方法" class="headerlink" title="UserMapper中定义接口方法"></a>UserMapper中定义接口方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; <span class="title function_">selectById</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过年龄查询用户信息并分页</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page Mybatis-Plus所提供的分页对象，必须位于第一位参数的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    Page&lt;User&gt; <span class="title function_">selectPageVo</span><span class="params">(<span class="meta">@Param(&quot;page&quot;)</span> Page&lt;User&gt; page,<span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置文件设置别名"><a href="#配置文件设置别名" class="headerlink" title="配置文件设置别名"></a>配置文件设置别名</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 配置数据源信息</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment"># 配置数据源类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="comment"># 配置连接数据库的各个信息</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="comment"># 设置Mybatis-Plus的全局配置</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="comment"># 设置实体类的统一前缀 会自动在实体类前加上前缀</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br><span class="line">      <span class="comment"># 设置全局统一的主键生成策略</span></span><br><span class="line">      <span class="comment">#id-type: auto</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.hua.study.pojo</span></span><br></pre></td></tr></table></figure><h4 id="UserMapper-xml中编写sql"><a href="#UserMapper-xml中编写sql" class="headerlink" title="UserMapper.xml中编写sql"></a>UserMapper.xml中编写sql</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.hua.study.mapper.UserMapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">&quot;selectById&quot;</span> resultType=<span class="string">&quot;map&quot;</span>&gt;</span><br><span class="line">        select id,name,age,email from user <span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">&quot;selectPageVo&quot;</span> resultType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">        select uid,user_name,age,email from t_user where age &gt; #&#123;age&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h4 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageVo</span><span class="params">()</span>&#123;</span><br><span class="line">        Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        Page&lt;User&gt; page1 = userMapper.selectPageVo(page, <span class="number">20</span>);</span><br><span class="line">        System.out.println(page);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前页：&quot;</span>+page.getCurrent());</span><br><span class="line">        System.out.println(<span class="string">&quot;获取当前页数据:&quot;</span>+page.getRecords());</span><br><span class="line">        System.out.println(<span class="string">&quot;获取总页数:&quot;</span>+page.getPages());</span><br><span class="line">        System.out.println(<span class="string">&quot;获取总记录数:&quot;</span>+page.getTotal());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否有上一页：&quot;</span>+page.hasPrevious());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否有下一页：&quot;</span>+page.hasNext());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JDBC Connection [HikariProxyConnection@<span class="number">175822565</span> wrapping com.mysql.cj.jdbc.ConnectionImpl@3b1ed14b] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: SELECT <span class="title function_">COUNT</span><span class="params">(*)</span> AS total FROM t_user WHERE age &gt; ?</span><br><span class="line">==&gt; Parameters: <span class="number">20</span>(Integer)</span><br><span class="line">&lt;==    Columns: total</span><br><span class="line">&lt;==        Row: <span class="number">12</span></span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">==&gt;  Preparing: select uid,user_name,age,email from t_user where age &gt; ? LIMIT ?</span><br><span class="line">==&gt; Parameters: <span class="number">20</span>(Integer), <span class="number">3</span>(Long)</span><br><span class="line">&lt;==    Columns: uid, user_name, age, email</span><br><span class="line">&lt;==        Row: <span class="number">3</span>, Tom, <span class="number">28</span>, test3<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==        Row: <span class="number">4</span>, lisi, <span class="number">21</span>, mybatis<span class="meta">@java</span>.com</span><br><span class="line">&lt;==        Row: <span class="number">5</span>, Billie, <span class="number">24</span>, test5<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==      Total: <span class="number">3</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@30a7c98f]</span><br><span class="line">com.baomidou.mybatisplus.extension.plugins.pagination.Page@6850b758</span><br><span class="line">当前页：<span class="number">1</span></span><br><span class="line">获取当前页数据:[User(id=<span class="literal">null</span>, name=<span class="literal">null</span>, age=<span class="number">28</span>, email=test3<span class="meta">@baomidou</span>.com, isDelete=<span class="literal">null</span>), User(id=<span class="literal">null</span>, name=<span class="literal">null</span>, age=<span class="number">21</span>, email=mybatis<span class="meta">@java</span>.com, isDelete=<span class="literal">null</span>), User(id=<span class="literal">null</span>, name=<span class="literal">null</span>, age=<span class="number">24</span>, email=test5<span class="meta">@baomidou</span>.com, isDelete=<span class="literal">null</span>)]</span><br><span class="line">获取总页数:<span class="number">4</span></span><br><span class="line">获取总记录数:<span class="number">12</span></span><br><span class="line">是否有上一页：<span class="literal">false</span></span><br><span class="line">是否有下一页：<span class="literal">true</span></span><br><span class="line"><span class="number">2022</span>-09-<span class="number">15</span> <span class="number">22</span>:<span class="number">00</span>:<span class="number">07.447</span>  INFO <span class="number">19508</span> --- [extShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-09-<span class="number">15</span> <span class="number">22</span>:<span class="number">00</span>:<span class="number">07.451</span>  INFO <span class="number">19508</span> --- [extShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><blockquote><p>一件商品，成本价是80元，售价是100元。老板先是通知小李，说你去把商品价格增加50元。小 李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到150元，价格太 高，可能会影响销量。又通知小王，你把商品价格降低30元。</p><p>此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格100元；小王 也在操作，取出的商品价格也是100元。小李将价格加了50元，并将100+50&#x3D;150元存入了数据 库；小王将商品减了30元，并将100-30&#x3D;70元存入了数据库。是的，如果没有锁，小李的操作就 完全被小王的覆盖了。</p><p>现在商品价格是70元，比成本价低10元。几分钟后，这个商品很快出售了1千多件商品，老板亏1 万多。</p></blockquote><h4 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h4><blockquote><p>上面的故事，如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过 了，则重新取出的被修改后的价格，150元，这样他会将120元存入数据库。</p><p>如果是悲观锁，小李取出数据后，小王只能等小李操作完之后，才能对价格进行操作，也会保证 最终的价格是120元。</p></blockquote><ol><li>悲观锁</li></ol><p>顾名思义，就是比较悲观的锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以<strong>每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）</strong>。<strong>一般多写的场景下用悲观锁就比较合适</strong>。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<strong>synchronized和ReentrantLock</strong>等独占锁就是悲观锁思想的实现。悲观锁的实现方式，即<code>synchronized</code>和<code>ReentrantLock</code>。</p><p>​2. 乐观锁</p><p>反之，总是假设最好的情况，<strong>每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据</strong>，可以使用<strong>版本号机制和CAS算法</strong>实现。<strong>乐观锁适用于多读的应用类型</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><ul><li><p>版本号机制：</p><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。就是通过version版本号作为一个标识，标识这个字段所属的数据是否被改变。</p></li><li><p>CAS算法：</p><p>即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。</p><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul><p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p></li></ul><p><strong>缺点：</strong></p><ol><li><strong>ABA 问题</strong></li></ol><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</p><p>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p>​2. <strong>循环时间长开销大</strong></p><p>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p><p>​3. <strong>只能保证一个共享变量的原子操作</strong></p><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p><h4 id="模拟修改冲突"><a href="#模拟修改冲突" class="headerlink" title="模拟修改冲突"></a>模拟修改冲突</h4><h5 id="数据库中增加商品表"><a href="#数据库中增加商品表" class="headerlink" title="数据库中增加商品表"></a>数据库中增加商品表</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_product</span><br><span class="line">(</span><br><span class="line">id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">price <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;价格&#x27;</span>,</span><br><span class="line">VERSION <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;乐观锁版本号&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="添加数据-1"><a href="#添加数据-1" class="headerlink" title="添加数据"></a>添加数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">INSERT INTO <span class="title function_">t_product</span> <span class="params">(id, NAME, price)</span> VALUES (<span class="number">1</span>, <span class="string">&#x27;外星人笔记本&#x27;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h5 id="添加实体"><a href="#添加实体" class="headerlink" title="添加实体"></a>添加实体</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加mapper-1"><a href="#添加mapper-1" class="headerlink" title="添加mapper"></a>添加mapper</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Product&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">productTest01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 小李查询商品价格</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">productLi</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小李查询的商品价格：&quot;</span> + productLi.getPrice());</span><br><span class="line">        <span class="comment">// 小王查询商品价格</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">productWang</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小王查询的商品价格：&quot;</span> + productWang.getPrice());</span><br><span class="line">        <span class="comment">// 小李将价格+50</span></span><br><span class="line">        productLi.setPrice(productLi.getPrice()+<span class="number">50</span>);</span><br><span class="line">        productMapper.updateById(productLi);</span><br><span class="line">        <span class="comment">// 小王将价格-30</span></span><br><span class="line">        productWang.setPrice(productWang.getPrice()-<span class="number">30</span>);</span><br><span class="line">        productMapper.updateById(productWang);</span><br><span class="line">        <span class="comment">// 老板查询商品价格</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">productBoss</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;老板查询的商品价格：&quot;</span> + productBoss.getPrice());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT id,name,price,version FROM t_product WHERE id=?</span><br><span class="line">小王查询的商品价格:<span class="number">100</span>    </span><br><span class="line">==&gt;  Preparing: SELECT id,name,price,version FROM t_product WHERE id=?</span><br><span class="line">小李查询的商品价格:<span class="number">100</span></span><br><span class="line">==&gt;  Preparing: SELECT id,name,price,version FROM t_product WHERE id=?</span><br><span class="line">老板查询的商品价格:<span class="number">70</span>  <span class="comment">//70替换了120</span></span><br></pre></td></tr></table></figure><h4 id="乐观锁实现流程"><a href="#乐观锁实现流程" class="headerlink" title="乐观锁实现流程"></a>乐观锁实现流程</h4><blockquote><p>数据库中添加<code>version字段</code></p><p>取出记录时，获取当前version</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,`name`,price,`version` <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>更新时，version + 1，如果where语句中的version版本不对，则更新失败</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> product <span class="keyword">SET</span> price<span class="operator">=</span>price<span class="operator">+</span><span class="number">50</span>, `version`<span class="operator">=</span>`version` <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span></span><br><span class="line">`version`<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="Mybatis-Plus实现乐观锁"><a href="#Mybatis-Plus实现乐观锁" class="headerlink" title="Mybatis-Plus实现乐观锁"></a>Mybatis-Plus实现乐观锁</h4><h5 id="修改实体类"><a href="#修改实体类" class="headerlink" title="修改实体类"></a>修改实体类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标识乐观锁版本号字段</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加乐观锁插件配置"><a href="#添加乐观锁插件配置" class="headerlink" title="添加乐观锁插件配置"></a>添加乐观锁插件配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com.hua.study.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="comment">//添加乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试方法不变"><a href="#测试方法不变" class="headerlink" title="测试方法不变"></a>测试方法不变</h5><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT id,name,price,version FROM t_product WHERE id=?</span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(Integer)</span><br><span class="line">&lt;==    Columns: id, name, price, version</span><br><span class="line">&lt;==        Row: <span class="number">1</span>, 外星人笔记本, <span class="number">100</span>, <span class="number">1</span></span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">小李查询的商品价格：<span class="number">100</span></span><br><span class="line">    </span><br><span class="line">==&gt;  Preparing: SELECT id,name,price,version FROM t_product WHERE id=?</span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(Integer)</span><br><span class="line">&lt;==    Columns: id, name, price, version</span><br><span class="line">&lt;==        Row: <span class="number">1</span>, 外星人笔记本, <span class="number">100</span>, <span class="number">1</span></span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">小王查询的商品价格:<span class="number">100</span></span><br><span class="line">    </span><br><span class="line">==&gt;  Preparing: UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?</span><br><span class="line">==&gt; Parameters: 外星人笔记本(String), <span class="number">150</span>(Integer), <span class="number">2</span>(Integer), <span class="number">1</span>(Integer), <span class="number">1</span>(Integer)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span> <span class="comment">//小李修改成功，version变为1</span></span><br><span class="line">    </span><br><span class="line">==&gt;  Preparing: UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?</span><br><span class="line">==&gt; Parameters: 外星人笔记本(String), <span class="number">70</span>(Integer), <span class="number">2</span>(Integer), <span class="number">1</span>(Integer), <span class="number">1</span>(Integer)</span><br><span class="line">&lt;==    Updates: <span class="number">0</span> <span class="comment">//小王修改失败了因为小王修改的version为0 找不到了 </span></span><br><span class="line"></span><br><span class="line">==&gt;  Preparing: UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?</span><br><span class="line">==&gt;  Preparing: SELECT id,name,price,version FROM t_product WHERE id=?</span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(Integer)</span><br><span class="line">&lt;==    Columns: id, name, price, version</span><br><span class="line">&lt;==        Row: <span class="number">1</span>, 外星人笔记本, <span class="number">150</span>, <span class="number">2</span></span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">老板查询的商品价格:<span class="number">150</span></span><br></pre></td></tr></table></figure><blockquote><p>小李查询商品信息：</p><p>SELECT id,name,price,version FROM t_product WHERE id&#x3D;?</p><p>小王查询商品信息：</p><p>SELECT id,name,price,version FROM t_product WHERE id&#x3D;?</p><p>小李修改商品价格，自动将version+1</p><p>UPDATE t_product SET name&#x3D;?, price&#x3D;?, version&#x3D;? WHERE id&#x3D;? AND version&#x3D;?</p><p>Parameters: 外星人笔记本(String), 150(Integer), 1(Integer), 1(Long), 0(Integer)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小王修改商品价格，此时version已更新，条件不成立，修改失败</span><br></pre></td></tr></table></figure><p>UPDATE t_product SET name&#x3D;?, price&#x3D;?, version&#x3D;? WHERE id&#x3D;? AND version&#x3D;?</p><p>Parameters: 外星人笔记本(String), 70(Integer), 1(Integer), 1(Long), 0(Integer)</p><p>最终，小王修改失败，Boss查询价格：150</p><p>SELECT id,name,price,version FROM t_product WHERE id&#x3D;?</p></blockquote><h5 id="优化流程"><a href="#优化流程" class="headerlink" title="优化流程"></a>优化流程</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProduct01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//小李查询商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productLi</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李查询的商品价格：&quot;</span>+productLi.getPrice());</span><br><span class="line">    <span class="comment">//小王查询商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productWang</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小王查询的商品价格:&quot;</span>+productWang.getPrice());</span><br><span class="line">    <span class="comment">//小李将商品价格加50</span></span><br><span class="line">    productLi.setPrice(productLi.getPrice()+<span class="number">50</span>);</span><br><span class="line">    productMapper.updateById(productLi);</span><br><span class="line">    <span class="comment">//小王将商品价格减去30</span></span><br><span class="line">    productWang.setPrice(productWang.getPrice()-<span class="number">30</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> productMapper.updateById(productWang);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//操作失败，重试，获得版本号</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">productNew</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">        productNew.setPrice(productLi.getPrice()-<span class="number">30</span>);</span><br><span class="line">        productMapper.updateById(productNew);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//老板查询商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productBoss</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;老板查询的商品价格:&quot;</span>+productBoss.getPrice());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT id,name,price,version FROM t_product WHERE id=?</span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(Long)</span><br><span class="line">&lt;==    Columns: id, name, price, version</span><br><span class="line">&lt;==        Row: <span class="number">1</span>, 外星人笔记本, <span class="number">120</span>, <span class="number">2</span></span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@23a5818e]</span><br><span class="line">老板查询的商品价格：<span class="number">120</span></span><br></pre></td></tr></table></figure><blockquote><p>小李查询商品的价格为100</p><p>小王查询商品的价格为100</p><p>小李修改商品价格为150，版本号修改为1</p><p>小王修改版本0的商品价格失败</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小王重新获取版本号</span><br></pre></td></tr></table></figure><p>小李修改商品价格为120，版本号修改为2</p><p>Boss查询商品价格为150，版本号为2</p></blockquote><h2 id="通用枚举"><a href="#通用枚举" class="headerlink" title="通用枚举"></a>通用枚举</h2><blockquote><p>表中的有些字段值是固定的，例如性别（男或女），此时我们可以使用MyBatis-Plus的通用枚举来实现</p></blockquote><h3 id="数据库添加字段sex"><a href="#数据库添加字段sex" class="headerlink" title="数据库添加字段sex"></a>数据库添加字段sex</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_user <span class="keyword">ADD</span> sex <span class="type">INT</span>(<span class="number">11</span>) </span><br></pre></td></tr></table></figure><h3 id="创建通用枚举类型"><a href="#创建通用枚举类型" class="headerlink" title="创建通用枚举类型"></a>创建通用枚举类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SexEnum</span> &#123;</span><br><span class="line">    MALE(<span class="number">1</span>,<span class="string">&quot;男&quot;</span>),</span><br><span class="line">    FEMALE(<span class="number">0</span>,<span class="string">&quot;女&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将注解所标识的属性的值存储到数据库中</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@EnumValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line">    <span class="keyword">private</span> String sexName;</span><br><span class="line"></span><br><span class="line">    SexEnum(Integer sex, String sexName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.sexName = sexName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置扫描枚举类型"><a href="#配置扫描枚举类型" class="headerlink" title="配置扫描枚举类型"></a>配置扫描枚举类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  # 配置数据源信息</span><br><span class="line">  datasource:</span><br><span class="line">    # 配置数据源类型</span><br><span class="line">    type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line">    # 配置连接数据库的各个信息</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    password: root</span><br><span class="line">    username: root</span><br><span class="line"># 日志</span><br><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">  # 设置Mybatis-Plus的全局配置</span><br><span class="line">  global-config:</span><br><span class="line">    # 设置实体类的统一前缀 会自动在实体类前加上前缀</span><br><span class="line">    db-config:</span><br><span class="line">      table-prefix: t_</span><br><span class="line">      # 设置全局统一的主键生成策略</span><br><span class="line">      #id-type: auto</span><br><span class="line">  type-aliases-<span class="keyword">package</span>: com.hua.study.pojo</span><br><span class="line">  # 扫描通用枚举的包</span><br><span class="line">  type-enums-<span class="keyword">package</span>: com.hua.study.enums</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试-5"><a href="#测试-5" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusEnumTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enumTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">33</span>);</span><br><span class="line">        user.setSex(SexEnum.MALE);</span><br><span class="line">        <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;result：&quot;</span> + insert);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">==&gt;  Preparing: INSERT INTO <span class="title function_">t_user</span> <span class="params">( uid, user_name, age, sex )</span> VALUES ( ?, ?, ?, ? )</span><br><span class="line">==&gt; Parameters: <span class="number">1570755286757560322</span>(Long), admin(String), <span class="number">33</span>(Integer), <span class="number">1</span>(Integer)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@95bb2a2]</span><br><span class="line">result：<span class="number">1</span></span><br><span class="line"><span class="number">2022</span>-09-<span class="number">16</span> <span class="number">20</span>:<span class="number">43</span>:<span class="number">38.534</span>  INFO <span class="number">23468</span> --- [extShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown initiated...</span><br><span class="line"><span class="number">2022</span>-09-<span class="number">16</span> <span class="number">20</span>:<span class="number">43</span>:<span class="number">38.537</span>  INFO <span class="number">23468</span> --- [extShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-<span class="number">1</span> - Shutdown completed.</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--代码生成器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="快速生成"><a href="#快速生成" class="headerlink" title="快速生成"></a>快速生成</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastAutoGeneratorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FastAutoGenerator.create(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mybatis_plus?&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>)</span><br><span class="line">                .globalConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.author(<span class="string">&quot;hua&quot;</span>) <span class="comment">// 设置作者</span></span><br><span class="line">                            <span class="comment">//.enableSwagger() // 开启 swagger 模式</span></span><br><span class="line">                            .fileOverride() <span class="comment">// 覆盖已生成文件</span></span><br><span class="line">                            .outputDir(<span class="string">&quot;D://mybatis-plus&quot;</span>); <span class="comment">// 指定输出目录</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .packageConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.parent(<span class="string">&quot;com.hua&quot;</span>) <span class="comment">// 设置父包名</span></span><br><span class="line">                            .moduleName(<span class="string">&quot;mybatisplus&quot;</span>) <span class="comment">// 设置父包模块名</span></span><br><span class="line">                            .pathInfo(Collections.singletonMap(OutputFile.mapperXml, <span class="string">&quot;D://mybatis-plus&quot;</span>)); <span class="comment">// 设置mapperXml生成路径</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .strategyConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.addInclude(<span class="string">&quot;t_user&quot;</span>) <span class="comment">// 设置需要生成的表名</span></span><br><span class="line">                            .addTablePrefix(<span class="string">&quot;t_&quot;</span>, <span class="string">&quot;c_&quot;</span>); <span class="comment">// 设置过滤表前缀</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .templateEngine(<span class="keyword">new</span> <span class="title class_">FreemarkerTemplateEngine</span>()) <span class="comment">// 使用Freemarker引擎模板，默认的是Velocity引擎模板</span></span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">52</span>:<span class="number">19.205</span> [main] DEBUG com.baomidou.mybatisplus.generator.AutoGenerator - ==========================准备生成文件...==========================</span><br><span class="line"><span class="number">20</span>:<span class="number">52</span>:<span class="number">19.461</span> [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 执行SQL:show table status WHERE <span class="number">1</span>=<span class="number">1</span>  AND NAME <span class="title function_">IN</span> <span class="params">(<span class="string">&#x27;t_user&#x27;</span>)</span></span><br><span class="line"><span class="number">20</span>:<span class="number">52</span>:<span class="number">19.480</span> [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 返回记录数:<span class="number">1</span>,耗时(ms):<span class="number">17</span></span><br><span class="line"><span class="number">20</span>:<span class="number">52</span>:<span class="number">19.503</span> [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 执行SQL:show full fields from `t_user`</span><br><span class="line"><span class="number">20</span>:<span class="number">52</span>:<span class="number">19.510</span> [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 返回记录数:<span class="number">6</span>,耗时(ms):<span class="number">7</span></span><br><span class="line"><span class="number">20</span>:<span class="number">52</span>:<span class="number">19.664</span> [main] DEBUG com.baomidou.mybatisplus.generator.AutoGenerator - ==========================文件生成完成！！！==========================</span><br></pre></td></tr></table></figure><p><img src="/2021/11/13/MyBatis-Plus/image-20220916205333660.png" alt="image-20220916205333660"></p><h2 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h2><blockquote><p>适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等</p><p>目前我们就来模拟一个纯粹多库的一个场景，其他场景类似</p><p>场景说明：</p><p>我们创建两个库，分别为：mybatis_plus（以前的库不动）与mybatis_plus_1（新建），将mybatis_plus库的product表移动到mybatis_plus_1库，这样每个库一张表，通过一个测试用例分别获取用户数据与商品数据，如果获取到说明多库模拟成功</p></blockquote><h3 id="创建数据库与表"><a href="#创建数据库与表" class="headerlink" title="创建数据库与表"></a>创建数据库与表</h3><blockquote><p>创建数据库mybatis_plus_1和表product</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `mybatis_plus_1` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>;</span><br><span class="line">USE `mybatis_plus_1`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product</span><br><span class="line">(</span><br><span class="line">id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">price <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;价格&#x27;</span>,</span><br><span class="line">VERSION <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;乐观锁版本号&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>添加测试数据</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product (id, NAME, price) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;外星人笔记本&#x27;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><blockquote><p>删除mybatis_plus库product表</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use mybatis_plus;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> t_product;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/13/MyBatis-Plus/image-20220916210435670.png" alt="image-20220916210435670"></p><h3 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置多数据源"><a href="#配置多数据源" class="headerlink" title="配置多数据源"></a>配置多数据源</h3><blockquote><p>说明：注释掉之前的数据库连接，添加新配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 配置数据源信息</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">      <span class="comment"># 设置默认的数据源或者数据源组,默认值即为master</span></span><br><span class="line">      <span class="attr">primary:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 严格匹配数据源,默认false true未匹配到指定数据源时抛异常,false使用默认数据源</span></span><br><span class="line">      <span class="attr">strict:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">master:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">slave_1:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="创建对应的JavaBean"><a href="#创建对应的JavaBean" class="headerlink" title="创建对应的JavaBean"></a>创建对应的JavaBean</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Integer isDeleted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加mapper-2"><a href="#添加mapper-2" class="headerlink" title="添加mapper"></a>添加mapper</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Product&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主启动类上面要加上@MapperScan(“XXX”)</p></blockquote><h4 id="继承通用Service"><a href="#继承通用Service" class="headerlink" title="继承通用Service"></a>继承通用Service</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Product&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建用户service"><a href="#创建用户service" class="headerlink" title="创建用户service"></a>创建用户service</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DS(&quot;master&quot;)</span> <span class="comment">////指定所操作的数据源</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建商品service"><a href="#创建商品service" class="headerlink" title="创建商品service"></a>创建商品service</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DS(&quot;slave_1&quot;)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ProductMapper, Product&gt; <span class="keyword">implements</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-6"><a href="#测试-6" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MybatisPlusDatasourceApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDynamicDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(userService.getById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(productService.getById(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User(uid=<span class="number">1</span>, userName=Jone, age=<span class="number">18</span>, sex=<span class="literal">null</span>, email=test1<span class="meta">@baomidou</span>.com, isDeleted=<span class="number">1</span>)<span class="comment">//isDeleted并没有标注@TableLogic</span></span><br><span class="line">Product(id=<span class="number">1</span>, name=外星人笔记本, price=<span class="number">100</span>, version=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>提示</p><ol><li><p>都能顺利获取对象，则测试成功</p></li><li><p>如果我们实现读写分离，将写操作方法上加上主库数据源注解，读操作方法上加上从库数据源注解，自动切换，是不是就能实现读写分离？</p><p><strong>@DS</strong> 可以注解在方法上或类上，<strong>同时存在就近原则 方法上注解优先于类上注解</strong>。</p></li></ol></blockquote><h2 id="MyBatisX插件"><a href="#MyBatisX插件" class="headerlink" title="MyBatisX插件"></a>MyBatisX插件</h2><blockquote><p>MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率</p><p>但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件</p><p>MyBatisX一款基于 IDEA 的快速开发插件，为效率而生。</p></blockquote><p>MyBatisX插件用法：<a href="https://baomidou.com/pages/ba5b24/">MybatisX快速开发插件 | MyBatis-Plus</a></p><h3 id="代码生成器-1"><a href="#代码生成器-1" class="headerlink" title="代码生成器"></a>代码生成器</h3><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting@master/studynotes/MyBatis/Plus-images/08/02.png" alt="01"></p><p><img src="/2021/11/13/MyBatis-Plus/03.png" alt="01"></p><p><img src="/2021/11/13/MyBatis-Plus/image-20220916220306856.png" alt="image-20220916220306856"></p><p><img src="/2021/11/13/MyBatis-Plus/image-20220916220454913.png" alt="image-20220916220454913"></p><p><img src="/2021/11/13/MyBatis-Plus/image-20220916220652043.png" alt="image-20220916220652043"></p><h3 id="生成自定义功能"><a href="#生成自定义功能" class="headerlink" title="生成自定义功能"></a>生成自定义功能</h3><p>只能添加展示出的方法（insert、delete、update、select）：</p><p><img src="/2021/11/13/MyBatis-Plus/image-20220916220943308.png" alt="image-20220916220943308"></p><p><img src="/2021/11/13/MyBatis-Plus/image-20220916221021048.png" alt="image-20220916221021048"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertSelective</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateAgeAndEmail</span><span class="params">(<span class="meta">@Param(&quot;age&quot;)</span> Integer age, <span class="meta">@Param(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByAgeBetweenAndIsDeleteAndEmail</span><span class="params">(<span class="meta">@Param(&quot;beginAge&quot;)</span> Integer beginAge, <span class="meta">@Param(&quot;endAge&quot;)</span> Integer endAge, <span class="meta">@Param(&quot;isDelete&quot;)</span> Integer isDelete, <span class="meta">@Param(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAllByAgeAfterOrAgeOrderByUidDesc</span><span class="params">(<span class="meta">@Param(&quot;age&quot;)</span> Integer age, <span class="meta">@Param(&quot;oldAge&quot;)</span> Integer oldAge)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper.xml中自动生成的sql</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.hua.study.mapper.UserMapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id=<span class="string">&quot;BaseResultMap&quot;</span> type=<span class="string">&quot;com.hua.study.pojo.User&quot;</span>&gt;</span><br><span class="line">            &lt;id property=<span class="string">&quot;uid&quot;</span> column=<span class="string">&quot;uid&quot;</span> jdbcType=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span><br><span class="line">            &lt;result property=<span class="string">&quot;userName&quot;</span> column=<span class="string">&quot;user_name&quot;</span> jdbcType=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span><br><span class="line">            &lt;result property=<span class="string">&quot;age&quot;</span> column=<span class="string">&quot;age&quot;</span> jdbcType=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span><br><span class="line">            &lt;result property=<span class="string">&quot;email&quot;</span> column=<span class="string">&quot;email&quot;</span> jdbcType=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span><br><span class="line">            &lt;result property=<span class="string">&quot;isDelete&quot;</span> column=<span class="string">&quot;is_delete&quot;</span> jdbcType=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span><br><span class="line">            &lt;result property=<span class="string">&quot;sex&quot;</span> column=<span class="string">&quot;sex&quot;</span> jdbcType=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sql id=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span><br><span class="line">        uid,user_name,age,</span><br><span class="line">        email,is_delete,sex</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line">    &lt;insert id=<span class="string">&quot;insertSelective&quot;</span>&gt;</span><br><span class="line">        insert into t_user</span><br><span class="line">        &lt;trim prefix=<span class="string">&quot;(&quot;</span> suffix=<span class="string">&quot;)&quot;</span> suffixOverrides=<span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;uid != null&quot;</span>&gt;uid,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;userName != null&quot;</span>&gt;user_name,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;age != null&quot;</span>&gt;age,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;email != null&quot;</span>&gt;email,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;isDelete != null&quot;</span>&gt;is_delete,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;sex != null&quot;</span>&gt;sex,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">        &lt;/trim&gt;</span><br><span class="line">        values</span><br><span class="line">        &lt;trim prefix=<span class="string">&quot;(&quot;</span> suffix=<span class="string">&quot;)&quot;</span> suffixOverrides=<span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;uid != null&quot;</span>&gt;#&#123;uid,jdbcType=BIGINT&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;userName != null&quot;</span>&gt;#&#123;userName,jdbcType=VARCHAR&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;age != null&quot;</span>&gt;#&#123;age,jdbcType=INTEGER&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;email != null&quot;</span>&gt;#&#123;email,jdbcType=VARCHAR&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;isDelete != null&quot;</span>&gt;#&#123;isDelete,jdbcType=INTEGER&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">if</span> test=<span class="string">&quot;sex != null&quot;</span>&gt;#&#123;sex,jdbcType=INTEGER&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">        &lt;/trim&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shiro-SpringBoot</title>
      <link href="/2021/11/06/Shiro-SpringBoot/"/>
      <url>/2021/11/06/Shiro-SpringBoot/</url>
      
        <content type="html"><![CDATA[<p>Shiro</p><h2 id="1-Shiro的工作原理"><a href="#1-Shiro的工作原理" class="headerlink" title="1.Shiro的工作原理"></a>1.Shiro的工作原理</h2><h3 id="1、Shiro的核心功能"><a href="#1、Shiro的核心功能" class="headerlink" title="1、Shiro的核心功能"></a>1、Shiro的核心功能</h3><p>认证（Authentication）：验证用户是否有相应的身份——登录认证；</p><p>授权（Authorization）：即权限验证；对已经通过认证的用户检查是否具有某个权限或者角色，从而控制是否能够进行某种操作；</p><p>会话管理（Session Management）：用户认证成功后创建会话，在没有退出之前，当前用户的所有信息都会保存在这个会话中；可以是普通的JavaSE应用，也可以是web应用；</p><p>加密管理（Cryptography）:对敏感信息进行加密处理；</p><h3 id="2-Shiro的核心组件"><a href="#2-Shiro的核心组件" class="headerlink" title="2.Shiro的核心组件"></a>2.Shiro的核心组件</h3><p><img src="https://bkimg.cdn.bcebos.com/pic/9825bc315c6034a8f93c7d0cce13495408237665?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto" alt="img"></p><p>Shrio三大核心组件：Subject、Security Manager、Realms</p><ul><li>Subject：表示待认证和授权的用户</li><li>Security Manager：他是Shiro框架的核心，Shiro就是通过Security Manager来进行内部实例的管理。并提过他来提供安全管理的各种服务。<ul><li>Authenticator，认证器</li><li>Anthorizer，授权器</li><li>Session Manager，会话管理器</li><li>CacheManager，缓存管理器</li></ul></li><li>Reaim：相当于Shiro进行认证和授权的数据源，充当了Shiro与安全数据之间的桥梁或者连接器。也就是说，当用户进行认证（登录）和授权（访问控制）验证时，Shiro会用应用配置的Realm中查找用户及其权限信息。</li></ul><h2 id="2、使用Shiro"><a href="#2、使用Shiro" class="headerlink" title="2、使用Shiro"></a>2、使用Shiro</h2><h3 id="1-导入Shiro的依赖"><a href="#1-导入Shiro的依赖" class="headerlink" title="1.导入Shiro的依赖"></a>1.导入Shiro的依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.4</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="2-创建Shiro配置文件"><a href="#2-创建Shiro配置文件" class="headerlink" title="2.创建Shiro配置文件"></a>2.创建Shiro配置文件</h3><p>​在resource目录下创建.ini文件</p><p><img src="/2021/11/06/Shiro-SpringBoot/1655902064967.jpg" alt="1655902064967"></p><p>​在文件中设置用户，角色和权限的配置</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="comment">#用户名=密码，角色</span></span><br><span class="line"><span class="attr">root</span>=<span class="number">123456</span>,teacher</span><br><span class="line"><span class="attr">admin</span>=<span class="number">12345</span>,student</span><br><span class="line"></span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="comment">#角色=权限  *表示所有权限</span></span><br><span class="line"><span class="attr">principal</span>=*</span><br><span class="line"><span class="attr">student</span>=achievement-list</span><br><span class="line"><span class="attr">teacher</span>=achievement-add,achievement-del,achievement-list</span><br></pre></td></tr></table></figure><h3 id="3-Shiro的基本使用"><a href="#3-Shiro的基本使用" class="headerlink" title="3.Shiro的基本使用"></a>3.Shiro的基本使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.shiro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.IncorrectCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.text.IniRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestShiro</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入账号：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建安全管理器</span></span><br><span class="line">        <span class="type">DefaultSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSecurityManager</span>();</span><br><span class="line">        <span class="comment">//2.创建Realm</span></span><br><span class="line">        <span class="type">IniRealm</span> <span class="variable">iniRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IniRealm</span>(<span class="string">&quot;classpath:shiro.ini&quot;</span>);</span><br><span class="line">        <span class="comment">//3.将Realm设置安全管理器</span></span><br><span class="line">        securityManager.setRealm(iniRealm);</span><br><span class="line">        <span class="comment">//4.将Realm设置给SecurityUtils工具</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//5.通过SecurityUtils工具类获取subject对象</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【认证流程】</span></span><br><span class="line">        <span class="comment">//1.将认证账号和密码封装到token对象中</span></span><br><span class="line">        <span class="type">AuthenticationToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username,password);</span><br><span class="line">        <span class="comment">//2.通过subject对象调用login方法进行认证申请(登录验证)</span></span><br><span class="line">        <span class="comment">//认证失败抛出IncorrectCredentialsException</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span><span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">            b = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">            b = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(b?<span class="string">&quot;登录成功&quot;</span>:<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【授权】</span></span><br><span class="line">        <span class="comment">//判断是否有某个角色</span></span><br><span class="line">        System.out.println(subject.hasRole(<span class="string">&quot;teacher&quot;</span>));</span><br><span class="line">        <span class="comment">//判断是否有某个权限</span></span><br><span class="line">        System.out.println(subject.isPermitted(<span class="string">&quot;achievement-list&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Shiro认证流程"><a href="#Shiro认证流程" class="headerlink" title="Shiro认证流程"></a>Shiro认证流程</h3><p><img src="/2021/11/06/Shiro-SpringBoot/1655905403869.jpg" alt="1655905403869"></p><h2 id="3、SpringBoot应用整合Shiro"><a href="#3、SpringBoot应用整合Shiro" class="headerlink" title="3、SpringBoot应用整合Shiro"></a>3、SpringBoot应用整合Shiro</h2><h3 id="1-创建SpringBoot，导入依赖"><a href="#1-创建SpringBoot，导入依赖" class="headerlink" title="1.创建SpringBoot，导入依赖"></a>1.创建SpringBoot，导入依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">2.2</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">1.1</span><span class="number">.10</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">1.4</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      url:  jdbc:mysql:<span class="comment">//localhost:3306/shiro</span></span><br><span class="line">      username: root</span><br><span class="line">      password: root</span><br><span class="line">      #Mysql如果是<span class="number">8.</span>X com.mysql.cj.jdbc.Driver</span><br><span class="line">      driver-class-name:  com.mysql.cj.jdbc.Driver</span><br><span class="line">mybatis:</span><br><span class="line">  config-location: classpath:mappers/Mybatis-config.xml</span><br><span class="line">  mapper-locations: classpath:mappers<span class="comment">/*Mapper.xml</span></span><br><span class="line"><span class="comment">  type-aliases-package: com.example.shiro_springboot.bean</span></span><br></pre></td></tr></table></figure><h3 id="3-整合Shiro"><a href="#3-整合Shiro" class="headerlink" title="3.整合Shiro"></a>3.整合Shiro</h3><ul><li>导入依赖</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">1.4</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>Shiro配置<ul><li>SpringBoot默认没有提供对Shiro的自动配置</li><li>Shiro_Config.java</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.shiro_springboot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.text.IniRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.web.ShiroFilterFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shiro_Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IniRealm <span class="title function_">getIniRealm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">IniRealm</span> <span class="variable">iniRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IniRealm</span>(<span class="string">&quot;classpath:Shiro.ini&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> iniRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">defaultWebSecurityManager</span><span class="params">(IniRealm iniRealm)</span>&#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">defaultWebSecurityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        <span class="comment">//SecurityManager进行效验，需要Realm</span></span><br><span class="line">        defaultWebSecurityManager.setRealm(iniRealm);</span><br><span class="line">        <span class="keyword">return</span> defaultWebSecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器就是Shiro进行权限效验的核心，进行认证和授权是需要SecurityManager的</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">shiroFilterFactoryBean</span><span class="params">(DefaultWebSecurityManager defaultWebSecurityManager)</span>&#123;</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">filterFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        filterFactoryBean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line">        <span class="comment">//设置Shiro的拦截规则</span></span><br><span class="line">        Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//项目的根路径不拦截</span></span><br><span class="line">        <span class="comment">//anon 匿名用户可访问</span></span><br><span class="line">        <span class="comment">//authc 认证用户可访问</span></span><br><span class="line">        <span class="comment">//user 使用RemeberMe的用户可访问</span></span><br><span class="line">        <span class="comment">//perms 对应权限的用户可访问</span></span><br><span class="line">        <span class="comment">//role 对应角色可访问</span></span><br><span class="line">        hashMap.put(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;/login.html&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        <span class="comment">//未认证用户访问页面，默认跳转到login.jsp</span></span><br><span class="line">        hashMap.put(<span class="string">&quot;/**&quot;</span>,<span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        filterFactoryBean.setLoginUrl(<span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">        <span class="comment">//设置未授权访问的页面路径</span></span><br><span class="line">        filterFactoryBean.setUnauthorizedUrl(<span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">        filterFactoryBean.setFilterChainDefinitionMap(hashMap);</span><br><span class="line">        <span class="keyword">return</span> filterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service层</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkLogin</span><span class="params">(String username,String password)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username,password);</span><br><span class="line">        subject.login(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">controler层</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">getIndex</span><span class="params">(String username, String password, ModelAndView modelAndView)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loginService.checkLogin(username,password);</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;name&quot;</span>,username);</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;pass&quot;</span>,password);</span><br><span class="line">            modelAndView.setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            modelAndView.setViewName(<span class="string">&quot;login&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4、SpringBoot应用整合Shiro-案例（JdbcRealm）"><a href="#4、SpringBoot应用整合Shiro-案例（JdbcRealm）" class="headerlink" title="4、SpringBoot应用整合Shiro-案例（JdbcRealm）"></a>4、SpringBoot应用整合Shiro-案例（JdbcRealm）</h2><h3 id="1-JdbcRealm介绍"><a href="#1-JdbcRealm介绍" class="headerlink" title="1.JdbcRealm介绍"></a>1.JdbcRealm介绍</h3><p><img src="/2021/11/06/Shiro-SpringBoot/1656410232753.jpg" alt="1656410232753">如果使用JdbcRealm，这必须提供JdbcRealm所需的表结构（权限设计）</p><h3 id="2-JdbcRealm规定的表结构"><a href="#2-JdbcRealm规定的表结构" class="headerlink" title="2.JdbcRealm规定的表结构"></a>2.JdbcRealm规定的表结构</h3><p>1.用户信息表：users</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">    password <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.角色信息表：user_roles</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_roles(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    role_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.权限信息表：roles_permissions</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> roles_permissions(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    role_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    permission <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">...</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/11/06/Shiro-SpringBoot/1656412259570.jpg" alt="1656412259570"></p><h3 id="3-SpringBoot整合Shiro"><a href="#3-SpringBoot整合Shiro" class="headerlink" title="3.SpringBoot整合Shiro"></a>3.SpringBoot整合Shiro</h3><ul><li><p>创建SpringBoot应用</p></li><li><p>整合Druid和MyBatis</p></li><li><p>整合Shiro</p><ul><li><p>添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">1.4</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>配置Shiro</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> JdbcRealm <span class="title function_">getRealm</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">    <span class="comment">//JdbcRealm会自动从数据库查询用户及权限数据（数据库的表结构要符合JdbcRealm的规范）</span></span><br><span class="line">    <span class="type">JdbcRealm</span> <span class="variable">jdbcRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcRealm</span>();</span><br><span class="line">    jdbcRealm.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">//JdbcRealm手动开启授权功能</span></span><br><span class="line">    jdbcRealm.setPermissionsLookupEnabled(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jdbcRealm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="5、Shiro的标签使用"><a href="#5、Shiro的标签使用" class="headerlink" title="5、Shiro的标签使用"></a>5、Shiro的标签使用</h2><blockquote><p>当用户认证进入到主页面之后，需要显示用户信息以及当前用户的权限信息；Shiro提供了一套标签用于在页面来进行权限数据的呈现</p></blockquote><ul><li><p>Shiro提供了可供JSP海洋的标签以及Thymeleaf中的标签</p><ul><li><p>JSP页面中引用：</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;shiro&quot;</span> uri=<span class="string">&quot;http://shiro.apache.org/tags&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;shiro:tag&gt;&lt;/shiro:tag&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Thymeleaf模板中引用：</p><ul><li><p>在pom.xml中导入thymeleaf模板对Shiro标签支持的依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">2.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在Shiro_JdbcRealm配置Shiro的方言支持</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> ShiroDialect <span class="title function_">shiroDialect</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShiroDialect</span>();</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li><li><p>thymelaef模板中引入Shiro的命名空间</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:shiro</span>=<span class="string">&quot;http://www.pollix.at/thymeleaf/shiro&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h4><ul><li><p>shiro:guest</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--游客访问可以显示，登录状态不显示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:guest</span>&gt;</span>欢迎游客访问<span class="tag">&lt;/<span class="name">shiro:guest</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>shiro:user    shiro:principal</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--游客访问不显示，登录状态显示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:user</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--获取登录用户的用户名--&gt;</span></span><br><span class="line">    已登录用户<span class="tag">&lt;<span class="name">shiro:principal</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:user</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>shiro:hasRole（判断当前用户的角色）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;shiro:user&gt;</span><br><span class="line">&lt;!--获取登录用户的用户名--&gt;</span><br><span class="line">    已登录用户&lt;shiro:principal/&gt;</span><br><span class="line">    当前用户角色为&lt;shiro:hasRole name=<span class="string">&quot;admin&quot;</span>&gt;管理员&lt;/shiro:hasRole&gt;</span><br><span class="line">                &lt;shiro:hasRole name=<span class="string">&quot;student&quot;</span>&gt;学生&lt;/shiro:hasRole&gt;</span><br><span class="line">                &lt;shiro:hasRole name=<span class="string">&quot;teacher&quot;</span>&gt;老师&lt;/shiro:hasRole&gt;</span><br><span class="line">&lt;/shiro:user&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>shiro:hasPression（判断当前用户的权限）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">成绩管理</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&lt;shiro:hasPermission name=<span class="string">&quot;stu:select&quot;</span>&gt;&lt;a href=<span class="string">&quot;&quot;</span> &gt;查看成绩&lt;/a&gt;&lt;/shiro:hasPermission&gt;&lt;/li&gt;</span><br><span class="line">    &lt;Li&gt;&lt;shiro:hasPermission name=<span class="string">&quot;stu:update&quot;</span>&gt;&lt;a href=<span class="string">&quot;&quot;</span> &gt;修改成绩&lt;/a&gt;&lt;/shiro:hasPermission&gt;&lt;/Li&gt;</span><br><span class="line">    &lt;Li&gt;&lt;shiro:hasPermission name=<span class="string">&quot;stu:delete&quot;</span>&gt;&lt;a href=<span class="string">&quot;&quot;</span> &gt;删除成绩&lt;/a&gt;&lt;/shiro:hasPermission&gt;&lt;/Li&gt;</span><br><span class="line">    &lt;Li&gt;&lt;shiro:hasPermission name=<span class="string">&quot;stu:add&quot;</span>&gt;&lt;a href=<span class="string">&quot;&quot;</span> &gt;添加成绩&lt;/a&gt;&lt;/shiro:hasPermission&gt;&lt;/Li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="6、自定义Reaml"><a href="#6、自定义Reaml" class="headerlink" title="6、自定义Reaml"></a>6、自定义Reaml</h2><h3 id="1-自定义数据库"><a href="#1-自定义数据库" class="headerlink" title="1.自定义数据库"></a>1.自定义数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用户信息表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_users(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY auto_increment,</span><br><span class="line">username <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">password <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">password_salt <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 角色信息表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_roles(</span><br><span class="line">role_id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">role_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 权限信息表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_permission(</span><br><span class="line">permission_id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">permission_code <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">permission_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 用户角色表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_users_roles(</span><br><span class="line">uid <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">rid <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="comment">-- PRIMARY KEY(uid,rid),</span></span><br><span class="line"><span class="comment">-- CONSTRAINT FK_user FOREIGN key(uid) REFERENCES tb_users(id),</span></span><br><span class="line"><span class="comment">-- CONSTRAINT FK_role FOREIGN key(rid) REFERENCES tb_roles(role_id)</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 角色权限表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_roles_permission(</span><br><span class="line">rid <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">pid <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-DAO（Mapper）实现"><a href="#2-DAO（Mapper）实现" class="headerlink" title="2.DAO（Mapper）实现"></a>2.DAO（Mapper）实现</h3><ul><li><p>根据用户名查询用户信息，用于认证</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_users where username=#&#123;username&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>根据用户名查询当前用户的角色信息，用于授权</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryRolesByName&quot;</span> <span class="attr">resultSets</span>=<span class="string">&quot;java.util.Set&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;string&quot;</span>&gt;</span></span><br><span class="line">    select role_name from tb_users inner join tb_users_roles</span><br><span class="line">    on tb_users.id = tb_users_roles.uid</span><br><span class="line">    inner join tb_roles</span><br><span class="line">    on tb_users_roles.rid = tb_roles.role_id</span><br><span class="line">    where tb_users.username=#&#123;username&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>根据用户名查询当前用户的权限信息，用于授权</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryPermissionByName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;string&quot;</span>&gt;</span></span><br><span class="line">    select permission_code from tb_users</span><br><span class="line">    inner join tb_users_roles</span><br><span class="line">    on tb_users.id = tb_users_roles.uid</span><br><span class="line">    inner join tb_roles</span><br><span class="line">    on tb_users_roles.rid = tb_roles.role_id</span><br><span class="line">    inner join tb_roles_permission</span><br><span class="line">    on tb_roles_permission.rid = tb_roles.role_id</span><br><span class="line">    inner join tb_permission</span><br><span class="line">    on tb_permission.permission_id = tb_roles_permission.pid</span><br><span class="line">    where tb_users.username=#&#123;username&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-整合Shiro-1"><a href="#3-整合Shiro-1" class="headerlink" title="3.整合Shiro"></a>3.整合Shiro</h3><ul><li><p>导入依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.4</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Shiro配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroDialect <span class="title function_">shiroDialect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShiroDialect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义Realm</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyRealm <span class="title function_">myRealm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyRealm</span> <span class="variable">myRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRealm</span>();</span><br><span class="line">        <span class="keyword">return</span> myRealm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">securityManager</span><span class="params">(MyRealm myRealm)</span>&#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        securityManager.setRealm(myRealm);</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">factoryBean</span><span class="params">(DefaultWebSecurityManager  securityManager)</span>&#123;</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        factoryBean.setSecurityManager(securityManager);</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;/login.html&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;/**&quot;</span>,<span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        factoryBean.setLoginUrl(<span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">        factoryBean.setUnauthorizedUrl(<span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">        factoryBean.setFilterChainDefinitionMap(map);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>自定义Realm</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.创建一个类继承AuthorizingRealm类（实现Realm接口的类）</span></span><br><span class="line"><span class="comment"> * 2.重写doGetAuthorizationInfo和doGetAuthenticationInfo方法</span></span><br><span class="line"><span class="comment"> * 3.重写getName方法,返回当前Realm的一个自定义名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;myRealm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *获取授权信息（返回当前用户的角色及权限信息）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> &#123;</span><br><span class="line">        <span class="comment">//获取用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) principalCollection.iterator().next();</span><br><span class="line">        <span class="comment">//获取当前用户的角色列表</span></span><br><span class="line">        Set&lt;String&gt; roles = userService.queryRolesByName(username);</span><br><span class="line">        <span class="comment">//获取当前用户的权限列表</span></span><br><span class="line">        Set&lt;String&gt;  permission = userService.queryPermissionByName(username);</span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">        info.setRoles(roles);</span><br><span class="line">        info.setStringPermissions(permission);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取认证信息（从数据库查询的用户的正确数据）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="comment">//参数AuthenticationToken就是传递的subject.login(token)</span></span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> (UsernamePasswordToken) authenticationToken;</span><br><span class="line">        <span class="comment">//从token中获取用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> token.getUsername();</span><br><span class="line">        <span class="comment">//根据用户名从数据库查询当前用户的安全数据</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.queryUserByName(username);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">AuthenticationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(username,user.getPassword(),getName());</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="项目部署"><a href="#项目部署" class="headerlink" title="#项目部署"></a>#项目部署</h4><p><img src="/2021/11/06/Shiro-SpringBoot/1656829499875.jpg" alt="1656829499875"></p><h3 id="使用layui整合"><a href="#使用layui整合" class="headerlink" title="使用layui整合"></a>使用layui整合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:shiro=<span class="string">&quot;http://www.pollix.at/thymeleaf/shiro&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;base href=<span class="string">&quot;/&quot;</span>&gt;&lt;!--从根路径进行获取静态资源--&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;layout 管理系统大布局 - Layui&lt;/title&gt;</span><br><span class="line">    &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;layui/css/layui.css&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;layui-layout layui-layout-admin&quot;</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;layui-header&quot;</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;layui-logo layui-hide-xs layui-bg-black&quot;</span>&gt;layout demo&lt;/div&gt;</span><br><span class="line">        &lt;!-- 头部区域（可配合layui 已有的水平导航） --&gt;</span><br><span class="line">        &lt;ul class=<span class="string">&quot;layui-nav layui-layout-left&quot;</span>&gt;</span><br><span class="line">            &lt;!-- 移动端显示 --&gt;</span><br><span class="line">            &lt;li class=<span class="string">&quot;layui-nav-item layui-show-xs-inline-block layui-hide-sm&quot;</span> lay-header-event=<span class="string">&quot;menuLeft&quot;</span>&gt;</span><br><span class="line">                &lt;i class=<span class="string">&quot;layui-icon layui-icon-spread-left&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">            &lt;li class=<span class="string">&quot;layui-nav-item layui-hide-xs&quot;</span>&gt;&lt;a href=<span class="string">&quot;&quot;</span>&gt;nav <span class="number">1</span>&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li class=<span class="string">&quot;layui-nav-item layui-hide-xs&quot;</span>&gt;&lt;a href=<span class="string">&quot;&quot;</span>&gt;nav <span class="number">2</span>&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li class=<span class="string">&quot;layui-nav-item layui-hide-xs&quot;</span>&gt;&lt;a href=<span class="string">&quot;&quot;</span>&gt;nav <span class="number">3</span>&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li class=<span class="string">&quot;layui-nav-item&quot;</span>&gt;</span><br><span class="line">                &lt;a href=<span class="string">&quot;javascript:;&quot;</span>&gt;nav groups&lt;/a&gt;</span><br><span class="line">                &lt;dl class=<span class="string">&quot;layui-nav-child&quot;</span>&gt;</span><br><span class="line">                    &lt;dd&gt;&lt;a href=<span class="string">&quot;&quot;</span>&gt;menu <span class="number">11</span>&lt;/a&gt;&lt;/dd&gt;</span><br><span class="line">                    &lt;dd&gt;&lt;a href=<span class="string">&quot;&quot;</span>&gt;menu <span class="number">22</span>&lt;/a&gt;&lt;/dd&gt;</span><br><span class="line">                    &lt;dd&gt;&lt;a href=<span class="string">&quot;&quot;</span>&gt;menu <span class="number">33</span>&lt;/a&gt;&lt;/dd&gt;</span><br><span class="line">                &lt;/dl&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;ul class=<span class="string">&quot;layui-nav layui-layout-right&quot;</span>&gt;</span><br><span class="line">            &lt;li class=<span class="string">&quot;layui-nav-item layui-hide layui-show-md-inline-block&quot;</span>&gt;</span><br><span class="line">                &lt;shiro:guest&gt;&lt;label style=<span class="string">&quot;color: white;text-decoration: underline&quot;</span> onclick=<span class="string">&quot;javascript:location.href=&#x27;login.html&#x27;&quot;</span>&gt;登录&lt;/label&gt;&lt;/shiro:guest&gt;</span><br><span class="line">                &lt;shiro:user&gt;</span><br><span class="line">                    &lt;a href=<span class="string">&quot;javascript:;&quot;</span>&gt;</span><br><span class="line">                        &lt;img src=<span class="string">&quot;//tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg&quot;</span> class=<span class="string">&quot;layui-nav-img&quot;</span>&gt;</span><br><span class="line">                        &lt;shiro:principal/&gt;</span><br><span class="line">                    &lt;/a&gt;</span><br><span class="line">                    &lt;dl class=<span class="string">&quot;layui-nav-child&quot;</span>&gt;</span><br><span class="line">                        &lt;dd&gt;&lt;a href=<span class="string">&quot;&quot;</span>&gt;Your Profile&lt;/a&gt;&lt;/dd&gt;</span><br><span class="line">                        &lt;dd&gt;&lt;a href=<span class="string">&quot;&quot;</span>&gt;Settings&lt;/a&gt;&lt;/dd&gt;</span><br><span class="line">                        &lt;dd&gt;&lt;a href=<span class="string">&quot;&quot;</span>&gt;Sign out&lt;/a&gt;&lt;/dd&gt;</span><br><span class="line">                    &lt;/dl&gt;</span><br><span class="line">                &lt;/shiro:user&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;li class=<span class="string">&quot;layui-nav-item&quot;</span> lay-header-event=<span class="string">&quot;menuRight&quot;</span> lay-unselect&gt;</span><br><span class="line">                &lt;a href=<span class="string">&quot;javascript:;&quot;</span>&gt;</span><br><span class="line">                    &lt;i class=<span class="string">&quot;layui-icon layui-icon-more-vertical&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">&quot;layui-side layui-bg-black&quot;</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">&quot;layui-side-scroll&quot;</span>&gt;</span><br><span class="line">            &lt;!-- 左侧导航区域（可配合layui已有的垂直导航） --&gt;</span><br><span class="line">            &lt;ul class=<span class="string">&quot;layui-nav layui-nav-tree&quot;</span> lay-filter=<span class="string">&quot;test&quot;</span>&gt;</span><br><span class="line">                &lt;li class=<span class="string">&quot;layui-nav-item layui-nav-itemed&quot;</span>&gt;</span><br><span class="line">                    &lt;a class=<span class="string">&quot;&quot;</span> href=<span class="string">&quot;javascript:;&quot;</span>&gt;menu group <span class="number">1</span>&lt;/a&gt;</span><br><span class="line">                    &lt;dl class=<span class="string">&quot;layui-nav-child&quot;</span>&gt;</span><br><span class="line">                        &lt;dd&gt;&lt;shiro:hasPermission name=<span class="string">&quot;stu:select&quot;</span>&gt;&lt;a href=<span class="string">&quot;&quot;</span> &gt;查看成绩&lt;/a&gt;&lt;/shiro:hasPermission&gt;&lt;/dd&gt;</span><br><span class="line">                        &lt;dd&gt;&lt;shiro:hasPermission name=<span class="string">&quot;stu:update&quot;</span>&gt;&lt;a href=<span class="string">&quot;&quot;</span> &gt;修改成绩&lt;/a&gt;&lt;/shiro:hasPermission&gt;&lt;/dd&gt;</span><br><span class="line">                        &lt;dd&gt;&lt;shiro:hasPermission name=<span class="string">&quot;stu:delete&quot;</span>&gt;&lt;a href=<span class="string">&quot;&quot;</span> &gt;删除成绩&lt;/a&gt;&lt;/shiro:hasPermission&gt;&lt;/dd&gt;</span><br><span class="line">                        &lt;dd&gt;&lt;shiro:hasPermission name=<span class="string">&quot;stu:add&quot;</span>&gt;&lt;a href=<span class="string">&quot;&quot;</span> &gt;添加成绩&lt;/a&gt;&lt;/shiro:hasPermission&gt;&lt;/dd&gt;</span><br><span class="line">                    &lt;/dl&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">                &lt;li class=<span class="string">&quot;layui-nav-item&quot;</span>&gt;</span><br><span class="line">                    &lt;a href=<span class="string">&quot;javascript:;&quot;</span>&gt;menu group <span class="number">2</span>&lt;/a&gt;</span><br><span class="line">                    &lt;dl class=<span class="string">&quot;layui-nav-child&quot;</span>&gt;</span><br><span class="line">                        &lt;dd&gt;&lt;a href=<span class="string">&quot;javascript:;&quot;</span>&gt;list <span class="number">1</span>&lt;/a&gt;&lt;/dd&gt;</span><br><span class="line">                        &lt;dd&gt;&lt;a href=<span class="string">&quot;javascript:;&quot;</span>&gt;list <span class="number">2</span>&lt;/a&gt;&lt;/dd&gt;</span><br><span class="line">                        &lt;dd&gt;&lt;a href=<span class="string">&quot;&quot;</span>&gt;超链接&lt;/a&gt;&lt;/dd&gt;</span><br><span class="line">                    &lt;/dl&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">                &lt;li class=<span class="string">&quot;layui-nav-item&quot;</span>&gt;&lt;a href=<span class="string">&quot;javascript:;&quot;</span>&gt;click menu item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li class=<span class="string">&quot;layui-nav-item&quot;</span>&gt;&lt;a href=<span class="string">&quot;&quot;</span>&gt;the links&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">&quot;layui-body&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 内容主体区域 --&gt;</span><br><span class="line">        &lt;div style=<span class="string">&quot;padding: 15px;&quot;</span>&gt;内容主体区域。记得修改 layui.css 和 js 的路径&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=<span class="string">&quot;layui-footer&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 底部固定区域 --&gt;</span><br><span class="line">        底部固定区域</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;layui/layui.js&quot;</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//JS</span></span><br><span class="line">    layui.use([<span class="string">&#x27;element&#x27;</span>, <span class="string">&#x27;layer&#x27;</span>, <span class="string">&#x27;util&#x27;</span>], function()&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">element</span> <span class="operator">=</span> layui.element</span><br><span class="line">            ,layer = layui.layer</span><br><span class="line">            ,util = layui.util</span><br><span class="line">            ,$ = layui.$;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//头部事件</span></span><br><span class="line">        util.event(<span class="string">&#x27;lay-header-event&#x27;</span>, &#123;</span><br><span class="line">            <span class="comment">//左侧菜单事件</span></span><br><span class="line">            menuLeft: function(othis)&#123;</span><br><span class="line">                layer.msg(<span class="string">&#x27;展开左侧菜单的操作&#x27;</span>, &#123;icon: <span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            ,menuRight: function()&#123;</span><br><span class="line">                layer.open(&#123;</span><br><span class="line">                    type: <span class="number">1</span></span><br><span class="line">                    ,content: <span class="string">&#x27;&lt;div style=&quot;padding: 15px;&quot;&gt;处理右侧面板的操作&lt;/div&gt;&#x27;</span></span><br><span class="line">                    ,area: [<span class="string">&#x27;260px&#x27;</span>, <span class="string">&#x27;100%&#x27;</span>]</span><br><span class="line">                    ,offset: <span class="string">&#x27;rt&#x27;</span> <span class="comment">//右上角</span></span><br><span class="line">                    ,anim: <span class="number">5</span></span><br><span class="line">                    ,shadeClose: <span class="literal">true</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-加密"><a href="#7-加密" class="headerlink" title="7.加密"></a>7.加密</h2><blockquote><p>对原有的内容进行对应编码，得到不同于原始内容但能够表示原始内容的数据</p><ul><li>明文———（加密规则）———密文</li><li>加密规则可以自定义，在项目开发中通常使用BASE64和MD5编码方式<ul><li>BASE64：可反编码的编码方式（明文&lt;——&gt;密文）</li><li>MD5：不可逆的编码方式（明文——&gt;密文）</li></ul></li></ul></blockquote><h3 id="7-1-Shiro使用加密认证"><a href="#7-1-Shiro使用加密认证" class="headerlink" title="7.1 Shiro使用加密认证"></a>7.1 Shiro使用加密认证</h3><ul><li><p>配置matcher</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroDialect <span class="title function_">shiroDialect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShiroDialect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义Realm</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyRealm <span class="title function_">myRealm</span><span class="params">(HashedCredentialsMatcher matcher)</span>&#123;</span><br><span class="line">        <span class="type">MyRealm</span> <span class="variable">myRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRealm</span>();</span><br><span class="line">        myRealm.setCredentialsMatcher(matcher);</span><br><span class="line">        <span class="keyword">return</span> myRealm;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    加密操作</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HashedCredentialsMatcher <span class="title function_">getMatcher</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">HashedCredentialsMatcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedCredentialsMatcher</span>();</span><br><span class="line">        <span class="comment">//设置加密规则（加密方式）</span></span><br><span class="line">        matcher.setHashAlgorithmName(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">        <span class="comment">//hash（加密）次数，必须与注册时次数相同</span></span><br><span class="line">        matcher.setHashIterations(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> matcher;</span><br><span class="line">    &#125;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Controller层，注册使用加密</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/regist&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">regist</span><span class="params">(User user)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册时对密码进行加密存储（普通加密）</span></span><br><span class="line">    <span class="type">Md5Hash</span> <span class="variable">md5Hash</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Md5Hash</span>(user.getPassword());</span><br><span class="line">    System.out.println(md5Hash.toHex());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加盐加密</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">9000</span>)+<span class="number">1000</span>;<span class="comment">//1000~10000</span></span><br><span class="line">    System.out.println(<span class="string">&quot;salt--&quot;</span>+i);</span><br><span class="line">    <span class="type">Md5Hash</span> <span class="variable">md5Hash1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Md5Hash</span>(user.getPassword(),Integer.toString(i));</span><br><span class="line">    System.out.println(md5Hash1.toHex());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加盐加密+多次hash</span></span><br><span class="line">    <span class="type">Md5Hash</span> <span class="variable">md5Hash2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Md5Hash</span>(user.getPassword(),Integer.toString(i),<span class="number">3</span>);</span><br><span class="line">    System.out.println(md5Hash2.toHex());</span><br><span class="line"></span><br><span class="line">    user.setPassword(md5Hash2.toHex());</span><br><span class="line">    user.setPassword_salt(Integer.toString(i));</span><br><span class="line">    userService.addUser(user);</span><br><span class="line"></span><br><span class="line">    <span class="type">SimpleHash</span> <span class="variable">simpleHash</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHash</span>(<span class="string">&quot;md5&quot;</span>,user.getPassword(),Integer.toString(i),<span class="number">3</span>);</span><br><span class="line">    System.out.println(simpleHash.toHex());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>如果数据进行了加盐操作，在自定义Realm中</p></li><li><pre><code class="java">/** * 1.创建一个类继承AuthorizingRealm类（实现Realm接口的类） * 2.重写doGetAuthorizationInfo和doGetAuthenticationInfo方法 * 3.重写getName方法,返回当前Realm的一个自定义名称 */public class MyRealm extends AuthorizingRealm &#123;    @Autowired    private UserDao userDao;    @Override    public String getName() &#123;        return &quot;myRealm&quot;;    &#125;    /**     *获取授权信息（返回当前用户的角色及权限信息）     */    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;        //获取用户名        String username = (String) principalCollection.iterator().next();        //获取当前用户的角色列表        Set&lt;String&gt; roles = userDao.queryRolesByName(username);        //获取当前用户的权限列表        Set&lt;String&gt;  permission = userDao.queryPermissionByName(username);        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();        info.setRoles(roles);        info.setStringPermissions(permission);        return info;    &#125;    /**     * 获取认证信息（从数据库查询的用户的正确数据）     */    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;        //参数AuthenticationToken就是传递的subject.login(token)        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;        //从token中获取用户名        String username = token.getUsername();        //根据用户名从数据库查询当前用户的安全数据        User user = userDao.queryUserByName(username);        if(user == null)&#123;            return null;        &#125;        //加盐加密需要加上ByteSource.Util.bytes(user.getPassword_salt())        AuthenticationInfo info = new SimpleAuthenticationInfo(username,user.getPassword(), ByteSource.Util.bytes(user.getPassword_salt()),getName());        return info;    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 8.退出登陆</span><br><span class="line"></span><br><span class="line">- 在ShiroConfig中过滤器中配置logout的路径</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  @Bean</span><br><span class="line">  public ShiroFilterFactoryBean factoryBean(DefaultWebSecurityManager securityManager)&#123;</span><br><span class="line">      ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();</span><br><span class="line">      factoryBean.setSecurityManager(securityManager);</span><br><span class="line">      Map&lt;String, String&gt; map = new HashMap();</span><br><span class="line">      map.put(&quot;/regist&quot;,&quot;anon&quot;);</span><br><span class="line">      map.put(&quot;/login.html&quot;,&quot;anon&quot;);</span><br><span class="line">      map.put(&quot;/login&quot;,&quot;anon&quot;);</span><br><span class="line">      map.put(&quot;/**&quot;,&quot;authc&quot;);</span><br><span class="line">  </span><br><span class="line">      map.put(&quot;/logout&quot;,&quot;logout&quot;);</span><br><span class="line">  </span><br><span class="line">      factoryBean.setLoginUrl(&quot;/login.html&quot;);</span><br><span class="line">      factoryBean.setUnauthorizedUrl(&quot;/login.html&quot;);</span><br><span class="line">      factoryBean.setFilterChainDefinitionMap(map);</span><br><span class="line">      return factoryBean;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></code></pre></li><li><p>在”退出”按钮加上指定的路径，默认跳转到登陆页面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;/logout&quot;</span>&gt;退出&lt;/a&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="9-授权"><a href="#9-授权" class="headerlink" title="9.授权"></a>9.授权</h2><blockquote><p>用户登录之后，要进行响应的操作就需要对应的权限；在操作之前检查权限</p><p>权限控制通常有两类做法：</p><ul><li>不同的用户显示不同的用户菜单</li><li>对所有用户显示所有菜单，当用户点击菜单时验证当前用户是否有此权限</li></ul></blockquote><h4 id="9-1-html授权"><a href="#9-1-html授权" class="headerlink" title="9.1 html授权"></a>9.1 html授权</h4><ul><li><p>只显示当前用户拥有权限的菜单</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dd&gt;</span><br><span class="line">&lt;shiro:hasPermission name=<span class="string">&quot;stu:select&quot;</span>&gt;&lt;a href=<span class="string">&quot;&quot;</span> &gt;查看成绩&lt;/a&gt;&lt;/shiro:hasPermission&gt;</span><br><span class="line">&lt;/dd&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="9-2-过滤器授权"><a href="#9-2-过滤器授权" class="headerlink" title="9.2 过滤器授权"></a>9.2 过滤器授权</h4><ul><li><p>在shiroConfig中过滤器中对请求的url进行权限设置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*指定路径访问的权限*/</span></span><br><span class="line">map.put(<span class="string">&quot;/addStu&quot;</span>,<span class="string">&quot;perms[stu:add]&quot;</span>);</span><br><span class="line"><span class="comment">/*未授权访问页面*/</span></span><br><span class="line">factoryBean.setUnauthorizedUrl(<span class="string">&quot;/error&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="9-3-注解授权"><a href="#9-3-注解授权" class="headerlink" title="9.3 注解授权"></a>9.3 注解授权</h4><ul><li><p>配置Spring对Shior注解的支持</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*注解支持*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title function_">defaultAdvisorAutoProxyCreator</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">DefaultAdvisorAutoProxyCreator</span> <span class="variable">autoProxyCreator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAdvisorAutoProxyCreator</span>();</span><br><span class="line">    autoProxyCreator.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> autoProxyCreator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title function_">attributeSourceAdvisor</span><span class="params">(DefaultWebSecurityManager securityManager)</span>&#123;</span><br><span class="line">    <span class="type">AuthorizationAttributeSourceAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorizationAttributeSourceAdvisor</span>();</span><br><span class="line">    advisor.setSecurityManager(securityManager);</span><br><span class="line">    <span class="keyword">return</span> advisor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在请求的控制器的方法上添加注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/delStu&quot;)</span></span><br><span class="line"> <span class="meta">@RequiresPermissions(&quot;stu:delete&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">delStu</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;delStudent&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p>通过全局异常处理，指定权限不足时的页面跳转</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobaIExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doException</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> AuthorizationException)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="9-4-手动授权"><a href="#9-4-手动授权" class="headerlink" title="9.4 手动授权"></a>9.4 手动授权</h4><ul><li><p>在代码中进行手动授权设置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(subject.isPermitted(<span class="string">&quot;stu:update&quot;</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="10-缓存使用"><a href="#10-缓存使用" class="headerlink" title="10.缓存使用"></a>10.缓存使用</h2><blockquote><p>使用Shiro进行权限管理过程中，每次进行权限验证时doGetAuthorizationInfo方法查询当前用户的角色及权限信息，如果系统的用户量比较大则会对数据库造成较大的压力</p><p>Shiro支持缓存以降低数据库的访问压力（缓存的是授权信息）</p></blockquote><h4 id="缓存的使用"><a href="#缓存的使用" class="headerlink" title="缓存的使用"></a>缓存的使用</h4><ul><li><p>导入依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//支持缓存</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="comment">//第三方缓存</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="comment">//shiro使用缓存</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.9</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>配置缓存策略</p><ul><li><p>在resources目录下创建一个xml文件（ehcache.xml）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;ehcache updateCheck=<span class="string">&quot;false&quot;</span> dynamicConfig=<span class="string">&quot;false&quot;</span>&gt;</span><br><span class="line">    &lt;!--磁盘存储--&gt;</span><br><span class="line">    &lt;diskStore path=<span class="string">&quot;C:\TEMP&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;cache name=<span class="string">&quot;users&quot;</span> timeToLiveSeconds=<span class="string">&quot;300&quot;</span> maxEntriesLocalHeap=<span class="string">&quot;1000&quot;</span>/&gt;</span><br><span class="line">    &lt;!-- 登录记录缓存锁定<span class="number">1</span>小时 --&gt;</span><br><span class="line">    &lt;defaultCache name=<span class="string">&quot;defaultCache&quot;</span></span><br><span class="line">                  maxElementsInMemory=<span class="string">&quot;10000&quot;</span></span><br><span class="line">                  eternal=<span class="string">&quot;false&quot;</span></span><br><span class="line">                  timeToIdleSeconds=<span class="string">&quot;120&quot;</span></span><br><span class="line">                  timeToLiveSeconds=<span class="string">&quot;120&quot;</span></span><br><span class="line">                  overflowToDisk=<span class="string">&quot;false&quot;</span></span><br><span class="line">                  maxElementsOnDisk=<span class="string">&quot;100000&quot;</span></span><br><span class="line">                  diskPersistent=<span class="string">&quot;false&quot;</span></span><br><span class="line">                  diskExpiryThreadIntervalSeconds=<span class="string">&quot;120&quot;</span></span><br><span class="line">                  memoryStoreEvictionPolicy=<span class="string">&quot;LRU&quot;</span>  &gt;</span><br><span class="line">        &lt;!--缓存淘汰策略：当缓存空间比较紧张时，我们要存储新的数据，就必然删除一些老的数据</span><br><span class="line">            LRU 最近最少使用</span><br><span class="line">            FIFO 先进先出</span><br><span class="line">            LFU 最少使用--&gt;</span><br><span class="line">    &lt;/defaultCache&gt;</span><br><span class="line">&lt;/ehcache&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>加入缓存管理（ShiroConfig.java）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> EhCacheManager <span class="title function_">getEhCacheCacheManager</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">EhCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EhCacheManager</span>();</span><br><span class="line">    cacheManager.setCacheManagerConfigFile(<span class="string">&quot;classpath:ehcache.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> cacheManager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">securityManager</span><span class="params">(MyRealm myRealm)</span>&#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        securityManager.setRealm(myRealm);</span><br><span class="line">        securityManager.setCacheManager(getEhCacheCacheManager());</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="11-session管理"><a href="#11-session管理" class="headerlink" title="11.session管理"></a>11.session管理</h2><blockquote><p>Shiro进行认证和授权是基于session实现的，Shiro包含了对session的管理</p></blockquote><ul><li><p>对session进行管理</p><ul><li>自定义session管理器</li><li>将自定义的session管理器设置给SecurityManager</li></ul></li><li><p>配置自定义sessionManager：ShiroConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DefaultWebSessionManager <span class="title function_">getDefaultWebSessionManager</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">DefaultWebSessionManager</span> <span class="variable">sessionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSessionManager</span>();</span><br><span class="line">    <span class="comment">//session默认为30分钟</span></span><br><span class="line">    System.out.println(sessionManager.getGlobalSessionTimeout());</span><br><span class="line">    sessionManager.setGlobalSessionTimeout(<span class="number">10</span>*<span class="number">1000</span>);<span class="comment">//单位为毫秒</span></span><br><span class="line">    <span class="keyword">return</span> sessionManager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">securityManager</span><span class="params">(MyRealm myRealm)</span>&#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        securityManager.setRealm(myRealm);</span><br><span class="line">        securityManager.setCacheManager(getEhCacheCacheManager());</span><br><span class="line">        securityManager.setSessionManager(getDefaultWebSessionManager());</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="12-RememberMe"><a href="#12-RememberMe" class="headerlink" title="12.RememberMe"></a>12.RememberMe</h2><blockquote><p>将用户对页面的访问权限分为三个级别：</p><ul><li>未认证—可访问的页面（如登录页）</li><li><strong>曾认证（记住我）—可访问的页面</strong>（如个人信息页）</li><li>认证—可访问的页面（如转账页面）</li></ul></blockquote><p><img src="/2021/11/06/Shiro-SpringBoot/1656932058129.jpg" alt="1656932058129"></p><ul><li>在过滤器中设置”记住我“可访问的url</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//anon 表示未认证可访问</span></span><br><span class="line"><span class="comment">//user 表示记住我可访问（已认证也可以访问）</span></span><br><span class="line"><span class="comment">//authc 表示已认证可访问</span></span><br><span class="line">map.put(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;/regist&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;/index&quot;</span>,<span class="string">&quot;user&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;/login.html&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;/**&quot;</span>,<span class="string">&quot;authc&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>在ShiroConfig中配置基于Cookie的rememberMe的管理器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CookieRememberMeManager <span class="title function_">getCookieRememberMeManager</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">CookieRememberMeManager</span> <span class="variable">rememberMeManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CookieRememberMeManager</span>();</span><br><span class="line">    <span class="type">SimpleCookie</span> <span class="variable">simpleCookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCookie</span>(<span class="string">&quot;rememberMe&quot;</span>);</span><br><span class="line">    simpleCookie.setMaxAge(<span class="number">30</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    rememberMeManager.setCookie(simpleCookie);</span><br><span class="line">    <span class="keyword">return</span> rememberMeManager;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">securityManager</span><span class="params">(MyRealm myRealm)</span>&#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        securityManager.setRealm(myRealm);</span><br><span class="line">        securityManager.setCacheManager(getEhCacheCacheManager());</span><br><span class="line">        securityManager.setSessionManager(getDefaultWebSessionManager());</span><br><span class="line">        <span class="comment">//设置rememberMe管理器</span></span><br><span class="line">        securityManager.setRememberMeManager(getCookieRememberMeManager());</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>前端使用</p><ul><li><p>登录页面</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    记住我<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rememberMe&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>控制器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ModelAndView <span class="title function_">getIndex</span><span class="params">(String username, String password, ModelAndView modelAndView,<span class="type">boolean</span> rememberMe)</span>&#123;</span><br><span class="line">       System.out.println(rememberMe);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           loginService.checkLogin(username,password,rememberMe);</span><br><span class="line">           modelAndView.addObject(<span class="string">&quot;name&quot;</span>,username);</span><br><span class="line">           modelAndView.addObject(<span class="string">&quot;pass&quot;</span>,password);</span><br><span class="line">           modelAndView.setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           modelAndView.setViewName(<span class="string">&quot;login&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> modelAndView;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>业务层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkLogin</span><span class="params">(String username,String password,<span class="type">boolean</span> rememberMe)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username,password);</span><br><span class="line">        token.setRememberMe(rememberMe);</span><br><span class="line">        subject.login(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="13-多Realm配置"><a href="#13-多Realm配置" class="headerlink" title="13.多Realm配置"></a>13.多Realm配置</h2><h4 id="1、使用场景"><a href="#1、使用场景" class="headerlink" title="1、使用场景"></a>1、使用场景</h4><ul><li><p>数据来自于不同的数据源时，我们可以给SecurityManager配置多个Realm</p><p><img src="/2021/11/06/Shiro-SpringBoot/1657002814588.jpg" alt="1657002814588"></p></li></ul><h4 id="2、多个Realm的处理方式"><a href="#2、多个Realm的处理方式" class="headerlink" title="2、多个Realm的处理方式"></a>2、多个Realm的处理方式</h4><ul><li><p>链式处理</p><ul><li><p>多个Realm依次进行认证</p></li><li><p>步骤：</p><ul><li><p>第一个MyRealm同上，第二个MyRealm2</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRealm2</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyRealm2.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyRealm2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;-------另一个Realm数据源&quot;</span>);</span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> (UsernamePasswordToken) authenticationToken;</span><br><span class="line">        <span class="comment">//模拟从另一个数据库根据用户名查找的信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> token.getUsername();</span><br><span class="line">        <span class="comment">//模拟另一个数据库查找到的信息</span></span><br><span class="line">        <span class="type">SimpleAuthenticationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(username,<span class="string">&quot;test&quot;</span>,getName());</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在ShiroConfig中配置多Realm</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置多个Realm（链式处理）</span></span><br><span class="line">Collection&lt;Realm&gt; realms = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">realms.add(myRealm);</span><br><span class="line">realms.add(myRealm2());</span><br><span class="line">securityManager.setRealms(realms);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Shiro认证源码分析</p><p><img src="/2021/11/06/Shiro-SpringBoot/1657007079970.jpg" alt="1657007079970"></p><p><img src="/2021/11/06/Shiro-SpringBoot/1657007122108.jpg" alt="1657007122108"></p></li><li><p>分支处理</p><ul><li><p>根据不同的条件从多个Realm中选择一个进行认证处理</p></li><li><p>实现</p><p><img src="/2021/11/06/Shiro-SpringBoot/1657008240254.jpg" alt="1657008240254"></p></li><li><p>案例：用户不同身份登录执行不同的Realm</p><ul><li><p>自定义Realm（MyRealm和MyRealm2）</p><ul><li>在登录页面选择“普通用户”，则执行MyRealm2的认证</li><li>在登录页面选择“管理员用户”，则执行MyRealm的认证</li></ul></li><li><p>Realm的声明和配置</p></li><li><p>自定义token</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyToken</span> <span class="keyword">extends</span> <span class="title class_">UsernamePasswordToken</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String loginType;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyToken</span><span class="params">(String username,String password,String loginType)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(username, password);</span><br><span class="line">        <span class="built_in">this</span>.loginType=loginType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLoginType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> loginType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoginType</span><span class="params">(String loginType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loginType = loginType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>自定义认证器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyModularRealm</span> <span class="keyword">extends</span> <span class="title class_">ModularRealmAuthenticator</span> &#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyModularRealm.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doAuthenticate</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;------自定义认证器&quot;</span>);</span><br><span class="line">        <span class="type">MyToken</span> <span class="variable">token</span> <span class="operator">=</span> (MyToken) authenticationToken;</span><br><span class="line">        <span class="type">String</span> <span class="variable">loginType</span> <span class="operator">=</span> token.getLoginType();</span><br><span class="line">        Collection&lt;Realm&gt; realms = <span class="built_in">this</span>.getRealms();</span><br><span class="line">        Collection&lt;Realm&gt; typeRealms = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Realm realm:realms)&#123;</span><br><span class="line">            <span class="keyword">if</span>(realm.getName().startsWith(loginType))&#123;</span><br><span class="line">                typeRealms.add(realm);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (typeRealms.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> doSingleRealmAuthentication(typeRealms.iterator().next(), authenticationToken);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> doMultiRealmAuthentication(typeRealms, authenticationToken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>配置自定义认证器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroDialect <span class="title function_">shiroDialect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShiroDialect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义Realm</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyRealm <span class="title function_">myRealm</span><span class="params">(HashedCredentialsMatcher matcher)</span>&#123;</span><br><span class="line">        <span class="type">MyRealm</span> <span class="variable">myRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRealm</span>();</span><br><span class="line">        <span class="comment">//加密</span></span><br><span class="line">        myRealm.setCredentialsMatcher(matcher);</span><br><span class="line">        <span class="keyword">return</span> myRealm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyRealm2 <span class="title function_">myRealm2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyRealm2</span> <span class="variable">myRealm2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRealm2</span>();</span><br><span class="line">        <span class="keyword">return</span> myRealm2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义认证器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyModularRealm <span class="title function_">myModularRealm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyModularRealm</span> <span class="variable">myModularRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyModularRealm</span>();</span><br><span class="line">        <span class="keyword">return</span> myModularRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">securityManager</span><span class="params">(MyRealm myRealm)</span>&#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        <span class="comment">//开启自定义认证器(放在realms设置之前)</span></span><br><span class="line">        securityManager.setAuthenticator(myModularRealm());</span><br><span class="line">        <span class="comment">//配置一个Realm</span></span><br><span class="line"><span class="comment">//        securityManager.setRealm(myRealm);</span></span><br><span class="line">        <span class="comment">//配置多个Realm（链式处理）</span></span><br><span class="line">        Collection&lt;Realm&gt; realms = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        realms.add(myRealm);</span><br><span class="line">        realms.add(myRealm2());</span><br><span class="line">        securityManager.setRealms(realms);</span><br><span class="line"></span><br><span class="line">        securityManager.setCacheManager(getEhCacheCacheManager());</span><br><span class="line">        securityManager.setSessionManager(getDefaultWebSessionManager());</span><br><span class="line">        <span class="comment">//设置rememberMe管理器</span></span><br><span class="line">        securityManager.setRememberMeManager(getCookieRememberMeManager());</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2</title>
      <link href="/2021/11/06/vue2.0/"/>
      <url>/2021/11/06/vue2.0/</url>
      
        <content type="html"><![CDATA[<h2 id="常用7大属性"><a href="#常用7大属性" class="headerlink" title="常用7大属性"></a>常用7大属性</h2><ul><li><p>el属性</p><ul><li>用来指示vue编译器从什么地方开始解析 vue的语法，可以说是一个占位符。</li></ul></li><li><p>data属性</p><ul><li>用来组织从view中抽象出来的属性，可以说将视图的数据抽象出来存放在data中。</li></ul></li><li><p>template属性</p><ul><li>用来设置模板，会替换页面元素，包括占位符。</li></ul></li><li><p>methods属性</p><ul><li>放置页面中的业务逻辑，js方法一般都放置在methods中</li></ul></li><li><p>render属性</p><ul><li>创建真正的Virtual Dom</li></ul></li><li><p>computed属性</p><ul><li>计算属性</li><li>用来计算</li></ul></li><li><p>watch属性</p><ul><li>watch:function(new,old){}</li><li>监听data中数据的变化</li><li>两个参数，一个返回新值，一个返回旧值。</li></ul></li></ul><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文本值 v-once插值一次</span><br><span class="line">&lt;span v-once&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;</span><br><span class="line"># 原始html 双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html</span><br><span class="line">&lt;span v-html=&quot;msg&quot;&gt;&lt;/span&gt;</span><br><span class="line"># attribute 属性</span><br><span class="line">&lt;div v-bind:id=&quot;msg&quot;&gt;&lt;/div&gt;</span><br><span class="line"># js表达式 只能单个表达式</span><br><span class="line">&#123;&#123; msg=null? 1:0 &#125;&#125;</span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line">&lt;div v-bind:id=&quot;&#x27;list-&#x27; + id&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 必须满足单个表达式 v-for除外</span><br><span class="line"># 判断 </span><br><span class="line">&lt;p v-if=&quot;flog&quot;&gt;&lt;/p&gt;</span><br><span class="line"># 绑定 告知 v-bind 指令将该元素的 href attribute 与表达式 url 的值绑定</span><br><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class="line"># 监听DOM事件</span><br><span class="line">&lt;a v-on:click=&quot;doSomething()&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</span><br><span class="line"># 这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。</span><br><span class="line">&lt;a v-bind:[attributeName]=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class="line">#当 eventName 的值为 &quot;focus&quot; 时，v-on:[eventName] 将等价于 v-on:focus</span><br><span class="line">&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>动态参数预期会求出一个字符串，异常情况下值为 <code>null</code>。这个特殊的 <code>null</code> 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。</p><p>动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这会触发一个编译警告 --&gt;</span><br><span class="line">&lt;a v-bind:[&#x27;foo&#x27; + bar]=&quot;value&quot;&gt; ... &lt;/a&gt;</span><br></pre></td></tr></table></figure><p><strong>变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。</strong></p><p>在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要<strong>避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写</strong>。</p></blockquote><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：</span><br><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># v-bind 缩写</span><br><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;</span><br><span class="line">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;a :[key]=&quot;url&quot;&gt; ... &lt;/a&gt;</span><br><span class="line"># v-on 缩写</span><br><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</span><br><span class="line">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;a @[event]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="计算属性与侦听器"><a href="#计算属性与侦听器" class="headerlink" title="计算属性与侦听器"></a>计算属性与侦听器</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。所以，对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>（computed）。</p><p>还可以使用<strong>方法</strong>（methods）。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; getMessage &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">el:&#x27;#demo&#x27;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message: &quot;hello&quot;;</span><br><span class="line">    &#125;,</span><br><span class="line">    # 使用计算属性</span><br><span class="line">    cpmputed:&#123;</span><br><span class="line">        getMessage:function()&#123;</span><br><span class="line">            return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    # 使用方法</span><br><span class="line">    methods:&#123;</span><br><span class="line">        getMessage:function()&#123;</span><br><span class="line">            return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">输出都为：olleh</span><br></pre></td></tr></table></figure><h4 id="计算属性与方法区别"><a href="#计算属性与方法区别" class="headerlink" title="计算属性与方法区别"></a>计算属性与方法区别</h4><p><strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在<strong>相关响应式依赖发生改变时它们才会重新求值</strong>。这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。而对于方法，每当触发重新渲染时，调用方法将<strong>总会</strong>再次执行函数。</p><p>这也同样意味着下面的计算属性将不再更新，因为 <code>Date.now()</code> 不是响应式依赖：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">getDate:function()&#123;</span><br><span class="line">return Date.now()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>计算属性适用于计算量大，复杂而且多处调用的函数，然后我们可能有其他的计算属性依赖于 <strong>A</strong>，使用缓存不用每次调用都执行一遍。</li></ul><h4 id="计算属性的setter"><a href="#计算属性的setter" class="headerlink" title="计算属性的setter"></a>计算属性的setter</h4><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">el:&#x27;#demo&#x27;,</span><br><span class="line">data: &#123;</span><br><span class="line">    firstName: &#x27;Foo&#x27;,</span><br><span class="line">    lastName: &#x27;Bar&#x27;,</span><br><span class="line">    fullName: &#x27;Foo Bar&#x27;</span><br><span class="line"> &#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">fullName:&#123;</span><br><span class="line"># getter方法</span><br><span class="line">get:function()&#123;</span><br><span class="line">return this.firstName + &#x27; &#x27; + this.lastName</span><br><span class="line">&#125;,</span><br><span class="line"># setter方法</span><br><span class="line">set:function(newValue)&#123;</span><br><span class="line">var names = newValue.split(&#x27; &#x27;)</span><br><span class="line">      this.firstName = names[0]</span><br><span class="line">      this.lastName = names[names.length - 1]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化。<strong>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</strong></p><ul><li>watch:function(new,old){}</li><li>监听data中数据的变化</li><li>两个参数，一个返回新值，一个返回旧值。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;watch-example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;question&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">——————————————————————————————————————————————————————————</span><br><span class="line"><span class="comment">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">el</span>: <span class="string">&#x27;#watch-example&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">question</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">answer</span>: <span class="string">&#x27;I cannot give you an answer until you ask a question!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">watch</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">question</span>: <span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Waiting for you to stop typing...&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="title function_">debouncedGetAnswer</span>()</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">debouncedGetAnswer</span> = _.<span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">getAnswer</span>, <span class="number">500</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">getAnswer</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">question</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;?&#x27;</span>) === -<span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Questions usually contain a question mark. ;-)&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Thinking...&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> vm = <span class="variable language_">this</span></span></span><br><span class="line"><span class="language-javascript">      axios.<span class="title function_">get</span>(<span class="string">&#x27;https://yesno.wtf/api&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          vm.<span class="property">answer</span> = _.<span class="title function_">capitalize</span>(response.<span class="property">data</span>.<span class="property">answer</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          vm.<span class="property">answer</span> = <span class="string">&#x27;Error! Could not reach the API. &#x27;</span> + error</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，使用 <code>watch</code> 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><h2 id="Class与Style绑定"><a href="#Class与Style绑定" class="headerlink" title="Class与Style绑定"></a>Class与Style绑定</h2><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 <code>v-bind</code> 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</p><h3 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a>绑定 HTML Class</h3><h4 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h4><p>[1] truthy 不是 <code>true</code>为真值，详见 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">MDN</a> 的解释。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># class中设置 isActive为truthy </span><br><span class="line">&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br><span class="line"># data中设置</span><br><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &#x27;text-danger&#x27;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 计算属性（computed）中设置</span><br><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  error: null</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      active: this.isActive &amp;&amp; !this.error,</span><br><span class="line">      &#x27;text-danger&#x27;: this.error &amp;&amp; this.error.type === &#x27;fatal&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h4><p>我们可以把一个数组传给 <code>v-bind:class</code>，以应用一个 class 列表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</span><br><span class="line">data:&#123;</span><br><span class="line">activeClass: &#x27;active&#x27;,</span><br><span class="line">errorClass: &#x27;text-danger&#x27;</span><br><span class="line">&#125;</span><br><span class="line"># 使用表达式</span><br><span class="line">&lt;div v-bind:class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;</span><br><span class="line"># 使用对象语法 </span><br><span class="line">&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a>用在组件上</h4><p>当在一个自定义组件上使用 <code>class</code> property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&#x27;my-component&#x27;, &#123;</span><br><span class="line">  template: &#x27;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">结果：</span><br><span class="line">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h3><h4 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h4><p><code>v-bind:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor,fontSize: fontSize+&#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">data:&#123;</span><br><span class="line">activeColor: &#x27;red&#x27;,</span><br><span class="line">fontSize: 10</span><br><span class="line">&#125;</span><br><span class="line">#</span><br><span class="line">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data:&#123;</span><br><span class="line">styleObject:&#123;</span><br><span class="line">color: &#x27;red&#x27;,</span><br><span class="line">fontSize: &#x27;10px&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组写法"><a href="#数组写法" class="headerlink" title="数组写法"></a>数组写法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</span><br><span class="line">data:&#123;</span><br><span class="line">baseStyles: &#x27;color:red&#x27;,</span><br><span class="line">overridingStyles: &#x27;fontSize:10px&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a>多重值</h4><p>从 2.3.0 起你可以为 <code>style</code> 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 <code>display: flex</code>。</p><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p><p>类似于 <code>v-else</code>，<code>v-else-if</code> 也必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素之后，否则它将不会被识别。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;</span><br><span class="line">      A</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;</span><br><span class="line">      B</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;</span><br><span class="line">      C</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div v-else&gt;</span><br><span class="line">      Not A/B/C</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 <code>key</code> 管理可复用的元素</h4><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>那么在上面的代码中切换 <code>loginType</code> 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code> 不会被替换掉——仅仅是替换了它的 <code>placeholder</code>。</p><p>Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 <code>key</code> attribute 即可：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>现在，每次切换时，输入框都将被重新渲染。</p><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>另一个用于根据条件展示元素的选项是 <code>v-show</code> 指令。用法大致一样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>不同的是带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code> 只是简单地切换元素的 CSS property <code>display</code>。</p><blockquote><p>注意，<code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</p></blockquote><h3 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a><code>v-if</code> vs <code>v-show</code></h3><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。<strong>因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</strong></p><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><h4 id="渲染数组"><a href="#渲染数组" class="headerlink" title="渲染数组"></a>渲染数组</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># item 每一位数组元素  index 索引值</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example-2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.message&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">var example2 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#example-2&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMessage: &#x27;Parent&#x27;,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; message: &#x27;Foo&#x27; &#125;,</span><br><span class="line">      &#123; message: &#x27;Bar&#x27; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"># v-for 也可以接受整数。在这种情况下，它会把模板重复对应次数</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 10&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="渲染对象"><a href="#渲染对象" class="headerlink" title="渲染对象"></a>渲染对象</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># value 对象属性值  name 对象属性名  index 索引值</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name, index) in object&quot;</span>&gt;</span>  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#v-for-object&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      title: &#x27;How to do lists in Vue&#x27;,</span><br><span class="line">      author: &#x27;Jane Doe&#x27;,</span><br><span class="line">      publishedAt: &#x27;2016-04-10&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你也可以用 <code>of</code> 替代 <code>in</code> 作为分隔符，因为它更接近 JavaScript 迭代器的语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><h4 id="变更方法"><a href="#变更方法" class="headerlink" title="变更方法"></a>变更方法</h4><p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p><ul><li><code>push()</code></li><li><code>pop()</code></li><li><code>shift()</code></li><li><code>unshift()</code></li><li><code>splice()</code></li><li><code>sort()</code></li><li><code>reverse()</code></li></ul><p>你可以打开控制台，然后对前面例子的 <code>items</code> 数组尝试调用变更方法。比如 <code>example-2.items.push(&#123; message: &#39;Baz&#39; &#125;)</code>。</p><p>例：<code>this.users.push(&#123; name:&quot;张三&quot;,message: &#39;测试&#39; &#125;)</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example-2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.message&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addUsers&quot;</span>&gt;</span>点击我添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">var example2 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#example-2&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMessage: &#x27;Parent&#x27;,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; name: &#x27;demo&#x27;,message: &#x27;Foo&#x27; &#125;,</span><br><span class="line">      &#123; name: &#x27;zsan&#x27;,message: &#x27;Bar&#x27; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">addUsers:function ()&#123;</span><br><span class="line">      this.users.push(&#123;</span><br><span class="line">        name:&quot;张三&quot;,</span><br><span class="line">        message: &#x27;测试&#x27;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h4><p>变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 <code>filter()</code>、<code>concat()</code> 和 <code>slice()</code>。它们不会变更原始数组，而<strong>总是返回一个新数组</strong>。当使用非变更方法时，可以用新数组替换旧数组：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item of users2&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; item.name &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">computed:&#123;</span><br><span class="line">    // eslint-disable-next-line vue/return-in-computed-property</span><br><span class="line">    users2:function ()&#123;</span><br><span class="line">        return this.users.filter(function (item) &#123;</span><br><span class="line">        return item.name.match(/demo/)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  结果：返回一个新数组只输出demo用户</span><br></pre></td></tr></table></figure><h3 id="显示过滤-x2F-排序后的结果"><a href="#显示过滤-x2F-排序后的结果" class="headerlink" title="显示过滤&#x2F;排序后的结果"></a>显示过滤&#x2F;排序后的结果</h3><p>有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  numbers: [ 1, 2, 3, 4, 5 ]</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  evenNumbers: function () &#123;</span><br><span class="line">    return this.numbers.filter(function (number) &#123;</span><br><span class="line">      return number % 2 === 0</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算属性不适用的情况下 (例如，在嵌套 <code>v-for</code> 循环中) 你可以使用一个方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul v-for=&quot;set in sets&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;n in even(set)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  even: function (numbers) &#123;</span><br><span class="line">    return numbers.filter(function (number) &#123;</span><br><span class="line">      return number % 2 === 0</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在组件上使用v-for"><a href="#在组件上使用v-for" class="headerlink" title="在组件上使用v-for"></a>在组件上使用v-for</h3><p>然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop。</p><p>不自动将 <code>item</code> 注入到组件里的原因是，这会使得组件与 <code>v-for</code> 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。</p><p>下面是一个简单的 todo 列表的完整例子：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;todo-list-example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;addNewTodo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;new-todo&quot;</span>&gt;</span>Add a todo<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model</span>=<span class="string">&quot;newTodoText&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;new-todo&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">placeholder</span>=<span class="string">&quot;E.g. Feed the cat&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">      <span class="attr">is</span>=<span class="string">&quot;todo-item&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">&quot;(todo, index) in todos&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:key</span>=<span class="string">&quot;todo.id&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:title</span>=<span class="string">&quot;todo.title&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-on:remove</span>=<span class="string">&quot;todos.splice(index, 1)&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里的 <code>is=&quot;todo-item&quot;</code> attribute。这种做法在使用 DOM 模板时是十分必要的，因为在 <code>&lt;ul&gt;</code> 元素内只有 <code>&lt;li&gt;</code> 元素会被看作有效内容。这样做实现的效果与 <code>&lt;todo-item&gt;</code> 相同，但是可以避开一些潜在的浏览器解析错误。查看 <a href="https://v2.cn.vuejs.org/v2/guide/components.html#%E8%A7%A3%E6%9E%90-DOM-%E6%A8%A1%E6%9D%BF%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">DOM 模板解析说明</a> 来了解更多信息。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;todo-item&#x27;, &#123;</span><br><span class="line">  template: &#x27;\</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>\</span><br><span class="line">      &#123;&#123; title &#125;&#125;\</span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(\&#x27;remove\&#x27;)&quot;</span>&gt;</span>Remove<span class="tag">&lt;/<span class="name">button</span>&gt;</span>\</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span>\</span><br><span class="line">  &#x27;,</span><br><span class="line">  props: [&#x27;title&#x27;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#todo-list-example&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    newTodoText: &#x27;&#x27;,</span><br><span class="line">    todos: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        title: &#x27;Do the dishes&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: 2,</span><br><span class="line">        title: &#x27;Take out the trash&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: 3,</span><br><span class="line">        title: &#x27;Mow the lawn&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    nextTodoId: 4</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addNewTodo: function () &#123;</span><br><span class="line">      this.todos.push(&#123;</span><br><span class="line">        id: this.nextTodoId++,</span><br><span class="line">        title: this.newTodoText</span><br><span class="line">      &#125;)</span><br><span class="line">      this.newTodoText = &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><p>可以用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;counter += 1&quot;</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">var example1 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#example-1&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h3><p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">// ...</span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: function (message, event) &#123;</span><br><span class="line">    // 现在我们可以访问原生事件对象</span><br><span class="line">    if (event) &#123;</span><br><span class="line">      event.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p><p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><h4 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h4><p>单个复选框，绑定到布尔值：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p>多个复选框，绑定到同一个数组：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;jack&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jack&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;jack&quot;</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;john&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;john&quot;</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mike&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mike&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mike&quot;</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;...&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    checkedNames: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="选择框"><a href="#选择框" class="headerlink" title="选择框"></a>选择框</h4><p>单选时：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-5&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;...&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: &#x27;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>如果 <code>v-model</code> 表达式的初始值未能匹配任何选项，<code>&lt;select&gt;</code> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p></blockquote><p>用 <code>v-for</code> 渲染的动态选项：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">&quot;option in options&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;option.value&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; option.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;...&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: &#x27;A&#x27;,</span><br><span class="line">    options: [</span><br><span class="line">      &#123; text: &#x27;One&#x27;, value: &#x27;A&#x27; &#125;,</span><br><span class="line">      &#123; text: &#x27;Two&#x27;, value: &#x27;B&#x27; &#125;,</span><br><span class="line">      &#123; text: &#x27;Three&#x27;, value: &#x27;C&#x27; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h3><h4 id="复选框-1"><a href="#复选框-1" class="headerlink" title="复选框"></a>复选框</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  type=&quot;checkbox&quot;</span><br><span class="line">  v-model=&quot;toggle&quot;</span><br><span class="line">  true-value=&quot;yes&quot;</span><br><span class="line">  false-value=&quot;no&quot;</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">// 当选中时</span><br><span class="line">vm.toggle === &#x27;yes&#x27;</span><br><span class="line">// 当没有选中时</span><br><span class="line">vm.toggle === &#x27;no&#x27;</span><br></pre></td></tr></table></figure><p>这里的 <code>true-value</code> 和 <code>false-value</code> attribute 并不会影响输入控件的 <code>value</code> attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(即“yes”或“no”)，请换用单选按钮。</p><h4 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; v-bind:value=&quot;a&quot;&gt;</span><br><span class="line"></span><br><span class="line">// 当选中时</span><br><span class="line">vm.pick === vm.a</span><br></pre></td></tr></table></figure><h4 id="选择框的选项"><a href="#选择框的选项" class="headerlink" title="选择框的选项"></a>选择框的选项</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select v-model=&quot;selected&quot;&gt;</span><br><span class="line">    &lt;!-- 内联对象字面量 --&gt;</span><br><span class="line">  &lt;option v-bind:value=&quot;&#123; number: 123 &#125;&quot;&gt;123&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">// 当选中时</span><br><span class="line">typeof vm.selected // =&gt; &#x27;object&#x27;</span><br><span class="line">vm.selected.number // =&gt; 123</span><br></pre></td></tr></table></figure><h3 id="修饰符-1"><a href="#修饰符-1" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h4><p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步 (除了<a href="https://v2.cn.vuejs.org/v2/guide/forms.html#vmodel-ime-tip">上述</a>输入法组合文字时)。你可以添加 <code>lazy</code> 修饰符，从而转为在 <code>change</code> 事件_之后_进行同步：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span><br><span class="line">&lt;input v-model.lazy=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h4><p>如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</span><br></pre></td></tr></table></figure><p>这通常很有用，因为即使在 <code>type=&quot;number&quot;</code> 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 <code>parseFloat()</code> 解析，则会返回原始的值。</p><h4 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h4><p>如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input v-model.trim=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><h3 id="组件的复用"><a href="#组件的复用" class="headerlink" title="组件的复用"></a>组件的复用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 定义一个名为 button-counter 的新组件</span><br><span class="line">Vue.component(&#x27;button-counter&#x27;, &#123;</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &#x27;<span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>You clicked me &#123;&#123; count &#125;&#125; times.<span class="tag">&lt;/<span class="name">button</span>&gt;</span>&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意当点击按钮时，每个组件都会各自独立维护它的 <code>count</code>。因为你每用一次组件，就会有一个它的新<strong>实例</strong>被创建。</p><h4 id="data-必须是一个函数"><a href="#data-必须是一个函数" class="headerlink" title="data 必须是一个函数"></a><code>data</code> 必须是一个函数</h4><p>当我们定义这个 <code>&lt;button-counter&gt;</code> 组件时，你可能会发现它的 <code>data</code> 并不是像这样直接提供一个对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  count: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取而代之的是，<strong>一个组件的 <code>data</code> 选项必须是一个函数</strong>，因此每个实例可以维护一份被返回对象的独立的拷贝：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Vue 没有这条规则，点击一个按钮就可能会影响到<em>其它所有实例</em>；点击一个全部改变。</p><h3 id="通过Prop向子组件传递数据"><a href="#通过Prop向子组件传递数据" class="headerlink" title="通过Prop向子组件传递数据"></a>通过Prop向子组件传递数据</h3><p>Prop 是你可以在组件上注册的一些自定义 attribute。当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;My journey with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;Blogging with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;Why Vue is so fun&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Vue.component(&#x27;blog-post&#x27;, &#123;</span><br><span class="line">  props: [&#x27;title&#x27;],</span><br><span class="line">  template: &#x27;<span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>传递多个值</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">&quot;post in posts&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">&quot;post.id&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">&quot;post.title&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#blog-post-demo&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    posts: [</span><br><span class="line">      &#123; id: 1, title: &#x27;My journey with Vue&#x27; &#125;,</span><br><span class="line">      &#123; id: 2, title: &#x27;Blogging with Vue&#x27; &#125;,</span><br><span class="line">      &#123; id: 3, title: &#x27;Why Vue is so fun&#x27; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上所示，你会发现我们可以使用 <code>v-bind</code> 来动态传递 prop。这在你一开始不清楚要渲染的具体内容，比如<a href="https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-component-blog-post-example">从一个 API 获取博文列表</a>的时候，是非常有用的。</p><h3 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h3><p>在每篇博文正文之前添加一个按钮来放大字号：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 父级组件可以像处理 native DOM 事件一样通过 v-on 监听子组件实例的任意事件：</span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">&quot;postFontSize += 0.1&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Vue.component(&#x27;blog-post&#x27;, &#123;</span><br><span class="line">  props: [&#x27;post&#x27;],</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;blog-post&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; post.title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      # 子组件可以通过调用内建的 $emit 方法并传入事件名称来触发一个事件：</span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;)&quot;</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;post.content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="使用事件抛出一个值"><a href="#使用事件抛出一个值" class="headerlink" title="使用事件抛出一个值"></a>使用事件抛出一个值</h4><p>有的时候用一个事件来抛出一个特定的值是非常有用的。例如我们可能想让 <code>&lt;blog-post&gt;</code> 组件决定它的文本要放大多少。这时可以使用 <code>$emit</code> 的第二个参数来提供这个值：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;, 0.1)&quot;</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后当在父级组件监听这个事件的时候，我们可以通过 <code>$event</code> 访问到被抛出的这个值：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">&quot;postFontSize += $event&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者，如果这个事件处理函数是一个方法：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">&quot;onEnlargeText&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么这个值将会作为第一个参数传入这个方法：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  onEnlargeText: function (enlargeAmount) &#123;</span><br><span class="line">    this.postFontSize += enlargeAmount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><h3 id="组件名命名"><a href="#组件名命名" class="headerlink" title="组件名命名"></a>组件名命名</h3><p>当直接在 DOM 中使用一个组件 (而不是在字符串模板或<a href="https://v2.cn.vuejs.org/v2/guide/single-file-components.html">单文件组件</a>) 的时候，我们强烈推荐遵循 <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name">W3C 规范</a>中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。你可以在<a href="https://v2.cn.vuejs.org/v2/style-guide/#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E5%90%8D-%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90">风格指南</a>中查阅到关于组件名的其它建议。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;my-component-name&#x27;, &#123; /* ... */ &#125;)</span><br></pre></td></tr></table></figure><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>这些组件是<strong>全局注册的</strong>。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (<code>new Vue</code>) 的模板中。比如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;component-a&#x27;, &#123; /* ... */ &#125;)</span><br><span class="line">Vue.component(&#x27;component-b&#x27;, &#123; /* ... */ &#125;)</span><br><span class="line">Vue.component(&#x27;component-c&#x27;, &#123; /* ... */ &#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123; el: &#x27;#app&#x27; &#125;)</span><br></pre></td></tr></table></figure><p>在所有子组件中也是如此，也就是说这三个组件<em>在各自内部</em>也都可以相互使用。</p><h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var ComponentA = &#123; /* ... */ &#125;</span><br><span class="line">var ComponentB = &#123; /* ... */ &#125;</span><br><span class="line">var ComponentC = &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>components</code> 选项中定义你想要使用的组件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &#x27;component-a&#x27;: ComponentA,</span><br><span class="line">    &#x27;component-b&#x27;: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于 <code>components</code> 对象中的每个 property 来说，其 property 名就是自定义元素的名字，其 property 值就是这个组件的选项对象。</p><p>或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import ComponentA from &#x27;./ComponentA.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在 ES2015+ 中，在对象中放一个类似 <code>ComponentA</code> 的变量名其实是 <code>ComponentA: ComponentA</code> 的缩写，即这个变量名同时是：</p><ul><li>用在模板中的自定义元素的名称</li><li>包含了这个组件选项的变量名</li></ul><h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><h4 id="局部注册-1"><a href="#局部注册-1" class="headerlink" title="局部注册"></a>局部注册</h4><p>在这些情况下，我们推荐创建一个 <code>components</code> 目录，并将每个组件放置在其各自的文件中。</p><p>然后你需要在局部注册之前导入每个你想使用的组件。例如，在一个假设的 <code>ComponentB.js</code> 或 <code>ComponentB.vue</code> 文件中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import ComponentA from &#x27;./ComponentA&#x27;</span><br><span class="line">import ComponentC from &#x27;./ComponentC&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA,</span><br><span class="line">    ComponentC</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动化全局注册"><a href="#自动化全局注册" class="headerlink" title="自动化全局注册"></a>自动化全局注册</h4><p>如果你恰好使用了 webpack (或在内部使用了 webpack 的 <a href="https://github.com/vuejs/vue-cli">Vue CLI 3+</a>)，那么就可以使用 <code>require.context</code> 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 <code>src/main.js</code>) 中全局导入基础组件的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import upperFirst from &#x27;lodash/upperFirst&#x27;</span><br><span class="line">import camelCase from &#x27;lodash/camelCase&#x27;</span><br><span class="line"></span><br><span class="line">const requireComponent = require.context(</span><br><span class="line">  // 其组件目录的相对路径</span><br><span class="line">  &#x27;./components&#x27;,</span><br><span class="line">  // 是否查询其子目录</span><br><span class="line">  false,</span><br><span class="line">  // 匹配基础组件文件名的正则表达式</span><br><span class="line">  /Base[A-Z]\w+\.(vue|js)$/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(fileName =&gt; &#123;</span><br><span class="line">  // 获取组件配置</span><br><span class="line">  const componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  // 获取组件的 PascalCase 命名</span><br><span class="line">  const componentName = upperFirst(</span><br><span class="line">    camelCase(</span><br><span class="line">      // 获取和目录深度无关的文件名</span><br><span class="line">      fileName</span><br><span class="line">        .split(&#x27;/&#x27;)</span><br><span class="line">        .pop()</span><br><span class="line">        .replace(/\.\w+$/, &#x27;&#x27;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  // 全局注册组件</span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    // 如果这个组件选项是通过 `export default` 导出的，</span><br><span class="line">    // 那么就会优先使用 `.default`，</span><br><span class="line">    // 否则回退到使用模块的根。</span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>记住<strong>全局注册的行为必须在根 Vue 实例 (通过 <code>new Vue</code>) 创建之前发生</strong>。<a href="https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js">这里</a>有一个真实项目情景下的示例。</p><h2 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h2><h3 id="prop的大小写"><a href="#prop的大小写" class="headerlink" title="prop的大小写"></a>prop的大小写</h3><p>HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：</p><p>在Prop中可以使用驼峰命名，父组件中使用短横线分隔命名。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;blog-post&#x27;, &#123;</span><br><span class="line">  // 在 JavaScript 中是 camelCase 的</span><br><span class="line">  props: [&#x27;postTitle&#x27;],</span><br><span class="line">  template: &#x27;<span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; postTitle &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">post-title</span>=<span class="string">&quot;hello!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="prop类型"><a href="#prop类型" class="headerlink" title="prop类型"></a>prop类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: String,</span><br><span class="line">  likes: Number,</span><br><span class="line">  isPublished: Boolean,</span><br><span class="line">  commentIds: Array,</span><br><span class="line">  author: Object,</span><br><span class="line">  callback: Function,</span><br><span class="line">  contactsPromise: Promise // or any other constructor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传递静态或动态-Prop"><a href="#传递静态或动态-Prop" class="headerlink" title="传递静态或动态 Prop"></a>传递静态或动态 Prop</h3><p>像这样，你已经知道了可以像这样给 prop 传入一个静态的值：（除了字符串，其他传入静态的值都需要v-bind进行绑定）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><p>你也知道 prop 可以通过 <code>v-bind</code> 动态赋值，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 动态赋予一个变量的值 --&gt;</span><br><span class="line">&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;!-- 动态赋予一个复杂表达式的值 --&gt;</span><br><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:title=&quot;post.title + &#x27; by &#x27; + post.author.name&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 传入一个数字 --&gt;</span><br><span class="line">&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span><br><span class="line">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="line">&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 传入一个布尔值 --&gt;</span><br><span class="line">&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;</span><br><span class="line">&lt;blog-post is-published&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;blog-post v-bind:is-published=&quot;post.isPublished&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 传入一个数组 --&gt;</span><br><span class="line">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="line">&lt;blog-post v-bind:comment-ids=&quot;[234, 266, 273]&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 传入一个对象 --&gt;</span><br><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:author=&quot;&#123;</span><br><span class="line">    name: &#x27;Veronica&#x27;,</span><br><span class="line">    company: &#x27;Veridian Dynamics&#x27;</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><!-- 传入一个对象的所有 property --><p>如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 <code>v-bind</code> (取代 <code>v-bind:prop-name</code>)。例如，对于一个给定的对象 <code>post</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post: &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  title: &#x27;My Journey with Vue&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的模板：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:id=&quot;post.id&quot;</span><br><span class="line">  v-bind:title=&quot;post.title&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不应该在一个子组件内部改变 prop</strong>。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p><p>这里有两种常见的试图变更一个 prop 的情形：</p><ol><li><p><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong>在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props: [&#x27;initialCounter&#x27;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    counter: this.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>这个 prop 以一种原始的值传入且需要进行转换。</strong>在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props: [&#x27;size&#x27;],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: function () &#123;</span><br><span class="line">    return this.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="prop验证"><a href="#prop验证" class="headerlink" title="prop验证"></a>prop验证</h3><p><code>type</code> 可以是下列原生构造函数中的一个：</p><ul><li><code>String</code></li><li><code>Number</code></li><li><code>Boolean</code></li><li><code>Array</code></li><li><code>Object</code></li><li><code>Date</code></li><li><code>Function</code></li><li><code>Symbol</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;my-component&#x27;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span><br><span class="line">    propA: Number,</span><br><span class="line">    // 多个可能的类型</span><br><span class="line">    propB: [String, Number],</span><br><span class="line">    // 必填的字符串</span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    // 带有默认值的数字</span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    // 带有默认值的对象</span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      // 对象或数组默认值必须从一个工厂函数获取</span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return &#123; message: &#x27;hello&#x27; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 自定义验证函数</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">        // 这个值必须匹配下列字符串中的一个</span><br><span class="line">        return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].includes(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意那些 prop 会在一个组件实例创建<strong>之前</strong>进行验证，所以实例的 property (如 <code>data</code>、<code>computed</code> 等) 在 <code>default</code> 或 <code>validator</code> 函数中是不可用的。</p></blockquote><p>额外的，<code>type</code> 还可以是一个自定义的构造函数，并且通过 <code>instanceof</code> 来进行检查确认。例如，给定下列现成的构造函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (firstName, lastName) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastName</span> = lastName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;blog-post&#x27;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    author: Person</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>来验证 <code>author</code> prop 的值是否是通过 <code>new Person</code> 创建的。</p><p>来验证 <code>author</code> prop 的值是否是通过 <code>new Person</code> 创建的。</p><h3 id="非-Prop-的-Attribute"><a href="#非-Prop-的-Attribute" class="headerlink" title="非 Prop 的 Attribute"></a>非 Prop 的 Attribute</h3><p>一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。</p><p>因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的 attribute，而这些 attribute 会被添加到这个组件的根元素上。</p><p>例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的 <code>&lt;bootstrap-date-input&gt;</code> 组件，这个插件需要在其 <code>&lt;input&gt;</code> 上用到一个 <code>data-date-picker</code> attribute。我们可以将这个 attribute 添加到你的组件实例上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bootstrap-date-input data-date-picker=&quot;activated&quot;&gt;&lt;/bootstrap-date-input&gt;</span><br></pre></td></tr></table></figure><p>然后这个 <code>data-date-picker=&quot;activated&quot;</code> attribute 就会自动添加到 <code>&lt;bootstrap-date-input&gt;</code> 的根元素上。</p><h4 id="替换-x2F-合并已有的-Attribute"><a href="#替换-x2F-合并已有的-Attribute" class="headerlink" title="替换&#x2F;合并已有的 Attribute"></a>替换&#x2F;合并已有的 Attribute</h4><p>想象一下 <code>&lt;bootstrap-date-input&gt;</code> 的模板是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;date&quot; class=&quot;form-control&quot;&gt;</span><br></pre></td></tr></table></figure><p>为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bootstrap-date-input</span><br><span class="line">  data-date-picker=&quot;activated&quot;</span><br><span class="line">  class=&quot;date-picker-theme-dark&quot;</span><br><span class="line">&gt;&lt;/bootstrap-date-input&gt;</span><br></pre></td></tr></table></figure><p>在这种情况下，我们定义了两个不同的 <code>class</code> 的值：</p><ul><li><code>form-control</code>，这是在组件的模板内设置好的</li><li><code>date-picker-theme-dark</code>，这是从组件的父级传入的</li></ul><p>对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 <code>type=&quot;text&quot;</code> 就会替换掉 <code>type=&quot;date&quot;</code> 并把它破坏！庆幸的是，<code>class</code> 和 <code>style</code> attribute 会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：<code>form-control date-picker-theme-dark</code>。</p><h4 id="禁用-Attribute-继承"><a href="#禁用-Attribute-继承" class="headerlink" title="禁用 Attribute 继承"></a>禁用 Attribute 继承</h4><p>如果你<strong>不</strong>希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;my-component&#x27;, &#123;</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这尤其适合配合实例的 <code>$attrs</code> property 使用，该 property 包含了传递给一个组件的 attribute 名和 attribute 值，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  required: true,</span><br><span class="line">  placeholder: &#x27;Enter your username&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 <code>inheritAttrs: false</code> 和 <code>$attrs</code>，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写<a href="https://v2.cn.vuejs.org/v2/style-guide/#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E5%90%8D-%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90">基础组件</a>的时候是常会用到的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;base-input&#x27;, &#123;</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  props: [&#x27;label&#x27;, &#x27;value&#x27;],</span><br><span class="line">  template: `</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">      &#123;&#123; label &#125;&#125;</span><br><span class="line">      &lt;input</span><br><span class="line">        v-bind=&quot;$attrs&quot;</span><br><span class="line">        v-bind:value=&quot;value&quot;</span><br><span class="line">        v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="line">      &gt;</span><br><span class="line">    &lt;/label&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意 <code>inheritAttrs: false</code> 选项<strong>不会</strong>影响 <code>style</code> 和 <code>class</code> 的绑定。</p><p>这个模式允许你在使用基础组件的时候更像是使用原始的 HTML 元素，而不会担心哪个元素是真正的根元素：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;base-input</span><br><span class="line">  label=&quot;Username:&quot;</span><br><span class="line">  v-model=&quot;username&quot;</span><br><span class="line">  required</span><br><span class="line">  placeholder=&quot;Enter your username&quot;</span><br><span class="line">&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><h3 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h3><p>我们推荐你<strong>始终使用 kebab-case 的事件名</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$emit(&#x27;my-event&#x27;)</span><br><span class="line"></span><br><span class="line">&lt;my-component v-on:my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义组件的v-model"><a href="#自定义组件的v-model" class="headerlink" title="自定义组件的v-model"></a>自定义组件的v-model</h3><p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">不同的目的</a>。<code>model</code> 选项可以用来避免这样的冲突：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;base-checkbox&#x27;, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &#x27;checked&#x27;,</span><br><span class="line">    event: &#x27;change&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: Boolean</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:checked</span>=<span class="string">&quot;checked&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-on:change</span>=<span class="string">&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在在这个组件上使用 <code>v-model</code> 的时候：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;</span><br></pre></td></tr></table></figure><p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的 property 将会被更新。</p><p>注意你仍然需要在组件的 <code>props</code> 选项里声明 <code>checked</code> 这个 prop。</p><h3 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a><code>.sync</code> 修饰符</h3><p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件两侧都没有明显的变更来源。</p><p>这也是为什么我们推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。举个例子，在一个包含 <code>title</code> prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$emit(&#x27;update:title&#x27;, newTitle)</span><br></pre></td></tr></table></figure><p>然后父组件可以监听那个事件并根据需要更新一个本地的数据 property。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;text-document</span><br><span class="line">  v-bind:title=&quot;doc.title&quot;</span><br><span class="line">  v-on:update:title=&quot;doc.title = $event&quot;</span><br><span class="line">&gt;&lt;/text-document&gt;</span><br></pre></td></tr></table></figure><p>为了方便起见，我们为这种模式提供一个缩写，即 <code>.sync</code> 修饰符：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> <strong>不能</strong>和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 <code>v-model</code>。</p></blockquote><p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 <code>.sync</code> 修饰符和 <code>v-bind</code> 配合使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;text-document v-bind.sync=&quot;doc&quot;&gt;&lt;/text-document&gt;</span><br></pre></td></tr></table></figure><p>这样会把 <code>doc</code> 对象中的每一个 property (如 <code>title</code>) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 <code>v-on</code> 监听器。</p><blockquote><p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”&#123; title: doc.title &#125;”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p></blockquote><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>插槽内可以包含任何模板代码，包括 HTML，甚至其它的组件。</p><h3 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h3><p>有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。</p><p>可以直接将要默认显示的数据放在 <code>&lt;slot&gt;</code> 标签内，父级组件中使用 <code>&lt;submit-button&gt;</code> 并且不提供任何插槽内容时显示默认的，否则被覆盖。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;submit-button&gt;&lt;/submit-button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button type=&quot;submit&quot;&gt;</span><br><span class="line">  &lt;slot&gt;Submit&lt;/slot&gt;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：<code>name</code>。这个 attribute 可以用来定义额外的插槽：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>一个不带 name 的 <slot> 出口会带有隐含的名字“default”。</slot></strong></p><p>在向具名插槽提供内容的时候，我们可以<strong>在一个 <template> 元素上使用 v-slot 指令</template></strong>，并以 v-slot 的参数的形式提供其名称：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:footer&gt;</span><br><span class="line">    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意 <strong><code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code> 上</strong> (只有<a href="https://v2.cn.vuejs.org/v2/guide/components-slots.html#%E7%8B%AC%E5%8D%A0%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99%E8%AF%AD%E6%B3%95">一种例外情况</a>)，这一点和已经废弃的 <a href="https://v2.cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95"><code>slot</code> attribute</a> 不同。</p></blockquote><p><strong>具名插槽的缩写：</strong>跟 <code>v-on</code> 和 <code>v-bind</code> 一样，<code>v-slot</code> 也有缩写，即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template #header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;template #default&gt;</span><br><span class="line">    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;And another one.&lt;/p&gt;  </span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #footer&gt;</span><br><span class="line">    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br></pre></td></tr></table></figure><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>父组件可以访问子组件的数据。</p><p>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 子组件中</span><br><span class="line">&lt;span&gt;</span><br><span class="line">  &lt;slot v-bind:user=&quot;user&quot;&gt;</span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  &lt;/slot&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为<strong>插槽 prop</strong>。现在在父级作用域中，我们可以使用带值的 <code>v-slot</code> 来定义我们提供的插槽 prop 的名字：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 父组件中</span><br><span class="line">&lt;current-user&gt;</span><br><span class="line">  &lt;template v-slot:default=&quot;slotProps&quot;&gt;// #default=&quot;slatProps&quot;</span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure><p><strong>简写语法</strong>：在上述情况下，当被提供的内容<em>只有</em>默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 <code>v-slot</code> 直接用在组件上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;current-user v-slot:default=&quot;slotProps&quot;&gt;</span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure><blockquote><p>只要出现多个插槽，请始终为<em>所有的</em>插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法。</p></blockquote><p><strong>解构插槽prop</strong></p><p>作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function (slotProps) &#123;</span><br><span class="line">  // 插槽内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另一种简写语法：</strong>这意味着 <code>v-slot</code> 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。所以在支持的环境下 (<a href="https://v2.cn.vuejs.org/v2/guide/single-file-components.html">单文件组件</a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9">现代浏览器</a>)，你也可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E8%A7%A3%E6%9E%84%E5%AF%B9%E8%B1%A1">ES2015 解构</a>来传入具体的插槽 prop，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;current-user v-slot=&quot;&#123; user &#125;&quot;&gt;</span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure><p>这样可以使模板更简洁，尤其是在该插槽提供了多个 prop 的时候。它同样开启了 prop 重命名等其它可能，例如将 <code>user</code> 重命名为 <code>person</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;current-user v-slot=&quot;&#123; user: person &#125;&quot;&gt;</span><br><span class="line">  &#123;&#123; person.firstName &#125;&#125;</span><br><span class="line">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure><p>你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;current-user v-slot=&quot;&#123; user = &#123; firstName: &#x27;Guest&#x27; &#125; &#125;&quot;&gt; // #default=&quot;&#123; user = &#123; firstName: &#x27;Guest&#x27; &#125; &#125;&quot;</span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure><h3 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h3><p><a href="https://v2.cn.vuejs.org/v2/guide/syntax.html#%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0">动态指令参数</a>也可以用在 <code>v-slot</code> 上，来定义动态的插槽名：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:[dynamicSlotName]&gt; // #[dynamicSlotName]</span><br><span class="line">    ...</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br></pre></td></tr></table></figure><h2 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件&amp;异步组件"></a>动态组件&amp;异步组件</h2><h3 id="在动态组件上使用keep-alive"><a href="#在动态组件上使用keep-alive" class="headerlink" title="在动态组件上使用keep-alive"></a>在动态组件上使用keep-alive</h3><p>我们之前在一个多标签的界面中使用 <code>is</code> attribute 来切换不同的组件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure><p>当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重新渲染导致的性能问题。</p><p>我们更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来。为了解决这个问题，我们可以用一个 <code>&lt;keep-alive&gt;</code> 元素将其动态组件包裹起来。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 失活的组件将会被缓存！--&gt;</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>现在这个 <em>Posts</em> 标签保持了它的状态 (被选中的文章) 甚至当它未被渲染时也是如此。你可以在<a href="https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-keep-alive-with-dynamic-components">这个示例</a>查阅到完整的代码。</p><blockquote><p>注意这个 <code>&lt;keep-alive&gt;</code> 要求被切换到的组件都有自己的名字，不论是通过组件的 <code>name</code> 选项还是局部&#x2F;全局注册。</p></blockquote><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><h2 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h2><h3 id="访问元素-amp-组件"><a href="#访问元素-amp-组件" class="headerlink" title="访问元素&amp;组件"></a>访问元素&amp;组件</h3><h4 id="访问根实例"><a href="#访问根实例" class="headerlink" title="访问根实例"></a>访问根实例</h4><p>在每个 <code>new Vue</code> 实例的子组件中，其根实例可以通过 <code>$root</code> property 进行访问。例如，在这个根实例中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 根实例</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">bar</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">baz</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所有的子组件都可以将这个实例作为一个全局 store 来访问或使用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取根组件的数据</span><br><span class="line">this.$root.foo</span><br><span class="line"></span><br><span class="line">// 写入根组件的数据</span><br><span class="line">this.$root.foo = 2</span><br><span class="line"></span><br><span class="line">// 访问根组件的计算属性</span><br><span class="line">this.$root.bar</span><br><span class="line"></span><br><span class="line">// 调用根组件的方法</span><br><span class="line">this.$root.baz()</span><br></pre></td></tr></table></figure><h4 id="访问子组件实例或子元素"><a href="#访问子组件实例或子元素" class="headerlink" title="访问子组件实例或子元素"></a>访问子组件实例或子元素</h4><p>尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 <code>ref</code> 这个 attribute 为子组件赋予一个 ID 引用。例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">ref</span>=<span class="string">&quot;usernameInput&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在在你已经定义了这个 <code>ref</code> 的组件里，你可以使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">usernameInput</span></span><br></pre></td></tr></table></figure><p>来访问这个 <code>&lt;base-input&gt;</code> 实例，以便不时之需。比如程序化地从一个父级组件聚焦这个输入框。在刚才那个例子中，该 <code>&lt;base-input&gt;</code> 组件也可以使用一个类似的 <code>ref</code> 提供对内部这个指定元素的访问，例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>甚至可以通过其父级组件定义方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="comment">// 用来从父级组件聚焦输入框</span></span><br><span class="line">  <span class="attr">focus</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">input</span>.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就允许父级组件通过下面的代码聚焦 <code>&lt;base-input&gt;</code> 里的输入框：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">usernameInput</span>.<span class="title function_">focus</span>()</span><br></pre></td></tr></table></figure><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>在此之前，在我们描述<a href="https://v2.cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E7%88%B6%E7%BA%A7%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B">访问父级组件实例</a>的时候，展示过一个类似这样的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;google-map&gt;</span><br><span class="line">  &lt;google-map-region v-bind:shape=&quot;cityBoundaries&quot;&gt;</span><br><span class="line">    &lt;google-map-markers v-bind:places=&quot;iceCreamShops&quot;&gt;&lt;/google-map-markers&gt;</span><br><span class="line">  &lt;/google-map-region&gt;</span><br><span class="line">&lt;/google-map&gt;</span><br></pre></td></tr></table></figure><p>在这个组件里，所有 <code>&lt;google-map&gt;</code> 的后代都需要访问一个 <code>getMap</code> 方法，以便知道要跟哪个地图进行交互。不幸的是，使用 <code>$parent</code> property 无法很好的扩展到更深层级的嵌套组件上。这也是依赖注入的用武之地，它用到了两个新的实例选项：<code>provide</code> 和 <code>inject</code>。</p><p><code>provide</code> 选项允许我们指定我们想要<strong>提供</strong>给后代组件的数据&#x2F;方法。在这个例子中，就是 <code>&lt;google-map&gt;</code> 内部的 <code>getMap</code> 方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">provide</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">getMap</span>: <span class="variable language_">this</span>.<span class="property">getMap</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在任何后代组件里，我们都可以使用 <code>inject</code> 选项来接收指定的我们想要添加在这个实例上的 property：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject</span>: [<span class="string">&#x27;getMap&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="程序化的事件侦听器"><a href="#程序化的事件侦听器" class="headerlink" title="程序化的事件侦听器"></a>程序化的事件侦听器</h3><p>现在，你已经知道了 <code>$emit</code> 的用法，它可以被 <code>v-on</code> 侦听，但是 Vue 实例同时在其事件接口中提供了其它的方法。我们可以：</p><ul><li>通过 <code>$on(eventName, eventHandler)</code> 侦听一个事件</li><li>通过 <code>$once(eventName, eventHandler)</code> 一次性侦听一个事件</li><li>通过 <code>$off(eventName, eventHandler)</code> 停止侦听一个事件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性将这个日期选择器附加到一个输入框上</span></span><br><span class="line"><span class="comment">// 它会被挂载到 DOM 上。</span></span><br><span class="line"><span class="attr">mounted</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Pikaday 是一个第三方日期选择器的库</span></span><br><span class="line">  <span class="keyword">var</span> picker = <span class="keyword">new</span> <span class="title class_">Pikaday</span>(&#123;</span><br><span class="line">    <span class="attr">field</span>: <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">input</span>,</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 在组件被销毁之前，</span></span><br><span class="line">  <span class="comment">// 也销毁这个日期选择器。</span></span><br><span class="line">  <span class="variable language_">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    picker.<span class="title function_">destroy</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><h4 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h4><h4 id="组件之间的循环引用"><a href="#组件之间的循环引用" class="headerlink" title="组件之间的循环引用"></a>组件之间的循环引用</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>how2j</title>
      <link href="/2021/10/06/how2j/"/>
      <url>/2021/10/06/how2j/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><h3 id="Java结束外部循环"><a href="#Java结束外部循环" class="headerlink" title="Java结束外部循环"></a>Java结束外部循环</h3><ol><li>结束当前循环</li></ol><p>break; 只能结束当前循环</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">`<span class="keyword">public</span>` `class` `HelloWorld &#123;``    ``<span class="keyword">public</span>` `<span class="keyword">static</span>` `<span class="keyword">void</span>` `main(String[] args) &#123;``         ` `        ``<span class="comment">//打印单数    ``        ``for` `(``int` `i = ``0``; i &lt; ``10``; i++) &#123;``            ` `            ``for` `(``int` `j = ``0``; j &lt; ``10``; j++) &#123;``                ``System.out.println(i+``&quot;:&quot;``+j);``                ``if``(``0``==j%``2``) ``                    ``break``; ``//如果是双数，结束当前循环``            ``&#125;``            ` `        ``&#125;``        ` `    ``&#125;``&#125;`</span></span><br></pre></td></tr></table></figure><ol><li>使用boolean变量结束外部循环</li></ol><p>借助boolean变量结束外部循环<br>需要在内部循环中修改这个变量值<br>每次内部循环结束后，都要在外部循环中判断，这个变量的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">breakout</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//是否终止外部循环的标记</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">System.out.println(i + <span class="string">&quot;:&quot;</span> + j);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == j % <span class="number">2</span>) &#123;</span><br><span class="line">breakout = <span class="literal">true</span>; <span class="comment">//终止外部循环的标记设置为true</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (breakout) <span class="comment">//判断是否终止外部循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用标签结束外部循环</li></ol><p>在外部循环的前一行，加上标签<br>在break的时候使用该标签<br>即能达到结束外部循环的效果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//打印单数     </span></span><br><span class="line">    outloop: <span class="comment">//outloop这个标示是可以自定义的比如outloop1,ol2,out5</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            System.out.println(i+<span class="string">&quot;:&quot;</span>+j);</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span>==j%<span class="number">2</span>)  </span><br><span class="line">            <span class="keyword">break</span> outloop; <span class="comment">//如果是双数，结束外部循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="理解随机数-Math-floor-Math-random-max-min-1-min"><a href="#理解随机数-Math-floor-Math-random-max-min-1-min" class="headerlink" title="理解随机数 Math.floor(Math.random() * (max - min + 1) + min)"></a>理解随机数 Math.floor(Math.random() * (max - min + 1) + min)</h3><p>众所周知 Math.floor(Math.random() * (max - min + 1) + min) ，会得到 [min,max]之间的随机整数</p><ol><li><p>使用Math.round()四舍五入小数</p><p>Math.round(Math.random() * (max - min)+min)</p><p>失败：<br><strong>实际上获得的数并不随机，由于Math.round()四舍五入 ，(2<del>2.5) 才是2,而 [2.5</del>3.5) 是3，很明显这对2和99都不公平 ，它两的随机概率只有其他人的一半</strong></p></li><li><p>使用Math.floor</p><p>floor是向下取整！</p><p>使用floor 上面的随机小数<strong>是取不到 最大值的</strong>，<br>那么 (min,max+1) ， 扩大区间 +1就好了</p></li></ol><h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><p>把一个数组的值，复制到另一个数组中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.arraycopy(src, srcPos, dest, destPos, length)</span><br></pre></td></tr></table></figure><p>src: 源数组<br>srcPos: 从源数组复制数据的起始位置<br>dest: 目标数组<br>destPos: 复制到目标数组的起始位置<br>length: 复制的长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a [] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">18</span>,<span class="number">62</span>,<span class="number">68</span>,<span class="number">82</span>,<span class="number">65</span>,<span class="number">9</span>&#125;;</span><br><span class="line">         </span><br><span class="line">        <span class="type">int</span> b[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">//分配了长度是3的空间，但是没有赋值</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//通过数组赋值把，a数组的前3位赋值到b数组</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//方法一： for循环</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//方法二: System.arraycopy(src, srcPos, dest, destPos, length)</span></span><br><span class="line">        <span class="comment">//src: 源数组</span></span><br><span class="line">        <span class="comment">//srcPos: 从源数组复制数据的起始位置</span></span><br><span class="line">        <span class="comment">//dest: 目标数组</span></span><br><span class="line">        <span class="comment">//destPos: 复制到目标数组的启始位置</span></span><br><span class="line">        <span class="comment">//length: 复制的长度       </span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, b, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//把内容打印出来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            System.out.print(b[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//初始化二维数组，</span></span><br><span class="line">       <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">//有两个一维数组，每个一维数组的长度是3</span></span><br><span class="line">       a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">5</span>;  <span class="comment">//可以直接访问一维数组，因为已经分配了空间</span></span><br><span class="line">          </span><br><span class="line">       <span class="comment">//只分配了二维数组</span></span><br><span class="line">       <span class="type">int</span>[][] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][]; <span class="comment">//有两个一维数组，每个一维数组的长度暂未分配</span></span><br><span class="line">       b[<span class="number">0</span>]  =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">//必须事先分配长度，才可以访问</span></span><br><span class="line">       b[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//指定内容的同时，分配空间</span></span><br><span class="line">       <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">               &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,</span><br><span class="line">               &#123;<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">               &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">       &#125;;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><ol><li>Arrays.fill(Object[ ] array, Object obj)——用指定元素填充整个数组(替换数组原元素)</li><li>Arrays.sort(Object [ ]arr)——对传入数组进行递增排序，字符则按照ASCII进行排序(不区分大小写)</li><li>Arrays.sort(Object [ ]arr,int start,int end)——对区间内的元素进行递增排序</li><li>Arrays.equal(Object []arr,Object [] nums)——判断两个数组是否相等，实际上比较的是两个数组的哈希值</li><li>Array.hashCode(Object []arr)——返回数组的哈希值</li><li>Arrays.copyOf(Object [])——拷贝数组，其内部调用了 System.arraycopy() 方法，从下标0开始，如果超过原数组长度，会用null进行填充。</li><li>Arrays.copyOfRange(T[] original, int from, int to)——拷贝数组，指定起始位置和结束位置，如果超过原数组长度，会用null进行填充</li><li>Arrays.toString(Object []arr)——将数组中的内容全部打印出来</li><li>Arrays.binarySearch(Object []arr,T ans)——二分查找法找指定元素的索引值(数组一定是排好序的，否则会出错。找到元素，只会返回最后一个位置)</li></ol><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>成员变量有四种修饰符：<strong>private</strong> 私有的，<strong>package</strong>&#x2F;friendly&#x2F;default 不写，<strong>protected</strong> 受保护的，<strong>public</strong> 公共的</p><ol><li>private 私有的</li></ol><p><strong>注： 红色字体，表示不可访问</strong></p><img src="/2021/10/06/how2j/10/06/how2j/604.png" class title="private 私有的"><ol><li>没有修饰符即代表package&#x2F;friendly&#x2F;default</li></ol><img src="/2021/10/06/how2j/10/06/how2j/609.png" class title="package&#x2F;friendly&#x2F;default 不写"><ol><li>protected 受保护的</li></ol><img src="/2021/10/06/how2j/10/06/how2j/610.png" class title="protected 受保护的"><ol><li>public 公共的</li></ol><img src="/2021/10/06/how2j/10/06/how2j/611.png" class title="public 公共的"><ol><li><p>那么什么情况该用什么修饰符呢？<br>从作用域来看，public能够使用所有的情况。 但是大家在工作的时候，又不会真正全部都使用public,那么到底什么情况该用什么修饰符呢？</p><ol><li>属性通常使用private封装起来</li><li>方法一般使用public用于被调用</li><li>会被子类继承的方法，通常使用protected</li><li>package用的不多，一般新手会用package,因为还不知道有修饰符这个东西</li></ol><p>再就是<strong>作用范围最小原则</strong><br>简单说，能用private就用private，不行就放大一级，用package,再不行就用protected，最后用public。 这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了</p></li></ol><h3 id="属性初始化"><a href="#属性初始化" class="headerlink" title="属性初始化"></a>属性初始化</h3><p>对象属性初始化有3种</p><ol><li><p>声明该属性的时候初始化</p></li><li><p>构造方法中初始化</p></li><li><p>初始化块</p><p>对象属性的初始化有三种方式<br>故意把初始化块，放在构造方法下面，问题：</p></li></ol><p>这三种方式，谁先执行？谁后执行？  属性声明——》构造方法——》初始化块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;some hero&quot;</span>; </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span>&#123;</span><br><span class="line">        name = <span class="string">&quot;one hero&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;the hero&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类属性初始化有2种</p><ol><li>声明该属性的时候初始化</li><li>静态初始化块</li></ol><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ol><li><p><strong>饿汉式</strong>是立即加载的方式，无论是否会用到这个对象，都会加载。<br>如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GiantDragon</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//私有化构造方法使得该类无法在外部通过new 进行实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GiantDragon</span><span class="params">()</span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GiantDragon</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GiantDragon</span>();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//public static 方法，提供给调用者获取12行定义的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>懒汉式</strong>，是延迟加载的方式，只有使用的时候才会加载。 并且有<a href="https://how2j.cn/k/thread/thread-synchronized/355.html#step793">线程安全</a>的考量 ，使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="literal">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;&#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance=<span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ol><li><p>介绍</p><ul><li><p>枚举对应英文(enumeration,简写 enum)</p></li><li><p>枚举是一组常量的集合</p></li><li><p>枚举属于一种特殊的类，里面只包含一组有限的特定的对象</p></li><li><p>不需要提供 setXxxx() 方法，因为枚举对象值通常为只读</p></li><li><p>对枚举对象&#x2F;属性使用 static+final 共同修饰</p><blockquote><p><strong>static+final</strong> 只有修饰基本数据类型和String类型才不会加载类，修饰对象或者方法还是会加载类</p><p>final 修饰对象(引用)只是保证引用的指向不变，但不能保证对象本身不变</p></blockquote></li><li><p>枚举对象名通常使用全部大写，与常量的命名规范一样</p></li><li><p>枚举对象根据需要，也可以有多个属性</p></li></ul></li><li><p>自定义类实现枚举</p><ul><li>将构造器私有化，目的是防止被new出对象</li><li>去掉 setXxxx() 方法，防止属性被修改</li><li>在Season内部，直接创建固定对象</li><li>对外暴露对象(通过为对象添加 <strong>public static final</strong> 修饰符)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.AUTUMN);</span><br><span class="line">        System.out.println(Season.SUMMER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="comment">//定义了四个对象</span></span><br><span class="line">    <span class="comment">//加final是为了使引用不能被修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用enum关键字实现枚举</p><ul><li>使用 enum 关键字代替 class</li><li>常量对象名(实参列表)</li><li>public static final Season2 SPRING &#x3D; new Season2(“春天”, “温暖”); 等价于 SPRING(“春天”, “温暖”);</li><li>如果有多个对象，需要使用 ，间隔</li><li>如果使用 enum 关键字来实现枚举，要求将定义的常量对象写在最前面</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season2.SPRING);</span><br><span class="line">        System.out.println(Season2.SUMMER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span>  <span class="title class_">Season2</span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>),WINTER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>),AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season2</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>enum的常用方法</p><blockquote><p>使用关键字enum时，会隐式继承Enum类，这样就可以使用Enum类的相关方法</p></blockquote><ul><li>toString()：Enum类已经重写过了，返回的是当前对象名；子类可以重写该方法，用于返回对象的属性信息</li><li>name()：返回当前对象名(常量名)，子类中不能重写</li><li>ordinal()：返回当前对象的位置号，默认从0开始</li><li>values()：返回当前枚举类中所有的常量对象</li><li>valueOf()：将字符串转换成已有的枚举对象，要求字符串必须为已有的常量名，否则报异常！</li><li>compareTo()：比较两个枚举常量的大小(编号),返回的结果是两个枚举常量的编号相减得到的数</li></ul></li><li><p>enum的使用细节</p><ul><li><strong>使用enum关键字创建的枚举类，就不能再继承其它类了</strong>，因为使用enum创建的枚举类会隐式的继<strong>承Enum类</strong>，而Java是单继承机制</li><li>枚举类和普通类一样，可以实现接口</li></ul></li></ol><h2 id="接口与继承"><a href="#接口与继承" class="headerlink" title="接口与继承"></a>接口与继承</h2><h3 id="编译类型和运行类型"><a href="#编译类型和运行类型" class="headerlink" title="编译类型和运行类型"></a>编译类型和运行类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.testpoly_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPoly_</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、编译类型和运行类型：</span></span><br><span class="line"><span class="comment">     * 例如：Animal dog = new Dog(&quot;小白&quot;);</span></span><br><span class="line"><span class="comment">     * Animal是编译类型（=的左边），Dog是运行类型（=的右边）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 2、编译类型确定即不能再改变，运行类型可以修改</span></span><br><span class="line"><span class="comment">     * 例如：Animal white = new Dog(&quot;小白狗&quot;);</span></span><br><span class="line"><span class="comment">     * white = new Cat(&quot;小白猫&quot;);</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 3、程序的执行结果是根据运行类型决定的，但是编译类型决定可以调用的方法有哪些</span></span><br><span class="line"><span class="comment">     * 例如：Animal white = new Dog(&quot;小白狗&quot;);</span></span><br><span class="line"><span class="comment">     * white对象可以调用的方法有：eat方法（Animal类里的所有方法），不能调用Dog类里的run方法</span></span><br><span class="line"><span class="comment">     * white对象调用的eat方法的执行结果，是Dog类的eat方法执行结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1、多态是两个类存在继承关系；</span></span><br><span class="line"><span class="comment"> * 2、多态向上转型：父类的引用指向子类的对象；语法：父类 xxx = new 子类();</span></span><br><span class="line"><span class="comment"> * 3、可以调用父类中的所有方法，前提是有访问权限，不能调用子类的独有方法；</span></span><br><span class="line"><span class="comment">　　  * 程序在编译阶段，已经决定这个对象可以调用的属性、方法</span></span><br><span class="line"><span class="comment"> * 4、程序运行结果是根据运行类型决定。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPolymorphism</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">white</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小白狗&quot;</span>);</span><br><span class="line">        white.eat();</span><br><span class="line"><span class="comment">//        white.run();  // 错误：没有run方法</span></span><br><span class="line"></span><br><span class="line">        white = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小白猫&quot;</span>);</span><br><span class="line">        white.eat();</span><br><span class="line"><span class="comment">//        cat.jump();   // 错误：没有jump方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;觅食...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;在啃骨头..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;在吃鱼..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat jump...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JAVA中的方法隐藏"><a href="#JAVA中的方法隐藏" class="headerlink" title="JAVA中的方法隐藏"></a>JAVA中的方法隐藏</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//类方法，静态方法</span></span><br><span class="line">    <span class="comment">//通过类就可以直接调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">battleWin</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hero battle win&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">######################################################</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADHero</span> <span class="keyword">extends</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">AD</span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">physicAttack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//隐藏父类的battleWin方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">battleWin</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ad hero battle win&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Hero.battleWin();</span><br><span class="line">        ADHero.battleWin();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">#######################################################</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="comment">// h.battleWin(); //battleWin是一个类方法</span></span><br><span class="line">  <span class="comment">// h是父类类型的引用</span></span><br><span class="line">  <span class="comment">// 但是指向一个子类对象</span></span><br><span class="line">  <span class="comment">// h.battleWin(); 会调用父类的方法？还是子类的方法？</span></span><br><span class="line">      <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ADHero</span>();</span><br><span class="line">          h.battleWin();</span><br><span class="line">          ADHero.battleWin();</span><br><span class="line">         </span><br><span class="line">          <span class="comment">//当继承的方法为静态方法时，父类指向子类，JVM使用的是静态绑定</span></span><br><span class="line">          <span class="comment">//当继承的方法不是静态方法时，父类指向子类，JVM使用的是动态绑定</span></span><br><span class="line">          <span class="comment">//想要继承的方法为静态的方法时，想要调用子类的重写方法，直接子类名称.静态方法</span></span><br><span class="line">          <span class="comment">//*当出现private,final,static,以及构造器的时候，JVM会调用静态绑定</span></span><br><span class="line">       </span><br><span class="line">          <span class="comment">//总结</span></span><br><span class="line">          <span class="comment">/*if(父类指向子类，调用的方法为静态方法)&#123;</span></span><br><span class="line"><span class="comment">              打印父类方法</span></span><br><span class="line"><span class="comment">          &#125;else(父类指向子类，调用的方法不是静态方法)&#123;</span></span><br><span class="line"><span class="comment">              打印子类方法</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="JAVA中的super关键字"><a href="#JAVA中的super关键字" class="headerlink" title="JAVA中的super关键字"></a>JAVA中的super关键字</h3><p>其<strong>父类的构造方法也会被调用</strong><br>并且是父类构造方法<strong>先调用</strong><br>子类构造方法会默认调用父类的 无参的构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> property.Item;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hero的构造方法 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">####################################################</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADHero</span> <span class="keyword">extends</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">AD</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ADHero</span><span class="params">()</span>&#123;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">&quot;AD Hero的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ADHero</span>();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">########输出#########</span><br><span class="line">Hero的构造方法</span><br><span class="line">AD Hero的构造方法</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//    故意不提供无参的构造方法</span></span><br><span class="line"><span class="comment">//    public Hero()&#123;</span></span><br><span class="line"><span class="comment">//     </span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#################################################</span><br><span class="line"> <span class="number">2</span>   </span><br><span class="line"> <span class="number">3</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADHero</span> <span class="keyword">extends</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">AD</span>&#123;</span><br><span class="line">       <span class="comment">// 创建子类对象时，会先调用其父类的构造方法，而此时父类没有无参构造，所以需要用super关键字去调用父类的有参构造方法</span></span><br><span class="line"> <span class="number">4</span>     <span class="keyword">public</span> <span class="title function_">ADHero</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="number">5</span>         <span class="built_in">super</span>(<span class="string">&quot;&quot;</span>);<span class="comment">//super(&quot;&quot;)调用的是父类的有参构造方法Hero(String name);</span></span><br><span class="line"> <span class="number">6</span>     &#125;</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="meta">@Override</span></span><br><span class="line"> <span class="number">9</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">physicAttack</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">10</span>         System.out.println(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line"><span class="number">11</span>     &#125;</span><br><span class="line"><span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="JAVA中的超类Object"><a href="#JAVA中的超类Object" class="headerlink" title="JAVA中的超类Object"></a>JAVA中的超类Object</h3><p>Object类是所有类的父类（toString()，finalize()，equals()，hashCode()，getClass()）</p><p>例：  当<strong>一个对象没有任何引用指向的</strong>时候，它就满足垃圾回收的条件</p><p>当它被垃圾回收的时候，它的finalize() 方法就会被调用。</p><p>finalize() 不是开发人员主动调用的方法，而是由虚拟机JVM调用的。  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这个英雄正在被回收&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//只有一引用</span></span><br><span class="line">        Hero h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//不断生成新的对象</span></span><br><span class="line">            <span class="comment">//每创建一个对象，前一个对象，就没有引用指向了</span></span><br><span class="line">            <span class="comment">//那些对象，就满足垃圾回收的条件</span></span><br><span class="line">            <span class="comment">//当，垃圾堆积的比较多的时候，就会触发垃圾回收</span></span><br><span class="line">            <span class="comment">//一旦这个对象被回收，它的finalize()方法就会被调用</span></span><br><span class="line">            h = <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JAVA抽象类"><a href="#JAVA抽象类" class="headerlink" title="JAVA抽象类"></a>JAVA抽象类</h3><ul><li>在类中声明一个方法，这个方法没有实现体，是一个“空”方法</li><li>这样的方法就叫抽象方法，使用修饰符“abstract”</li><li>当一个类有抽象方法的时候，该类必须被声明为抽象类  </li><li>抽象类可以没有抽象方法<ul><li>Hero类可以在不提供抽象方法的前提下，声明为抽象类</li><li><strong>一旦一个类被声明为抽象类，就不能够被直接实例化</strong></li></ul></li><li>抽象类和接口的区别<ul><li>区别1：<br>子类只能继承一个抽象类，不能继承多个<br>子类可以实现<strong>多个</strong>接口</li><li>区别2：<br>抽象类可以定义：public,protected,package,private；静态和非静态属性；final和非final属性<br>但是接口中声明的属性，只能是public；静态；final的</li></ul></li></ul><h3 id="JAVA内部类"><a href="#JAVA内部类" class="headerlink" title="JAVA内部类"></a>JAVA内部类</h3><ol><li><p>非静态内部类</p><p>语法: <strong>new 外部类().new 内部类()</strong><br>作为Hero的非静态内部类，是可以直接访问外部类的<strong>private</strong>实例属性name的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">float</span> hp; <span class="comment">// 血量</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">float</span> armor; <span class="comment">// 护甲</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> moveSpeed; <span class="comment">// 移动速度</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 非静态内部类，只有一个外部类对象存在的时候，才有意义</span></span><br><span class="line">    <span class="comment">// 战斗成绩只有在一个英雄对象存在的时候才有意义</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BattleScore</span> &#123;</span><br><span class="line">        <span class="type">int</span> kill;</span><br><span class="line">        <span class="type">int</span> die;</span><br><span class="line">        <span class="type">int</span> assit;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">legendary</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (kill &gt;= <span class="number">8</span>)</span><br><span class="line">                System.out.println(name + <span class="string">&quot;超神！&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(name + <span class="string">&quot;尚未超神！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">garen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        garen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        <span class="comment">// 实例化内部类</span></span><br><span class="line">        <span class="comment">// BattleScore对象只有在一个英雄对象存在的时候才有意义</span></span><br><span class="line">        <span class="comment">// 所以其实例化必须建立在一个外部类对象的基础之上</span></span><br><span class="line">        <span class="type">BattleScore</span> <span class="variable">score</span> <span class="operator">=</span> garen.<span class="keyword">new</span> <span class="title class_">BattleScore</span>();</span><br><span class="line">        score.kill = <span class="number">9</span>;</span><br><span class="line">        score.legendary();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态内部类</p><p>语法：<strong>new 外部类.静态内部类();</strong><br>因为没有一个外部类的实例，所以在静态内部类里面<strong>不可以访问外部类的实例属性和方法</strong><br>除了可以访问外部类的<strong>私有静态成员外</strong>，静态内部类和普通类没什么大的区别</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">float</span> hp;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">battleWin</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;battle win&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//敌方的水晶</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnemyCrystal</span>&#123;</span><br><span class="line">        <span class="type">int</span> hp=<span class="number">5000</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//如果水晶的血量为0，则宣布胜利</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkIfVictory</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hp==<span class="number">0</span>)&#123;</span><br><span class="line">                Hero.battleWin();</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">//静态内部类不能直接访问外部类的对象属性</span></span><br><span class="line">                System.out.println(name + <span class="string">&quot; win this game&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//实例化静态内部类</span></span><br><span class="line">        Hero.<span class="type">EnemyCrystal</span> <span class="variable">crystal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>.EnemyCrystal();</span><br><span class="line">        crystal.checkIfVictory();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匿名类</p><p>匿名类指的是在<strong>声明一个类的同时实例化它</strong>，使代码更加简洁精练<br>通常情况下，要使用一个接口或者抽象类，都必须创建一个子类</p><p>有的时候，为了快速使用，直接实例化一个抽象类，并“<strong>当场</strong>”实现其抽象方法。<br>既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。<br>这样的类，叫做匿名类  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    String name; <span class="comment">//姓名</span></span><br><span class="line">          </span><br><span class="line">    <span class="type">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">          </span><br><span class="line">    <span class="type">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">          </span><br><span class="line">    <span class="type">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        ADHero adh=<span class="keyword">new</span> <span class="title class_">ADHero</span>();</span><br><span class="line">        <span class="comment">//通过打印adh，可以看到adh这个对象属于ADHero类</span></span><br><span class="line">        adh.attack();</span><br><span class="line">        System.out.println(adh);</span><br><span class="line">          </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>()&#123;</span><br><span class="line">            <span class="comment">//当场实现attack方法</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;新的进攻手段&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.attack();</span><br><span class="line">        <span class="comment">//通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名</span></span><br><span class="line">          </span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>本地类</p><p>本地类可以理解为有名字的匿名类<br>内部类与匿名类不一样的是，内部类必须声明在成员的位置，即与属性和方法平等的位置。<br>本地类和匿名类一样，直接声明在代码块里面，可以是主方法，for循环里等等地方</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    String name; <span class="comment">//姓名</span></span><br><span class="line">          </span><br><span class="line">    <span class="type">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">          </span><br><span class="line">    <span class="type">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">          </span><br><span class="line">    <span class="type">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//与匿名类的区别在于，本地类有了自定义的类名</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">SomeHero</span> <span class="keyword">extends</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println( name+ <span class="string">&quot; 新的进攻手段&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="type">SomeHero</span> <span class="variable">h</span>  <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">SomeHero</span>();</span><br><span class="line">        h.name =<span class="string">&quot;地卜师&quot;</span>;</span><br><span class="line">        h.attack();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在匿名类中使用外部的局部变量</p><p>在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final</p><p>为什么要声明为final，其机制比较复杂，请参考第二个Hero代码中的解释</p><p><strong>注：</strong>在jdk8中，已经不需要强制修饰成final了，如果没有写final，不会报错，因为编译器<strong>偷偷的</strong>帮你加上了看不见的final  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//在匿名类中使用外部的局部变量damage 必须修饰为final</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">damage</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//这里使用本地类AnonymousHero来模拟匿名类的隐藏属性机制</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//事实上的匿名类，会在匿名类里声明一个damage属性，并且使用构造方法初始化该属性的值</span></span><br><span class="line">        <span class="comment">//在attack中使用的damage，真正使用的是这个内部damage，而非外部damage</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//假设外部属性不需要声明为final</span></span><br><span class="line">        <span class="comment">//那么在attack中修改damage的值，就会被暗示为修改了外部变量damage的值</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//但是他们俩是不同的变量，是不可能修改外部变量damage的</span></span><br><span class="line">        <span class="comment">//所以为了避免产生误导，外部的damage必须声明为final,&quot;看上去&quot;就不能修改了</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">AnonymousHero</span> <span class="keyword">extends</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">            <span class="type">int</span> damage;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">AnonymousHero</span><span class="params">(<span class="type">int</span> damage)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.damage = damage;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">                damage = <span class="number">10</span>;</span><br><span class="line">                System.out.printf(<span class="string">&quot;新的进攻手段，造成%d点伤害&quot;</span>,<span class="built_in">this</span>.damage );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonymousHero</span>(damage);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>  默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法</p><p>Mortal 这个接口，增加了一个<strong>默认方法</strong> revive，这个方法有实现体，并且被声明为了<strong>default</strong>  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mortal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">die</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">revive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本英雄复活了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><img src="/2021/10/06/how2j/10/06/how2j/2318.png" class title="解释UML-类图"><p>带箭头的实线，表示 Spider，Cat, Fish都继承于Animal这个父类.</p><img src="/2021/10/06/how2j/10/06/how2j/2320.png" class title="解释UML-继承关系"><p>表示 Fish实现了 Pet这个接口</p><img src="/2021/10/06/how2j/10/06/how2j/2321.png" class title="解释UML-实现关系"><h2 id="数字与字符串"><a href="#数字与字符串" class="headerlink" title="数字与字符串"></a>数字与字符串</h2><h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h3><ol><li><p>数字转字符串</p><p>方法1： 使用String类的静态方法valueOf<br>方法2： 先把基本类型装箱为对象，然后调用对象的toString</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//方法1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//方法2</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> it.toString();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符串转数字</p><p>调用Integer的静态方法parseInt</p></li></ol><h3 id="Math类常用方法"><a href="#Math类常用方法" class="headerlink" title="Math类常用方法"></a>Math类常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">5.4f</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">5.5f</span>;</span><br><span class="line">        <span class="comment">//5.4四舍五入即5</span></span><br><span class="line">        System.out.println(Math.round(f1));</span><br><span class="line">        <span class="comment">//5.5四舍五入即6</span></span><br><span class="line">        System.out.println(Math.round(f2));</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//得到一个0-1之间的随机浮点数（取不到1）</span></span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//得到一个0-10之间的随机整数 （取不到10）</span></span><br><span class="line">        System.out.println((<span class="type">int</span>)( Math.random()*<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//开方</span></span><br><span class="line">        System.out.println(Math.sqrt(<span class="number">9</span>));</span><br><span class="line">        <span class="comment">//次方（2的4次方）</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//π</span></span><br><span class="line">        System.out.println(Math.PI);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//自然常数</span></span><br><span class="line">        System.out.println(Math.E);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><ol><li><p>如果不使用格式化输出，就需要进行字符串连接，如果变量比较多，拼接就会显得繁琐<br>使用格式化输出，就可以简洁明了</p><p>%s 表示字符串<br>%d 表示数字<br>%n 表示换行</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">kill</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        String title=<span class="string">&quot;超神&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//直接使用+进行字符串连接，编码感觉会比较繁琐，并且维护性差,易读性差</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sentence</span> <span class="operator">=</span> name+ <span class="string">&quot; 在进行了连续 &quot;</span> + kill + <span class="string">&quot; 次击杀后，获得了 &quot;</span> + title +<span class="string">&quot; 的称号&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(sentence);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//使用格式化输出</span></span><br><span class="line">        <span class="comment">//%s表示字符串，%d表示数字,%n表示换行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sentenceFormat</span> <span class="operator">=</span><span class="string">&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;</span>;</span><br><span class="line">        System.out.printf(sentenceFormat,name,kill,title);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>printf和format能够达到一模一样的效果，<a href="https://how2j.cn/k/helloworld/helloworld-eclipse-tips/300.html#step706">如何通过eclipse查看java源代码</a> 可以看到，在printf中直接调用了format</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">kill</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        String title=<span class="string">&quot;超神&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">String</span> <span class="variable">sentenceFormat</span> <span class="operator">=</span><span class="string">&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;</span>;</span><br><span class="line">        <span class="comment">//使用printf格式化输出</span></span><br><span class="line">        System.out.printf(sentenceFormat,name,kill,title);</span><br><span class="line">        <span class="comment">//使用format格式化输出</span></span><br><span class="line">        System.out.format(sentenceFormat,name,kill,title);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> <span class="number">2020</span>;</span><br><span class="line">        <span class="comment">//总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//直接打印数字</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,默认右对齐</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%8d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,左对齐</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%-8d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,不够补0</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%08d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//千位分隔符</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%,8d%n&quot;</span>,year*<span class="number">10000</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//小数点位数</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%.2f%n&quot;</span>,Math.PI);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//不同国家的千位分隔符</span></span><br><span class="line">        System.out.format(Locale.FRANCE,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">        System.out.format(Locale.US,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">        System.out.format(Locale.UK,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><ol><li><p>Character常见方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> character;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChar</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         </span><br><span class="line">        System.out.println(Character.isLetter(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是否为字母</span></span><br><span class="line">        System.out.println(Character.isDigit(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//判断是否为数字</span></span><br><span class="line">        System.out.println(Character.isWhitespace(<span class="string">&#x27; &#x27;</span>)); <span class="comment">//是否是空白</span></span><br><span class="line">        System.out.println(Character.isUpperCase(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//是否是大写</span></span><br><span class="line">        System.out.println(Character.isLowerCase(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//是否是小写</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//转换为大写</span></span><br><span class="line">        System.out.println(Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>)); <span class="comment">//转换为小写</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; <span class="comment">//不能够直接把一个字符转换成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> Character.toString(<span class="string">&#x27;a&#x27;</span>); <span class="comment">//转换为字符串</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>常见转义</p><img src="/2021/10/06/how2j/10/06/how2j/696.png" class title="常见转义"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> character;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChar</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用空格无法达到对齐的效果&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;abc def&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ab def&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a def&quot;</span>);</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;使用\\t制表符可以达到对齐的效果&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;abc\tdef&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ab\tdef&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a\tdef&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">&quot;一个\\t制表符长度是8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;12345678def&quot;</span>);</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;换行符 \\n&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;abc\ndef&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;单引号 \\&#x27;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;abc\&#x27;def&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;双引号 \\\&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;abc\&quot;def&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;反斜杠本身 \\&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;abc\\def&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>使用equals进行字符串内容的比较，必须大小写一致<br>equalsIgnoreCase，忽略大小写判断内容是否一致</p><table><thead><tr><th>charAt</th><th>获取字符</th><th><a href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step712">示例代码</a></th></tr></thead><tbody><tr><td>toCharArray</td><td>获取对应的字符数组</td><td><a href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step719">示例代码</a></td></tr><tr><td>subString</td><td>截取子字符串</td><td><a href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step713">示例代码</a></td></tr><tr><td>split</td><td>分隔</td><td><a href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step714">示例代码</a></td></tr><tr><td>trim</td><td>去掉首尾空格</td><td><a href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step715">示例代码</a></td></tr><tr><td>toLowerCase toUpperCase</td><td>大小写</td><td><a href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step716">示例代码</a></td></tr><tr><td>indexOf lastIndexOf contains</td><td>定位</td><td><a href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step717">示例代码</a></td></tr><tr><td>replaceAll replaceFirst</td><td>替换</td><td><a href="https://how2j.cn/k/number-string/number-string-manipulate/325.html#step718">示例代码</a></td></tr></tbody></table><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><table><thead><tr><th>append delete insert reverse</th><th>追加 删除 插入 反转</th><th><a href="https://how2j.cn/k/number-string/number-string-stringbuilder/328.html#step723">示例代码</a></th></tr></thead><tbody><tr><td>length capacity</td><td>长度 容量</td><td><a href="https://how2j.cn/k/number-string/number-string-stringbuilder/328.html#step724">示例代码</a></td></tr></tbody></table><p>为什么StringBuffer可以变长？<br>和String<strong>内部是一个字符数组</strong>一样，StringBuffer也维护了一个字符数组。 但是，这个字符数组，<strong>留有冗余长度</strong><br>比如说new StringBuffer(“the”)，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。<br>如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，<strong>看上去</strong> 数组长度就变长了 参考<a href="https://how2j.cn/k/number-string/number-string-mystringbuilder/331.html">MyStringBuffer</a><br>length: “the”的长度 3<br>capacity: 分配的总空间 19</p><h1 id="JAVA中级"><a href="#JAVA中级" class="headerlink" title="JAVA中级"></a>JAVA中级</h1><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h3><ol><li><p>使用绝对路径或者相对路径创建File对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFile</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 绝对路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOLFolder&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;f1的绝对路径：&quot;</span> + f1.getAbsolutePath());</span><br><span class="line">        <span class="comment">// 相对路径,相对于工作目录，如果在eclipse中，就是项目目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;LOL.exe&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;f2的绝对路径：&quot;</span> + f2.getAbsolutePath());</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 把f1作为父目录创建文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(f1, <span class="string">&quot;LOL.exe&quot;</span>);</span><br><span class="line">  </span><br><span class="line">        System.out.println(<span class="string">&quot;f3的绝对路径：&quot;</span> + f3.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文件常用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFile</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOLFolder/LOL.exe&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前文件是：&quot;</span> +f);</span><br><span class="line">        <span class="comment">//文件是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断是否存在：&quot;</span>+f.exists());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//是否是文件夹</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断是否是文件夹：&quot;</span>+f.isDirectory());</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//是否是文件（非文件夹）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断是否是文件：&quot;</span>+f.isFile());</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//文件长度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取文件的长度：&quot;</span>+f.length());</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//文件最后修改时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> f.lastModified();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取文件的最后修改时间：&quot;</span>+d);</span><br><span class="line">        <span class="comment">//设置文件修改时间为1970.1.1 08:00:00</span></span><br><span class="line">        f.setLastModified(<span class="number">0</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//文件重命名</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOLFolder/DOTA.exe&quot;</span>);</span><br><span class="line">        f.renameTo(f2);</span><br><span class="line">        System.out.println(<span class="string">&quot;把LOL.exe改名成了DOTA.exe&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">&quot;注意： 需要在D:\\LOLFolder确实存在一个LOL.exe,\r\n才可以看到对应的文件长度、修改时间等信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">############################################################### </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFile</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/LOLFolder/skin/garen.ski&quot;</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</span></span><br><span class="line">        f.list();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</span></span><br><span class="line">        File[]fs= f.listFiles();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 以字符串形式返回获取所在文件夹</span></span><br><span class="line">        f.getParent();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 以文件形式返回获取所在文件夹</span></span><br><span class="line">        f.getParentFile();</span><br><span class="line">        <span class="comment">// 创建文件夹，如果父文件夹skin不存在，创建就无效</span></span><br><span class="line">        f.mkdir();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 创建文件夹，如果父文件夹skin不存在，就会创建父文件夹</span></span><br><span class="line">        f.mkdirs();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 创建一个空文件,如果父文件夹skin不存在，就会抛出异常</span></span><br><span class="line">        f.createNewFile();</span><br><span class="line">        <span class="comment">// 所以创建一个空文件之前，通常都会创建父目录</span></span><br><span class="line">        f.getParentFile().mkdirs();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 列出所有的盘符c: d: e: 等等</span></span><br><span class="line">        f.listRoots();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 刪除文件</span></span><br><span class="line">        f.delete();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// JVM结束的时候，刪除文件，常用于临时文件的删除</span></span><br><span class="line">        f.deleteOnExit();</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="JAVA的流"><a href="#JAVA的流" class="headerlink" title="JAVA的流"></a>JAVA的流</h3><p>什么是流</p><p>当不同的介质之间有数据交互的时候，JAVA就使用流来实现。<br>数据源可以是文件，还可以是数据库，网络甚至是其他的程序</p><p>比如读取文件的数据到程序中，站在程序的角度来看，就叫做输入流.</p><p>文件输入流，这个流可以用来把数据从硬盘的文件，读取到JVM(内存)，输出流则相反。</p><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul><li>InputStream是字节输入流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。FileInputStream 是InputStream子类，以FileInputStream 为例进行文件读取</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//准备文件lol.txt其中的内容是AB，对应的ASCII分别是65 66</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//创建基于文件的输入流</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            <span class="comment">//创建字节数组，其长度就是文件的长度</span></span><br><span class="line">            <span class="type">byte</span>[] all =<span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">            <span class="comment">//以字节流的形式读取文件所有内容</span></span><br><span class="line">            fis.read(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">byte</span> b : all) &#123;</span><br><span class="line">                <span class="comment">//打印出来是65 66</span></span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//每次使用完流，都应该进行关闭</span></span><br><span class="line">            fis.close();</span><br><span class="line">              </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>OutputStream是字节输出流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。FileOutputStream 是OutputStream子类，以FileOutputStream 为例向文件写出数据。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 准备文件lol2.txt其中的内容是空的</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol2.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 准备长度是2的字节数组，用88,89初始化，其对应的字符分别是X,Y</span></span><br><span class="line">            <span class="type">byte</span> data[] = &#123; <span class="number">88</span>, <span class="number">89</span> &#125;;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 创建基于文件的输出流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">            <span class="comment">// 把数据写入到输出流</span></span><br><span class="line">            fos.write(data);</span><br><span class="line">            <span class="comment">// 关闭输出流</span></span><br><span class="line">            fos.close();</span><br><span class="line">             </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关闭流的方式"><a href="#关闭流的方式" class="headerlink" title="关闭流的方式"></a>关闭流的方式</h3><ul><li><p>在try中关闭</p><p>在try的作用域里关闭文件输入流，在前面的示例中都是使用这种方式，这样做有一个弊端；<br>如果文件不存在，或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患。 <strong>不推荐</strong>使用</p></li><li><p>在finally中关闭</p><p>这是标准的关闭流的方式</p><ol><li>首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally.</li><li>在finally关闭之前，要先判断该引用是否为空</li><li>关闭的时候，需要再一次进行try catch处理</li></ol></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            <span class="type">byte</span>[] all = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">            fis.read(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">byte</span> b : all) &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 在finally 里关闭流</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != fis)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用try()的方式</p><p>把流定义在try()里,try,catch或者finally结束的时候，会自动关闭<br>这种编写代码的方式叫做 <strong>try-with-resources</strong>， 这是从JDK7开始支持的技术</p><p>所有的流，都实现了一个接口叫做 <strong>AutoCloseable</strong>，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//把流定义在try()里,try,catch或者finally结束的时候，会自动关闭</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f)) &#123;</span><br><span class="line">            <span class="type">byte</span>[] all = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">            fis.read(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">byte</span> b : all) &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul><li>Reader字符输入流：FileReader 是Reader子类，以FileReader 为例进行文件读取</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备文件lol.txt其中的内容是AB</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建基于文件的Reader</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(f)) &#123;</span><br><span class="line">            <span class="comment">// 创建字符数组，其长度就是文件的长度</span></span><br><span class="line">            <span class="type">char</span>[] all = <span class="keyword">new</span> <span class="title class_">char</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">            <span class="comment">// 以字符流的形式读取文件所有内容</span></span><br><span class="line">            fr.read(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> b : all) &#123;</span><br><span class="line">                <span class="comment">// 打印出来是A B</span></span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Writer字符输出流：FileWriter 是Writer的子类，以FileWriter 为例把字符串写入到文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备文件lol2.txt</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol2.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建基于文件的Writer</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f)) &#123;</span><br><span class="line">            <span class="comment">// 以字符流的形式把数据写入到文件中</span></span><br><span class="line">            String data=<span class="string">&quot;abcdefg1234567890&quot;</span>;</span><br><span class="line">            <span class="type">char</span>[] cs = data.toCharArray();</span><br><span class="line">            fr.write(cs);</span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>专门用于字符的形式读取和写入数据</li></ul><h3 id="I-x2F-O中文问题"><a href="#I-x2F-O中文问题" class="headerlink" title="I&#x2F;O中文问题"></a>I&#x2F;O中文问题</h3><img src="/2021/10/06/how2j/10/06/how2j/2481.png" class title="编码概念"><p>工作后经常接触的编码方式有如下几种：</p><ul><li><strong>ISO-8859-1 ASCII</strong> 数字和西欧字母</li><li><strong>GBK GB2312 BIG5</strong> 中文</li><li><strong>UNICODE</strong> (统一码，万国码)</li></ul><p>其中</p><ul><li>ISO-8859-1 包含 ASCII</li><li>GB2312 是简体中文，BIG5是繁体中文，GBK同时包含简体和繁体以及日文。</li><li>UNICODE 包括了所有的文字，无论中文，英文，藏文，法文，世界所有的文字都包含其中</li></ul><p><strong>UNICODE和UTF</strong></p><p>根据前面的学习，我们了解到不同的编码方式对应不同的<strong>棋盘</strong>，而UNICODE因为要存放所有的数据，那么它的棋盘是最大的。<br>不仅如此，棋盘里每个数字都是很长的(4个字节)，因为不仅要表示字母，还要表示汉字等。</p><p>如果完全按照UNICODE的方式来存储数据，就会有很大的浪费。<br>比如在ISO-8859-1中，<strong>a</strong> 字符对应的数字是0x61<br>而UNICODE中对应的数字是 0x00000061，倘若一篇文章大部分都是英文字母，那么按照UNICODE的方式进行数据保存就会消耗很多空间</p><p>在这种情况下，就出现了UNICODE的各种<strong>减肥</strong>子编码, 比如UTF-8对数字和字母就使用一个字节，而对汉字就使用3个字节，从而达到了<strong>减肥还能保证健康</strong>的效果</p><p>UTF-8，UTF-16和UTF-32 针对不同类型的数据有不同的<strong>减肥效果</strong>，一般说来UTF-8是比较常用的方式</p><p>UTF-8，UTF-16和UTF-32 彼此的区别在此不作赘述，有兴趣的可以参考 <a href="http://baike.baidu.com/link?url=ty4mEX5hSfK2xAyPO8N2zgxTibBE59CShSb5yFxbVkBun_QVz65llOPEXOepgPeqe3AQDLt6LLjTayn6tioS4_#4">unicode-百度百科</a></p><img src="/2021/10/06/how2j/10/06/how2j/2482.png" class title="UNICODE和UTF"><p><strong>Java采用的是Unicode</strong></p><p>写在.java源代码中的汉字，在执行之后，都会变成JVM中的字符。<br>而这些中文字符采用的编码方式，都是使用UNICODE. “中”字对应的UNICODE是<strong>4E2D</strong>,所以在内存中，实际保存的数据就是十六进制的0x4E2D, 也就是十进制的20013。</p><p>以字符 <strong>中</strong> 为例，查看其在不同编码方式下的值是多少</p><p>也即在不同的<strong>棋盘上的位置</strong></p><img src="/2021/10/06/how2j/10/06/how2j/2483.png" class title="一个汉字使用不同编码方式的表现"><p><strong>用FileInputStream 字节流正确读取中文</strong></p><p>为了能够正确的读取中文内容</p><ol><li>必须了解文本是以哪种编码方式保存字符的</li><li>使用字节流读取了文本后，再使用对应的<strong>编码方式去识别这些数字</strong>，得到正确的字符<br>如本例，一个文件中的内容是字符<strong>中</strong>，编码方式是GBK，那么读出来的数据一定是D6D0。<br>再使用GBK编码方式识别D6D0，就能正确的得到字符<strong>中</strong></li></ol><p><strong>注：</strong> 在GBK的棋盘上找到的<strong>中</strong>字后，JVM会自动找到<strong>中</strong>在UNICODE这个棋盘上对应的数字，并且以<a href="https://how2j.cn/k/io/io-encoding/695.html#step2486">UNICODE上的数字保存在内存中</a>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:\\project\\j2sc\\test.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f))&#123;</span><br><span class="line">            Byte[] bytes = <span class="keyword">new</span> <span class="title class_">Byte</span>[(<span class="type">int</span>)fis.length()];</span><br><span class="line">            fis.read(f);</span><br><span class="line">            System.out.println(<span class="string">&quot;读出来的数据为：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">byte</span> i : bytes)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b&amp;<span class="number">0x000000ff</span>;<span class="comment">//只取16进制的后俩位</span></span><br><span class="line">                System.out.print(Integer.toHexString(i));<span class="comment">//转换为16进制</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;把这个数字，放在GBK的棋盘上去：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><img src="/2021/10/06/how2j/10/06/how2j/2488.png" class title="用FileInputStream 字节流正确读取中文"><p><strong>用FileReader 字符流正确读取中文</strong></p><p>FileReader得到的是字符，所以一定是已经把字节<strong>根据某种编码识别成了字符</strong>了<br>而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBK<br>FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替，像这样：<code>new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;))</code>;<br>在本例中，用记事本另存为UTF-8格式，然后用UTF-8就能识别对应的中文了。</p><p><strong>解释：</strong> 为什么中字前面有一个?<br>如果是使用记事本另存为UTF-8的格式，那么在第一个字节有一个<strong>标示符</strong>，叫做BOM用来标志这个文件是用UTF-8来编码的。</p><img src="/2021/10/06/how2j/10/06/how2j/2489.png" class title="用FileReader 字符流正确读取中文"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException, FileNotFoundException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\project\\j2se\\src\\test.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;默认编码方式:&quot;</span>+Charset.defaultCharset());</span><br><span class="line">        <span class="comment">//FileReader得到的是字符，所以一定是已经把字节根据某种编码识别成了字符了</span></span><br><span class="line">        <span class="comment">//而FileReader使用的编码方式是Charset.defaultCharset()的返回值，如果是中文的操作系统，就是GBK</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(f)) &#123;</span><br><span class="line">            <span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">            fr.read(cs);</span><br><span class="line">            System.out.printf(<span class="string">&quot;FileReader会使用默认的编码方式%s,识别出来的字符是：%n&quot;</span>,Charset.defaultCharset());</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(cs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//FileReader是不能手动设置编码方式的，为了使用其他的编码方式，只能使用InputStreamReader来代替</span></span><br><span class="line">        <span class="comment">//并且使用new InputStreamReader(new FileInputStream(f),Charset.forName(&quot;UTF-8&quot;)); 这样的形式</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f),Charset.forName(<span class="string">&quot;UTF-8&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line">            isr.read(cs);</span><br><span class="line">            System.out.printf(<span class="string">&quot;InputStreamReader 指定编码方式UTF-8,识别出来的字符是：%n&quot;</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(cs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存流"><a href="#缓存流" class="headerlink" title="缓存流"></a>缓存流</h3><p>以介质是硬盘为例，<strong>字节流和字符流的弊端</strong>：<br>在每一次读写的时候，都会访问硬盘。 如果读写的频率比较高的时候，其性能表现不佳。</p><p>为了解决以上弊端，采用缓存流。<br>缓存流在读取的时候，<strong>会一次性读较多的数据到缓存中</strong>，以后每一次的读取，都是在缓存中访问，直到缓存中的数据读取完毕，再到硬盘中读取。</p><p>就好比吃饭，<strong>不用缓存就是每吃一口都到锅里去铲</strong>。<strong>用缓存就是先把饭盛到碗里</strong>，碗里的吃完了，再到锅里去铲</p><p>缓存流在写入数据的时候，会先把数据写入到缓存区，直到缓存区<strong>达到一定的量</strong>，才把这些数据，<strong>一起写入到硬盘中去</strong>。按照这种操作模式，就不会像字节流，字符流那样<strong>每写一个字节都访问硬盘</strong>，从而减少了IO操作。</p><ul><li>使用缓存流读取数据——缓存字符输入流 BufferedReader 可以一次读取一行数据</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备文件lol.txt其中的内容是</span></span><br><span class="line">        <span class="comment">// garen kill teemo</span></span><br><span class="line">        <span class="comment">// teemo revive after 1 minutes</span></span><br><span class="line">        <span class="comment">// teemo try to garen, but killed again</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建文件字符流</span></span><br><span class="line">        <span class="comment">// 缓存流必须建立在一个存在的流的基础上</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(f);</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">            )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 一次读一行</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == line)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用缓存流写出数据——PrintWriter 缓存字符输出流， 可以一次写出一行数据</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向文件lol2.txt中写入三行语句</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol2.txt&quot;</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建文件字符流</span></span><br><span class="line">                <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f);</span><br><span class="line">                <span class="comment">// 缓存流必须建立在一个存在的流的基础上              </span></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(fw);              </span><br><span class="line">        ) &#123;</span><br><span class="line">            pw.println(<span class="string">&quot;garen kill teemo&quot;</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;teemo revive after 1 minutes&quot;</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;teemo try to garen, but killed again&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flush——有的时候，需要<strong>立即把数据写入到硬盘</strong>，而不是等缓存满了才写出去。 这时候就需要用到flush</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//向文件lol2.txt中写入三行语句</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol2.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//创建文件字符流</span></span><br><span class="line">        <span class="comment">//缓存流必须建立在一个存在的流的基础上</span></span><br><span class="line">        <span class="keyword">try</span>(<span class="type">FileWriter</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f);<span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(fr);) &#123;</span><br><span class="line">            pw.println(<span class="string">&quot;garen kill teemo&quot;</span>);</span><br><span class="line">            <span class="comment">//强制把缓存中的数据写入硬盘，无论缓存是否已满</span></span><br><span class="line">                pw.flush();           </span><br><span class="line">            pw.println(<span class="string">&quot;teemo revive after 1 minutes&quot;</span>);</span><br><span class="line">                pw.flush();</span><br><span class="line">            pw.println(<span class="string">&quot;teemo try to garen, but killed again&quot;</span>);</span><br><span class="line">                pw.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>DataInputStream 数据输入流；DataOutputStream 数据输出流；</p><p>使用数据流的<strong>writeUTF()和readUTF()</strong> 可以进行数据的<strong>格式化顺序读写</strong><br>如本例，通过DataOutputStream 向文件顺序写出 布尔值，整数和字符串。 然后再通过DataInputStream 顺序读入这些数据。</p><p><strong>注：</strong> 要用DataInputStream 读取一个文件，这个文件必须是由DataOutputStream 写出的，否则会出现EOFException，因为DataOutputStream 在写出的时候会做一些特殊标记，只有DataInputStream 才能成功的读取。</p><img src="/2021/10/06/how2j/10/06/how2j/771.png" class title="直接进行字符串的读写"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        write();</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">FileInputStream</span> <span class="variable">fis</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">                <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fis);</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="type">boolean</span> b= dis.readBoolean();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">             </span><br><span class="line">            System.out.println(<span class="string">&quot;读取到布尔值:&quot;</span>+b);</span><br><span class="line">            System.out.println(<span class="string">&quot;读取到整数:&quot;</span>+i);</span><br><span class="line">            System.out.println(<span class="string">&quot;读取到字符串:&quot;</span>+str);</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">fos</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">                <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fos);</span><br><span class="line">        )&#123;</span><br><span class="line">            dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">            dos.writeInt(<span class="number">300</span>);</span><br><span class="line">            dos.writeUTF(<span class="string">&quot;123 this is gareen&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><p>对象流指的是可以直接<strong>把一个对象以流的形式</strong>传输给其他的介质，比如硬盘</p><p>一个对象以流的形式进行传输，叫做序列化。 该对象所对应的类，必须是实现Serializable接口</p><p>例：创建一个Hero对象，设置其名称为garen。把该对象序列化到一个文件garen.lol。然后再通过序列化把该文件转换为一个Hero对象。</p><p><strong>注：</strong>把一个对象序列化有一个前提是：这个对象的类，必须实现了Serializable接口。</p><p>TestStream.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Hero garen</span></span><br><span class="line">        <span class="comment">//要把Hero对象直接保存在文件上，务必让Hero类实现Serializable接口</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        h.name = <span class="string">&quot;garen&quot;</span>;</span><br><span class="line">        h.hp = <span class="number">616</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//准备一个文件用于保存该对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/garen.lol&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">//创建对象输出流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">            <span class="comment">//创建对象输入流              </span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        ) &#123;</span><br><span class="line">            oos.writeObject(h);</span><br><span class="line">            <span class="type">Hero</span> <span class="variable">h2</span> <span class="operator">=</span> (Hero) ois.readObject();</span><br><span class="line">            System.out.println(h2.name);</span><br><span class="line">            System.out.println(h2.hp);</span><br><span class="line">               </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hero.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="I-x2F-O-System-in"><a href="#I-x2F-O-System-in" class="headerlink" title="I&#x2F;O System.in"></a>I&#x2F;O System.in</h3><p><code>System.out</code> 是常用的在控制台输出数据的。<br><code>System.in</code> 可以从控制台输入数据。</p><p><strong>System.in</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 控制台输入</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> System.in;) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 敲入a,然后敲回车可以看到</span></span><br><span class="line">                <span class="comment">// 97 13 10</span></span><br><span class="line">                <span class="comment">// 97是a的ASCII码</span></span><br><span class="line">                <span class="comment">// 13 10分别对应回车换行</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> is.read();</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Scanner读取字符串</strong></p><p>使用System.in.read虽然可以读取数据，但是很不方便<br>使用Scanner就可以逐行读取了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         </span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> s.nextLine();</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Scanner从控制台读取整数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(s.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line">            System.out.println(<span class="string">&quot;读取到的数字：&quot;</span>+ i );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>如果要存放多个对象，可以使用数组，但是数组有局限性；比如 声明长度是10的数组；不用的数组就浪费了；超过10的个数，又放不下。</p><p>为了解决数组的局限性，引入容器类的概念。 最常见的容器类就是<code>ArrayList</code><br><a href="https://how2j.cn/k/number-string/number-string-stringbuilder/328.html#step724">容器的容量</a>“capacity”会随着对象的增加，自动增长，只需要不断往容器里增加英雄即可，不用担心会出现数组的边界问题。</p><p><strong>常用方法</strong></p><table><thead><tr><th align="left">关键字</th><th align="left">简介</th><th align="left">示例代码</th></tr></thead><tbody><tr><td align="left">add</td><td align="left">增加</td><td align="left"><a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2453">示例代码</a></td></tr><tr><td align="left">contains</td><td align="left">判断是否存在</td><td align="left"><a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2454">示例代码</a></td></tr><tr><td align="left">get</td><td align="left">获取指定位置的对象</td><td align="left"><a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2455">示例代码</a></td></tr><tr><td align="left">indexOf</td><td align="left">获取对象所处的位置</td><td align="left"><a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2456">示例代码</a></td></tr><tr><td align="left">remove</td><td align="left">删除</td><td align="left"><a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2457">示例代码</a></td></tr><tr><td align="left">set</td><td align="left">替换</td><td align="left"><a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2458">示例代码</a></td></tr><tr><td align="left">size</td><td align="left">获取大小</td><td align="left"><a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2459">示例代码</a></td></tr><tr><td align="left">toArray</td><td align="left">转换为数组</td><td align="left"><a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2460">示例代码</a></td></tr><tr><td align="left">addAll</td><td align="left">把另一个容器所有对象都加进来</td><td align="left"><a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2461">示例代码</a></td></tr><tr><td align="left">clear</td><td align="left">清空</td><td align="left"><a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html#step2462">示例代码</a></td></tr></tbody></table><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p>ArrayList实现了接口List<br>常见的写法会把引用声明为接口List类型<br>注意：是<strong>java.util.List</strong>,而<strong>不是</strong>java.awt.List</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//ArrayList实现了接口List</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//常见的写法会把引用声明为接口List类型</span></span><br><span class="line">        <span class="comment">//注意：是java.util.List,而不是java.awt.List</span></span><br><span class="line">        <span class="comment">//接口引用指向子类对象（多态）</span></span><br><span class="line">         </span><br><span class="line">        <span class="type">List</span> <span class="variable">heros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        heros.add( <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;盖伦&quot;</span>));</span><br><span class="line">        System.out.println(heros.size());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><table><thead><tr><th align="left">关键字</th><th align="left">简介</th><th align="left">示例代码</th></tr></thead><tbody><tr><td align="left">for</td><td align="left">用for循环遍历</td><td align="left"><a href="https://how2j.cn/k/collection/collection-arraylist-iterator/688.html#step2469">示例代码</a></td></tr><tr><td align="left">iterator</td><td align="left">迭代器遍历</td><td align="left"><a href="https://how2j.cn/k/collection/collection-arraylist-iterator/688.html#step806">示例代码</a></td></tr><tr><td align="left">for:</td><td align="left">用增强型for循环</td><td align="left"><a href="https://how2j.cn/k/collection/collection-arraylist-iterator/688.html#step2470">示例代码</a></td></tr></tbody></table><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>序列分先进先出FIFO,先进后出FILO<br>FIFO在Java中又叫Queue 队列<br>FILO在Java中又叫Stack 栈</p><p>与<a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html">ArrayList</a>一样，LinkedList也实现了List接口，诸如add,remove,contains等等方法。 详细使用，请参考 <a href="https://how2j.cn/k/collection/collection-arraylist-method/685.html">ArrayList 常用方法</a>，在此不作赘述。</p><p>接下来要讲的是LinkedList的一些特别的地方</p><h4 id="双向链表-Deque"><a href="#双向链表-Deque" class="headerlink" title="双向链表 - Deque"></a>双向链表 - Deque</h4><p>除了实现了List接口外，LinkedList还实现了<strong>双向链表结构</strong>Deque，可以很方便的在头尾插入删除数据。</p><p>什么是链表结构: 与数组结构相比较，数组结构，就好像是电影院，每个位置都有标示，每个位置之间的间隔都是一样的。 而链表就相当于佛珠，每个珠子，只连接前一个和后一个，不用关心除此之外的其他佛珠在哪里。</p><img src="/2021/10/06/how2j/10/06/how2j/809.png" class title="双向链表 - Deque"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//LinkedList是一个双向链表结构的list</span></span><br><span class="line">        LinkedList&lt;Hero&gt; ll =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Hero&gt;();</span><br><span class="line">        <span class="comment">//所以可以很方便的在头部和尾部插入数据</span></span><br><span class="line">        <span class="comment">//在最后插入新的英雄</span></span><br><span class="line">        ll.addLast(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero1&quot;</span>));</span><br><span class="line">        ll.addLast(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero2&quot;</span>));</span><br><span class="line">        ll.addLast(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero3&quot;</span>));</span><br><span class="line">        System.out.println(ll);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//在最前面插入新的英雄</span></span><br><span class="line">        ll.addFirst(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;heroX&quot;</span>));</span><br><span class="line">        System.out.println(ll);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//查看最前面的英雄</span></span><br><span class="line">        System.out.println(ll.getFirst());</span><br><span class="line">        <span class="comment">//查看最后面的英雄</span></span><br><span class="line">        System.out.println(ll.getLast());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//查看不会导致英雄被删除</span></span><br><span class="line">        System.out.println(ll);</span><br><span class="line">        <span class="comment">//取出最前面的英雄</span></span><br><span class="line">        System.out.println(ll.removeFirst());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//取出最后面的英雄</span></span><br><span class="line">        System.out.println(ll.removeLast());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//取出会导致英雄被删除</span></span><br><span class="line">        System.out.println(ll);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 - Queue"></a>队列 - Queue</h4><p>LinkedList 除了实现了List和Deque外，还实现了<strong>Queue</strong>接口(队列)。</p><p>Queue是先进先出队列 <strong>FIFO</strong>，常用方法：</p><ul><li><strong>offer</strong> 在最后添加元素</li><li><strong>poll</strong> 取出第一个元素</li><li><strong>peek</strong> 查看第一个元素</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//和ArrayList一样，LinkedList也实现了List接口</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">ll</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Hero&gt;();</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//所不同的是LinkedList还实现了Deque，进而又实现了Queue这个接口</span></span><br><span class="line">        <span class="comment">//Queue代表FIFO 先进先出的队列</span></span><br><span class="line">        Queue&lt;Hero&gt; q= <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Hero&gt;();</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//加在队列的最后面</span></span><br><span class="line">        System.out.print(<span class="string">&quot;初始化队列：\t&quot;</span>);</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;Hero1&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;Hero2&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;Hero3&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;Hero4&quot;</span>));</span><br><span class="line">          </span><br><span class="line">        System.out.println(q);</span><br><span class="line">        System.out.print(<span class="string">&quot;把第一个元素取poll()出来:\t&quot;</span>);</span><br><span class="line">        <span class="comment">//取出第一个Hero，FIFO 先进先出</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        System.out.println(h);</span><br><span class="line">        System.out.print(<span class="string">&quot;取出第一个元素之后的队列:\t&quot;</span>);</span><br><span class="line">        System.out.println(q);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//把第一个拿出来看一看，但是不取出来</span></span><br><span class="line">        h=q.peek();</span><br><span class="line">        System.out.print(<span class="string">&quot;查看peek()第一个元素:\t&quot;</span>);</span><br><span class="line">        System.out.println(h);</span><br><span class="line">        System.out.print(<span class="string">&quot;查看并不会导致第一个元素被取出来:\t&quot;</span>);</span><br><span class="line">        System.out.println(q);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList与LinkedList区别"><a href="#ArrayList与LinkedList区别" class="headerlink" title="ArrayList与LinkedList区别"></a>ArrayList与LinkedList区别</h3><ul><li><strong>是否保证线程安全</strong>：都是非同步，线程不安全</li><li><strong>底层数据结构</strong>：ArrayList底层数据结构为Object数组，LinkedList底层数据结构为双向链表。</li><li>ArrayList支持快速查询。</li><li><strong>插入和删除是否受元素位置的影响</strong>：<ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</li><li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），时间复杂度为 O(1)。</li></ul></li><li><strong>内存空间占用</strong>：<code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h4><p>二叉树由各种<strong>节点</strong>组成<br>二叉树特点：<br>每个节点都可以有<strong>左子</strong>节点，<strong>右子</strong>节点<br>每一个节点都有一个<strong>值</strong></p><img src="/2021/10/06/how2j/10/06/how2j/1008.png" class title="二叉树概念"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node leftNode;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node rightNode;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">public</span> Object value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树排序-插入数据"><a href="#二叉树排序-插入数据" class="headerlink" title="二叉树排序-插入数据"></a>二叉树排序-插入数据</h4><p>假设通过二叉树对如下10个随机数进行排序<br>67,7,30,73,10,0,78,81,10,74<br>排序的第一个步骤是把数据插入到该二叉树中<br>插入基本逻辑是，<strong>小、相同的放左边</strong>，<strong>大的放右边</strong></p><img src="/2021/10/06/how2j/10/06/how2j/1009.png" class title="二叉树排序-插入数据"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node leftNode;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node rightNode;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">public</span> Object value;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 插入 数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object v)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点没有值，就把数据放在当前节点上</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == value)</span><br><span class="line">            value = v;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 如果当前节点有值，就进行判断，新增的值与当前值的大小关系</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新增的值，比当前值小或者相同</span></span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> ((Integer) v -((Integer)value) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == leftNode)</span><br><span class="line">                    leftNode = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                leftNode.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新增的值，比当前值大</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == rightNode)</span><br><span class="line">                    rightNode = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                rightNode.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span> randoms[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">67</span>, <span class="number">7</span>, <span class="number">30</span>, <span class="number">73</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">81</span>, <span class="number">10</span>, <span class="number">74</span> &#125;;</span><br><span class="line">  </span><br><span class="line">        <span class="type">Node</span> <span class="variable">roots</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> number : randoms) &#123;</span><br><span class="line">            roots.add(number);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树排序-遍历"><a href="#二叉树排序-遍历" class="headerlink" title="二叉树排序-遍历"></a>二叉树排序-遍历</h4><p>通过上一个步骤的插入行为，实际上，数据就已经排好序了。 接下来要做的是看，把<strong>这些已经排好序的数据</strong>，遍历成我们常用的List或者数组的形式</p><p>二叉树的遍历分左序，中序，右序<br><strong>左序</strong>即： 中间的数遍历后放在<strong>左边</strong><br><strong>中序</strong>即： 中间的数遍历后放在<strong>中间</strong><br><strong>右序</strong>即： 中间的数遍历后放在<strong>右边</strong><br>如图所见，我们希望遍历后的结果是从小到大的，所以应该采用<strong>中序遍历</strong></p><img src="/2021/10/06/how2j/10/06/how2j/1010.png" class title="二叉树排序-遍历"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node leftNode;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node rightNode;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">public</span> Object value;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 插入 数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object v)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点没有值，就把数据放在当前节点上</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == value)</span><br><span class="line">            value = v;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 如果当前节点有值，就进行判断，新增的值与当前值的大小关系</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新增的值，比当前值小或者相同</span></span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> ((Integer) v -((Integer)value) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == leftNode)</span><br><span class="line">                    leftNode = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                leftNode.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新增的值，比当前值大</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == rightNode)</span><br><span class="line">                    rightNode = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                rightNode.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 中序遍历所有的节点</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Object&gt; values = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 左节点的遍历结果</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != leftNode)</span><br><span class="line">            values.addAll(leftNode.values());</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 当前节点</span></span><br><span class="line">        values.add(value);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 右节点的遍历结果</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != rightNode)</span><br><span class="line">  </span><br><span class="line">            values.addAll(rightNode.values());</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span> randoms[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">67</span>, <span class="number">7</span>, <span class="number">30</span>, <span class="number">73</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">78</span>, <span class="number">81</span>, <span class="number">10</span>, <span class="number">74</span> &#125;;</span><br><span class="line">  </span><br><span class="line">        <span class="type">Node</span> <span class="variable">roots</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> number : randoms) &#123;</span><br><span class="line">            roots.add(number);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        System.out.println(roots.values());</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote><p>HashMap储存数据的方式是—— 键值对</p><p>对于HashMap而言，key是唯一的，不可以重复的。<br>所以，以相同的key 把不同的value插入到 Map中会导致旧元素被覆盖，只留下最后插入的元素。<br>不过，同一个对象可以作为值插入到map中，只要对应的key不一样</p></blockquote><h4 id="hashMap和hashTable的区别"><a href="#hashMap和hashTable的区别" class="headerlink" title="hashMap和hashTable的区别"></a>hashMap和hashTable的区别</h4><ul><li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</li></ul><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><blockquote><p>元素不能重复</p><p>Set中的元素，没有顺序。严格的说，是没有按照元素的插入顺序排列。HashSet的具体顺序，既不是按照插入顺序，也不是按照hashcode的顺序。</p></blockquote><table><thead><tr><th><code>HashMap</code></th><th><code>HashSet</code></th></tr></thead><tbody><tr><td>实现了 <code>Map</code> 接口</td><td>实现 <code>Set</code> 接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用 <code>put()</code>向 map 中添加元素</td><td>调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr><tr><td><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td><td><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Set不提供get方法来获取指定位置的元素</span></span><br><span class="line">        <span class="comment">//numbers.get(0)</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//遍历Set可以采用迭代器iterator</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;Integer&gt; iterator = numbers.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer) iterator.next();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//或者采用增强型for循环</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : numbers) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HashSet和HashMap的关系"><a href="#HashSet和HashMap的关系" class="headerlink" title="HashSet和HashMap的关系"></a>HashSet和HashMap的关系</h4><blockquote><p>通过观察HashSet的源代码<br>可以发现HashSet自身并没有独立的实现，而是在里面封装了一个Map.<br>HashSet是作为Map的key而存在的<br>而value是一个命名为PRESENT的static的Object对象，因为是一个类属性，所以只会有一个。</p><p>private static final Object PRESENT &#x3D; new Object();</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//HashSet里封装了一个HashMap</span></span><br><span class="line">    <span class="keyword">private</span>  HashMap&lt;E,Object&gt; map;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//HashSet的构造方法初始化这个HashMap</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//向HashSet中增加元素，其实就是把该元素作为key，增加到Map中</span></span><br><span class="line">    <span class="comment">//value是PRESENT，静态，final的对象，所有的HashSet都使用这么同一个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//HashSet的size就是map的size</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//清空Set就是清空Map</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//迭代Set,就是把Map的键拿出来迭代</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><blockquote><p>Collection是 Set List Queue和 Deque的接口<br>Queue: 先进先出队列<br>Deque: 双向链表</p><p><strong>注：</strong>Collection和Map之间没有关系，Collection是放一个一个对象的，Map 是放键值对的<br><strong>注：</strong>Deque 继承 Queue,间接的继承了 Collection</p></blockquote><img src="/2021/10/06/how2j/10/06/how2j/830.png" class title="Collection"><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>Collections是一个类，容器的工具类,就如同Arrays是数组的工具类。</p><table><thead><tr><th align="left">关键字</th><th align="left">简介</th><th align="left">示例代码</th></tr></thead><tbody><tr><td align="left">reverse</td><td align="left">反转</td><td align="left"><a href="https://how2j.cn/k/collection/collection-collections/369.html#step2498">示例代码</a></td></tr><tr><td align="left">shuffle</td><td align="left">混淆</td><td align="left"><a href="https://how2j.cn/k/collection/collection-collections/369.html#step2501">示例代码</a></td></tr><tr><td align="left">sort</td><td align="left">排序</td><td align="left"><a href="https://how2j.cn/k/collection/collection-collections/369.html#step2499">示例代码</a></td></tr><tr><td align="left">swap</td><td align="left">交换</td><td align="left"><a href="https://how2j.cn/k/collection/collection-collections/369.html#step2500">示例代码</a></td></tr><tr><td align="left">rotate</td><td align="left">滚动</td><td align="left"><a href="https://how2j.cn/k/collection/collection-collections/369.html#step2497">示例代码</a></td></tr><tr><td align="left">synchronizedList</td><td align="left">线程安全化</td><td align="left"><a href="https://how2j.cn/k/collection/collection-collections/369.html#step2502">示例代码</a></td></tr></tbody></table><ul><li><strong>shuffle</strong> 混淆List中数据的顺序</li></ul><img src="/2021/10/06/how2j/10/06/how2j/2501.png" class title="混淆"><ul><li><strong>rotate</strong> 把List中的数据，向右滚动指定单位的长度</li></ul><img src="/2021/10/06/how2j/10/06/how2j/2497.png" class title="滚动"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化集合numbers</span></span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">&quot;集合中的数据:&quot;</span>);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">        Collections.rotate(numbers,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;把集合向右滚动2个单位，标的数据后，集合中的数据:&quot;</span>);</span><br><span class="line">        System.out.println(numbers);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>synchronizedList</strong> 把非线程安全的List转换为线程安全的List。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;把非线程安全的List转换为线程安全的List&quot;</span>);</span><br><span class="line">        List&lt;Integer&gt; synchronizedNumbers = (List&lt;Integer&gt;) Collections.synchronizedList(numbers);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h3><h4 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h4><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><img src="/2021/10/06/how2j/10/06/how2j/jdk1.7_hashmap.png" class title="jdk1.8 之前的内部结构-HashMap"><h4 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h4><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><img src="/2021/10/06/how2j/10/06/how2j/jdk1.8_hashmap.png" class title="jdk1.8之后的内部结构-HashMap"><blockquote><p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><p>我们来结合源码分析一下 <code>HashMap</code> 链表到红黑树的转换。</p><p><strong>1、 <code>putVal</code> 方法中执行链表转红黑树的判断逻辑。</strong></p><p>链表的长度大于 8 的时候，就执行 <code>treeifyBin</code> （转换红黑树）的逻辑。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">    <span class="comment">// 遍历到链表最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            <span class="comment">// 红黑树转换（并不会直接转换成红黑树）</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    p = e;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>2、<code>treeifyBin</code> 方法中判断是否真的转换为红黑树。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 判断当前数组的长度是否小于 64</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">// 如果当前数组的长度小于 64，那么会选择先进行数组扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 否则才将列表转换为红黑树</span></span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树。</p><h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><h4 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h4><p>例：假设Hero有三个属性 name,hp,damage<br>一个集合中放存放10个Hero,通过Collections.sort对这10个进行排序<br>那么<strong>到底是hp小的放前面？还是damage小的放前面？</strong>Collections.sort也无法确定<br>所以要指定到底按照哪种属性进行排序<br>这里就需要提供一个Comparator给定如何进行两个对象之间的<strong>大小</strong>比较</p><img src="/2021/10/06/how2j/10/06/how2j/828.png" class title="Comparator"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero [name=&quot;</span> + name + <span class="string">&quot;, hp=&quot;</span> + hp + <span class="string">&quot;, damage=&quot;</span> + damage + <span class="string">&quot;]\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name, <span class="type">int</span> hp, <span class="type">int</span> damage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.hp = hp;</span><br><span class="line">        <span class="built_in">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Hero&gt;();</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//通过随机值实例化hero的hp和damage</span></span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span>+ i, r.nextInt(<span class="number">100</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化后的集合：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//直接调用sort会出现编译错误，因为Hero有各种属性</span></span><br><span class="line">        <span class="comment">//到底按照哪种属性进行比较，Collections也不知道，不确定，所以没法排</span></span><br><span class="line">        <span class="comment">//Collections.sort(heros);</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//引入Comparator，指定比较的算法</span></span><br><span class="line">        Comparator&lt;Hero&gt; c = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Hero&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Hero h1, Hero h2)</span> &#123;</span><br><span class="line">                <span class="comment">//按照hp进行排序</span></span><br><span class="line">                <span class="keyword">if</span>(h1.hp&gt;=h2.hp)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//正数表示h1比h2要大</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Collections.sort(heros,c);</span><br><span class="line">        System.out.println(<span class="string">&quot;按照血量排序后的集合：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h4><p>例：使Hero类实现Comparable接口<br>在类里面提供比较算法<br>Collections.sort就有足够的信息进行排序了，也无需额外提供比较器Comparator<br><strong>注：</strong> 如果返回-1, 就表示当前的更小，否则就是更大</p><img src="/2021/10/06/how2j/10/06/how2j/829.png" class title="Comparable"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Hero&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span>&#123;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name =name;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//初始化name,hp,damage的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name,<span class="type">float</span> hp, <span class="type">int</span> damage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name =name;</span><br><span class="line">        <span class="built_in">this</span>.hp = hp;</span><br><span class="line">        <span class="built_in">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Hero anotherHero)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(damage&lt;anotherHero.damage)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero [name=&quot;</span> + name + <span class="string">&quot;, hp=&quot;</span> + hp + <span class="string">&quot;, damage=&quot;</span> + damage + <span class="string">&quot;]\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Hero&gt;();</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//通过随机值实例化hero的hp和damage</span></span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span>+ i, r.nextInt(<span class="number">100</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;初始化后的集合&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//Hero类实现了接口Comparable，即自带比较信息。</span></span><br><span class="line">        <span class="comment">//Collections直接进行排序，无需额外的Comparator</span></span><br><span class="line">        Collections.sort(heros);</span><br><span class="line">        System.out.println(<span class="string">&quot;按照伤害高低排序后的集合&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>JDK8之后，引入了对集合的聚合操作，可以非常容易的遍历，筛选，比较集合中的元素。</p><p>像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span>heros</span><br><span class="line">          .stream()</span><br><span class="line">          .sorted((h1,h2)-&gt;h1.hp&gt;h2.hp?-<span class="number">1</span>:<span class="number">1</span>)</span><br><span class="line">          .skip(<span class="number">2</span>)</span><br><span class="line">          .map(h-&gt;h.getName())</span><br><span class="line">          .findFirst()</span><br><span class="line">          .get();</span><br></pre></td></tr></table></figure><p>但是要用好聚合，必须先掌握Lambda表达式。</p><img src="/2021/10/06/how2j/10/06/how2j/2564.png" class title="聚合操作"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAggregate</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Hero&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;初始化集合后的数据 (最后一个数据重复)：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//传统方式</span></span><br><span class="line">        Collections.sort(heros,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Hero&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Hero o1, Hero o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">int</span>) (o2.hp-o1.hp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">hero</span> <span class="operator">=</span> heros.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;通过传统方式找出来的hp第三高的英雄名称是:&quot;</span> + hero.name);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//聚合方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span>heros</span><br><span class="line">            .stream()</span><br><span class="line">            .sorted((h1,h2)-&gt;h1.hp&gt;h2.hp?-<span class="number">1</span>:<span class="number">1</span>)</span><br><span class="line">            .skip(<span class="number">2</span>)</span><br><span class="line">            .map(h-&gt;h.getName())</span><br><span class="line">            .findFirst()</span><br><span class="line">            .get();</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;通过聚合操作找出来的hp第三高的英雄名称是:&quot;</span> + name);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><h4 id="extends"><a href="#extends" class="headerlink" title="? extends"></a>? extends</h4><p><code>ArrayList heroList&lt;? extends Hero&gt;</code>表示这是一个Hero泛型或者其子类泛型<br>heroList 的泛型可能是Hero<br>heroList 的泛型可能是APHero<br>heroList 的泛型可能是ADHero<br>所以 可以确凿的是，<strong>从heroList取出来的对象，一定是可以转型成Hero的</strong></p><p>但是，不能往里面放东西，因为<br>放APHero就不满足<ADHero><br>放ADHero又不满足<APHero></APHero></ADHero></p><img src="/2021/10/06/how2j/10/06/how2j/837.png" class title="? extends"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGeneric</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        ArrayList&lt;APHero&gt; apHeroList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;APHero&gt;();</span><br><span class="line">        apHeroList.add(<span class="keyword">new</span> <span class="title class_">APHero</span>());</span><br><span class="line">         </span><br><span class="line">        ArrayList&lt;? <span class="keyword">extends</span> <span class="title class_">Hero</span>&gt; heroList = apHeroList;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//? extends Hero 表示这是一个Hero泛型的子类泛型</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//heroList 的泛型可以是Hero</span></span><br><span class="line">        <span class="comment">//heroList 的泛型可以使APHero</span></span><br><span class="line">        <span class="comment">//heroList 的泛型可以使ADHero</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//可以确凿的是，从heroList取出来的对象，一定是可以转型成Hero的</span></span><br><span class="line">          </span><br><span class="line">        Hero h= heroList.get(<span class="number">0</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//但是，不能往里面放东西</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> <span class="title class_">ADHero</span>()); <span class="comment">//编译错误，因为heroList的泛型 有可能是APHero</span></span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="super"><a href="#super" class="headerlink" title="? super"></a>? super</h4><p><code>ArrayList heroList&lt;? super Hero&gt; </code>表示这是一个Hero泛型或者其父类泛型<br>heroList的泛型可能是Hero<br>heroList的泛型可能是Object</p><p><strong>可以往里面插入Hero以及Hero的子类</strong><br>但是取出来有风险，因为不确定取出来是Hero还是Object</p><img src="/2021/10/06/how2j/10/06/how2j/838.png" class title="? super"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGeneric</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        ArrayList&lt;? <span class="built_in">super</span> Hero&gt; heroList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//? super Hero 表示 heroList的泛型是Hero或者其父类泛型</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//heroList 的泛型可以是Hero</span></span><br><span class="line">        <span class="comment">//heroList 的泛型可以是Object</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//所以就可以插入Hero</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> <span class="title class_">Hero</span>());</span><br><span class="line">        <span class="comment">//也可以插入Hero的子类</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> <span class="title class_">APHero</span>());</span><br><span class="line">        heroList.add(<span class="keyword">new</span> <span class="title class_">ADHero</span>());</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//但是，不能从里面取数据出来,因为其泛型可能是Object,而Object强转Hero会失败</span></span><br><span class="line">        Hero h= heroList.get(<span class="number">0</span>);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符?"></a>泛型通配符?</h4><p>泛型通配符? 代表任意泛型<br>既然?代表任意泛型，那么换句话说，这个容器什么泛型都有可能</p><p>所以只能以Object的形式取出来<br>并且不能往里面放对象，因为不知道到底是一个什么泛型的容器</p><img src="/2021/10/06/how2j/10/06/how2j/836.png" class title="泛型通配符?"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGeneric</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        ArrayList&lt;APHero&gt; apHeroList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;APHero&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//?泛型通配符，表示任意泛型</span></span><br><span class="line">        ArrayList&lt;?&gt; generalList = apHeroList;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//?的缺陷1： 既然?代表任意泛型，那么换句话说，你就不知道这个容器里面是什么类型</span></span><br><span class="line">        <span class="comment">//所以只能以Object的形式取出来</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> generalList.get(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//?的缺陷2： 既然?代表任意泛型，那么既有可能是Hero,也有可能是Item</span></span><br><span class="line">        <span class="comment">//所以，放哪种对象进去，都有风险，结果就什么什么类型的对象，都不能放进去</span></span><br><span class="line">        generalList.add(<span class="keyword">new</span> <span class="title class_">Item</span>()); <span class="comment">//编译错误 因为?代表任意泛型，很有可能不是Item</span></span><br><span class="line">        generalList.add(<span class="keyword">new</span> <span class="title class_">Hero</span>()); <span class="comment">//编译错误 因为?代表任意泛型，很有可能不是Hero</span></span><br><span class="line">        generalList.add(<span class="keyword">new</span> <span class="title class_">APHero</span>()); <span class="comment">//编译错误  因为?代表任意泛型，很有可能不是APHero</span></span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>如果希望只取出，不插入，就使用? extends Hero（只读不写）</strong><br><strong>如果希望只插入，不取出，就使用? super Hero（只写不读）</strong><br><strong>如果希望，又能插入，又能取出，就不要用通配符？，? extends</strong></p><h3 id="泛型转型"><a href="#泛型转型" class="headerlink" title="泛型转型"></a>泛型转型</h3><p><strong>子类泛型转父类泛型和父类泛型转父类泛型都不可以</strong></p><p>例：<br>hs的泛型是父类Hero<br>adhs 的泛型是子类ADHero</p><p>那么 把adhs转换为hs能成功吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGeneric</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Hero&gt; hs =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ADHero&gt; adhs =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//子类泛型转父类泛型</span></span><br><span class="line">        hs = adhs;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设可以转型成功<br>引用hs指向了ADHero泛型的容器<br>作为Hero泛型的引用hs, 看上去是可以往里面加一个APHero的。<br>但是hs这个引用，实际上是指向的一个ADHero泛型的容器<br>如果能加进去，就变成了ADHero泛型的容器里放进了APHero，这就矛盾了</p><p>所以子类泛型<strong>不可以</strong>转换为父类泛型</p><img src="/2021/10/06/how2j/10/06/how2j/835.png" class title="假设可以转型成功"><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><h3 id="匿名类方式"><a href="#匿名类方式" class="headerlink" title="匿名类方式"></a>匿名类方式</h3><p>首先准备一个接口HeroChecker，提供一个test(Hero)方法<br>然后通过匿名类的方式，实现这个接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">HeroChecker</span> <span class="variable">checker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroChecker</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Hero h)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (h.hp&gt;<span class="number">100</span> &amp;&amp; h.damage&lt;<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>与<a href="https://how2j.cn/k/interface-inheritance/interface-inheritance-inner-class/322.html#step687">匿名类</a> 概念相比较，<br>Lambda 其实就是<strong>匿名方法</strong>，这是一种<strong>把方法作为参数</strong>进行传递的编程思想。</p><p>虽然代码是这么写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter(heros, h -&gt; h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>但是，Java会在背后，悄悄的，把这些都还原成<a href="https://how2j.cn/k/lambda/lambda-lamdba-tutorials/697.html#step2552">匿名类方式</a>。<br>引入Lambda表达式，会使得代码更加紧凑，而不是各种接口和匿名类到处飞。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>lambda 表达式的语法格式如下：</p><p>(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }</p><p>以下是lambda表达式的重要特征:</p><ul><li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li><li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li><li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</li></ul><h3 id="Lambda-表达式实例"><a href="#Lambda-表达式实例" class="headerlink" title="Lambda 表达式实例"></a>Lambda 表达式实例</h3><p>Lambda 表达式的简单例子:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 类型声明</span></span><br><span class="line">      <span class="type">MathOperation</span> <span class="variable">addition</span> <span class="operator">=</span> (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; a + b;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 不用类型声明</span></span><br><span class="line">      <span class="type">MathOperation</span> <span class="variable">subtraction</span> <span class="operator">=</span> (a, b) -&gt; a - b;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 大括号中的返回语句</span></span><br><span class="line">      <span class="type">MathOperation</span> <span class="variable">multiplication</span> <span class="operator">=</span> (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 没有大括号及返回语句</span></span><br><span class="line">      <span class="type">MathOperation</span> <span class="variable">division</span> <span class="operator">=</span> (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; a / b;</span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, addition));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, subtraction));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 x 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, multiplication));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 / 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, division));</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 不用括号</span></span><br><span class="line">      <span class="type">GreetingService</span> <span class="variable">greetService1</span> <span class="operator">=</span> message -&gt;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 用括号</span></span><br><span class="line">      <span class="type">GreetingService</span> <span class="variable">greetService2</span> <span class="operator">=</span> (message) -&gt;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">        </span><br><span class="line">      greetService1.sayMessage(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">      greetService2.sayMessage(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">interface</span> <span class="title class_">MathOperation</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="title function_">operation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">interface</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">(String message)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, MathOperation mathOperation)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mathOperation.operation(a, b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line"><span class="number">10</span> + <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"><span class="number">10</span> - <span class="number">5</span> = <span class="number">5</span></span><br><span class="line"><span class="number">10</span> x <span class="number">5</span> = <span class="number">50</span></span><br><span class="line"><span class="number">10</span> / <span class="number">5</span> = <span class="number">2</span></span><br><span class="line">Hello Runoob</span><br><span class="line">Hello Google</span><br></pre></td></tr></table></figure><blockquote><p>使用 Lambda 表达式需要注意以下两点：</p><ul><li>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。</li><li>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</li></ul></blockquote><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p><p>在 Java8Tester.java 文件输入以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">salutation</span> <span class="operator">=</span> <span class="string">&quot;Hello! &quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">GreetingService</span> <span class="variable">greetService1</span> <span class="operator">=</span> message -&gt; </span><br><span class="line">      System.out.println(salutation + message);</span><br><span class="line">      greetService1.sayMessage(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">interface</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">(String message)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));</span><br><span class="line">s.convert(<span class="number">2</span>);</span><br><span class="line">num = <span class="number">5</span>;  </span><br><span class="line"><span class="comment">//报错信息：Local variable num defined in an enclosing scope must be final or effectively </span></span><br><span class="line"> <span class="keyword">final</span></span><br></pre></td></tr></table></figure><p><strong>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length());  <span class="comment">//编译会出错 </span></span><br></pre></td></tr></table></figure><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。</p><ul><li><p>方法引用通过方法的名字来指向一个方法。</p></li><li><p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p></li><li><p>方法引用使用一对冒号 <code>::</code></p></li></ul><img src="/2021/10/06/how2j/10/06/how2j/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAT29aenp5,size_20,color_FFFFFF,t_70,g_se,x_16.png" class title="在这里插入图片描述"><h4 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">//Supplier是jdk1.8的接口，这里和lamda一起使用了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> Supplier&lt;Car&gt; supplier)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">collide</span><span class="params">(<span class="keyword">final</span> Car car)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Collided &quot;</span> + car.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="keyword">final</span> Car another)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Following the &quot;</span> + another.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">repair</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Repaired &quot;</span> + <span class="built_in">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>构造器引用：</strong>它的语法是<code>Class::new</code>，或者更一般的Class&lt; T &gt;::new实例如下：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> Car.create( Car::<span class="keyword">new</span> ); </span><br><span class="line"><span class="keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );</span><br></pre></td></tr></table></figure><ul><li><strong>静态方法引用：</strong>它的语法是<code>Class::static_method</code>，实例如下：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意事项：</span></span><br><span class="line"><span class="comment">// 1.collide方法是静态的</span></span><br><span class="line"><span class="comment">// 2.参数列表与 collide(T o1) 参数列表保持一致</span></span><br><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure><ul><li><strong>特定类的任意对象的方法引用(对象方法引用)：</strong>它的语法是Class::method实例如下：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意事项：</span></span><br><span class="line"><span class="comment">// 1.repair方法是非静态的，方法由对象调用</span></span><br><span class="line"><span class="comment">// 2.参数列表与 repair参数列表保持一致</span></span><br><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure><ul><li><strong>特定对象的方法引用(实例方法引用)：</strong>它的语法是instance::method实例如下：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意事项：</span></span><br><span class="line"><span class="comment">// 1.follow方法是非静态的</span></span><br><span class="line"><span class="comment">// 2.follow(T o1) 参数列表中的第一个参数在follow方法中被省略（参数 o1 默认为调用者本身）</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Car</span> <span class="variable">police</span> <span class="operator">=</span> Car.create( Car::<span class="keyword">new</span> ); </span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure><h3 id="聚合操作-1"><a href="#聚合操作-1" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>遍历数据的传统方式就是使用for循环，然后条件判断，最后打印出满足条件的数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Hero h : heros) &#123;</span><br><span class="line">   <span class="keyword">if</span> (h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>)</span><br><span class="line">     System.out.println(h.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用聚合操作方式，<strong>画风</strong>就发生了变化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">heros</span><br><span class="line">.stream()</span><br><span class="line">.filter(h -&gt; h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>)</span><br><span class="line">.forEach(h -&gt; System.out.println(h.name));</span><br></pre></td></tr></table></figure><h4 id="Stream和管道的概念"><a href="#Stream和管道的概念" class="headerlink" title="Stream和管道的概念"></a>Stream和管道的概念</h4><p>要了解聚合操作，首先要建立<strong>Stream</strong>和<strong>管道</strong>的概念<br><strong>Stream</strong> 和Collection结构化的数据不一样，Stream是一系列的元素，就像是生产线上的罐头一样，一串串的出来。<br><strong>管道</strong>指的是一系列的聚合操作。</p><p>管道又分3个部分</p><ul><li><strong>管道源</strong>：在这个例子里，源是一个List</li><li><strong>中间操作</strong>： 每个中间操作，又会返回一个Stream，比如.filter()又返回一个Stream, 中间操作是“懒”操作，并不会真正进行遍历。</li><li><strong>结束操作</strong>：当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。 结束操作不会返回Stream，但是会返回int、float、String、 Collection或者像forEach，什么都不返回, 结束操作才进行真正的遍历行为，在遍历的时候，才会去进行中间操作的相关判断</li></ul><p><strong>注：</strong> 这个Stream和I&#x2F;O章节的InputStream,OutputStream是不一样的概念。</p><h4 id="管道源"><a href="#管道源" class="headerlink" title="管道源"></a>管道源</h4><p>把Collection切换成管道源很简单，调用stream()就行了。<code>heros.stream()</code></p><p>但是数组却没有stream()方法，需要使用<code>Arrays.stream(hs)</code>或者<code>Stream.of(hs)</code></p><h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><p>每个中间操作，又会返回一个Stream，比如.filter()又返回一个Stream, 中间操作是“懒”操作，并不会真正进行遍历。</p><p>中间操作比较多，主要分两类</p><p>对元素进行筛选 和 转换为其他形式的流</p><p><strong>对元素进行筛选：</strong></p><ul><li><code>filter</code> 匹配</li><li><code>distinct</code> 去除重复(根据equals判断)</li><li><code>sorted</code> 自然排序</li><li><code>sorted(Comparator&lt;T&gt;)</code> 指定排序</li><li><code>limit</code> 保留</li><li><code>skip </code>忽略</li></ul><p><strong>转换为其他形式的流</strong></p><ul><li><code>mapToDouble</code> 转换为double的流</li><li><code>map</code> 转换为任意类型的流</li></ul><p>案例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Hero&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span>&#123;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getHp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHp</span><span class="params">(<span class="type">float</span> hp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDamage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> damage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDamage</span><span class="params">(<span class="type">int</span> damage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name =name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化name,hp,damage的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name,<span class="type">float</span> hp, <span class="type">int</span> damage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name =name;</span><br><span class="line">        <span class="built_in">this</span>.hp = hp;</span><br><span class="line">        <span class="built_in">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Hero anotherHero)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(damage&lt;anotherHero.damage)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero [name=&quot;</span> + name + <span class="string">&quot;, hp=&quot;</span> + hp + <span class="string">&quot;, damage=&quot;</span> + damage + <span class="string">&quot;]\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAggregate</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Hero&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//制造一个重复数据</span></span><br><span class="line">        heros.add(heros.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化集合后的数据 (最后一个数据重复)：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(<span class="string">&quot;满足条件hp&gt;100&amp;&amp;damage&lt;50的数据&quot;</span>);</span><br><span class="line">          </span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(h-&gt;h.hp&gt;<span class="number">100</span>&amp;&amp;h.damage&lt;<span class="number">50</span>)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;去除重复的数据，去除标准是看equals&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .distinct()</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">        System.out.println(<span class="string">&quot;按照血量排序&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .sorted((h1,h2)-&gt;h1.hp&gt;=h2.hp?<span class="number">1</span>:-<span class="number">1</span>)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;保留3个&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .limit(<span class="number">3</span>)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;忽略前3个&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .skip(<span class="number">3</span>)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;转换为double的Stream&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .mapToDouble(Hero::getHp)</span><br><span class="line">            .forEach(h-&gt;System.out.println(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;转换任意类型的Stream&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .map((h)-&gt; h.name + <span class="string">&quot; - &quot;</span> + h.hp + <span class="string">&quot; - &quot;</span> + h.damage)</span><br><span class="line">            .forEach(h-&gt;System.out.println(h));</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结束操作"><a href="#结束操作" class="headerlink" title="结束操作"></a>结束操作</h4><p>当进行结束操作后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。 结束操作不会返回Stream，但是会返回int、float、String、 Collection或者像forEach，什么都不返回,。</p><p>结束操作才真正进行遍历行为，前面的中间操作也在这个时候，才真正的执行。</p><p>常见结束操作如下：</p><ul><li><strong>forEach()</strong> 遍历每个元素</li><li><strong>toArray()</strong> 转换为数组</li><li><strong>min(Comparator<T>)</T></strong> 取最小的元素</li><li><strong>max(Comparator<T>)</T></strong> 取最大的元素</li><li><strong>count()</strong> 总数</li><li><strong>findFirst()</strong> 第一个元素</li></ul><p>案例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAggregate</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Hero&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;遍历集合中的每个数据&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">        System.out.println(<span class="string">&quot;返回一个数组&quot;</span>);</span><br><span class="line">        Object[] hs= heros</span><br><span class="line">            .stream()</span><br><span class="line">            .toArray();</span><br><span class="line">        System.out.println(Arrays.toString(hs));</span><br><span class="line">        System.out.println(<span class="string">&quot;返回伤害最低的那个英雄&quot;</span>);</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">minDamageHero</span> <span class="operator">=</span></span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .min((h1,h2)-&gt;h1.damage-h2.damage)</span><br><span class="line">            .get();</span><br><span class="line">        System.out.print(minDamageHero);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回伤害最高的那个英雄&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">mxnDamageHero</span> <span class="operator">=</span></span><br><span class="line">                heros</span><br><span class="line">                .stream()</span><br><span class="line">                .max((h1,h2)-&gt;h1.damage-h2.damage)</span><br><span class="line">                .get();</span><br><span class="line">        System.out.print(mxnDamageHero);     </span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">&quot;流中数据的总数&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> heros</span><br><span class="line">                .stream()</span><br><span class="line">                .count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;第一个英雄&quot;</span>);</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">firstHero</span> <span class="operator">=</span></span><br><span class="line">                heros</span><br><span class="line">                .stream()</span><br><span class="line">                .findFirst()</span><br><span class="line">                .get();</span><br><span class="line">         </span><br><span class="line">        System.out.println(firstHero);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程即在同一时间，可以做多件事情。</p><p>创建多线程有3种方式，分别是继承线程类，实现Runnable接口，匿名类。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><img src="/2021/10/06/how2j/10/06/how2j/java-runtime-data-areas-jdk1.8.png" class title="Java 运行时数据区域（JDK1.8 之后）"><p>首先要理解进程(Processor)和线程(Thread)的区别<br><strong>进程：</strong>启动一个LOL.exe就叫一个进程。 接着又启动一个DOTA.exe，这叫两个进程。<br><strong>线程：</strong>线程是在进程内部同时做的事情，比如在LOL里，有很多事情要同时做，比如”盖伦” 击杀“提莫”，<strong>同时</strong>“赏金猎人”又在击杀“盲僧”，这就是由多线程来实现的。</p><h3 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h3><h4 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h4><p>使用多线程，就可以做到盖伦在攻击提莫的<strong>同时</strong>，赏金猎人也在攻击盲僧<br>设计一个类KillThread <strong>继承Thread</strong>，<strong>并且重写run方法</strong><br>启动线程办法： 实例化一个KillThread对象，并且调用其<strong>start</strong>方法<br>就可以观察到 赏金猎人攻击盲僧的<strong>同时</strong>，盖伦也在攻击提莫</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KillThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> Hero h1;</span><br><span class="line">    <span class="keyword">private</span> Hero h2;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KillThread</span><span class="params">(Hero h1, Hero h2)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.h1 = h1;</span><br><span class="line">        <span class="built_in">this</span>.h2 = h2;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!h2.isDead())&#123;</span><br><span class="line">            h1.attackHero(h2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">        gareen.damage = <span class="number">50</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">300</span>;</span><br><span class="line">        teemo.damage = <span class="number">30</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">500</span>;</span><br><span class="line">        bh.damage = <span class="number">65</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">455</span>;</span><br><span class="line">        leesin.damage = <span class="number">80</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">KillThread</span> <span class="variable">killThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KillThread</span>(gareen,teemo);</span><br><span class="line">        killThread1.start();</span><br><span class="line">        <span class="type">KillThread</span> <span class="variable">killThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KillThread</span>(bh,leesin);</span><br><span class="line">        killThread2.start();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/10/06/how2j/778.png" alt="创建多线程-继承线程类"></p><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><p>创建类Battle，实现Runnable接口<br>启动的时候，首先创建一个Battle对象，然后再根据该battle对象创建一个线程对象，并启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Battle</span> <span class="variable">battle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Battle</span>(gareen,teemo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(battle1).start();</span><br></pre></td></tr></table></figure><p> battle1 对象实现了Runnable接口，所以有run方法，但是直接调用run方法，并不会启动一个新的线程。<br>必须，借助一个线程对象的start()方法，才会启动一个新的线程。<br>所以，在创建Thread对象的时候，把battle1作为构造方法的参数传递进去，这个线程启动的时候，就会去执行battle1.run()方法了。</p><p>例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Battle</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> Hero h1;</span><br><span class="line">    <span class="keyword">private</span> Hero h2;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Battle</span><span class="params">(Hero h1, Hero h2)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.h1 = h1;</span><br><span class="line">        <span class="built_in">this</span>.h2 = h2;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!h2.isDead())&#123;</span><br><span class="line">            h1.attackHero(h2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">        gareen.damage = <span class="number">50</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">300</span>;</span><br><span class="line">        teemo.damage = <span class="number">30</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">500</span>;</span><br><span class="line">        bh.damage = <span class="number">65</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">455</span>;</span><br><span class="line">        leesin.damage = <span class="number">80</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Battle</span> <span class="variable">battle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Battle</span>(gareen,teemo);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(battle1).start();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Battle</span> <span class="variable">battle2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Battle</span>(bh,leesin);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(battle2).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h4><p>使用<a href="https://how2j.cn/k/interface-inheritance/interface-inheritance-inner-class/322.html#step687">匿名类</a>，继承Thread,重写run方法，直接在run方法中写业务代码<br>匿名类的一个好处是可以很方便的访问外部的局部变量。<br>前提是外部的局部变量需要被声明为final。(JDK7以后就不需要了)</p><p>例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">        gareen.damage = <span class="number">50</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">300</span>;</span><br><span class="line">        teemo.damage = <span class="number">30</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">500</span>;</span><br><span class="line">        bh.damage = <span class="number">65</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="type">Hero</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">455</span>;</span><br><span class="line">        leesin.damage = <span class="number">80</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//匿名类</span></span><br><span class="line">        Thread t1= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//匿名类中用到外部的局部变量teemo，必须把teemo声明为final</span></span><br><span class="line">                <span class="comment">//但是在JDK7以后，就不是必须加final的了</span></span><br><span class="line">                <span class="keyword">while</span>(!teemo.isDead())&#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">         </span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// lambda形式</span></span><br><span class="line">        Thread t2= <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(!leesin.isDead())&#123;</span><br><span class="line">                bh.attackHero(leesin);      </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见线程方法"><a href="#常见线程方法" class="headerlink" title="常见线程方法"></a>常见线程方法</h3><table><thead><tr><th align="left">关键字</th><th align="left">简介</th><th align="left">示例代码</th></tr></thead><tbody><tr><td align="left">sleep</td><td align="left">当前线程暂停</td><td align="left"><a href="https://how2j.cn/k/thread/thread-methods/354.html#step781">示例代码</a></td></tr><tr><td align="left">join</td><td align="left">加入到当前线程中</td><td align="left"><a href="https://how2j.cn/k/thread/thread-methods/354.html#step782">示例代码</a></td></tr><tr><td align="left">setPriority</td><td align="left">线程优先级</td><td align="left"><a href="https://how2j.cn/k/thread/thread-methods/354.html#step783">示例代码</a></td></tr><tr><td align="left">yield</td><td align="left">临时暂停</td><td align="left"><a href="https://how2j.cn/k/thread/thread-methods/354.html#step784">示例代码</a></td></tr><tr><td align="left">setDaemon</td><td align="left">守护线程</td><td align="left"><a href="https://how2j.cn/k/thread/thread-methods/354.html#step2403">示例代码</a></td></tr></tbody></table><h4 id="join-加入到当前线程中"><a href="#join-加入到当前线程中" class="headerlink" title="join 加入到当前线程中"></a>join 加入到当前线程中</h4><p>首先解释一下<strong>主线程</strong>的概念<br>所有进程，至少会有一个线程即主线程，即main方法开始执行，就会有一个<strong>看不见</strong>的主线程存在。<br>在42行执行t.join，即表明<strong>在主线程中加入该线程</strong>。<br>主线程会等待该线程结束完毕， 才会往下运行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">        gareen.damage = <span class="number">50</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">300</span>;</span><br><span class="line">        teemo.damage = <span class="number">30</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">500</span>;</span><br><span class="line">        bh.damage = <span class="number">65</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">455</span>;</span><br><span class="line">        leesin.damage = <span class="number">80</span>;</span><br><span class="line">          </span><br><span class="line">        Thread t1= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!teemo.isDead())&#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        t1.start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//代码执行到这里，一直是main线程在运行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//t1线程加入到main线程中来，只有t1线程运行结束，才会继续往下走</span></span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Thread t2= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!leesin.isDead())&#123;</span><br><span class="line">                    bh.attackHero(leesin);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//会观察到盖伦把提莫杀掉后，才运行t2线程</span></span><br><span class="line">        t2.start();</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setPriority-线程优先级"><a href="#setPriority-线程优先级" class="headerlink" title="setPriority 线程优先级"></a>setPriority 线程优先级</h4><p>当线程处于竞争关系的时候，优先级高的线程会有更大的几率获得CPU资源<br>为了演示该效果，要把暂停时间去掉，多条线程各自会尽力去占有CPU资源<br>同时把英雄的血量增加100倍，攻击减低到1，才有足够的时间观察到优先级的演示<br>如图可见，线程1的优先级是MAX_PRIORITY，所以它争取到了更多的CPU资源执行代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackHero</span><span class="params">(Hero h)</span> &#123;</span><br><span class="line">        <span class="comment">//把暂停时间去掉，多条线程各自会尽力去占有CPU资源</span></span><br><span class="line">        <span class="comment">//线程的优先级效果才可以看得出来</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//           </span></span><br><span class="line"><span class="comment">//            Thread.sleep(0);</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            // TODO Auto-generated catch block</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        h.hp-=damage;</span><br><span class="line">        System.out.format(<span class="string">&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;</span>,name,h.name,h.name,h.hp);</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span>(h.isDead())</span><br><span class="line">            System.out.println(h.name +<span class="string">&quot;死了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>&gt;=hp?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">6160</span>;</span><br><span class="line">        gareen.damage = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">3000</span>;</span><br><span class="line">        teemo.damage = <span class="number">1</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">5000</span>;</span><br><span class="line">        bh.damage = <span class="number">1</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">leesin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">4505</span>;</span><br><span class="line">        leesin.damage = <span class="number">1</span>;</span><br><span class="line">          </span><br><span class="line">        Thread t1= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">while</span>(!teemo.isDead())&#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        Thread t2= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!leesin.isDead())&#123;</span><br><span class="line">                    bh.attackHero(leesin);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">         </span><br><span class="line">        t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setDaemon-守护线程"><a href="#setDaemon-守护线程" class="headerlink" title="setDaemon 守护线程"></a>setDaemon 守护线程</h4><p>守护线程的概念是： 当一个进程里，所有的线程都是守护线程的时候，结束当前进程。</p><p>就好像一个公司有销售部，生产部这些和业务挂钩的部门。<br>除此之外，还有后勤，行政等这些支持部门。</p><p>如果一家公司销售部，生产部都解散了，那么只剩下后勤和行政，那么这家公司也可以解散了。</p><p>守护线程就相当于那些支持部门，如果一个进程只剩下守护线程，那么进程就会自动结束。</p><p>守护线程通常会被用来做日志，性能统计等工作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          </span><br><span class="line">        Thread t1= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">seconds</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;已经玩了LOL %d 秒%n&quot;</span>, seconds++);</span><br><span class="line">                     </span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><img src="/2021/10/06/how2j/10/06/how2j/jmm.png" class title="JMM(Java 内存模型)"><img src="/2021/10/06/how2j/10/06/how2j/jmm2.png" class title="JMM(Java 内存模型)强制在主存中进行读取"><p><code>volatile</code> 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p><h4 id="如何禁止指令重排序？"><a href="#如何禁止指令重排序？" class="headerlink" title="如何禁止指令重排序？"></a>如何禁止指令重排序？</h4><p><strong>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><p>在 Java 中，<code>Unsafe</code> 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>理论上来说，你通过这个三个方法也可以实现和<code>volatile</code>禁止重排序一样的效果，只是会麻烦一些。</p><p>下面我以一个常见的面试题为例讲解一下 <code>volatile</code> 关键字禁止指令重排序的效果。</p><p><strong>双重校验锁实现对象单例（线程安全）</strong> ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><h4 id="volatile-可以保证原子性么"><a href="#volatile-可以保证原子性么" class="headerlink" title="volatile 可以保证原子性么"></a>volatile 可以保证原子性么</h4><p><strong><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p><p>我们通过下面的代码即可证明：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatoleAtomicityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatoleAtomicityDemo</span> <span class="variable">volatoleAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatoleAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatoleAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待1.5秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>正常情况下，运行上面的代码理应输出 <code>2500</code>。但你真正运行了上面的代码之后，你会发现每次输出结果都小于 <code>2500</code>。</p><p>为什么会出现这种情况呢？不是说好了，<code>volatile</code> 可以保证变量的可见性嘛！</p><p>也就是说，如果 <code>volatile</code> 能保证 <code>inc++</code> 操作的原子性的话。每个线程中对 <code>inc</code> 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5*500&#x3D;2500。</p><p>但是<code>inc++</code>不是原子操作，实际上，<code>inc++</code> 其实是一个复合操作，包括三步：</p><ol><li>读取 inc 的值。</li><li>对 inc 加 1。</li><li>将 inc 的值写回内存。</li></ol><p><code>volatile</code> 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现：</p><ol><li>线程 1 对 <code>inc</code> 进行读取操作之后，还未对其进行修改。线程 2 又读取了 <code>inc</code>的值并对其进行修改（+1），再将<code>inc</code> 的值写回内存。</li><li>线程 2 操作完毕后，线程 1 对 <code>inc</code>的值进行修改（+1），再将<code>inc</code> 的值写回内存。</li></ol><p>这也就导致两个线程分别对 <code>inc</code> 进行了一次自增操作后，<code>inc</code> 实际上只增加了 1。</p><p>其实，如果想要保证上面的代码运行正确也非常简单，利用 <code>synchronized</code> 、<code>Lock</code>或者<code>AtomicInteger</code>都可以。</p><p>使用 <code>synchronized</code> 改进：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc++;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>使用 <code>AtomicInteger</code> 改进：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">AtomicInteger</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc.getAndIncrement();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>使用 <code>ReentrantLock</code> 改进：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>多线程的同步问题指的是多个线程同时修改一个数据的时候，可能导致的问题，多线程的问题，又叫<strong>Concurrency</strong> 问题。</p><h4 id="synchronized-同步对象概念"><a href="#synchronized-同步对象概念" class="headerlink" title="synchronized 同步对象概念"></a>synchronized 同步对象概念</h4><p>解决上述问题之前，先理解<strong>synchronized</strong>关键字的意义<br>如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">someObject</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (someObject)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//此处的代码只有占有了someObject后才可以执行</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>synchronized表示当前线程，独占 对象 someObject</strong><br>当前线程<strong>独占</strong> 了对象someObject，如果有<strong>其他线程****试图占有对象</strong>someObject，<strong>就会等待</strong>，直到当前线程释放对someObject的占用。<br>someObject 又叫同步对象，所有的对象，都可以作为同步对象<br>为了达到同步的效果，必须使用同一个同步对象</p><p><strong>释放同步对象</strong>的方式： synchronized 块自然结束，或者有异常抛出</p><h4 id="synchronized-和-volatile-的区别？"><a href="#synchronized-和-volatile-的区别？" class="headerlink" title="synchronized 和 volatile 的区别？"></a>synchronized 和 volatile 的区别？</h4><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ul><li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li><li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li><li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li></ul><h4 id="使用synchronized-解决同步问题"><a href="#使用synchronized-解决同步问题" class="headerlink" title="使用synchronized 解决同步问题"></a>使用synchronized 解决同步问题</h4><p>所有需要修改hp的地方，有要<strong>建立在占有someObject的基础上</strong>。<br>而对象 someObject在同一时间，只能被一个线程占有。 间接地，<strong>导致同一时间，hp只能被一个线程</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">someObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">10000</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">  </span><br><span class="line">        Thread[] addThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[n];</span><br><span class="line">        Thread[] reduceThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[n];</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                     </span><br><span class="line">                    <span class="comment">//任何线程要修改hp的值，必须先占用someObject</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (someObject) &#123;</span><br><span class="line">                        gareen.recover();</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            addThreads[i] = t;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    <span class="comment">//任何线程要修改hp的值，必须先占用someObject</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (someObject) &#123;</span><br><span class="line">                        gareen.hurt();</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            reduceThreads[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待所有增加线程结束</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : addThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待所有减少线程结束</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : reduceThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        System.out.printf(<span class="string">&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n&quot;</span>, n,n,gareen.hp);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用hero对象作为同步对象（同步代码块）"><a href="#使用hero对象作为同步对象（同步代码块）" class="headerlink" title="使用hero对象作为同步对象（同步代码块）"></a>使用hero对象作为同步对象（同步代码块）</h4><p>既然任意对象都可以用来作为同步对象，而所有的线程访问的都是同一个hero对象，<strong>索性就使用gareen来作为同步对象</strong><br>进一步的，对于Hero的hurt方法，加上：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示当前对象为同步对象，即也是gareen为同步对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//回血</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">()</span>&#123;</span><br><span class="line">        hp=hp+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//掉血</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hurt</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//使用this作为同步对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            hp=hp-<span class="number">1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>&gt;=hp?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">10000</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">  </span><br><span class="line">        Thread[] addThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[n];</span><br><span class="line">        Thread[] reduceThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[n];</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                     </span><br><span class="line">                    <span class="comment">//使用gareen作为synchronized</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (gareen) &#123;</span><br><span class="line">                        gareen.recover();</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            addThreads[i] = t;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    <span class="comment">//使用gareen作为synchronized</span></span><br><span class="line">                    <span class="comment">//在方法hurt中有synchronized(this)</span></span><br><span class="line">                    gareen.hurt();</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            reduceThreads[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (Thread t : addThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : reduceThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        System.out.printf(<span class="string">&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n&quot;</span>, n,n,gareen.hp);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><p>在recover前，直接加上synchronized ，其所对应的同步对象，就是this<br>和hurt方法达到的效果是一样<br>外部线程访问gareen的方法，就不需要额外使用synchronized 了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//回血</span></span><br><span class="line">    <span class="comment">//直接在方法前加上修饰符synchronized</span></span><br><span class="line">    <span class="comment">//其所对应的同步对象，就是this</span></span><br><span class="line">    <span class="comment">//和hurt方法达到的效果一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">()</span>&#123;</span><br><span class="line">        hp=hp+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//掉血</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hurt</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//使用this作为同步对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            hp=hp-<span class="number">1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackHero</span><span class="params">(Hero h)</span> &#123;</span><br><span class="line">        h.hp-=damage;</span><br><span class="line">        System.out.format(<span class="string">&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;</span>,name,h.name,h.name,h.hp);</span><br><span class="line">        <span class="keyword">if</span>(h.isDead())</span><br><span class="line">            System.out.println(h.name +<span class="string">&quot;死了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>&gt;=hp?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">10000</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">  </span><br><span class="line">        Thread[] addThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[n];</span><br><span class="line">        Thread[] reduceThreads = <span class="keyword">new</span> <span class="title class_">Thread</span>[n];</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                     </span><br><span class="line">                    <span class="comment">//recover自带synchronized</span></span><br><span class="line">                    gareen.recover();</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            addThreads[i] = t;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    <span class="comment">//hurt自带synchronized</span></span><br><span class="line">                    gareen.hurt();</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            reduceThreads[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (Thread t : addThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : reduceThreads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        System.out.printf(<span class="string">&quot;%d个增加线程和%d个减少线程结束后%n盖伦的血量是 %.0f%n&quot;</span>, n,n,gareen.hp);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修饰类-线程安全的类"><a href="#修饰类-线程安全的类" class="headerlink" title="修饰类 线程安全的类"></a>修饰类 线程安全的类</h4><p>如果一个类，其<strong>方法都是有synchronized修饰的</strong>，那么该类就叫做<strong>线程安全的类</strong></p><p>同一时间，只有一个线程能够进入 <strong>这种类的一个实例</strong> 的去修改数据，进而保证了这个实例中的数据的安全(不会同时被多线程修改而变成脏数据)</p><p>比如StringBuffer和StringBuilder的区别<br>StringBuffer的方法都是有synchronized修饰的，StringBuffer就叫做线程安全的类<br>而StringBuilder就不是线程安全的类</p><img src="/2021/10/06/how2j/10/06/how2j/793.png" class title="线程安全的类"><h4 id="把非线程安全的集合转换为线程安全"><a href="#把非线程安全的集合转换为线程安全" class="headerlink" title="把非线程安全的集合转换为线程安全"></a>把非线程安全的集合转换为线程安全</h4><p>ArrayList是非线程安全的，换句话说，多个线程可以同时进入<strong>一个ArrayList对象</strong>的add方法</p><p>借助Collections.synchronizedList，可以把ArrayList转换为线程安全的List。</p><p>与此类似的，还有HashSet,LinkedList,HashMap等等非线程安全的类，都通过<a href="https://how2j.cn/k/collection/collection-collections/369.html">工具类Collections</a>转换为线程安全的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list2 = Collections.synchronizedList(list1);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>例：</p><ol><li>线程1 首先占有对象1，接着试图占有对象2</li><li>线程2 首先占有对象2，接着试图占有对象1</li><li>线程1 等待线程2释放对象2</li><li>与此同时，线程2等待线程1释放对象1<br>就会。。。一直等待下去，直到天荒地老，海枯石烂，山无棱 ，天地合。。。</li></ol><img src="/2021/10/06/how2j/10/06/how2j/794.png" class title="演示死锁"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">ahri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        ahri.name = <span class="string">&quot;九尾妖狐&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">annie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        annie.name = <span class="string">&quot;安妮&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//占有九尾妖狐</span></span><br><span class="line">                <span class="keyword">synchronized</span> (ahri) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1 已占有九尾妖狐&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//停顿1000毫秒，另一个线程有足够的时间占有安妮</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    System.out.println(<span class="string">&quot;t1 试图占有安妮&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1 等待中 。。。。&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (annie) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  </span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//占有安妮</span></span><br><span class="line">                <span class="keyword">synchronized</span> (annie) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2 已占有安妮&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">//停顿1000毫秒，另一个线程有足够的时间占有暂用九尾妖狐</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2 试图占有九尾妖狐&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2 等待中 。。。。&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (ahri) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  </span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交互——wait、notify"><a href="#交互——wait、notify" class="headerlink" title="交互——wait、notify"></a>交互——wait、notify</h3><p>例：</p><p>线程之间有<strong>交互通知</strong>的需求，考虑如下情况：<br>有两个线程，处理同一个英雄。<br>一个加血，一个减血。</p><p>减血的线程，发现血量&#x3D;1，就停止减血，直到加血的线程为英雄加了血，才可以继续减血</p><h4 id="使用wait和notify进行线程交互"><a href="#使用wait和notify进行线程交互" class="headerlink" title="使用wait和notify进行线程交互"></a>使用wait和notify进行线程交互</h4><p>在Hero类中：hurt()减血方法：当hp&#x3D;1的时候，执行this.wait().<br>this.wait()<strong>表示 让占有this的线程等待，并临时释放占有</strong><br>进入hurt方法的线程必然是减血线程，this.wait()会让减血线程临时释放对this的占有。 <strong>这样加血线程，就有机会进入recover()加血方法了</strong>。<br>recover() 加血方法：增加了血量，执行this.notify();<br>this.notify() 表示通知那些<strong>等待在this的线程</strong>，可以苏醒过来了。 等待在this的线程，恰恰就是减血线程。 一旦recover()结束， 加血线程释放了this，减血线程，就可以重新占有this，并执行后面的减血工作。</p><img src="/2021/10/06/how2j/10/06/how2j/796.png" class title="使用wait和notify进行线程交互"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">()</span> &#123;</span><br><span class="line">        hp = hp + <span class="number">1</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s 回血1点,增加血后，%s的血量是%.0f%n&quot;</span>, name, name, hp);</span><br><span class="line">        <span class="comment">// 通知那些等待在this对象上的线程，可以醒过来了，如第20行，等待着的减血线程，苏醒过来</span></span><br><span class="line">        <span class="built_in">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">hurt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hp == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 让占有this的减血线程，暂时释放对this的占有，并等待</span></span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        hp = hp - <span class="number">1</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s 减血1点,减少血后，%s的血量是%.0f%n&quot;</span>, name, name, hp);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackHero</span><span class="params">(Hero h)</span> &#123;</span><br><span class="line">        h.hp -= damage;</span><br><span class="line">        System.out.format(<span class="string">&quot;%s 正在攻击 %s, %s的血变成了 %.0f%n&quot;</span>, name, h.name, h.name, h.hp);</span><br><span class="line">        <span class="keyword">if</span> (h.isDead())</span><br><span class="line">            System.out.println(h.name + <span class="string">&quot;死了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &gt;= hp ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Hero</span> <span class="variable">gareen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">             </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                       </span><br><span class="line">                    <span class="comment">//无需循环判断</span></span><br><span class="line"><span class="comment">//                    while(gareen.hp==1)&#123;</span></span><br><span class="line"><span class="comment">//                        continue;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                       </span><br><span class="line">                    gareen.hurt();</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">   </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    gareen.recover();</span><br><span class="line">   </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于wait、notify和notifyAll"><a href="#关于wait、notify和notifyAll" class="headerlink" title="关于wait、notify和notifyAll"></a>关于wait、notify和notifyAll</h4><p>留意wait()和notify() 这两个方法是什么对象上的？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">hurt</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  。。。</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.wait();</span><br><span class="line"></span><br><span class="line">  。。。</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">   。。。</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.notify();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要强调的是，wait方法和notify方法，并<strong>不是Thread线程上的方法</strong>，它们是Object上的方法。</p><p>因为所有的Object都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法。</p><p>wait()的意思是： 让占用了这个同步对象的<strong>线程</strong>，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，<strong>一定是在synchronized块里，否则就会出错</strong>。</p><p>notify() 的意思是，通知<strong>一个</strong>等待在这个同步对象上的线程，<strong>你</strong>可以苏醒过来了，有机会重新占用当前对象了。</p><p>notifyAll() 的意思是，通知<strong>所有的</strong>等待在这个同步对象上的线程，<strong>你们</strong>可以苏醒过来了，有机会重新占用当前对象了。</p><h4 id="sleep-方法和-wait-方法对比"><a href="#sleep-方法和-wait-方法对比" class="headerlink" title="sleep() 方法和 wait() 方法对比"></a>sleep() 方法和 wait() 方法对比</h4><p><strong>共同点</strong> ：两者都可以暂停线程的执行。</p><p><strong>区别</strong> ：</p><ul><li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li><li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li></ul><h4 id="为什么-wait-方法不定义在-Thread-中？"><a href="#为什么-wait-方法不定义在-Thread-中？" class="headerlink" title="为什么 wait() 方法不定义在 Thread 中？"></a>为什么 wait() 方法不定义在 Thread 中？</h4><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p><p>类似的问题：<strong>为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</strong></p><p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>每一个线程的启动和结束都是比较消耗时间和占用资源的。</p><p>如果在系统中用到了很多的线程，大量的启动和结束动作会导致系统的性能变卡，响应变慢。</p><p>为了解决这个问题，引入线程池这种设计思想。</p><p>线程池的模式很像<a href="https://how2j.cn/k/thread/thread-wait-notify/358.html#step2591">生产者消费者模式</a>，消费的对象是一个一个的能够运行的<strong>任务</strong>。</p><h4 id="线程池设计思路"><a href="#线程池设计思路" class="headerlink" title="线程池设计思路"></a>线程池设计思路</h4><p>线程池的思路和<a href="https://how2j.cn/k/thread/thread-wait-notify/358.html#step2591">生产者消费者模型</a>是很接近的。</p><ol><li><p>准备一个任务容器</p></li><li><p>一次性启动10个 消费者线程</p></li><li><p>刚开始任务容器是空的，所以线程都<strong>wait</strong>在上面。</p></li><li><p>直到一个外部线程往这个任务容器中扔了一个“任务”，就会有一个消费者线程被唤醒notify</p></li><li><p>这个消费者线程取出“任务”，并且<strong>执行这个任务</strong>，执行完毕后，继续等待下一次任务的到来。</p></li><li><p>如果短时间内，有较多的任务加入，那么就会有多个线程被<strong>唤醒</strong>，去执行这些任务。</p></li></ol><p>在整个过程中，都不需要创建新的线程，而是<strong>循环使用这些已经存在的线程</strong>。</p><h4 id="开发一个自定义线程池"><a href="#开发一个自定义线程池" class="headerlink" title="开发一个自定义线程池"></a>开发一个自定义线程池</h4><p>这是一个自定义的线程池，虽然不够完善和健壮，但是已经足以说明线程池的工作原理</p><p>创造一个情景，每个任务执行的时间都是1秒<br>刚开始是间隔1秒钟向线程池中添加任务</p><p>然后间隔时间越来越短，执行任务的线程还没有来得及结束，新的任务又来了。<br>就会观察到线程池里的其他线程被唤醒来执行这些任务</p><img src="/2021/10/06/how2j/10/06/how2j/image-20220920114116086.png" class title="image-20220920114116086"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 线程池大小</span></span><br><span class="line">    <span class="type">int</span> threadPoolSize;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 任务容器</span></span><br><span class="line">    LinkedList&lt;Runnable&gt; tasks = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Runnable&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 试图消费任务的线程</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        threadPoolSize = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 启动10个任务消费者线程</span></span><br><span class="line">        <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadPoolSize; i++) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TaskConsumeThread</span>(<span class="string">&quot;任务消费者线程 &quot;</span> + i).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">            tasks.add(r);</span><br><span class="line">            <span class="comment">// 唤醒等待的任务消费者线程</span></span><br><span class="line">            tasks.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TaskConsumeThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TaskConsumeThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        Runnable task;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;启动： &quot;</span> + <span class="built_in">this</span>.getName());</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (tasks.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            tasks.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    task = tasks.removeLast();</span><br><span class="line">                    <span class="comment">// 允许添加任务的线程可以继续添加任务</span></span><br><span class="line">                    tasks.notifyAll();</span><br><span class="line">  </span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot; 获取到任务，并执行&quot;</span>);</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadPool pool= <span class="keyword">new</span> <span class="title class_">ThreadPool</span>();</span><br><span class="line">        <span class="type">int</span> sleep=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            pool.add(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">//System.out.println(&quot;执行任务&quot;);</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(sleep);</span><br><span class="line">                sleep = sleep&gt;<span class="number">100</span>?sleep-<span class="number">100</span>:sleep;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用java自带线程池"><a href="#使用java自带线程池" class="headerlink" title="使用java自带线程池"></a>使用java自带线程池</h4><p>java提供自带的线程池，而不需要自己去开发一个自定义线程池了。</p><p>线程池类<strong>ThreadPoolExecutor</strong>在包<strong>java.util.concurrent</strong>下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPool= <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">15</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure><p><strong>第一个</strong>参数10 表示这个线程池<strong>初始化了10个</strong>线程在里面工作<br><strong>第二个</strong>参数15 表示如果10个线程不够用了，就会自动增加到<strong>最多15个线程</strong><br><strong>第三个</strong>参数60 结合第四个参数TimeUnit.SECONDS，表示经过<strong>60秒</strong>，多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个<br><strong>第四个</strong>参数TimeUnit.SECONDS 如上<br><strong>第五个</strong>参数 new LinkedBlockingQueue() 用来放任务的集合</p><p><strong>execute</strong>方法用于添加新的任务。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">           </span><br><span class="line">        ThreadPoolExecutor threadPool= <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">15</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">           </span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                System.out.println(<span class="string">&quot;任务1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">               </span><br><span class="line">        &#125;);</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lock对象"><a href="#Lock对象" class="headerlink" title="Lock对象"></a>Lock对象</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Lock是一个接口，为了使用一个Lock对象，需要用到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure><p>与 <strong>synchronized (someObject)</strong> 类似的，<strong>lock()<strong>方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。<br>与 <strong>synchronized</strong> 不同的是，一旦synchronized 块结束，就会自动释放对</strong>someObject</strong>的占用。 lock却必须调用<strong>unlock</strong>方法进行手动释放，为了保证释放的执行，往往会把unlock() 放在finally中进行。</p><img src="/2021/10/06/how2j/10/06/how2j/2611.png" class title="使用Lock对象实现同步效果"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">now</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s %s %s %n&quot;</span>, now() , Thread.currentThread().getName() , msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line"> </span><br><span class="line">                    lock.lock();</span><br><span class="line"> </span><br><span class="line">                    log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"> </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先让t1飞2秒</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line"> </span><br><span class="line">                    lock.lock();</span><br><span class="line"> </span><br><span class="line">                    log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"> </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trylock方法"><a href="#trylock方法" class="headerlink" title="trylock方法"></a>trylock方法</h4><p>synchronized 是<strong>不占用到手不罢休</strong>的，会一直试图占用下去。与 synchronized 的<strong>钻牛角尖</strong>不一样，Lock接口还提供了一个trylock方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.tryLock(<span class="number">1</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>trylock会在指定时间范围内<strong>试图占用</strong>，占成功了，就啪啪啪。 如果时间到了，还占用不成功，扭头就走~</p><p>注意： 因为使用trylock有可能成功，有可能失败，所以后面unlock释放锁的时候，需要判断是否占用成功了，如果没占用成功也unlock,就会抛出异常。</p><img src="/2021/10/06/how2j/10/06/how2j/image-20220927095221974.png" class title="image-20220927095221974"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">now</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s %s %s %n&quot;</span>, now() , Thread.currentThread().getName() , msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line">                    <span class="comment">// 模拟在规定时间未占用</span></span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    <span class="comment">// 获取对象时间设置为1秒</span></span><br><span class="line">                    locked = lock.tryLock(<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line">                    <span class="keyword">if</span>(locked)&#123;</span><br><span class="line">                        log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                        log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        log(<span class="string">&quot;经过1秒钟的努力，还没有占有对象，放弃占有&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(locked)&#123;</span><br><span class="line">                        log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先让t1飞2秒</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    locked = lock.tryLock(<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line">                    <span class="keyword">if</span>(locked)&#123;</span><br><span class="line">                        log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                        log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        log(<span class="string">&quot;经过1秒钟的努力，还没有占有对象，放弃占有&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(locked)&#123;</span><br><span class="line">                        log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程交互"><a href="#线程交互" class="headerlink" title="线程交互"></a>线程交互</h4><p>使用synchronized方式进行线程交互，用到的是同步对象的<strong>wait,notify和notifyAll方法</strong></p><p>Lock也提供了类似的解决办法，首先通过lock对象得到一个Condition对象，然后分别调用这个Condition对象的：<strong>await</strong>, <strong>signal</strong>,<strong>signalAll</strong> 方法</p><p><strong>注意</strong>： 不是Condition对象的wait,nofity,notifyAll方法,是await,signal,signalAll</p><img src="/2021/10/06/how2j/10/06/how2j/2617.png" class title="线程交互"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">now</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s %s %s %n&quot;</span>, now() , Thread.currentThread().getName() , msg);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">         </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line">  </span><br><span class="line">                    lock.lock();</span><br><span class="line">  </span><br><span class="line">                    log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    log(<span class="string">&quot;临时释放对象 lock， 并等待&quot;</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                    log(<span class="string">&quot;重新占有对象 lock，并进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先让t1飞2秒</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line">  </span><br><span class="line">                    lock.lock();</span><br><span class="line">  </span><br><span class="line">                    log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    log(<span class="string">&quot;唤醒等待中的线程&quot;</span>);</span><br><span class="line">                    condition.signal();</span><br><span class="line">  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lock和synchronized的区别"><a href="#Lock和synchronized的区别" class="headerlink" title="Lock和synchronized的区别"></a>Lock和synchronized的区别</h4><ol><li><strong>两者都是可重入锁</strong></li></ol><p><strong>“可重入锁” 指的是自己可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p><ol start="2"><li><p><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong>，Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。</p></li><li><p>Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。</p></li><li><p>synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。</p></li><li><p><strong>ReentrantLock 比 synchronized 增加了一些高级功能</strong></p><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul></li></ol><h3 id="原子访问"><a href="#原子访问" class="headerlink" title="原子访问"></a>原子访问</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p><p>所谓的<strong>原子性操作</strong>即不可中断的操作，比如赋值操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">count += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>原子性操作本身是线程安全的</strong></p><p>但是 count++ 这个行为，至少需要三条 CPU 指令:</p><ol><li>首先，需要把变量 count 从内存加载到 CPU 的寄存器；</li><li>之后，在寄存器中执行 +1 操作；</li><li>最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li></ol><img src="/2021/10/06/how2j/10/06/how2j/b64543a98226cffc05735d3d67367a99f703eaa1.png" class title="img"><p>这三个步骤，每一步都是一个原子操作，但是合在一起，就不是原子操作。就<strong>不是线程安全</strong>的。</p><p>换句话说，一个线程在步骤1 取icount的值结束后，还没有来得及进行步骤2，另一个线程也可以取 count的值了。</p><p>这也是<a href="https://how2j.cn/k/thread/thread-synchronized/355.html#step787">分析同步问题产生的原因</a> 中的原理。i++ ，i–， i &#x3D; i+1 这些都是非原子性操作。只有int i &#x3D; 1,这个赋值操作是原子性的。</p><h4 id="AtomicInteger（原子类）"><a href="#AtomicInteger（原子类）" class="headerlink" title="AtomicInteger（原子类）"></a>AtomicInteger（原子类）</h4><p>JDK6 以后，新增加了一个包<strong>java.util.concurrent.atomic</strong>，里面有各种原子类，比如<strong>AtomicInteger</strong>。<br>而AtomicInteger提供了各种自增，自减等方法，这些方法都是原子性的。 换句话说，自增方法 <strong>incrementAndGet</strong> 是线程安全的，同一个时间，只有一个线程可以调用这个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicI</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> atomicI.decrementAndGet();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> atomicI.incrementAndGet();</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> atomicI.addAndGet(<span class="number">3</span>);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>分别使用基本变量的非原子性的**++<strong>运算符和 原子性的</strong>AtomicInteger对象的 incrementAndGet** 来进行多线程测试。<br>测试结果如图所示</p><img src="/2021/10/06/how2j/10/06/how2j/2626.png" class title="同步测试"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicValue</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">        Thread[] ts1 = <span class="keyword">new</span> <span class="title class_">Thread</span>[number];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    value++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts1[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//等待这些线程全部结束</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : ts1) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.printf(<span class="string">&quot;%d个线程进行value++后，value的值变成:%d%n&quot;</span>, number,value);</span><br><span class="line">        Thread[] ts2 = <span class="keyword">new</span> <span class="title class_">Thread</span>[number];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    atomicValue.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts2[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//等待这些线程全部结束</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : ts2) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d个线程进行atomicValue.incrementAndGet();后，atomicValue的值变成:%d%n&quot;</span>, number,atomicValue.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="使用Statement"><a href="#使用Statement" class="headerlink" title="使用Statement"></a>使用Statement</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">                <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>); <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from hero&quot;</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 执行查询语句，并把结果集返回给ResultSet</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> s.executeQuery(sql);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);<span class="comment">// 可以使用字段名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>);<span class="comment">// 也可以使用字段的顺序</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">hp</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;hp&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">damage</span> <span class="operator">=</span> rs.getInt(<span class="number">4</span>);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t%s\t%f\t%d%n&quot;</span>, id, name, hp, damage);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不一定要在这里关闭ReultSet，因为Statement关闭的时候，会自动关闭ResultSet</span></span><br><span class="line">            <span class="comment">// rs.close();</span></span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用PreparedStatement"><a href="#使用PreparedStatement" class="headerlink" title="使用PreparedStatement"></a>使用PreparedStatement</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into hero values(null,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql);</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// Statement需要进行字符串拼接，可读性和维修性比较差</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql0</span> <span class="operator">=</span> <span class="string">&quot;insert into hero values(null,&quot;</span> + <span class="string">&quot;&#x27;提莫&#x27;&quot;</span> + <span class="string">&quot;,&quot;</span> + <span class="number">313.0f</span> + <span class="string">&quot;,&quot;</span> + <span class="number">50</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            s.execute(sql0);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// PreparedStatement 使用参数设置，可读性好，不易犯错</span></span><br><span class="line">            <span class="comment">// &quot;insert into hero values(null,?,?,?)&quot;;</span></span><br><span class="line">            ps.setString(<span class="number">1</span>, <span class="string">&quot;提莫&quot;</span>);</span><br><span class="line">            ps.setFloat(<span class="number">2</span>, <span class="number">313.0f</span>);</span><br><span class="line">            ps.setInt(<span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line">            ps.execute();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>参数设置</li></ul><blockquote><p><strong>Statement</strong> 需要进行字符串拼接，可读性和维护性比较差</p><p>String sql &#x3D; “insert into hero values(null,”+”‘提莫’”+”,”+313.0f+”,”+50+”)”;</p><p> <strong>PreparedStatement</strong> 使用参数设置，可读性好，不易犯错</p><p>String sql &#x3D; “insert into hero values(null,?,?,?)”;</p></blockquote><ul><li>性能表现</li></ul><p>PreparedStatement有预编译机制，性能比Statement更快</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// Statement执行10次，需要10次把SQL语句传输到数据库端</span></span><br><span class="line">            <span class="comment">// 数据库要对每一次来的SQL语句进行编译处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">sql0</span> <span class="operator">=</span> <span class="string">&quot;insert into hero values(null,&quot;</span> + <span class="string">&quot;&#x27;提莫&#x27;&quot;</span> + <span class="string">&quot;,&quot;</span></span><br><span class="line">                        + <span class="number">313.0f</span> + <span class="string">&quot;,&quot;</span> + <span class="number">50</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                s.execute(sql0);</span><br><span class="line">            &#125;</span><br><span class="line">            s.close();</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// PreparedStatement 执行10次，只需要1次把SQL语句传输到数据库端</span></span><br><span class="line">            <span class="comment">// 数据库对带?的SQL进行预编译</span></span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 每次执行，只需要传输参数到数据库端</span></span><br><span class="line">            <span class="comment">// 1. 网络传输量比Statement更小</span></span><br><span class="line">            <span class="comment">// 2. 数据库不需要再进行编译，响应更快</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                ps.setString(<span class="number">1</span>, <span class="string">&quot;提莫&quot;</span>);</span><br><span class="line">                ps.setFloat(<span class="number">2</span>, <span class="number">313.0f</span>);</span><br><span class="line">                ps.setInt(<span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line">                ps.execute();</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>防止SQL注入式攻击</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from hero where name = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">                <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql);</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 假设name是用户提交来的数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&#x27;盖伦&#x27; OR 1=1&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql0</span> <span class="operator">=</span> <span class="string">&quot;select * from hero where name = &quot;</span> + name;</span><br><span class="line">            <span class="comment">// 拼接出来的SQL语句就是</span></span><br><span class="line">            <span class="comment">// select * from hero where name = &#x27;盖伦&#x27; OR 1=1</span></span><br><span class="line">            <span class="comment">// 因为有OR 1=1，所以恒成立</span></span><br><span class="line">            <span class="comment">// 那么就会把所有的英雄都查出来，而不只是盖伦</span></span><br><span class="line">            <span class="comment">// 如果Hero表里的数据是海量的，比如几百万条，把这个表里的数据全部查出来</span></span><br><span class="line">            <span class="comment">// 会让数据库负载变高，CPU100%，内存消耗光，响应变得极其缓慢</span></span><br><span class="line">            System.out.println(sql0);</span><br><span class="line">  </span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs0</span> <span class="operator">=</span> s.executeQuery(sql0);</span><br><span class="line">            <span class="keyword">while</span> (rs0.next()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">heroName</span> <span class="operator">=</span> rs0.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                System.out.println(heroName);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            s.execute(sql0);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 使用预编译Statement就可以杜绝SQL注入</span></span><br><span class="line">  </span><br><span class="line">            ps.setString(<span class="number">1</span>, name);</span><br><span class="line">  </span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line">            <span class="comment">// 查不出数据出来</span></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">heroName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                System.out.println(heroName);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="execute与executeUpdate的区别"><a href="#execute与executeUpdate的区别" class="headerlink" title="execute与executeUpdate的区别"></a>execute与executeUpdate的区别</h3><p><strong>execute</strong>与<strong>executeUpdate</strong>的相同点：都可以执行增加，删除，修改。</p><p>不同1：<br>execute<strong>可以执行查询语句</strong>，然后通过getResultSet，把结果集取出来；<br>executeUpdate<strong>不能执行查询语句；</strong><br>不同2:<br>execute<strong>返回boolean类型</strong>，true表示执行的是查询语句，false表示执行的是insert,delete,update等等；<br>executeUpdate<strong>返回的是int</strong>，表示有多少条数据受到了影响；</p><h3 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h3><h4 id="获取自增长id"><a href="#获取自增长id" class="headerlink" title="获取自增长id"></a>获取自增长id</h4><p>通过<strong>Statement</strong>的<strong>getGeneratedKeys</strong>获取该id;</p><blockquote><p><strong>注：</strong> 第20行的代码，后面加了个<strong>Statement.RETURN_GENERATED_KEYS</strong>参数，以确保会返回自增长ID。 通常情况下不需要加这个，有的时候需要加，所以先加上，保险一些</p><p><code>PreparedStatement ps = c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into hero values(null,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">                <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> c.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);          </span><br><span class="line">                ) &#123;</span><br><span class="line">  </span><br><span class="line">            ps.setString(<span class="number">1</span>, <span class="string">&quot;盖伦&quot;</span>);</span><br><span class="line">            ps.setFloat(<span class="number">2</span>, <span class="number">616</span>);</span><br><span class="line">            ps.setInt(<span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line">   </span><br><span class="line">            <span class="comment">// 执行插入语句</span></span><br><span class="line">            ps.execute();</span><br><span class="line">   </span><br><span class="line">            <span class="comment">// 在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id</span></span><br><span class="line">            <span class="comment">// JDBC通过getGeneratedKeys获取该id</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.getGeneratedKeys();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">                System.out.println(id);</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取表的元数据"><a href="#获取表的元数据" class="headerlink" title="获取表的元数据"></a>获取表的元数据</h4><p>元数据概念：<br>和数据库服务器相关的数据，比如数据库版本，有哪些表，表有哪些字段，字段类型是什么等等。</p><img src="/2021/10/06/how2j/10/06/how2j/878.png" class title="获取表的元数据"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);) &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 查看数据库层面的元数据</span></span><br><span class="line">            <span class="comment">// 即数据库服务器版本，驱动版本，都有哪些数据库等等</span></span><br><span class="line">  </span><br><span class="line">            <span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> c.getMetaData();</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取数据库服务器产品名称</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库产品名称:\t&quot;</span>+dbmd.getDatabaseProductName());</span><br><span class="line">            <span class="comment">// 获取数据库服务器产品版本号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库产品版本:\t&quot;</span>+dbmd.getDatabaseProductVersion());</span><br><span class="line">            <span class="comment">// 获取数据库服务器用作类别和表名之间的分隔符 如test.user</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库和表分隔符:\t&quot;</span>+dbmd.getCatalogSeparator());</span><br><span class="line">            <span class="comment">// 获取驱动版本</span></span><br><span class="line">            System.out.println(<span class="string">&quot;驱动版本:\t&quot;</span>+dbmd.getDriverVersion());</span><br><span class="line">  </span><br><span class="line">            System.out.println(<span class="string">&quot;可用的数据库列表：&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取数据库名称</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> dbmd.getCatalogs();</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库名称:\t&quot;</span>+rs.getString(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h3><p>在Mysql中，只有当表的类型是INNODB的时候，才支持事务，所以需要把表的类型设置为INNODB,否则无法观察到事务.</p><p>修改表的类型为INNODB的SQL：<code>alter table hero ENGINE  = innodb;</code></p><p>查看表的类型的SQL：<code>show table status from how2java; </code></p><p>不过有个前提，就是当前的MYSQL服务器本身要支持INNODB,如果不支持，请看 <a href="https://how2j.cn/k/mysql/mysql-innodb/1064.html">开启MYSQL INNODB的办法</a></p><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>在事务中的多个操作，<strong>要么都成功，要么都失败</strong><br>通过 c.setAutoCommit(false);<strong>关闭自动提交</strong><br>使用 c.commit();进行<strong>手动提交</strong><br>在22行-35行之间的数据库操作，就处于同一个事务当中，要么都成功，要么都失败<br>所以，虽然第一条SQL语句是可以执行的，但是第二条SQL语句有错误，其结果就是两条SQL语句<strong>都没有被提交</strong>。 除非两条SQL语句都是正确的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">s</span> <span class="operator">=</span> c.createStatement();) &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 有事务的前提下</span></span><br><span class="line">            <span class="comment">// 在事务中的多个操作，要么都成功，要么都失败</span></span><br><span class="line">  </span><br><span class="line">            c.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 加血的SQL</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update hero set hp = hp +1 where id = 22&quot;</span>;</span><br><span class="line">            s.execute(sql1);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 减血的SQL</span></span><br><span class="line">            <span class="comment">// 不小心写错写成了 updata(而非update)</span></span><br><span class="line">  </span><br><span class="line">            <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;updata hero set hp = hp -1 where id = 22&quot;</span>;</span><br><span class="line">            s.execute(sql2);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 手动提交</span></span><br><span class="line">            c.commit();</span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><h4 id="数据库连接池原理-传统方式"><a href="#数据库连接池原理-传统方式" class="headerlink" title="数据库连接池原理-传统方式"></a>数据库连接池原理-传统方式</h4><p>当有多个线程，每个线程都需要连接数据库执行SQL语句的话，那么每个线程都会创建一个连接，并且在使用完毕后，关闭连接。</p><p>创建连接和关闭连接的过程也是比较消耗时间的，当多线程并发的时候，系统就会变得很卡顿。</p><p>同时，一个数据库同时支持的连接总数也是有限的，如果多线程并发量很大，那么数据库连接的总数就会被消耗光，后续线程发起的数据库连接就会失败。</p><img src="/2021/10/06/how2j/10/06/how2j/2654.png" class title="数据库连接池原理-传统方式"><h4 id="数据库连接池原理-使用池"><a href="#数据库连接池原理-使用池" class="headerlink" title="数据库连接池原理-使用池"></a>数据库连接池原理-使用池</h4><p>与传统方式不同，连接池在使用之前，就会创建好一定数量的连接。<br>如果有任何线程需要使用连接，那么就从连接池里面<strong>借用</strong>，<strong>而不是自己重新创建</strong>.<br>使用完毕后，又把这个连接<strong>归还</strong>给连接池供下一次或者其他线程使用。<br>倘若发生多线程并发情况，连接池里的连接被<strong>借用光</strong>了，那么其他线程就会临时等待，直到有连接被<strong>归还</strong>回来，再继续使用。<br>整个过程，这些连接都<strong>不会被关闭</strong>，而是不断的被循环使用，从而节约了启动和关闭连接的时间。</p><img src="/2021/10/06/how2j/10/06/how2j/2655.png" class title="数据库连接池原理-使用池"><h4 id="ConnectionPool构造方法和初始化"><a href="#ConnectionPool构造方法和初始化" class="headerlink" title="ConnectionPool构造方法和初始化"></a>ConnectionPool构造方法和初始化</h4><ol><li><p>ConnectionPool() 构造方法约定了这个连接池一共有多少连接</p></li><li><p>在init() 初始化方法中，创建了size条连接。 注意，这里不能使用try-with-resource这种自动关闭连接的方式，因为连接恰恰需要保持不关闭状态，供后续循环使用</p></li><li><p>getConnection， 判断是否为空，如果是空的就wait等待，否则就借用一条连接出去</p></li><li><p>returnConnection， 在使用完毕后，归还这个连接到连接池，并且在归还完毕后，调用notifyAll，通知那些等待的线程，有新的连接可以借用了。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;</span><br><span class="line">  </span><br><span class="line">    List&lt;Connection&gt; cs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Connection&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConnectionPool</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//这里恰恰不能使用try-with-resource的方式，因为这些连接都需要是&quot;活&quot;的，不要被自动关闭了</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> DriverManager</span><br><span class="line">                        .getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">  </span><br><span class="line">                cs.add(c);</span><br><span class="line">  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (cs.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> cs.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">returnConnection</span><span class="params">(Connection c)</span> &#123;</span><br><span class="line">        cs.add(c);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><p>首先初始化一个有3条连接的数据库连接池<br>然后创建100个线程，每个线程都会从连接池中<strong>借用连接</strong>，并且在借用之后，归还连接。 拿到连接之后，执行一个耗时1秒的SQL语句。</p><p>运行程序，就可以观察到如图所示的效果;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConnectionPool</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConnectionPool</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionPool</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">WorkingThread</span>(<span class="string">&quot;working thread&quot;</span> + i, cp).start();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkingThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ConnectionPool cp;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WorkingThread</span><span class="params">(String name, ConnectionPool cp)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.cp = cp;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> cp.getConnection();</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getName()+ <span class="string">&quot;:\t 获取了一根连接，并开始工作&quot;</span>  );</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> c.createStatement())&#123;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//模拟时耗１秒的数据库ＳＱＬ语句</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            st.execute(<span class="string">&quot;select * from hero&quot;</span>);</span><br><span class="line">   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException | InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        cp.returnConnection(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h2><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="IP地址-端口"><a href="#IP地址-端口" class="headerlink" title="IP地址 端口"></a>IP地址 端口</h3><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>在网络中每台计算机都必须有一个的IP地址；<br>32位，4个字节，常用点分十进制的格式表示，例如：192.168.1.100<br>127.0.0.1 是固定ip地址，代表当前计算机，相当于面向对象里的 “<strong>this</strong>“</p><img src="/2021/10/06/how2j/10/06/how2j/880.png" class title="IP地址"><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>两台计算机进行连接，总有一台服务器，一台客户端。<br>服务器和客户端之间的通信通过端口进行。如图：</p><p>ip地址是 192.168.1.100的服务器通过端口 8080<br>与ip地址是192.168.1.189的客户端 的1087端口通信</p><img src="/2021/10/06/how2j/10/06/how2j/881.png" class title="端口"><h4 id="获取本机IP"><a href="#获取本机IP" class="headerlink" title="获取本机IP"></a>获取本机IP</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSocket</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">host</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span>host.getHostAddress();</span><br><span class="line">        System.out.println(<span class="string">&quot;本机ip地址：&quot;</span> + ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用java-执行ping命令"><a href="#使用java-执行ping命令" class="headerlink" title="使用java 执行ping命令"></a>使用java 执行ping命令</h4><p>借助 Runtime.getRuntime().exec() 可以运行一个windows的exe程序<br>如图，使用java运行 <strong>ping 192.168.2.106</strong>，返回这样的字符串</p><img src="/2021/10/06/how2j/10/06/how2j/2718.png" class title="使用java 执行ping命令"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSocket</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;ping &quot;</span> + <span class="string">&quot;192.168.2.106&quot;</span>);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(p.getInputStream()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.length() != <span class="number">0</span>)</span><br><span class="line">                sb.append(line + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;本次指令返回的消息是：&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>使用 Socket(套接字)进行不同的程序之间的通信;</p><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><ol><li>服务端开启8888端口，并监听着，时刻等待着客户端的连接请求</li><li>客户端知道服务端的ip地址和监听端口号，发出请求到服务端，客户端的端口地址是系统分配的，通常都会大于1024</li></ol><p>一旦建立了连接，服务端会得到一个新的Socket对象，该对象负责与客户端进行通信。</p><p><strong>注意：</strong> 在开发调试的过程中，如果修改过了服务器Server代码，要关闭启动的Server,否则新的Server不能启动，因为8888端口被占用了</p><img src="/2021/10/06/how2j/10/06/how2j/882.png" class title="建立连接"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//服务端打开端口8888</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">               </span><br><span class="line">            <span class="comment">//在8888端口上监听，看是否有连接请求过来</span></span><br><span class="line">            System.out.println(<span class="string">&quot;监听在端口号:8888&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span>  ss.accept();</span><br><span class="line">               </span><br><span class="line">            System.out.println(<span class="string">&quot;有连接过来&quot;</span> + s);</span><br><span class="line">             </span><br><span class="line">            s.close();</span><br><span class="line">            ss.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//连接到本机的8888端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            s.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收发数字"><a href="#收发数字" class="headerlink" title="收发数字"></a>收发数字</h4><p>一旦建立了连接，服务端和客户端就可以通过Socket进行通信了</p><ol><li>客户端打开输出流，并发送数字 110</li><li>服务端打开输入流，接受数字 110，并打印</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;监听在端口号:8888&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//打开输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//读取客户端发送的数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">msg</span> <span class="operator">=</span> is.read();</span><br><span class="line">            <span class="comment">//打印出来</span></span><br><span class="line">            System.out.println(msg);</span><br><span class="line">            is.close();</span><br><span class="line"> </span><br><span class="line">            s.close();</span><br><span class="line">            ss.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 打开输出流</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 发送数字110到服务端</span></span><br><span class="line">            os.write(<span class="number">110</span>);</span><br><span class="line">            os.close();</span><br><span class="line"> </span><br><span class="line">            s.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收发字符串"><a href="#收发字符串" class="headerlink" title="收发字符串"></a>收发字符串</h4><p>直接使用字节流收发字符串比较麻烦，使用<a href="https://how2j.cn/k/io/io-datastream/350.html#step771">数据流</a>对字节流进行封装，这样收发字符串就容易了</p><ol><li>把输出流封装在DataOutputStream中，使用writeUTF发送字符串 “Legendary!”</li><li>把输入流封装在DataInputStream，使用readUTF读取字符串,并打印</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;监听在端口号:8888&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"> </span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//把输入流封装在DataInputStream</span></span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="comment">//使用readUTF读取字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">            dis.close();</span><br><span class="line">            s.close();</span><br><span class="line">            ss.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————————————————</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//把输出流封装在DataOutputStream中</span></span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line">            <span class="comment">//使用writeUTF发送字符串</span></span><br><span class="line">            dos.writeUTF(<span class="string">&quot;Legendary!&quot;</span>);</span><br><span class="line">            dos.close();</span><br><span class="line">            s.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程聊天"><a href="#多线程聊天" class="headerlink" title="多线程聊天"></a>多线程聊天</h3><p>如果使用单线程开发Socket应用，那么同一时间，要么收消息，要么发消息，不能同时进行。</p><p>为了实现<strong>同时收发消息</strong>，就需要用到多线程；</p><h4 id="同时收发消息"><a href="#同时收发消息" class="headerlink" title="同时收发消息"></a>同时收发消息</h4><p>在<a href="https://how2j.cn/k/socket/socket-socket/400.html#step2737">练习-服务端和客户端互聊</a> 中，只能一人说一句，说了之后，必须等待另一个人的回复，才能说下一句。</p><p>这是因为接受和发送都在主线程中，不能同时进行。 为了实现同时收发消息，基本设计思路是把收发分别放在不同的线程中进行</p><ol><li>SendThread 发送消息线程</li><li>RecieveThread 接受消息线程</li><li>Server一旦接受到连接，就启动收发两个线程</li><li>Client 一旦建立了连接，就启动收发两个线程</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 发送线程</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Socket s;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SendThread</span><span class="params">(Socket s)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">                dos.writeUTF(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"># 接收线程</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecieveThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Socket s;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RecieveThread</span><span class="params">(Socket s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line"> </span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"># </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;监听在端口号:8888&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//启动发送消息线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SendThread</span>(s).start();</span><br><span class="line">            <span class="comment">//启动接受消息线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RecieveThread</span>(s).start();</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 启动发送消息线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SendThread</span>(s).start();</span><br><span class="line">            <span class="comment">// 启动接受消息线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RecieveThread</span>(s).start();</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JAVA高级"><a href="#JAVA高级" class="headerlink" title="JAVA高级"></a>JAVA高级</h1><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p><strong>Java 反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制。</strong>也就是说，反射本质上是一个“反着来”的过程。我们通过new创建一个类的实例时，实际上是由Java虚拟机根据这个类的Class对象在运行时构建出来的，而反射是通过一个类的Class对象来获取它的定义信息，从而我们可以访问到它的属性、方法，知道这个类的父类、实现了哪些接口等信息。</p><p>要想解剖一个类，必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法。所以先要获取到每一个字节码文件对应的Class类型的对象。</p><p><strong>反射就是把java类中的各种成分映射成一个个的Java对象</strong>。<br>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把一个个组成部分映射成一个个对象。（其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）</p><p>加载的时候：<strong>Class对象的由来是将 .class 文件读入内存，并为之创建一个Class对象。</strong></p><pre><code>    Class类    Class 类的实例表示正在运行的 Java 应用程序中的类和接口。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型）    Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass 方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。    我们知道Spring框架可以帮我们创建和管理对象。需要对象时，我们无需自己手动new对象，直接从Spring提供的容器中的Beans获取即可。Beans底层其实就是一个Map&lt;String,Object&gt;，最终通过getBean(“user”)来获取。而这其中最核心的实现就是利用反射技术。       Bean        1、Java面向对象，对象有方法和属性，那么就需要对象实例来调用方法和属性（即实例化）；    2、凡是有方法或属性的类都需要实例化，这样才能具象化去使用这些方法和属性；    3、规律：凡是子类及带有方法或属性的类都要加上注册Bean到Spring IoC的注解；（@Component , @Repository , @ Controller , @Service , @Configration）    4、把Bean理解为类的代理或代言人（实际上确实是通过反射、代理来实现的），这样它就能代表类拥有该拥有的东西了    5、在Spring中，你标识一个@符号，那么Spring就会来看看，并且从这里拿到一个Bean（注册）或者给出一个Bean（使用）</code></pre><p><strong>反射机制有什么用？</strong></p><p>通过java语言中的反射机制可以操作字节码文件（可以读和修改<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&spm=1001.2101.3001.7020">字节码</a>文件。）<br>通过反射机制可以操作代码片段。（class文件。）</p><p><strong>反射机制的相关类在哪个包下？</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.reflect.*;</span><br></pre></td></tr></table></figure><p><strong>反射机制相关的重要的类有哪些？</strong></p><table><thead><tr><th>类</th><th>含义</th></tr></thead><tbody><tr><td>java.lang.Class</td><td>java.lang.Class</td></tr><tr><td>java.lang.reflect.Method</td><td>代表字节码中的方法字节码。代表类中的方法。</td></tr><tr><td>java.lang.reflect.Constructor</td><td>代表字节码中的构造方法字节码。代表类中的构造方法。</td></tr><tr><td>java.lang.reflect.Field</td><td>代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。</td></tr></tbody></table><blockquote><p><strong>注</strong>：<strong>必须先获得Class才能获取Method、Constructor、Field</strong>。</p></blockquote><p><strong>Class类方法</strong></p><table><thead><tr><th>方法名</th><th>备注</th></tr></thead><tbody><tr><td>public T <strong>newInstance</strong>()</td><td>创建对象</td></tr><tr><td>public String <strong>getName</strong>()</td><td>返回完整类名带包名</td></tr><tr><td>public String <strong>getSimpleName</strong>()</td><td>返回类名</td></tr><tr><td>public Field[] <strong>getFields</strong>()</td><td>返回类中public修饰的属性</td></tr><tr><td>public Field[] <strong>getDeclaredFields</strong>()</td><td>返回类中所有的属性</td></tr><tr><td>public Field <strong>getDeclaredField</strong>(String name)</td><td>根据属性名name获取指定的属性</td></tr><tr><td>public native int <strong>getModifiers</strong>()</td><td>获取属性的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td></tr><tr><td>public Method[] <strong>getDeclaredMethods</strong>()</td><td>返回类中所有的实例方法</td></tr><tr><td>public Method <strong>getDeclaredMethod</strong>(String name, Class&lt;?&gt;… parameterTypes)</td><td>根据方法名name和方法形参获取指定方法</td></tr><tr><td>public Constructor&lt;?&gt;[] <strong>getDeclaredConstructors</strong>()</td><td>返回类中所有的构造方法</td></tr><tr><td>public Constructor <strong>getDeclaredConstructor</strong>(Class&lt;?&gt;… parameterTypes)</td><td>根据方法形参获取指定的构造方法</td></tr><tr><td>public native Class&lt;? super T&gt; <strong>getSuperclass</strong>()</td><td>返回调用类的父类</td></tr><tr><td>public Class&lt;?&gt;[] <strong>getInterfaces</strong>()</td><td>返回调用类实现的接口集合</td></tr></tbody></table><h3 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h3><p>类对象概念： 所有的类，都存在一个<strong>类对象</strong>，这个类对象用于提供<strong>类本身</strong>的信息，比如有几种构造方法， 有多少属性，有哪些普通方法。</p><h4 id="获取Class的方式"><a href="#获取Class的方式" class="headerlink" title="获取Class的方式"></a>获取Class的方式</h4><p>要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java.lang.Class实例？</p><table><thead><tr><th>方式</th><th>备注</th></tr></thead><tbody><tr><td>Class.forName(“完整类名带包名”)</td><td>静态方法</td></tr><tr><td>对象.getClass()</td><td></td></tr><tr><td>任何类型.class</td><td></td></tr></tbody></table><p><strong>案例：</strong></p><ol><li>Class.forName</li><li>Hero.class</li><li>new Hero().getClass()</li></ol><p>在一个JVM中，一种类，只会有一个类对象存在。所以以上三种方式取出来的类对象，都是一样的。</p><p><strong>注：</strong> 准确的讲是一个ClassLoader下，一种类，只会有一个类对象存在。通常一个JVM下，只会有一个ClassLoader。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 类路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;charactor.Hero&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class pClass1=Class.forName(className);</span><br><span class="line">                Class pClass2=Hero.class;</span><br><span class="line">                Class pClass3=<span class="keyword">new</span> <span class="title class_">Hero</span>().getClass();</span><br><span class="line">                System.out.println(pClass1==pClass2);</span><br><span class="line">                System.out.println(pClass1==pClass3);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDBC重点-Class-forName导致类加载"><a href="#JDBC重点-Class-forName导致类加载" class="headerlink" title="JDBC重点(Class.forName导致类加载)"></a>JDBC重点(Class.forName导致类加载)</h4><p>如果你只是希望一个类的<strong>静态代码块</strong>执行，其它代码一律不执行，可以使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;完整类名&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个方法的执行会导致<strong>类加载</strong>，类加载时，静态代码块执行。其他两种方式不执行。</p><p><strong>案例：</strong></p><img src="/2021/10/06/how2j/10/06/how2j/2708.png" class title="获取类对象的时候，会导致类属性被初始化"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 实体类</span><br><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> String copyright;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化 copyright&quot;</span>);</span><br><span class="line">        copyright = <span class="string">&quot;版权由Riot Games公司所有&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"># 测试类</span><br><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;charactor.Hero&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class pClass1=Class.forName(className);</span><br><span class="line">                Class pClass2=Hero.class;</span><br><span class="line">                Class pClass3=<span class="keyword">new</span> <span class="title class_">Hero</span>().getClass();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在静态方法上加synchronized，同步对象是什么？"><a href="#在静态方法上加synchronized，同步对象是什么？" class="headerlink" title="在静态方法上加synchronized，同步对象是什么？"></a>在静态方法上加synchronized，同步对象是什么？</h4><p>静态方法被修饰为synchronized的时候，其同步对象就是当前类的类对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread t1= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//调用method1</span></span><br><span class="line">                TestReflection.method1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(<span class="string">&quot;第一个线程&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//保证第一个线程先调用method1</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">         </span><br><span class="line">        Thread t2= <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//调用method2</span></span><br><span class="line">                TestReflection.method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(<span class="string">&quot;第二个线程&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">synchronized</span> (TestReflection.class) &#123;</span><br><span class="line">            <span class="comment">// 对于method1而言，同步对象是TestReflection.class，只有占用TestReflection.class才可以执行到这里</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入了method1方法&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;运行5秒&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> </span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 对于mehotd2而言，必然有个同步对象，通过观察发现，当某个线程在method1中，占用了TestReflection.class之后</span></span><br><span class="line">        <span class="comment">// 就无法进入method2，推断出，method2的同步对象，就是TestReflection.class</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入了method2方法&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;运行5秒&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//传统的使用new的方式创建对象</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        h1.name = <span class="string">&quot;teemo&quot;</span>;</span><br><span class="line">        System.out.println(h1);</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用反射的方式创建对象</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;charactor.Hero&quot;</span>;</span><br><span class="line">            <span class="comment">//类对象</span></span><br><span class="line">            Class pClass=Class.forName(className);</span><br><span class="line">            <span class="comment">//构造器</span></span><br><span class="line">            Constructor c= pClass.getConstructor();</span><br><span class="line">            <span class="comment">//通过构造器实例化</span></span><br><span class="line">            Hero h2= (Hero) c.newInstance();</span><br><span class="line">            h2.name=<span class="string">&quot;gareen&quot;</span>;</span><br><span class="line">            System.out.println(h2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p><strong>Field类方法</strong></p><table><thead><tr><th>方法名</th><th>备注</th></tr></thead><tbody><tr><td>public String <strong>getName</strong>()</td><td>返回属性名</td></tr><tr><td>public int <strong>getModifiers</strong>()</td><td>获取属性的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td></tr><tr><td>public Class&lt;?&gt; <strong>getType</strong>()</td><td>以Class类型，返回属性类型【一般配合Class类的getSimpleName()方法使用】</td></tr><tr><td>public void <strong>set</strong>(Object obj, Object value)</td><td>设置属性值</td></tr><tr><td>public Object <strong>get</strong>(Object obj)</td><td>读取属性值</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 实体类</span><br><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        name =string;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero [name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackHero</span><span class="params">(Hero h2)</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name+ <span class="string">&quot; 正在攻击 &quot;</span> + h2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"># 测试类访问属性</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">            <span class="comment">//使用传统方式修改name的值为garen</span></span><br><span class="line">            h.name = <span class="string">&quot;garen&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取类Hero的名字叫做name的字段</span></span><br><span class="line">                Field f1= h.getClass().getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="comment">//修改这个字段的值</span></span><br><span class="line">                f1.set(h, <span class="string">&quot;teemo&quot;</span>);</span><br><span class="line">                <span class="comment">//打印被修改后的值</span></span><br><span class="line">                System.out.println(h.name);</span><br><span class="line">                 </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注：</strong> Field类中set()、get()使用注意事项：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">属性.set(对象, 值);</span><br><span class="line"></span><br><span class="line">属性.get(对象);</span><br></pre></td></tr></table></figure></blockquote><h4 id="getField和getDeclaredField的区别"><a href="#getField和getDeclaredField的区别" class="headerlink" title="getField和getDeclaredField的区别"></a>getField和getDeclaredField的区别</h4><p>这两个方法都是用于获取字段<br><code>getField</code> <strong>只能获取</strong>public的，包括<strong>从父类继承</strong>来的字段。<br><code>getDeclaredField</code> 可以获取本类所有的字段，<strong>包括private</strong>的，但是<strong>不能获取继承</strong>来的字段。 (<strong>注</strong>： 这里只能获取到private的<strong>字段</strong>，但并不能访问该private字段的<strong>值</strong>,除非加上**<code>setAccessible(true)</code>**</p><table><thead><tr><th>方法</th><th>备注</th></tr></thead><tbody><tr><td>public void <strong>setAccessible</strong>(boolean flag)</td><td>默认false，设置为true为打破封装</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以访问私有的属性吗？</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> studentClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 打破封装（反射机制的缺点：打破封装，可能会给不法分子留下机会！！！）</span></span><br><span class="line"><span class="comment">// 这样设置完之后，在外部也是可以访问private的。</span></span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 给name属性赋值</span></span><br><span class="line">nameField.set(nameField.getConstructor().newInstance(), <span class="string">&quot;xiaowu&quot;</span>);</span><br><span class="line"><span class="comment">// 获取name属性的值</span></span><br><span class="line">System.out.println(nameField.get(obj));</span><br></pre></td></tr></table></figure><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><table><thead><tr><th>方法名</th><th>备注</th></tr></thead><tbody><tr><td>public String <strong>getName</strong>()</td><td>返回方法名</td></tr><tr><td>public int <strong>getModifiers</strong>()</td><td>获取方法的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td></tr><tr><td>public Class&lt;?&gt; <strong>getReturnType</strong>()</td><td>以Class类型，返回方法类型【一般配合Class类的getSimpleName()方法使用】</td></tr><tr><td>public Class&lt;?&gt;[] <strong>getParameterTypes</strong>()</td><td>返回方法的修饰符列表（一个方法的参数可能会有多个。）【结果集一般配合Class类的getSimpleName()方法使用】</td></tr><tr><td>public Object <strong>invoke</strong>(Object obj, Object… args)</td><td>调用方法</td></tr></tbody></table><blockquote><p><strong>注：</strong> Method类中invoke()使用注意事项：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法.invoke(对象, 实参);</span><br></pre></td></tr></table></figure></blockquote><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 实体类</span><br><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> damage;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        name =string;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero [name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackHero</span><span class="params">(Hero h2)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"># 测试类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取这个名字叫做setName，参数类型是String的方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> h.getClass().getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">            <span class="comment">// 对h对象，调用这个方法</span></span><br><span class="line">            m.invoke(h, <span class="string">&quot;盖伦&quot;</span>);</span><br><span class="line">            <span class="comment">// 使用传统的方式，调用getName方法</span></span><br><span class="line">            System.out.println(h.getName());</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><table><thead><tr><th>方法名</th><th>备注</th></tr></thead><tbody><tr><td>public String <strong>getName</strong>()</td><td>返回构造方法名</td></tr><tr><td>public int <strong>getModifiers</strong>()</td><td>获取构造方法的修饰符列表,返回的修饰符是一个数字，每个数字是修饰符的代号【一般配合Modifier类的toString(int x)方法使用】</td></tr><tr><td>public Class&lt;?&gt;[] <strong>getParameterTypes</strong>()</td><td>返回构造方法的修饰符列表（一个方法的参数可能会有多个。）【结果集一般配合Class类的getSimpleName()方法使用】</td></tr><tr><td>public T <strong>newInstance</strong>(Object … initargs)</td><td>创建对象【参数为创建对象的数据】</td></tr></tbody></table><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">反编译一个类的Constructor构造方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectTest11</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javase.reflectBean.Vip&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public class UserService &#123;</span></span><br><span class="line">        s.append(Modifier.toString(vipClass.getModifiers()));</span><br><span class="line">        s.append(<span class="string">&quot; class &quot;</span>);</span><br><span class="line">        s.append(vipClass.getSimpleName());</span><br><span class="line">        s.append(<span class="string">&quot;&#123;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Constructor[] constructors = vipClass.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors)&#123;</span><br><span class="line">            <span class="comment">//public Vip(int no, String name, String birth, boolean sex) &#123;</span></span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            s.append(Modifier.toString(c.getModifiers()));</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">//            s.append(c.getName());//包名+类名</span></span><br><span class="line">            s.append(vipClass.getSimpleName());<span class="comment">//类名</span></span><br><span class="line">            s.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            Class[] parameterTypes = c.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++)&#123;</span><br><span class="line">                s.append(parameterTypes[i].getSimpleName());</span><br><span class="line">                <span class="keyword">if</span> (i != parameterTypes.length - <span class="number">1</span> ) s.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.append(<span class="string">&quot;)&#123;&#125;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="基本内置注解"><a href="#基本内置注解" class="headerlink" title="基本内置注解"></a>基本内置注解</h3><ul><li><p>@Override 用在方法上，表示这个方法重写了父类的方法，如toString()。如果父类没有这个方法，那么就无法编译通过。</p></li><li><p>@Deprecated 表示这个方法已经过期，不建议开发者使用。(暗示在将来某个不确定的版本，就有可能会取消掉)，被注解为过期，在调用的时候，就会受到提示。</p></li><li><p>@SuppressWarnings Suppress英文的意思是抑制的意思，这个注解的用处是忽略警告信息。<br>比如大家使用集合的时候，有时候为了偷懒，会不写泛型，像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">heros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure><p>那么就会导致编译器出现警告，而加上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unused&quot; &#125;)</span></span><br></pre></td></tr></table></figure><p>就对这些警告进行了<strong>抑制</strong>，即忽略掉这些警告信息。</p><p>@SuppressWarnings 有常见的值，分别对应如下意思</p><ul><li>deprecation：使用了不赞成使用的类或方法时的警告(使用@Deprecated使得编译器产生的警告)；</li><li>unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 关闭编译器警告</li><li>fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;</li><li>path：在类路径、源文件路径等中有不存在的路径时的警告;</li><li>serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告;</li><li>finally：任何 finally 子句不能正常完成时的警告;</li><li>rawtypes 泛型类型未指明</li><li>unused 引用定义了，但是没有被使用</li><li>all：关于以上所有情况的警告。</li></ul></li><li><p>@SafeVarargs 这是1.7 之后新加入的基本注解. 如例所示，当使用可变数量的参数的时候，而参数的类型又是泛型T的话，就会出现警告。 这个时候，就使用@SafeVarargs来去掉这个警告</p><p>@SafeVarargs注解只能用在参数长度可变的方法或构造方法上，且方法必须声明为static或final，否则会出现编译错误。一个方法使用@SafeVarargs注解的前提是，开发人员必须确保这个方法的实现中对泛型类型参数的处理不会引发类型安全问题。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getFirstOne</span><span class="params">(T... elements)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elements.length &gt; <span class="number">0</span> ? elements[<span class="number">0</span>] : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@FunctionalInterface这是Java1.8 新增的注解，用于约定函数式接口。<br>函数式接口概念： 如果接口中只有一个抽象方法（可以包含多个默认方法或多个static方法），该接口称为函数式接口。函数式接口其存在的意义，主要是配合Lambda 表达式来使用。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adAttack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>在本例中，把数据库连接的工具类DBUtil改造成为注解的方式，来举例演示怎么自定义注解以及如何解析这些自定义注解。</p><p>首先创建一个注解JDBCConfig：</p><ol><li><p>创建注解类型的时候即不使用class也不使用interface,而是使用**<code>@interface</code>**</p></li><li><p>元注解<br><strong><code>@Target(&#123;METHOD,TYPE&#125;)</code></strong> 表示这个注解可以用用在类&#x2F;接口上，还可以用在方法上<br><strong><code>@Retention(RetentionPolicy.RUNTIME)</code></strong> 表示这是一个运行时注解，即运行起来之后，才获取注解中的相关信息，而不像基本注解如<a href="https://how2j.cn/k/annotation/annotation-system/1060.html#step4028">@Override </a>那种不用运行，在编译时eclipse就可以进行相关工作的编译时注解。<br><strong><code>@Inherited</code></strong> 表示这个注解可以被子类继承<br><strong><code>@Documented</code></strong> 表示当执行javadoc的时候，本注解会生成相关文档</p></li><li><p>注解元素，这些注解元素就用于存放注解信息，在解析的时候获取出来</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.METHOD;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.TYPE;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Target(&#123;METHOD,TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JDBCConfig &#123;</span><br><span class="line">     String <span class="title function_">ip</span><span class="params">()</span>;</span><br><span class="line">     <span class="type">int</span> <span class="title function_">port</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">3306</span>;</span><br><span class="line">     String <span class="title function_">database</span><span class="params">()</span>;</span><br><span class="line">     String <span class="title function_">encoding</span><span class="params">()</span>;</span><br><span class="line">     String <span class="title function_">loginName</span><span class="params">()</span>;</span><br><span class="line">     String <span class="title function_">password</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> anno.JDBCConfig;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@JDBCConfig(ip = &quot;127.0.0.1&quot;, database = &quot;test&quot;, encoding = &quot;UTF-8&quot;, loginName = &quot;root&quot;, password = &quot;admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtil</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, NoSuchMethodException, SecurityException &#123;</span><br><span class="line">        <span class="comment">// 通过反射，获取这个DBUtil这个类上的注解对象</span></span><br><span class="line">        <span class="type">JDBCConfig</span> <span class="variable">config</span> <span class="operator">=</span> DBUtil.class.getAnnotation(JDBCConfig.class);</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> config.ip();</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> config.port();</span><br><span class="line">        <span class="type">String</span> <span class="variable">database</span> <span class="operator">=</span> config.database();</span><br><span class="line">        <span class="type">String</span> <span class="variable">encoding</span> <span class="operator">=</span> config.encoding();</span><br><span class="line">        <span class="type">String</span> <span class="variable">loginName</span> <span class="operator">=</span> config.loginName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> config.password();</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> String.format(<span class="string">&quot;jdbc:mysql://%s:%d/%s?characterEncoding=%s&quot;</span>, ip, port, database, encoding);</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, loginName, password);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException, SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> getConnection();</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul><li><p>@Target 表示这个注解能放在什么位置上，是只能放在类上？还是即可以放在方法上，又可以放在属性上。自定义注解@JDBCConfig这个注解上的@Target是：@Target({METHOD,TYPE})，表示他可以用在方法和类型上（类和接口），但是不能放在属性等其他位置。 可以选择的位置列表如</p><ul><li><code>ElementType.TYPE</code>：能修饰类、接口或枚举类型</li><li><code>ElementType.FIELD</code>：能修饰成员变量</li><li><code>ElementType.METHOD</code>：能修饰方法</li><li><code>ElementType.PARAMETER</code>：能修饰参数</li><li><code>ElementType.CONSTRUCTOR</code>：能修饰构造器</li><li><code>ElementType.LOCAL_VARIABLE</code>：能修饰局部变量</li><li><code>ElementType.ANNOTATION_TYPE</code>：能修饰注解</li><li><code>ElementType.PACKAGE</code>：能修饰包</li></ul></li><li><p>@Retention 表示生命周期，<a href="https://how2j.cn/k/annotation/annotation-customize/1056.html#step4035">自定义注解@JDBCConfig</a> 上的值是 RetentionPolicy.RUNTIME, 表示可以在运行的时候依然可以使用。 @Retention可选的值有3个：</p><ul><li><strong><code>RetentionPolicy.SOURCE</code>：</strong> 注解只在源代码中存在，编译成class之后，就没了。<a href="https://how2j.cn/k/annotation/annotation-system/1060.html#step4028">@Override </a>就是这种注解。</li><li><strong><code>RetentionPolicy.CLASS</code>：</strong> 注解在java文件编程成.class文件后，依然存在，但是运行起来后就没了。@Retention的默认值，即当没有显式指定@Retention的时候，就会是这种类型。</li><li><strong><code>RetentionPolicy.RUNTIME</code>：</strong> 注解在运行起来之后依然存在，程序可以通过反射获取这些信息，<a href="https://how2j.cn/k/annotation/annotation-customize/1056.html#step4035">自定义注解@JDBCConfig</a> 就是这样。</li></ul></li><li><p>@Inherited 表示该注解具有继承性。如例，设计一个DBUtil的子类，其getConnection2方法，可以获取到父类DBUtil上的注解信息。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtilChild</span> <span class="keyword">extends</span> <span class="title class_">DBUtil</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, NoSuchMethodException, SecurityException &#123;</span><br><span class="line">        <span class="type">JDBCConfig</span> <span class="variable">config</span> <span class="operator">=</span> DBUtilChild.class.getAnnotation(JDBCConfig.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> config.ip();</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> config.port();</span><br><span class="line">        <span class="type">String</span> <span class="variable">database</span> <span class="operator">=</span> config.database();</span><br><span class="line">        <span class="type">String</span> <span class="variable">encoding</span> <span class="operator">=</span> config.encoding();</span><br><span class="line">        <span class="type">String</span> <span class="variable">loginName</span> <span class="operator">=</span> config.loginName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> config.password();</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> String.format(<span class="string">&quot;jdbc:mysql://%s:%d/%s?characterEncoding=%s&quot;</span>, ip, port, database, encoding);</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, loginName, password);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException, SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">c</span> <span class="operator">=</span> getConnection2();</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>@Documented 如图所示， 在用javadoc命令生成API文档后，DBUtil的文档里会出现该注解说明。</p></li><li><p>@Repeatable (java1.8 新增)，</p></li><li><p>当没有@Repeatable修饰的时候，注解在同一个位置，只能出现一次，如例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JDBCConfig(ip = &quot;127.0.0.1&quot;, database = &quot;test&quot;, encoding = &quot;UTF-8&quot;, loginName = &quot;root&quot;, password = &quot;admin&quot;)</span></span><br><span class="line"><span class="meta">@JDBCConfig(ip = &quot;127.0.0.1&quot;, database = &quot;test&quot;, encoding = &quot;UTF-8&quot;, loginName = &quot;root&quot;, password = &quot;admin&quot;)</span></span><br></pre></td></tr></table></figure><p>重复做两次就会报错了。<br>使用<code>@Repeatable</code>之后，再配合一些其他动作，就可以在同一个地方使用多次了。</p></li></ul><p><strong>案例：</strong></p><p>比如在练习<a href="https://how2j.cn/k/io/io-filecopy-foldercopy/344.html#step2491">练习-查找文件内容</a> 中有一个要求，即查找文件后缀名是.java的文件，我们把部分代码修改为注解，并且使用@Repeatable 这个元注解来表示，文件后缀名的范围可以是java, html, css, js 等等。</p><p>为了紧凑起见，把注解作为内部类的形式放在一个文件里。</p><ol><li>注解FileTypes，其value()返回一个FileType数组。</li><li>注解FileType，其@Repeatable的值采用FileTypes。</li><li>运用注解：在work方法上重复使用多次@FileType注解。</li><li>解析注解： 在work方法内，通过反射获取到本方法上的FileType类型的注解数组，然后遍历本数组。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindFiles</span> &#123;</span><br><span class="line">    <span class="meta">@Target( METHOD)</span></span><br><span class="line">    <span class="meta">@Retention( RetentionPolicy.RUNTIME )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> FileTypes &#123;</span><br><span class="line">        FileType[] value();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Target(  METHOD )</span></span><br><span class="line">    <span class="meta">@Retention( RetentionPolicy.RUNTIME )</span></span><br><span class="line">    <span class="meta">@Repeatable( FileTypes.class )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> FileType &#123;</span><br><span class="line">        String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@FileType( &quot;.java&quot; )</span></span><br><span class="line">    <span class="meta">@FileType( &quot;.html&quot; )</span></span><br><span class="line">    <span class="meta">@FileType( &quot;.css&quot; )</span></span><br><span class="line">    <span class="meta">@FileType( &quot;.js&quot; )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileType[] fileTypes= <span class="built_in">this</span>.getClass().getMethod(<span class="string">&quot;work&quot;</span>).getAnnotationsByType(FileType.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;将从如下后缀名的文件中查找文件内容&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (FileType fileType : fileTypes) &#123;</span><br><span class="line">                System.out.println(fileType.value());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;查找过程略。。。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | SecurityException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FindFiles</span>().work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仿Hibernate注解"><a href="#仿Hibernate注解" class="headerlink" title="仿Hibernate注解"></a>仿Hibernate注解</h3><p><a href="https://how2j.cn/k/annotation/annotation-like-hibernate/1058.html">注解系列教材 （五）- 仿Hibernate注解 (how2j.cn)</a></p><h1 id="JAVA应用"><a href="#JAVA应用" class="headerlink" title="JAVA应用"></a>JAVA应用</h1><h2 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ol><li>基于类的名称获取日志对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(TestLog4j.class);</span><br></pre></td></tr></table></figure><ol start="2"><li>进行默认配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BasicConfigurator.configure();</span><br></pre></td></tr></table></figure><ol start="3"><li>设置日志输出级别</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.setLevel(Level.DEBUG);</span><br></pre></td></tr></table></figure><ol start="4"><li>进行不同级别的日志输出</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.trace(<span class="string">&quot;跟踪信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&quot;调试信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">&quot;输出信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">logger.warn(<span class="string">&quot;警告信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">logger.error(<span class="string">&quot;错误信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">logger.fatal(<span class="string">&quot;致命信息&quot;</span>);</span><br></pre></td></tr></table></figure><p>Thread.sleep(1000); 是为了便于观察前后日志输出的时间差</p><h3 id="配置文件设置Log4j"><a href="#配置文件设置Log4j" class="headerlink" title="配置文件设置Log4j"></a>配置文件设置Log4j</h3><p>方式不同，采用指定配置文件</p><ul><li>log4j.properties</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 设置日志输出的等级为debug,低于debug就不会输出了</span><br><span class="line"># 设置日志输出到两种地方，分别叫做 stdout和 R</span><br><span class="line">log4j.rootLogger=debug, stdout, R</span><br><span class="line">    </span><br><span class="line"># 第一个地方stdout, 输出到控制台</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">    </span><br><span class="line"># 输出格式是 %5p [%t] (%F:%L) - %m%n  </span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] (%F:%L) - %m%n</span><br><span class="line"></span><br><span class="line"># 第二个地方R, 以滚动的方式输出到文件，文件名是example.log,文件最大100k, 最多滚动<span class="number">5</span>个文件</span><br><span class="line">log4j.appender.R=org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.R.File=example.log</span><br><span class="line">log4j.appender.R.MaxFileSize=100KB</span><br><span class="line">log4j.appender.R.MaxBackupIndex=<span class="number">5</span></span><br><span class="line">    </span><br><span class="line"># 输出格式是 %p %t %c - %m%n</span><br><span class="line">log4j.appender.R.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n</span><br></pre></td></tr></table></figure><blockquote><p>log4j日志输出格式一览：<br>    <code>%c</code> 输出日志信息所属的类的全名<br>    <code>%d </code>输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy-MM-dd HH:mm:ss }，输出类似：2002-10-18- 22：10：28<br>    <code>%f </code>输出日志信息所属的类的类名<br>    <code>%l</code> 输出日志事件的发生位置，即输出日志信息的语句处于它所在的类的第几行<br>    <code>%m</code> 输出代码中指定的信息，如log(message)中的message<br>    <code>%n</code> 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”<br>    <code>%p</code> 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL。如果是调用debug()输出的，则为DEBUG，依此类推<br>    <code>%r </code>输出自应用启动到输出该日志信息所耗费的毫秒数<br>    <code>%t</code> 输出产生该日志事件的线程名</p><p>所以：<br><code>%5p [%t] (%F:%L) - %m%n </code>就表示<br>宽度是5的优先等级 线程名称 (文件名:行号) - 信息 回车换行</p></blockquote><ul><li>测试类TestLog4j<ul><li>然后修改TestLog4j，并运行。 有两个效果<ol><li>输出在控制台，并且格式有所变化，如图所示，会显示是哪个类的哪一行输出的信息</li><li>不仅仅在控制台有输出，在把日志输出到了 E:\project\log4j\example.log 这个位置</li></ol></li></ul></li></ul><img src="/2021/10/06/how2j/10/06/how2j/4163.png" class title="TestLog4j"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> log4j;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.PropertyConfigurator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLog4j</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(TestLog4j.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// Log4j的配置方式按照log4j.properties中的设置进行</span></span><br><span class="line">        PropertyConfigurator.configure(<span class="string">&quot;e:\\project\\log4j\\src\\log4j.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;跟踪信息&quot;</span>);</span><br><span class="line">            logger.debug(<span class="string">&quot;调试信息&quot;</span>);</span><br><span class="line">            logger.info(<span class="string">&quot;输出信息&quot;</span>);</span><br><span class="line">            logger.warn(<span class="string">&quot;警告信息&quot;</span>);</span><br><span class="line">            logger.error(<span class="string">&quot;错误信息&quot;</span>);</span><br><span class="line">            logger.fatal(<span class="string">&quot;致命信息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="xml形式配置Log4j"><a href="#xml形式配置Log4j" class="headerlink" title="xml形式配置Log4j"></a>xml形式配置Log4j</h3><ul><li>log4j.xml</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE log4j:configuration PUBLIC <span class="string">&quot;-//log4j/log4j Configuration//EN&quot;</span> <span class="string">&quot;log4j.dtd&quot;</span>&gt;</span><br><span class="line">  </span><br><span class="line">&lt;log4j:configuration xmlns:log4j=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span><br><span class="line">      </span><br><span class="line">    &lt;appender name=<span class="string">&quot;STDOUT&quot;</span> class=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span><br><span class="line">       &lt;layout class=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span><br><span class="line">          &lt;param name=<span class="string">&quot;ConversionPattern&quot;</span> value=<span class="string">&quot;%d %-5p %c.%M:%L - %m%n&quot;</span>/&gt;</span><br><span class="line">       &lt;/layout&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;!-- specify the logging level <span class="keyword">for</span> loggers from other libraries --&gt;</span><br><span class="line">    &lt;logger name=<span class="string">&quot;com.opensymphony&quot;</span>&gt;</span><br><span class="line">        &lt;level value=<span class="string">&quot;ERROR&quot;</span> /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;logger name=<span class="string">&quot;org.apache&quot;</span>&gt;</span><br><span class="line">         &lt;level value=<span class="string">&quot;ERROR&quot;</span> /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;logger name=<span class="string">&quot;org.hibernate&quot;</span>&gt;</span><br><span class="line">         &lt;level value=<span class="string">&quot;ERROR&quot;</span> /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    </span><br><span class="line">   &lt;!-- <span class="keyword">for</span> all other loggers log only debug and above log messages --&gt;</span><br><span class="line">     &lt;root&gt;</span><br><span class="line">        &lt;priority value=<span class="string">&quot;ERROR&quot;</span>/&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span><br><span class="line">     &lt;/root&gt;</span><br><span class="line">      </span><br><span class="line">&lt;/log4j:configuration&gt;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> log4j;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.PropertyConfigurator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLog4j</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(TestLog4j.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        PropertyConfigurator.configure(<span class="string">&quot;e:\\project\\log4j\\src\\log4j.xml&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;跟踪信息&quot;</span>);</span><br><span class="line">            logger.debug(<span class="string">&quot;调试信息&quot;</span>);</span><br><span class="line">            logger.info(<span class="string">&quot;输出信息&quot;</span>);</span><br><span class="line">            logger.warn(<span class="string">&quot;警告信息&quot;</span>);</span><br><span class="line">            logger.error(<span class="string">&quot;错误信息&quot;</span>);</span><br><span class="line">            logger.fatal(<span class="string">&quot;致命信息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="junit白盒测试"><a href="#junit白盒测试" class="headerlink" title="junit白盒测试"></a>junit白盒测试</h2><h3 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h3><p>@Before @After 也是常见的测试框架注解，分别用来在测试开始之前做的事情，和结束之后做的事情。</p><img src="/2021/10/06/how2j/10/06/how2j/8833.png" class title="before &amp; after"><p>关于 Assert的用法，除了举例里的判断数字是否相等，还可以判断boolean, 是否是null ，是否是相同对象等等常见逻辑。</p><img src="/2021/10/06/how2j/10/06/how2j/8832.png" class title="Assert"><h2 id="hutool"><a href="#hutool" class="headerlink" title="hutool"></a>hutool</h2><h2 id="jsoup——html解析"><a href="#jsoup——html解析" class="headerlink" title="jsoup——html解析"></a>jsoup——html解析</h2><p>更多关于 jsoup的资料请查阅 jsoup 官方网站： <a href="https://jsoup.org/">https://jsoup.org/</a></p><h3 id="HTML-amp-xml"><a href="#HTML-amp-xml" class="headerlink" title="HTML&amp;xml"></a>HTML&amp;xml</h3><ul><li>xml 是<strong>可扩展标记语言</strong>的缩写： Extensible Markup Language。</li></ul><p>比如做 web 应用开发，需要配置 web.xml，就是个典型的 xml文件。<br>它里面就有这些元素： web-app, servlet, servlet-name, servlet-class 这些。</p><p><strong>注：</strong> 什么是元素？ 像这样的格式就是一个元素 ： &lt;元素名称&gt; 元素内容 &lt;&#x2F;元素名称&gt;。 比如： <servlet-name>HelloServlet</servlet-name> 就是 servlet-name 元素。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>html</strong> 是 <strong>HyperText Markup Language</strong>的缩写,<strong>超文本标记语言</strong>。</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>html 可以简单看成是 xml 的一个子集。 html 用的都是一些预先定义的元素，如 <html>, <a>, <body>, <table> 。 而 xml 什么元素都可以自定义： 如 <a> , <b>, <aabb> 。</aabb></b></a></table></body></a></html></p><h3 id="jsoup"><a href="#jsoup" class="headerlink" title="jsoup"></a>jsoup</h3><h4 id="xml解析"><a href="#xml解析" class="headerlink" title="xml解析"></a>xml解析</h4><p>既然 html 是 xml 的子集，那么解析起来就和 xml一样了，下面我们就来谈 xml的解析就可以了。</p><ol><li>把文本解析成 Document 对象， Document 对象就代表整个 xml 文档。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(html);</span><br></pre></td></tr></table></figure><p>​2. 获取所有的 p 元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Elements as= doc.getElementsByTag(<span class="string">&quot;p&quot;</span>);</span><br></pre></td></tr></table></figure><p>​3. 遍历 所有的 p 元素 （这里其实只有一个）， 打印其内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Element e : as) &#123;</span><br><span class="line">System.out.println(e.text());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/10/06/how2j/10/06/how2j/9992.png" class title="示例"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.how2j.jsoup;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello HTML&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(html);</span><br><span class="line">         </span><br><span class="line">        Elements as= doc.getElementsByTag(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element e : as) &#123;</span><br><span class="line">            System.out.println(e.text());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取文档"><a href="#获取文档" class="headerlink" title="获取文档"></a>获取文档</h4><p>获取Document对象的方式有多种，常见的就是基于字符串，文件，网页地址。</p><img src="/2021/10/06/how2j/10/06/how2j/9996.png" class title="代码演示"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.how2j.jsoup;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">html1</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello HTML&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc1</span> <span class="operator">=</span> Jsoup.parse(html1);</span><br><span class="line">        System.out.println(<span class="string">&quot;基于字符串方式得到的 Document:\r\n&quot;</span>+ doc1);</span><br><span class="line">         </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f.exists()) &#123;</span><br><span class="line">            <span class="type">Document</span> <span class="variable">doc2</span> <span class="operator">=</span> Jsoup.parse(f,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;基于文件方式得到的 Document:\r\n&quot;</span>+ doc2);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://www.baidu.com&quot;</span>;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc3</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">URL</span>(url),<span class="number">5000</span>); <span class="comment">//超过5秒就报错</span></span><br><span class="line">        System.out.println(<span class="string">&quot;基于URL方式得到的 Document:\r\n&quot;</span>+ doc3);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><img src="/2021/10/06/how2j/10/06/how2j/9999.png" class title="准备 html 内容"><p>获取元素比较常见的几种方式： 通过id, 标签或者类名称获取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.how2j.jsoup;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!f.exists())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(f,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//通过id获取</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">e</span> <span class="operator">=</span> doc.getElementById(<span class="string">&quot;productName&quot;</span>);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//通过标签获取</span></span><br><span class="line">        Elements es;</span><br><span class="line">        es = doc.getElementsByTag(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        show(es);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//通过类名称获取</span></span><br><span class="line">        es = doc.getElementsByClass(<span class="string">&quot;RightBox&quot;</span>);</span><br><span class="line">        show(es);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//通过属性获取</span></span><br><span class="line">        es = doc.getElementsByAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        show(es);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Elements es)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Element e : es) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取内容和文本"><a href="#获取内容和文本" class="headerlink" title="获取内容和文本"></a>获取内容和文本</h4><p><code>c.html</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;c1 c2&quot;</span>&gt;</span>let us<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;how2j.cn&quot;</span>&gt;</span>study java<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.how2j.jsoup;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;c.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!f.exists())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(f,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Element</span> <span class="variable">e</span> <span class="operator">=</span>doc.getElementById(<span class="string">&quot;d1&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//获取属性</span></span><br><span class="line">        System.out.println(e.attr(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//获取所有属性</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(e.attributes());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//获取id</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(e.id());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//获取类名称</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(e.className());</span><br><span class="line">        <span class="comment">//获取所有类名称</span></span><br><span class="line">        System.out.println(e.classNames());</span><br><span class="line">        <span class="comment">//获取文本</span></span><br><span class="line">        System.out.println(e.text());</span><br><span class="line">        <span class="comment">//获取html</span></span><br><span class="line">        System.out.println(e.html());</span><br><span class="line">        <span class="comment">//获取外html</span></span><br><span class="line">        System.out.println(e.outerHtml());</span><br><span class="line">        <span class="comment">//获取标签信息</span></span><br><span class="line">        System.out.println(e.tagName());</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择器语法"><a href="#选择器语法" class="headerlink" title="选择器语法"></a>选择器语法</h4><p>在选择元素的时候，除了使用方法名如 getElementById 这样的外，还可以用 选择器语法来选择。 操作起来就像 jquery了，比如getElementById 就可以写成是 select(“#id”)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.how2j.jsoup;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Document doc;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!f.exists())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        doc = Jsoup.parse(f,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//像 jquery 那样的选择器语法</span></span><br><span class="line">        show(<span class="string">&quot;选择所有的超链&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;根据id进行选择&quot;</span>, <span class="string">&quot;#logocover&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;根据class进行选择&quot;</span>, <span class="string">&quot;.clearfloat&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;根据属性进行选择&quot;</span>, <span class="string">&quot;[href]&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;有属性以tar开头&quot;</span>, <span class="string">&quot;[^tar]&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;根据属性值选择&quot;</span>, <span class="string">&quot;[type=&#x27;application/javascript&#x27;]&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;属性值以什么开头&quot;</span>, <span class="string">&quot;[href^=&#x27;http://www.oracle.com&#x27;]&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;属性值以什么结尾&quot;</span>, <span class="string">&quot;[href$=&#x27;index.html&#x27;]&quot;</span>);</span><br><span class="line">        show(<span class="string">&quot;属性值包含什么&quot;</span>, <span class="string">&quot;[href*=&#x27;download&#x27;]&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String text, String selector)</span> &#123;</span><br><span class="line">        show(text,selector,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String text, String selector, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="type">Elements</span> <span class="variable">es</span> <span class="operator">=</span>doc.select(selector);</span><br><span class="line">        <span class="keyword">if</span>(es.size()&gt;<span class="number">1</span>)</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;%s - 使用的选择器是: \&quot;%s\&quot; \t (最多显示 %d 条 )&quot;</span>, text,selector,limit));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;%s - 使用的选择器是: \&quot;%s\&quot;&quot;</span>, text,selector));</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Element e : es) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i++&lt;limit)</span><br><span class="line">                System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改属性和内容"><a href="#修改属性和内容" class="headerlink" title="修改属性和内容"></a>修改属性和内容</h4><p>jsoup 除了可以解析 html&#x2F;xml 外，还可以进行修改行为。</p><img src="/2021/10/06/how2j/10/06/how2j/10008.png" class title="Test.java"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.how2j.jsoup;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Document doc;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!f.exists())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        doc = Jsoup.parse(f,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        System.out.println(doc);</span><br><span class="line">         </span><br><span class="line">        <span class="type">Element</span> <span class="variable">e</span> <span class="operator">=</span> doc.select(<span class="string">&quot;p&quot;</span>).first();</span><br><span class="line">        e.attr(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;class1&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        e.appendText(<span class="string">&quot; Hello JSoup&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(doc);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><p><a href="https://projectlombok.org/features/all">https://projectlombok.org/features/all</a></p><ul><li><code>@Data</code> 注解会为类的所有属性自动生成setter&#x2F;getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。</li><li><code>@AllArgsConstructor @NoArgsConstructor</code>：分别提供全参构造方法和无参构造方法</li><li><code>@Getter/@Setter</code> ：如果觉得@Data太过粗暴不够精细，可以使用@Getter&#x2F;@Setter注解，此注解在属性上，可以为相应的属性自动生成Getter&#x2F;Setter方法</li><li><code>@ToString</code>类使用@ToString注解，Lombok会生成一个toString()方法，默认情况下，会输出类名、所有属性（会按照属性定义顺序），用逗号来分割。通过exclude属性指定忽略字段不输出</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 忽略 id 字段不输出</span><br><span class="line"><span class="meta">@ToString(exclude = &#123;&quot;id&quot;&#125;)</span></span><br></pre></td></tr></table></figure><ul><li><code>@Builder</code>实例化和设置属性值的风格变了。。。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//传统方式</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        h1.setId(<span class="number">1</span>);</span><br><span class="line">        h1.setName(<span class="string">&quot;garren&quot;</span>);</span><br><span class="line">        System.out.println(h1);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//builder 方式</span></span><br><span class="line">        <span class="type">Hero</span> <span class="variable">h2</span> <span class="operator">=</span>Hero.builder().id(<span class="number">1</span>).name(<span class="string">&quot;gareen&quot;</span>).build();</span><br><span class="line">        System.out.println(h2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="J2EE-企业级应用开发"><a href="#J2EE-企业级应用开发" class="headerlink" title="J2EE-企业级应用开发"></a>J2EE-企业级应用开发</h1><h2 id="TOMCAT"><a href="#TOMCAT" class="headerlink" title="TOMCAT"></a>TOMCAT</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>不使用tomcat访问html</li></ul><p>不使用tomcat也可以打开html页面，但是可以在浏览器的地址里看到 <strong>file:d:&#x2F;test.html</strong> 这样的格式，是通过打开本地文件的形式打开的</p><img src="/2021/10/06/how2j/10/06/how2j/1554.png" class title="不使用tomcat访问html"><p>但是我们平时上网看到的html网址一般都是:<br><a href="http://12306.com/index.html">http://12306.com/index.html</a> 这样的形式，这是因为有web服务器的存在。</p><ul><li>使用tomcat后，访问html</li></ul><p>使用tomcat后，可以这样 <strong>127.0.0.1:8080&#x2F;test.html</strong> 像访问一个网站似的，访问一个html文件了。</p><p>这是因为tomcat本身是一个web 服务器，test.html部署在了这个web服务器上，所以就可以这样访问了。</p><img src="/2021/10/06/how2j/10/06/how2j/1555.png" class title="使用tomcat后，访问html"><ul><li>启动Tomcat</li></ul><p>首先右边下载 tomcat.rar</p><p>解压在d:盘，随便你解压在哪里，一般解压在一个好找的地方，因为后续的学习需要频繁的启动它</p><p>然后运行批处理文件： <strong>D:&#x2F;tomcat&#x2F;bin&#x2F;startup.bat</strong></p><p>最后如果你看到Server startup in xxx ms，就表明启动成功了。</p><p><strong>注</strong> Tomcat启动之后，不要关闭。。。。 关闭了就不能访问了。。。。</p><p>为了正常运行，请务必确认当前java环境是JDK1.8.<br>在命令行中输入<strong>java -version</strong>进行校验<br>参考JDK下载以及配置办法： <a href="https://how2j.cn/k/helloworld/helloworld-jdk/141.html">JDK1.8以及更高版本下载和环境变量配置</a><br>JDK9 不够稳定，特别是Tomcat7 <strong>无法在JDK9 中运行</strong>，请勿使用JDK9运行本Tomcat7，请切换至JDK8，谢谢</p><ul><li>如何部署网页</li></ul><p>部署一个功能完备的web应用 有很多种方式，但是如果只是部署一个test.html，很简单</p><p>把test.html 复制到 <strong>D:\tomcat\webapps\ROOT</strong> 目录下</p><p>就可以通过 <a href="http://127.0.0.1:8080/test.html">http://127.0.0.1:8080/test.html</a> 访问了</p><img src="/2021/10/06/how2j/10/06/how2j/1557.png" class title="如何部署网页">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL卸载安装步骤</title>
      <link href="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
      <url>/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL卸载安装步骤"><a href="#MySQL卸载安装步骤" class="headerlink" title="MySQL卸载安装步骤"></a>MySQL卸载安装步骤</h2><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><h4 id="步骤1：停止MySQL服务"><a href="#步骤1：停止MySQL服务" class="headerlink" title="步骤1：停止MySQL服务"></a>步骤1：停止MySQL服务</h4><p><strong>在卸载之前，先停止MySQL8.0的服务</strong></p><p>Ctrl + Alt + Delete 组合键，打开 任务管理器对话框，可以在 服务 列表找到 MySQL8.0 的服务，如果现在“正在运行”状态，可以右键单击服务，选择“停 ”选项停止MySQL8.0的服务</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yqq5Yqb55qE5bCP6bO05Lq6,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><h4 id="步骤2：软件的卸载"><a href="#步骤2：软件的卸载" class="headerlink" title="步骤2：软件的卸载"></a>步骤2：软件的卸载</h4><p>方式1：通过控制面板方式</p><p>卸载MySQL8.0的程序可以和其他桌面应用程序一样直接在“控制面板”选择“卸载程序”，并在程序列表中 找到MySQL8.0服务器程序，双击卸载</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yqq5Yqb55qE5bCP6bO05Lq6,size_16,color_FFFFFF,t_70,g_se,x_16-16624301518061.png" alt="img"></p><p>方式2：通过安装包提供的卸载功能卸载 </p><p>①双击下载的mysql-installer-community-8.0.26.0.msi文件，打开安装向导，安装向导会自动检测已安装的MySQL服务器程序</p><p>②选择要卸载的MySQL服务器程序，单击 Remove，进行卸载</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yqq5Yqb55qE5bCP6bO05Lq6,size_16,color_FFFFFF,t_70,g_se,x_16-16624301518062.png" alt="img"></p><p> ③单击 Next，确认卸载</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yqq5Yqb55qE5bCP6bO05Lq6,size_16,color_FFFFFF,t_70,g_se,x_16-16624301518063.png" alt="img"></p><p> ④弹出是否同时移除数据目录选择窗口</p><p>如果想要同时删除MySQL服务器中的数据，则勾选 Remove the data directory</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yqq5Yqb55qE5bCP6bO05Lq6,size_16,color_FFFFFF,t_70,g_se,x_16-16624301518074.png" alt="img"></p><p>⑤执行卸载，单击 Execute</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yqq5Yqb55qE5bCP6bO05Lq6,size_16,color_FFFFFF,t_70,g_se,x_16-16624301518075.png" alt="img"></p><p>⑥完成卸载，单击 Finish</p><p>如果想要同时卸载MySQL8.0的安装向导程序，勾选 Yes，Uninstall MySQL Installer</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yqq5Yqb55qE5bCP6bO05Lq6,size_16,color_FFFFFF,t_70,g_se,x_16-16624301518076.png" alt="img"></p><h4 id="步骤3：残余文件的清理"><a href="#步骤3：残余文件的清理" class="headerlink" title="步骤3：残余文件的清理"></a>步骤3：残余文件的清理</h4><p><strong>（1）服务目录：mysql服务的安装目录</strong></p><p><strong>（2）数据目录：默认在C:\ProgramData\MySQL</strong></p><blockquote><p>如果再次安装不成功，可以卸载后对残余文件进行清理后再安装</p><p>🎁注：请在卸载前做好数据备份，在操作完后需重启计算机后进行安装</p><p>如果仍然安装失败，需要继续操作如下 步骤4</p></blockquote><h4 id="步骤4：清理注册表"><a href="#步骤4：清理注册表" class="headerlink" title="步骤4：清理注册表"></a>步骤4：清理注册表</h4><p>在系统的搜索框中输入 regedit，打开注册表编辑器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL服务 目录删除</span><br><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\MySQL服务 目录删除</span><br><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL服务 目录删除</span><br><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\MySQL服务 目录删除</span><br><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL服务目录删除</span><br><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MySQL服务删除</span><br></pre></td></tr></table></figure><h4 id="步骤5：删除环境变量配置"><a href="#步骤5：删除环境变量配置" class="headerlink" title="步骤5：删除环境变量配置"></a>步骤5：删除环境变量配置</h4><p>找到path环境变量，将其中关于mysql的环境变量删除</p><p>切记不要全部删除</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yqq5Yqb55qE5bCP6bO05Lq6,size_17,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="一、下载流程"><a href="#一、下载流程" class="headerlink" title="一、下载流程"></a>一、下载流程</h4><ol><li><p>进入 MySQL官网 <a href="https://www.mysql.com,然后点击/">https://www.mysql.com，然后点击</a> DOWNLOADS，如下图：</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/1.jpg"></p></li><li><p>然后向下翻找，点击如下图链接：</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/2.jpg"></p></li><li><p>进入如下界面，点击红框选中链接</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/3.jpg"></p></li><li><p>然后进入下载界面，选择 Download</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/4.jpg"></p></li><li><p>然后进入以下页面,他要求登录或注册，点击以下红框选中链接即</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/5.jpg"></p></li></ol><h4 id="二、配置过程"><a href="#二、配置过程" class="headerlink" title="二、配置过程"></a>二、配置过程</h4><ol><li><p>将下载安装包解压后放在某盘某文件下，例如：(在此说明，下载的data文件夹是没有的，不用担心，接着来)</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/6.png"></p></li><li><p>配置环境变量（以下省略一些具体过程），修改Path中的值，双击打开或点击编辑：</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/7.png"></p></li><li><p>添加你 MySQL 安装包存放的位置，直达下载的mysql文件中的bin文件路径，如下图所示：(不用在乎其他的，也不要胡思乱想)</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/8.png"></p></li><li><p>配置MySql</p><ul><li>首先要进入 MySQL 安装包下的bin目录下。</li><li>以管理员身份打开cmd，也可以去掉第一步，用cmd中的命令跳转到MySQL 安装包下的bin目录下，然后进行下一步。</li><li>输入 mysqld install,会出现 Service successfully installed。</li></ul><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/9.jpg"></p></li><li><p>接着初始化mysql，输入mysqld –initialize-insecure –user&#x3D;mysql，然后不输入密码，直接登录，直接按Enter</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/10.jpg"></p></li><li><p>或者mysqld –initialize –console初始化mysql，会产生一个随机密码，记录下这个密码，后面会用到</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyd5qKm5peg55eV,size_18,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p></li><li><p>net start mysql开启mysql的服务</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/44a93bbf7aa34327af34d99191a0712a.png" alt="在这里插入图片描述"></p></li><li><p>mysql -u root -p后按Enter输入密码，登录验证mysql是否安装成功(注意随机密码拷贝时不要包含字符前的空格，否则会登陆失败)，如果和下图所示一样，则说明你的mysql已经安装成功。注意，要先开启服务，不然会登陆失败，出现拒绝访问的提示！</p><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/33f9635977de47788c90a860eb905cc0.png" alt="在这里插入图片描述"></p></li><li><p>接着修改密码</p><ul><li>第一行命令可以修改用户（也就是当前用户，一般是管理员）密码， 后面是要修改的具体密码</li><li>然后再执行第二条代码，执行第二条代码的原因见 <a href="https://www.cnblogs.com/hanwuxing/p/8431636.html">https://www.cnblogs.com/hanwuxing/p/8431636.html</a></li></ul><p><img src="/2021/09/08/MySQL%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/11.jpg"></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句</title>
      <link href="/2021/09/06/SQL%E8%AF%AD%E5%8F%A5/"/>
      <url>/2021/09/06/SQL%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="SQl语句"><a href="#SQl语句" class="headerlink" title="SQl语句"></a>SQl语句</h1><h2 id="DDL-Data-Definition-Language-数据定义语言"><a href="#DDL-Data-Definition-Language-数据定义语言" class="headerlink" title="DDL(Data Definition Language)数据定义语言"></a>DDL(Data Definition Language)数据定义语言</h2><h3 id="操作库"><a href="#操作库" class="headerlink" title="操作库"></a>操作库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建库</span></span><br><span class="line"><span class="keyword">create</span> database db;</span><br><span class="line"><span class="comment">-- 创建的库是否存在，不存在创建</span></span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> db;</span><br><span class="line"><span class="comment">-- 查看所有数据库</span></span><br><span class="line"><span class="keyword">show</span> database;</span><br><span class="line"><span class="comment">-- 查看某个数据库的定义信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database 库名;</span><br><span class="line"><span class="comment">-- 修改数据库字符信息</span></span><br><span class="line"><span class="keyword">alter</span> database 库名 <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"><span class="comment">-- 删除数据库</span></span><br><span class="line"><span class="keyword">delete</span> database 库名;</span><br></pre></td></tr></table></figure><h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    ...</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line"><span class="keyword">desc</span> 表名;</span><br><span class="line"><span class="comment">-- 查看创建表的SQL语句</span></span><br><span class="line"><span class="keyword">show</span> crerate <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="comment">-- 修改表名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 rename <span class="keyword">to</span> 新表名;</span><br><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 数据类型;</span><br><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line">aletr <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> 表名;</span><br></pre></td></tr></table></figure><h2 id="DML-Data-Manipulation-Language-数据操作语言"><a href="#DML-Data-Manipulation-Language-数据操作语言" class="headerlink" title="DML(Data Manipulation Language)数据操作语言"></a>DML(Data Manipulation Language)数据操作语言</h2><h3 id="添加（insert-into）"><a href="#添加（insert-into）" class="headerlink" title="添加（insert into）"></a>添加（insert into）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 写全所有列名</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>,...列名n) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...值n);</span><br><span class="line"><span class="comment">-- 不写列名（所有列全部添加）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...值n);</span><br><span class="line"><span class="comment">-- 插入部分数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="删除（delete）"><a href="#删除（delete）" class="headerlink" title="删除（delete）"></a>删除（delete）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除表中数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 列名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="comment">-- 删除表中所有数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="comment">-- 删除表中所有数据（高效 先删除表，然后再创建一张一样的表。）</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure><h3 id="修改（update）"><a href="#修改（update）" class="headerlink" title="修改（update）"></a>修改（update）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不带条件的修改(会修改所有行)</span></span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 列名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="comment">-- 带条件的修改</span></span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 列名 <span class="operator">=</span> 值 <span class="keyword">where</span> 列名<span class="operator">=</span>值;</span><br></pre></td></tr></table></figure><h2 id="DQL-Data-Query-Language-数据查询语言"><a href="#DQL-Data-Query-Language-数据查询语言" class="headerlink" title="DQL(Data Query Language)数据查询语言"></a>DQL(Data Query Language)数据查询语言</h2><h3 id="基础关键字"><a href="#基础关键字" class="headerlink" title="基础关键字"></a>基础关键字</h3><h4 id="BETWEEN…AND-和-IN（集合）"><a href="#BETWEEN…AND-和-IN（集合）" class="headerlink" title="BETWEEN…AND 和 IN（集合）"></a>BETWEEN…AND 和 IN（集合）</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄大于等于20 小于等于30</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="operator">&amp;&amp;</span>  age <span class="operator">&lt;=</span><span class="number">30</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="keyword">AND</span>  age <span class="operator">&lt;=</span><span class="number">30</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄22岁，18岁，25岁的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">22</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">18</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">25</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IN</span> (<span class="number">22</span>,<span class="number">18</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><h4 id="is-null-和-like（模糊查询）和-distinct（去除重复值）"><a href="#is-null-和-like（模糊查询）和-distinct（去除重复值）" class="headerlink" title="is null 和 like（模糊查询）和 distinct（去除重复值）"></a>is null 和 like（模糊查询）和 distinct（去除重复值）</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询id不为null</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"> _:单个任意字符</span><br><span class="line"> <span class="operator">%</span>：多个任意字符</span><br><span class="line"><span class="comment">-- 查询姓马的有哪些？ like</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;马%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询姓名第二个字是化的人</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> &quot;_化%&quot;;</span><br><span class="line"><span class="comment">-- 查询姓名是3个字的人</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;___&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询姓名中包含德的人</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;%腾%&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 关键词 DISTINCT 用于返回唯一不同的值。</span></span><br><span class="line"><span class="comment">-- 语法：SELECT DISTINCT 列名称 FROM 表名称</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> NAME <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><h3 id="排序查询-order-by"><a href="#排序查询-order-by" class="headerlink" title="排序查询 order by"></a>排序查询 order by</h3><p><strong>语法</strong>：order by 子句</p><p>​     order by 排序字段1 排序方式1，排序字段2 排序方式2…</p><p><strong>注意：</strong><br>      如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 默认升序（ASC）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br><span class="line"><span class="comment">-- 降序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">-- 查询前10条数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="聚合函数：将一列数据作为一个整体，进行纵向的计算"><a href="#聚合函数：将一列数据作为一个整体，进行纵向的计算" class="headerlink" title="聚合函数：将一列数据作为一个整体，进行纵向的计算"></a>聚合函数：将一列数据作为一个整体，进行纵向的计算</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">count：获取个数max：获取最大值min：获取最小值sum：计算和avg：计算平均值</span><br></pre></td></tr></table></figure><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p><strong>语法</strong>：group by 分组字段;</p><p><strong>注意</strong>：分组之后查询的字段：分组字段、聚合函数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按照性别分组，查找男、女同学最大的年龄</span></span><br><span class="line"><span class="keyword">SELECT</span> sex,<span class="built_in">max</span>(age) <span class="keyword">FROM</span> Student <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按照性别分组。分别查询男、女同学的平均分</span></span><br><span class="line"><span class="keyword">SELECT</span> sex,<span class="built_in">AVG</span>(math) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 按照性别分组。分别查询男、女同学的平均分,人数</span></span><br><span class="line"><span class="keyword">SELECT</span> sex,<span class="built_in">AVG</span>(math),<span class="built_in">COUNT</span>(id) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组</span></span><br><span class="line"><span class="keyword">SELECT</span> sex , <span class="built_in">AVG</span>(math),<span class="built_in">COUNT</span>(id) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人</span></span><br><span class="line"><span class="keyword">SELECT</span> sex,<span class="built_in">AVG</span>(math),<span class="built_in">COUNT</span>(id) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(id) <span class="operator">&gt;</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p><strong>语法</strong>：limit 开始的索引,每页查询的条数;</p><p><strong>公式</strong>：开始的索引 &#x3D; （当前的页码 - 1） * 每页显示的条数</p><p>limit 是一个MySQL”方言” </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 每页显示3条记录 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">0</span>,<span class="number">3</span>; <span class="comment">-- 第1页(1~3)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">3</span>,<span class="number">3</span>; <span class="comment">-- 第2页(4~6)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">6</span>,<span class="number">3</span>; <span class="comment">-- 第3页(7~9)</span></span><br></pre></td></tr></table></figure><h3 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h3><ul><li><p><strong>从哪些表中查询数据</strong></p></li><li><p><strong>条件是什么</strong></p></li><li><p><strong>查询哪些字段</strong></p></li></ul><h4 id="隐式内连接：使用where条件消除无用数据"><a href="#隐式内连接：使用where条件消除无用数据" class="headerlink" title="隐式内连接：使用where条件消除无用数据"></a>隐式内连接：使用where条件消除无用数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询员工表的名称，性别。部门表的名称</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.name,emp.gender,dept.name <span class="keyword">FROM</span> emp,dept <span class="keyword">WHERE</span> emp.`dept_id` <span class="operator">=</span> dept.`id`;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    t1.name, <span class="comment">-- 员工表的姓名</span></span><br><span class="line">    t1.gender,<span class="comment">-- 员工表的性别</span></span><br><span class="line">    t2.name <span class="comment">-- 部门表的名称</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    emp t1,</span><br><span class="line">    dept t2</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    t1.`dept_id` <span class="operator">=</span> t2.`id`;</span><br></pre></td></tr></table></figure><h4 id="显式内连接"><a href="#显式内连接" class="headerlink" title="显式内连接"></a>显式内连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表达式</span><br><span class="line"><span class="comment">-- 例：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br></pre></td></tr></table></figure><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><h4 id="左外连接——查询的是左表所有数据以及交集部分"><a href="#左外连接——查询的是左表所有数据以及交集部分" class="headerlink" title="左外连接——查询的是左表所有数据以及交集部分"></a>左外连接——查询的是左表所有数据以及交集部分</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 表达式</span><br><span class="line"><span class="comment">-- 例：查询到emp表全部数据以及dept表中与dept_id相同id的列数据</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.<span class="operator">*</span>,t2.name <span class="keyword">FROM</span> emp t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept t2 <span class="keyword">ON</span> t1.dept_id <span class="operator">=</span> t2.id;</span><br></pre></td></tr></table></figure><h4 id="右外连接——查询的是右表所有数据以及交集部分"><a href="#右外连接——查询的是右表所有数据以及交集部分" class="headerlink" title="右外连接——查询的是右表所有数据以及交集部分"></a>右外连接——查询的是右表所有数据以及交集部分</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：</span></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件；</span><br><span class="line"><span class="comment">-- 例子：</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">FROM</span> dept t2 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> emp t1 <span class="keyword">ON</span> t1.`dept_id` <span class="operator">=</span> t2.`id`;</span><br></pre></td></tr></table></figure><h3 id="子查询：查询中嵌套查询"><a href="#子查询：查询中嵌套查询" class="headerlink" title="子查询：查询中嵌套查询"></a>子查询：查询中嵌套查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资最高的员工信息</span></span><br><span class="line"><span class="comment">-- 1 查询最高的工资是多少 9000</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> emp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 2 查询员工信息，并且工资等于9000的</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.`salary` <span class="operator">=</span> <span class="number">9000</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">-- 一条sql就完成这个操作。这就是子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.`salary` <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> emp);</span><br></pre></td></tr></table></figure><h4 id="子查询的结果是单行单列的"><a href="#子查询的结果是单行单列的" class="headerlink" title="子查询的结果是单行单列的"></a>子查询的结果是单行单列的</h4><p>子查询可以作为条件，使用<strong>运算符去判断</strong>。 运算符： &gt; &gt;&#x3D; &lt; &lt;&#x3D; &#x3D;</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询小于平均工资的人</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.salary <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> emp);</span><br></pre></td></tr></table></figure><h4 id="子查询的结果是多行单列的："><a href="#子查询的结果是多行单列的：" class="headerlink" title="子查询的结果是多行单列的："></a>子查询的结果是多行单列的：</h4><p>  子查询可以作为条件，使用<strong>运算符in</strong>来判断：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询开发部的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> dept_id <span class="keyword">in</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;开发部&quot;);</span><br></pre></td></tr></table></figure><h4 id="子查询的结果是多行多列的："><a href="#子查询的结果是多行多列的：" class="headerlink" title="子查询的结果是多行多列的："></a>子查询的结果是多行多列的：</h4><p>子查询可以作为一张<strong>虚拟表</strong>参与查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息</span></span><br><span class="line"><span class="comment">-- 子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dept t1 ,(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.`join_date` <span class="operator">&gt;</span> <span class="string">&#x27;2011-11-11&#x27;</span>) t2 <span class="keyword">WHERE</span> t1.id <span class="operator">=</span> t2.dept_id;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 普通内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp t1,dept t2 <span class="keyword">WHERE</span> t1.`dept_id` <span class="operator">=</span> t2.`id` <span class="keyword">AND</span> t1.`join_date` <span class="operator">&gt;</span>  <span class="string">&#x27;2011-11-11&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="DCL-Data-Control-Language-数据控制语言"><a href="#DCL-Data-Control-Language-数据控制语言" class="headerlink" title="DCL(Data Control Language)数据控制语言"></a>DCL(Data Control Language)数据控制语言</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><ul><li>添加用户</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>删除用户</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><ul><li>查询权限</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询权限</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;lisi&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>授予权限</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授予权限</span></span><br><span class="line"><span class="keyword">grant</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 给张三用户授予所有权限，在任意数据库任意表上</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>撤销权限</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 撤销权限：</span></span><br><span class="line"><span class="keyword">revoke</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">from</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> db3.`account` <span class="keyword">FROM</span> <span class="string">&#x27;lisi&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2021/09/02/Git/"/>
      <url>/2021/09/02/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git-概述"><a href="#Git-概述" class="headerlink" title="Git 概述"></a>Git 概述</h2><ul><li>Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种<br>项目。</li><li>Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作<br>流分支等特性。 其性能优于 Subversion、 CVS、 Perforce 和 ClearCase 等版本控制工具。</li><li>官网地址：<a href="http://./Git-scm.com/">http:/./Git-scm.com/</a></li></ul><h3 id="何为版本控制"><a href="#何为版本控制" class="headerlink" title="何为版本控制"></a>何为版本控制</h3><p>版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。<br>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，<br>方便版本切换。 </p><p><img src="https://img-blog.csdnimg.cn/img_convert/2abc5f18d46afc2d50cee7db484a460f.png" alt="img"></p><h3 id="为什么需要版本控制"><a href="#为什么需要版本控制" class="headerlink" title="为什么需要版本控制"></a>为什么需要版本控制</h3><p>个人开发过渡到团队协作。 </p><p><img src="https://img-blog.csdnimg.cn/img_convert/2bcf55bc8f1e6cda16fc048ed30e12fc.png" alt="img"></p><h3 id="版本控制工具"><a href="#版本控制工具" class="headerlink" title="版本控制工具"></a>版本控制工具</h3><ul><li><strong>集中式版本控制工具</strong></li></ul><p>CVS、 SVN(Subversion)、 VSS……<br>集中化的版本控制系统诸如 CVS、 SVN 等，都有一个单一的集中管理的服务器，保存<br>所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或<br>者提交更新。多年以来，这已成为版本控制系统的标准做法。<br>这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什<br>么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统， 要<br>远比在各个客户端上维护本地数据库来得轻松容易。<br>事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕<br>机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 </p><p><img src="https://img-blog.csdnimg.cn/img_convert/f0cc7f6f1eb57316f7f8fce8e2f03f45.png" alt="img"></p><ul><li><strong>分布式版本控制工具</strong></li></ul><p>Git、 Mercurial、 Bazaar、 Darcs……</p><p>像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</p><p>分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷：</p><ol><li>服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</li><li>每个客户端保存的也都是整个完整的项目（包含历史记录， 更加安全）</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/340e9b3bc50013b61f0e83e96b99f86a.png" alt="img"></p><h3 id="概述-发展历史"><a href="#概述-发展历史" class="headerlink" title="概述_发展历史"></a>概述_发展历史</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/3f25cba01665ab8dcb63fcc79d05f04f.png" alt="img"></p><h3 id="Git工作机制"><a href="#Git工作机制" class="headerlink" title="Git工作机制"></a>Git工作机制</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/1706b3553447ac9f8d95377d965d4fd2.png" alt="img"></p><h3 id="Git-和代码托管中心"><a href="#Git-和代码托管中心" class="headerlink" title="Git 和代码托管中心"></a>Git 和代码托管中心</h3><p>代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为<strong>远程库</strong>。</p><ul><li>局域网<ul><li>GitLab</li></ul></li><li>互联网<ul><li>GitHub（外网）</li><li>Gitee 码云（国内网站）</li></ul></li></ul><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>官网地址： <a href="https://git-scm.com/">https://Git-scm.com/</a></p><ul><li>查看 GNU 协议，可以直接点击下一步</li></ul><p><img src="/2021/09/02/Git/1662177441840.jpg" alt="1662177441840"></p><ul><li>选择 Git 安装位置，要求是非中文并且没有空格的目录，然后下一步</li></ul><p><img src="/2021/09/02/Git/1662184473724.png" alt="1662184473724"></p><ul><li>Git 选项配置，推荐默认设置，然后下一步。</li></ul><p><img src="/2021/09/02/Git/1662184486378.png" alt="1662184486378"></p><ul><li>Git 安装目录名，不用修改，直接点击下一步。</li></ul><p><img src="/2021/09/02/Git/1662184499191.png" alt="1662184499191"></p><ul><li>Git 的默认编辑器，建议使用默认的 Vim 编辑器，然后点击下一步。</li></ul><p><img src="/2021/09/02/Git/1662184513038.png" alt="1662184513038"></p><ul><li>默认分支名设置，选择让 Git 决定，分支名默认为 master，下一步。</li></ul><p><img src="/2021/09/02/Git/1662184623539.png" alt="1662184623539"></p><ul><li>修改 Git 的环境变量，选第一个，不修改环境变量，只在 Git Bash 里使用 Git。</li></ul><p><img src="/2021/09/02/Git/1662184641029.png" alt="1662184641029"></p><ul><li>选择后台客户端连接协议，选默认值 OpenSSL，然后下一步</li></ul><p><img src="/2021/09/02/Git/1662184660545.png" alt="1662184660545"></p><ul><li>配置 Git 文件的行末换行符，Windows 使用 CRLF，Linux 使用 LF，选择第一个自动转换，然后继续下一步。</li></ul><p><img src="/2021/09/02/Git/1662184684701.png" alt="1662184684701"></p><ul><li>选择 Git 终端类型，选择默认的 Git Bash 终端，然后继续下一步</li></ul><p><img src="/2021/09/02/Git/1662184705650.png" alt="1662184705650"></p><ul><li>选择 Git pull 合并的模式，选择默认，然后下一步</li></ul><p><img src="/2021/09/02/Git/1662184721455.png" alt="1662184721455"></p><ul><li>选择 Git 的凭据管理器，选择默认的跨平台的凭据管理器，然后下一步</li></ul><p><img src="/2021/09/02/Git/1662184741905.png" alt="1662184741905"></p><ul><li>其他配置，选择默认设置，然后下一步。</li></ul><p><img src="/2021/09/02/Git/1662184793900.png" alt="1662184793900"></p><ul><li>实验室功能，技术还不成熟，有已知的 bug，不要勾选，然后点击右下角的 Install按钮，开始安装 Git。</li></ul><p><img src="/2021/09/02/Git/1662184815921.png" alt="1662184815921"></p><ul><li>点击 Finsh 按钮，Git 安装成功！</li></ul><p><img src="/2021/09/02/Git/1662184840072.png" alt="1662184840072"></p><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config –global user.email 邮箱</td><td>设置用户email地址</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset –hard 版本号</td><td>版本穿梭</td></tr></tbody></table><h3 id="设置用户签名"><a href="#设置用户签名" class="headerlink" title="设置用户签名"></a>设置用户签名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name hua #用户名</span><br><span class="line">git config --global user.email hua@123.com</span><br></pre></td></tr></table></figure><p>说明：<strong>签名的作用是区分不同操作者身份</strong>。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。 <strong>Git 首次安装必须设置一下用户签名，否则无法提交代码</strong>。</p><p><strong>注意</strong>： 这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</p><p>查看设置过用户签名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@hua MINGW64 /f./GitHello</span><br><span class="line">$ cat ~/.gitconfig</span><br><span class="line">[user]</span><br><span class="line">        name = HUA</span><br><span class="line">        email = 2164277973@qq.com</span><br><span class="line">[credential &quot;https:/./Gitee.com&quot;]</span><br><span class="line">        provider = generic</span><br><span class="line">[http]</span><br><span class="line">        sslverify = false</span><br><span class="line">[credential &quot;https://e.coding.net&quot;]</span><br><span class="line">        provider = generic</span><br></pre></td></tr></table></figure><h3 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a>初始化本地库</h3><p>基本语法：**<code>git init</code>**</p><p>案例实操：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@hua MINGW64 /f./GitHello</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in F:./GitHello/.git/</span><br><span class="line"></span><br><span class="line">Administrator@hua MINGW64 /f./GitHello (master)</span><br><span class="line">$ ll</span><br><span class="line">total 0</span><br><span class="line"></span><br><span class="line">Administrator@hua MINGW64 /f./GitHello (master)</span><br><span class="line">$ ll -a</span><br><span class="line">total 44</span><br><span class="line">drwxr-xr-x 1 Administrator 197121 0 Sep  2 14:13 ./</span><br><span class="line">drwxr-xr-x 1 Administrator 197121 0 Sep  2 11:17 ../</span><br><span class="line">drwxr-xr-x 1 Administrator 197121 0 Sep  2 14:13 .git/</span><br></pre></td></tr></table></figure><h3 id="查看本地库状态"><a href="#查看本地库状态" class="headerlink" title="查看本地库状态"></a>查看本地库状态</h3><p>基本语法：**<code>git status</code>**</p><p>案例实操：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 首次查看（工作区没有任何文件）</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</span><br><span class="line"></span><br><span class="line"># 新增文件（hello.txt）</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ vim hello.txt</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ cat hello.txt</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line"></span><br><span class="line"># 再次查看（检测到未追踪的文件）</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        hello.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="添加暂存区"><a href="#添加暂存区" class="headerlink" title="添加暂存区"></a>添加暂存区</h3><p>基本语法：**<code>git add</code>**</p><p>案例实操：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        hello.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br><span class="line">#添加至暂存区</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git add hello.txt</span><br><span class="line">warning: LF will be replaced by CRLF in hello.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">#查看状态（检测到暂存区有新文件）</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   hello.txt</span><br><span class="line"></span><br><span class="line">#移除暂存区的hello.txt</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git rm --cached hello.txt</span><br><span class="line">rm &#x27;hello.txt&#x27;</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        hello.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br><span class="line"># 再次添加</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git add hello.txt</span><br><span class="line">warning: LF will be replaced by CRLF in hello.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br></pre></td></tr></table></figure><h3 id="提交本地库"><a href="#提交本地库" class="headerlink" title="提交本地库"></a>提交本地库</h3><p>基本语法：**<code>git commit -m &quot;日志信息&quot; 文件名</code>**</p><p>案例实操：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        hello.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git add hello.txt</span><br><span class="line">warning: LF will be replaced by CRLF in hello.txt.#正常错误：将CPLF换行符自动转换为LF</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line">#提交本地库</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git commit -m &quot;first commit&quot; hello.txt</span><br><span class="line">[master (root-commit) b0006bc] first commit</span><br><span class="line"> 1 file changed, 19 insertions(+)</span><br><span class="line"> create mode 100644 hello.txt</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>修改文件之后提示需要再提交，提交之后保存两个版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ vim hello.txt</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ cat hello.txt</span><br><span class="line">hello, git!222</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line"></span><br><span class="line">#提示 hello.txt 被修改过（modified）</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   hello.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line"># 将修改的文件再次添加暂存区</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git add hello.txt</span><br><span class="line">warning: LF will be replaced by CRLF in hello.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line"># 第2次提交</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git commit -m &quot;second commit&quot;</span><br><span class="line">[master 6967bf0] second commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git reflog</span><br><span class="line">6967bf0 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: second commit</span><br><span class="line">b0006bc HEAD@&#123;1&#125;: commit (initial): first commit</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h3><p>基本语法：**<code>git reflog</code>**：查看版本信息**<code>git log</code>**：查看版本详细信息</p><p>案例实操：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git reflog</span><br><span class="line">41f776b (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: third commit</span><br><span class="line">6967bf0 HEAD@&#123;1&#125;: commit: second commit</span><br><span class="line">b0006bc HEAD@&#123;2&#125;: commit (initial): first commit</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git log</span><br><span class="line">commit 41f776ba69ea06c42bd449098d818ab73608d4dd (HEAD -&gt; master)</span><br><span class="line">Author: abc &lt;abc@123.com&gt;</span><br><span class="line">Date:   Tue Jul 6 01:18:21 2021 +0800</span><br><span class="line"></span><br><span class="line">    third commit</span><br><span class="line"></span><br><span class="line">commit 6967bf01bdcbc8e326f1b8c45d45db8bd4c0c868</span><br><span class="line">Author: abc &lt;abc@123.com&gt;</span><br><span class="line">Date:   Tue Jul 6 01:02:10 2021 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line">commit b0006bc538b98b7eb77b4b4aaa17b6e333c4289e</span><br><span class="line">Author: abc &lt;abc@123.com&gt;</span><br><span class="line">Date:   Tue Jul 6 00:38:24 2021 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><p><strong>git log与git reflog区别</strong></p><p><code>git log</code> 命令可以显示所有提交过的版本信息，如果感觉太繁琐，可以加上参数 <code>--pretty=oneline</code>，只会显示版本号和提交时的备注信息。</p><p><code>git reflog</code> 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）。例如，执行 <code>git reset --soft HEAD^</code>，退回到上一个版本，用<code>git log</code>则是看不出来被删除的commitid，用<code>git reflog</code>则可以看到被删除的commitid，我们就可以买后悔药，恢复到被删除的那个版本。<a href="https://blog.csdn.net/u013252047/article/details/80230781">link</a></p><h3 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h3><p>基本语法：**<code>git reset --hard 版本号</code>**</p><p>案例实操：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 首先查看当前的历史记录</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git reflog</span><br><span class="line">41f776b (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: third commit</span><br><span class="line">6967bf0 HEAD@&#123;1&#125;: commit: second commit</span><br><span class="line">b0006bc HEAD@&#123;2&#125;: commit (initial): first commit</span><br><span class="line"></span><br><span class="line"># 切换到 b0006bc 版本，也就是第一次提交的版本</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git reset --hard b0006bc</span><br><span class="line">HEAD is now at b0006bc first commit</span><br><span class="line"></span><br><span class="line"># 切换完毕之后再查看历史记录，当前成功切换到了 b0006bc 版本</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git reflog</span><br><span class="line">b0006bc (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to b0006bc</span><br><span class="line">41f776b HEAD@&#123;1&#125;: commit: third commit</span><br><span class="line">6967bf0 HEAD@&#123;2&#125;: commit: second commit</span><br><span class="line">b0006bc (HEAD -&gt; master) HEAD@&#123;3&#125;: commit (initial): first commit</span><br><span class="line"></span><br><span class="line"># 然后查看文件 hello.txt，发现文件内容回到第一版本</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ cat hello.txt</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br></pre></td></tr></table></figure><p>当你在切换版本后，再更改文本内容提交：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ vim hello.txt</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   hello.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git add hello.txt</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git commit -m &quot;forth commit&quot; hello.txt</span><br><span class="line">[master 5f8dbf6] forth commit</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git reflog</span><br><span class="line">5f8dbf6 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: forth commit</span><br><span class="line">b0006bc HEAD@&#123;1&#125;: reset: moving to b0006bc</span><br><span class="line">41f776b HEAD@&#123;2&#125;: commit: third commit</span><br><span class="line">6967bf0 HEAD@&#123;3&#125;: commit: second commit</span><br><span class="line">b0006bc HEAD@&#123;4&#125;: commit (initial): first commit</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次切换到第一版本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git reset --hard b0006bc</span><br><span class="line">HEAD is now at b0006bc first commit</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git reflog</span><br><span class="line">b0006bc (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to b0006bc</span><br><span class="line">5f8dbf6 HEAD@&#123;1&#125;: commit: forth commit</span><br><span class="line">b0006bc (HEAD -&gt; master) HEAD@&#123;2&#125;: reset: moving to b0006bc</span><br><span class="line">41f776b HEAD@&#123;3&#125;: commit: third commit</span><br><span class="line">6967bf0 HEAD@&#123;4&#125;: commit: second commit</span><br><span class="line">b0006bc (HEAD -&gt; master) HEAD@&#123;5&#125;: commit (initial): first commit</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ cat hello.txt</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br></pre></td></tr></table></figure><p><strong>Git 切换版本， 底层其实是移动的 HEAD 指针。</strong></p><p><img src="/2021/09/02/Git/Users\Administrator\AppData\Roaming\Typora\typora-user-images\1662100609902.png" alt="1662100609902"></p><h2 id="Git分支操作"><a href="#Git分支操作" class="headerlink" title="Git分支操作"></a>Git分支操作</h2><p>​<img src="https://img-blog.csdnimg.cn/img_convert/bcad650a512a72097b3391e00ecb8bbe.png" alt="img"></p><h3 id="什么是分支"><a href="#什么是分支" class="headerlink" title="什么是分支"></a>什么是分支</h3><p>​在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来， 开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用） </p><p><img src="https://img-blog.csdnimg.cn/img_convert/f1d0659ed000e9dfa295fc696a58cf74.png" alt="某项目有四条分支"></p><h3 id="分支的好处"><a href="#分支的好处" class="headerlink" title="分支的好处"></a>分支的好处</h3><ul><li>同时并行推进多个功能开发，提高开发效率。</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</li></ul><h3 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h3><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git branch 分支名</td><td>创建分支</td></tr><tr><td>git branch -v</td><td>查看分支</td></tr><tr><td>git checkout 分支名</td><td>切换分支</td></tr><tr><td>git merge 分支名</td><td>把指定的分支合并到当前分支上</td></tr></tbody></table><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><p>基本语法：**<code>git branch -v</code>**</p><p>案例实操：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git branch -v</span><br><span class="line">* master b0006bc first commit</span><br></pre></td></tr></table></figure><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>基本语法：**<code>git branch 分支名</code>**</p><p>案例实操：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Layne@LAPTOP-Layne MINGW64 /d./Git-Space/SH0720 (master)</span><br><span class="line">$ git branch hot-fix</span><br><span class="line">Layne@LAPTOP-Layne MINGW64 /d./Git-Space/SH0720 (master)</span><br><span class="line">$ git branch -v</span><br><span class="line">hot-fix 087a1a7 my third commit （刚创建的新的分支，并将主分支 master的内容复制了一份）</span><br><span class="line">* master 087a1a7 my third commit</span><br></pre></td></tr></table></figure><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><p>基本语法：**<code>git cheackout 分支名</code>** </p><p>案例实操：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git checkout hot-fix</span><br><span class="line">Switched to branch &#x27;hot-fix&#x27;</span><br><span class="line"></span><br><span class="line"># 切换到刚创建的分支上</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (hot-fix)</span><br><span class="line">$ git branch -v</span><br><span class="line">* hot-fix b0006bc first commit</span><br><span class="line">  master  b0006bc first commit</span><br></pre></td></tr></table></figure><p>切换分支后，在新分支修改文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (hot-fix)</span><br><span class="line">$ vim hello.txt</span><br><span class="line">--查看 hot-fix 分支上的文件内容发现与 master 分支上的内容不同</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (hot-fix)</span><br><span class="line">$ cat hello.txt</span><br><span class="line">hello, git!hot-fix</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (hot-fix)</span><br><span class="line">$ git status</span><br><span class="line">On branch hot-fix</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   hello.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (hot-fix)</span><br><span class="line">$ git add hello.txt</span><br><span class="line"></span><br><span class="line">#在hot-fix提交</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (hot-fix)</span><br><span class="line">$ git commit -m &quot;hot-fix first commit&quot;</span><br><span class="line">[hot-fix 25f62d6] hot-fix first commit</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (hot-fix)</span><br><span class="line">$ git reflog</span><br><span class="line">25f62d6 (HEAD -&gt; hot-fix) HEAD@&#123;0&#125;: commit: hot-fix first commit</span><br><span class="line">b0006bc (master) HEAD@&#123;1&#125;: checkout: moving from master to hot-fix</span><br><span class="line">b0006bc (master) HEAD@&#123;2&#125;: reset: moving to b0006bc</span><br><span class="line">5f8dbf6 HEAD@&#123;3&#125;: commit: forth commit</span><br><span class="line">b0006bc (master) HEAD@&#123;4&#125;: reset: moving to b0006bc</span><br><span class="line">41f776b HEAD@&#123;5&#125;: commit: third commit</span><br><span class="line">6967bf0 HEAD@&#123;6&#125;: commit: second commit</span><br><span class="line">b0006bc (master) HEAD@&#123;7&#125;: commit (initial): first commit</span><br></pre></td></tr></table></figure><h4 id="合并分支-正常合并"><a href="#合并分支-正常合并" class="headerlink" title="合并分支-正常合并"></a>合并分支-正常合并</h4><p>基本语法：**<code>git merge 分支名</code>**</p><p>案例实操（在master分支上合并hot-fix分支）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Layne@LAPTOP-Layne MINGW64 /d./Git-Space/SH0720 (master)</span><br><span class="line">$ git merge hot-fix</span><br><span class="line">Auto-merging hello.txt</span><br><span class="line">CONFLICT (content): Merge conflict in hello.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><h4 id="合并分支-冲突合并"><a href="#合并分支-冲突合并" class="headerlink" title="合并分支-冲突合并"></a>合并分支-冲突合并</h4><p><strong>冲突产生的原因</strong></p><p>并分支时，两个分支在<strong>同一个文件的同一个位置</strong>有两套完全不同的修改。 Git 无法替我们决定使用哪一个，因此，必须<strong>人为决定</strong>新代码内容。</p><p><strong>产生冲突</strong></p><p>首先，在master分支修改文件hello.txt最后一行内容，并提交：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ vim hello.txt</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ cat hello.txt</span><br><span class="line">hello, git!hot-fix</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!master test</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   hello.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git add hello.txt</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git commit -m &quot;master test&quot;</span><br><span class="line">[master fb0e30b] master test</span><br><span class="line"> 1 file changed, 2 insertions(+), 2 deletions(-)</span><br></pre></td></tr></table></figure><p>然后，在hot-fix分支修改文件hello.txt最后一行内容，并提交：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git checkout hot-fix</span><br><span class="line">Switched to branch &#x27;hot-fix&#x27;</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (hot-fix)</span><br><span class="line">$ vim hello.txt</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (hot-fix)</span><br><span class="line">$ cat hello.txt</span><br><span class="line">hello, git!hot-fix</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!hot-fix test</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (hot-fix)</span><br><span class="line">$ git add hello.txt</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (hot-fix)</span><br><span class="line">$ git commit -m &quot;hot-fix test&quot;</span><br><span class="line">[hot-fix 47d2d8f] hot-fix test</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>切换到master分支，然后将hot-fix分支的合并到master，冲突产生：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (hot-fix)</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"></span><br><span class="line"># 冲突产生</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git merge hot-fix</span><br><span class="line">Auto-merging hello.txt</span><br><span class="line">CONFLICT (content): Merge conflict in hello.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line"></span><br><span class="line"># MERGING 出现，表示有冲突待解决</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master|MERGING)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line">        both modified:   hello.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master|MERGING)</span><br><span class="line">$ cat hello.txt</span><br><span class="line">hello, git!hot-fix</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">hello, git!hot-fix test</span><br><span class="line">hello, git!master test</span><br><span class="line">=======</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!hot-fix test</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</span><br></pre></td></tr></table></figure><p><strong>解决冲突</strong></p><p>编辑有冲突的文件，<strong>删除特殊符号</strong>，决定要使用的内容</p><p>特殊符号：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">当前分支的代码 </span><br><span class="line">======= </span><br><span class="line">合并过来的代码 </span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</span><br></pre></td></tr></table></figure><p>删除不需要的数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master|MERGING)</span><br><span class="line">$ cat hello.txt</span><br><span class="line">hello, git!hot-fix</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">hello, git!hot-fix test</span><br><span class="line">hello, git!master test</span><br><span class="line">=======</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!hot-fix test</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master|MERGING)</span><br><span class="line">$ vim hello.txt</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master|MERGING)</span><br><span class="line">$ cat hello.txt</span><br><span class="line">hello, git!hot-fix</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!hot-fix test</span><br><span class="line">hello, git!master test</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master|MERGING)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line">        both modified:   hello.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master|MERGING)</span><br><span class="line">$ git add hello.txt</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master|MERGING)</span><br><span class="line">$ git commit -m &quot;conflict solved&quot;</span><br><span class="line">[master 785ab46] conflict solved</span><br><span class="line"></span><br><span class="line"># (master|MERGING)的|MERGING消失了，冲突解决</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git reflog</span><br><span class="line">785ab46 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit (merge): conflict solved</span><br><span class="line">fb0e30b HEAD@&#123;1&#125;: checkout: moving from hot-fix to master</span><br><span class="line">47d2d8f (hot-fix) HEAD@&#123;2&#125;: commit: hot-fix test</span><br><span class="line">25f62d6 HEAD@&#123;3&#125;: checkout: moving from master to hot-fix</span><br><span class="line">fb0e30b HEAD@&#123;4&#125;: commit: master test</span><br><span class="line">25f62d6 HEAD@&#123;5&#125;: checkout: moving from hot-fix to master</span><br><span class="line">25f62d6 HEAD@&#123;6&#125;: checkout: moving from master to hot-fix</span><br><span class="line">25f62d6 HEAD@&#123;7&#125;: checkout: moving from hot-fix to master</span><br><span class="line">25f62d6 HEAD@&#123;8&#125;: checkout: moving from master to hot-fix</span><br><span class="line">25f62d6 HEAD@&#123;9&#125;: merge hot-fix: Fast-forward</span><br><span class="line">b0006bc HEAD@&#123;10&#125;: checkout: moving from hot-fix to master</span><br><span class="line">25f62d6 HEAD@&#123;11&#125;: commit: hot-fix first commit</span><br><span class="line">b0006bc HEAD@&#123;12&#125;: checkout: moving from master to hot-fix</span><br><span class="line">b0006bc HEAD@&#123;13&#125;: reset: moving to b0006bc</span><br><span class="line">5f8dbf6 HEAD@&#123;14&#125;: commit: forth commit</span><br><span class="line">b0006bc HEAD@&#123;15&#125;: reset: moving to b0006bc</span><br><span class="line">41f776b HEAD@&#123;16&#125;: commit: third commit</span><br><span class="line">6967bf0 HEAD@&#123;17&#125;: commit: second commit</span><br><span class="line">b0006bc HEAD@&#123;18&#125;: commit (initial): first commit</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建分支和切换分支图解"><a href="#创建分支和切换分支图解" class="headerlink" title="创建分支和切换分支图解"></a>创建分支和切换分支图解</h3><ul><li>master、 hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD决定的。所以创建分支的本质就是多创建一个指针。</li><li>HEAD 如果指向 master，那么我们现在就在 master 分支上。</li><li>HEAD 如果执行 hotfix，那么我们现在就在 hotfix 分支上。</li></ul><p><strong>所以切换分支的本质就是移动HEAD指针。</strong></p><h2 id="Git团队协作机制"><a href="#Git团队协作机制" class="headerlink" title="Git团队协作机制"></a>Git团队协作机制</h2><p><strong>团队内协作</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c397bde00d728c4e41eca79f578d25c3.png" alt="img"></p><p><strong>跨团队协作</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/e3069f865cc2d9760801b7a06c9d213b.png" alt="img"></p><h2 id="GitHub操作"><a href="#GitHub操作" class="headerlink" title="GitHub操作"></a>GitHub操作</h2><p><a href="https://./Github.com/">GitHub网址</a></p><h3 id="创建远程库"><a href="#创建远程库" class="headerlink" title="创建远程库"></a>创建远程库</h3><p>登陆后，点击在网页右上角的“+” –&gt; “New repository”，创建远程库。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3dfd6ad9419bfcef2635e08a5c02e86c.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/fba2c7ad888d2aeeea3a6f4a28c7fb03.png" alt="img"></p><h3 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h3><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td>git remote add 别名 远程地址</td><td>起别名</td></tr><tr><td>git push 别名 分支</td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td>git clone 远程地址 -b 分支名</td><td>将远程仓库指定分支的内容克隆到本地</td></tr><tr><td>git pull 远程库地址别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td></tr></tbody></table><h4 id="创建别名"><a href="#创建别名" class="headerlink" title="创建别名"></a>创建别名</h4><p><strong>基本语法</strong>：</p><ul><li><code>git remote -v</code> 查看当前所有远程地址别名</li><li><code>git remote add 别名 远程地址</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git remote add hellogit https:/./Github.com/abc/HelloGit.git</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git remote -v</span><br><span class="line">hellogit        https:/./Github.com/abc/HelloGit.git (fetch)</span><br><span class="line">hellogit        https:/./Github.com/abc/HelloGit.git (push)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="GitHub-推送本地库到远程库"><a href="#GitHub-推送本地库到远程库" class="headerlink" title="GitHub_推送本地库到远程库"></a>GitHub_推送本地库到远程库</h4><p>基本语法：<code>git push 别名 分支</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将master分支推送到别名为hellogit远程地址，</span><br><span class="line"># 也就推送到https:/./Github.com/abc/HelloGit.git（具体看前一节）</span><br><span class="line"># 这里需要授权认证操作（输入账号密码）</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git push hellogit master</span><br><span class="line">fatal: unable to access &#x27;https:/./Github.com/abc/HelloGit.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git push hellogit master</span><br><span class="line">Enumerating objects: 13, done.</span><br><span class="line">Counting objects: 100% (13/13), done.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (9/9), done.</span><br><span class="line">Writing objects: 100% (13/13), 1.02 KiB | 523.00 KiB/s, done.</span><br><span class="line">Total 13 (delta 4), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (4/4), done.</span><br><span class="line">To https:/./Github.com/abc/HelloGit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>推送成功后，刷新https:&#x2F;.&#x2F;Github.com&#x2F;abc&#x2F;HelloGit：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/84e90e7cd9e5cda112179e28facb2c2e.png" alt="img"></p><h4 id="GitHub-拉取远程库到本地库"><a href="#GitHub-拉取远程库到本地库" class="headerlink" title="GitHub_拉取远程库到本地库"></a>GitHub_拉取远程库到本地库</h4><p>基本语法：<code>git pull 别名 分支</code></p><p>在Github上修改hello.txt文件，并提交。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bfe5dcc2d0362f94437bf09b16986ee5.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#从hellogit拉取到master分支上</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git pull hellogit master</span><br><span class="line">remote: Enumerating objects: 5, done.</span><br><span class="line">remote: Counting objects: 100% (5/5), done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), 672 bytes | 168.00 KiB/s, done.</span><br><span class="line">From https:/./Github.com/JallenKwong/HelloGit</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">   785ab46..47e257f  master     -&gt; hellogit/master</span><br><span class="line">Updating 785ab46..47e257f</span><br><span class="line">Fast-forward</span><br><span class="line"> hello.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line"># 可看到从Github上修改后痕迹</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ cat hello.txt</span><br><span class="line">hello, git!hot-fix</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!</span><br><span class="line">hello, git!modify from Github editor</span><br><span class="line">hello, git!hot-fix test</span><br><span class="line">hello, git!master test</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ git reflog</span><br><span class="line">47e257f (HEAD -&gt; master, hellogit/master) HEAD@&#123;0&#125;: pull hellogit master: Fast-forward</span><br><span class="line">785ab46 HEAD@&#123;1&#125;: commit (merge): conflict solved</span><br><span class="line">fb0e30b HEAD@&#123;2&#125;: checkout: moving from hot-fix to master</span><br><span class="line">47d2d8f (hot-fix) HEAD@&#123;3&#125;: commit: hot-fix test</span><br><span class="line">25f62d6 HEAD@&#123;4&#125;: checkout: moving from master to hot-fix</span><br><span class="line">fb0e30b HEAD@&#123;5&#125;: commit: master test</span><br><span class="line">25f62d6 HEAD@&#123;6&#125;: checkout: moving from hot-fix to master</span><br><span class="line">25f62d6 HEAD@&#123;7&#125;: checkout: moving from master to hot-fix</span><br><span class="line">25f62d6 HEAD@&#123;8&#125;: checkout: moving from hot-fix to master</span><br><span class="line">25f62d6 HEAD@&#123;9&#125;: checkout: moving from master to hot-fix</span><br><span class="line">25f62d6 HEAD@&#123;10&#125;: merge hot-fix: Fast-forward</span><br><span class="line">b0006bc HEAD@&#123;11&#125;: checkout: moving from hot-fix to master</span><br><span class="line">25f62d6 HEAD@&#123;12&#125;: commit: hot-fix first commit</span><br><span class="line">b0006bc HEAD@&#123;13&#125;: checkout: moving from master to hot-fix</span><br><span class="line">b0006bc HEAD@&#123;14&#125;: reset: moving to b0006bc</span><br><span class="line">5f8dbf6 HEAD@&#123;15&#125;: commit: forth commit</span><br><span class="line">b0006bc HEAD@&#123;16&#125;: reset: moving to b0006bc</span><br><span class="line">41f776b HEAD@&#123;17&#125;: commit: third commit</span><br><span class="line">6967bf0 HEAD@&#123;18&#125;: commit: second commit</span><br><span class="line">b0006bc HEAD@&#123;19&#125;: commit (initial): first commit</span><br></pre></td></tr></table></figure><h4 id="GitHub-克隆远程库到本地"><a href="#GitHub-克隆远程库到本地" class="headerlink" title="GitHub_克隆远程库到本地"></a>GitHub_克隆远程库到本地</h4><p>基本语法：<code>git clone 远程地址</code></p><p>在远程库获取地址URL</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ff23330d5eab8f2a681c6f91727a37ca.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit (master)</span><br><span class="line">$ cd ..</span><br><span class="line"></span><br><span class="line"># 创建一个新文件夹</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop</span><br><span class="line">$ mkdir HelloGit-clone</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop</span><br><span class="line">$ cd HelloGit-clone/</span><br><span class="line"></span><br><span class="line"># 在新的文件夹内，克隆远程库到本地</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit-clone</span><br><span class="line">$ git clone https:/./Github.com/abc/HelloGit.git</span><br><span class="line">Cloning into &#x27;HelloGit&#x27;...</span><br><span class="line">remote: Enumerating objects: 16, done.</span><br><span class="line">remote: Counting objects: 100% (16/16), done.</span><br><span class="line">remote: Compressing objects: 100% (7/7), done.</span><br><span class="line">remote: Total 16 (delta 5), reused 12 (delta 4), pack-reused 0</span><br><span class="line">Receiving objects: 100% (16/16), done.</span><br><span class="line">Resolving deltas: 100% (5/5), done.</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit-clone</span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line">fatal: not a git repository (or any of the parent directories): .git</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit-clone</span><br><span class="line">$ ls</span><br><span class="line">HelloGit/</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit-clone</span><br><span class="line">$ cd HelloGit/</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit-clone/HelloGit (master)</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https:/./Github.com/abc/HelloGit.git (fetch)</span><br><span class="line">origin  https:/./Github.com/abc/HelloGit.git (push)</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit-clone/HelloGit (master)</span><br><span class="line">$ git reflog</span><br><span class="line">47e257f (HEAD -&gt; master, origin/master, origin/HEAD) HEAD@&#123;0&#125;: clone: from https:/./Github.com/JallenKwong/HelloGit.git</span><br></pre></td></tr></table></figure><p>clone 会做如下操作：</p><ol><li>拉取代码。</li><li>初始化本地仓库。</li><li>创建别名。</li></ol><h3 id="GitHub-团队内协作"><a href="#GitHub-团队内协作" class="headerlink" title="GitHub_团队内协作"></a>GitHub_团队内协作</h3><p>一、选择邀请合作者。（在仓库设置里操作）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/945f1ba6e29fb725ee0d852ff59c3851.png" alt="img"></p><p>二、填入目标合作者。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ee1b6a6656efe2adbb740b38954529b9.png" alt="img"></p><p>三、复制网址发送给你目标合作者 ， 复制内容如下：https:&#x2F;.&#x2F;Github.com&#x2F;atguiguyueyue.&#x2F;Git-shTest&#x2F;invitations。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0f5ec0155e64421d315594aa537fd187.png" alt="img"></p><p>四、目标合作者接收到网址，用浏览器打开它，点击接受邀请。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/295a2398e0a3150d50530d5db21103aa.png" alt="img"></p><p>五、接受邀请成功之后，可以在目标合作者Github账号上看到将来共同开发远程仓库。</p><p><img src="/2021/09/02/Git/ddca26e11277016e10eb610195567dac.png" alt="img"></p><p>六、目标合作者可以修改内容并 push 到远程仓库。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编辑 clone 下来的文件</span><br><span class="line">Layne@LAPTOP-Layne MINGW64 /d./Git-Space/pro-linghuchong./Git-shTest(master)</span><br><span class="line">$ vim hello.txt</span><br><span class="line">Layne@LAPTOP-Layne MINGW64 /d./Git-Space/pro-linghuchong./Git-shTest(master)</span><br><span class="line">$ cat hello.txt</span><br><span class="line">hello git! hello atguigu! 2222222222222</span><br><span class="line">hello git! hello atguigu! 33333333333333</span><br><span class="line">hello git! hello atguigu!</span><br><span class="line">hello git! hello atguigu!</span><br><span class="line">hello git! hello atguigu! 我是最帅的， 比岳不群还帅</span><br><span class="line">hello git! hello atguigu!</span><br><span class="line">hello git! hello atguigu!</span><br><span class="line">hello git! hello atguigu!</span><br><span class="line">hello git! hello atguigu!</span><br><span class="line">hello git! hello atguigu! master test</span><br><span class="line">hello git! hello atguigu! hot-fix test</span><br><span class="line"></span><br><span class="line"># 将编辑好的文件添加到暂存区</span><br><span class="line">Layne@LAPTOP-Layne MINGW64 /d./Git-Space/pro-linghuchong./Git-shTest(master)</span><br><span class="line">$ git add hello.txt</span><br><span class="line"></span><br><span class="line"># 将暂存区的文件上传到本地库</span><br><span class="line">Layne@LAPTOP-Layne MINGW64 /d./Git-Space/pro-linghuchong./Git-shTest(master)</span><br><span class="line">$ git commit -m &quot;lhc commit&quot; hello.txt</span><br><span class="line">[master 5dabe6b] lhc commit</span><br><span class="line">1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line"># 将本地库的内容 push 到远程仓库</span><br><span class="line">Layne@LAPTOP-Layne MINGW64 /d./Git-Space/pro-linghuchong./Git-shTest</span><br><span class="line">(master)</span><br><span class="line">$ git push origin master</span><br><span class="line">Logon failed, use ctrl+c to cancel basic credential prompt.</span><br><span class="line">Username for &#x27;https:/./Github.com&#x27;: atguigulinghuchong</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 12 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 309 bytes | 309.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (1/1), completed with 1 local object.</span><br><span class="line">To https:/./Github.com/atguiguyueyue./Git-shTest.git</span><br><span class="line">7cb4d02..5dabe6b master -&gt; master</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>七、回到发送合作邀请者的 GitHub 远程仓库中可以看到，最后一次是目标合作者提交的。</p><p><img src="/2021/09/02/Git/b1a36bdb929e5dcb8cc03744e8806221.png" alt="img"></p><p><img src="/2021/09/02/Git/2bb7de5f45f0a6b692d18806f976a932.png" alt="img"></p><h3 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h3><ul><li>将远程仓库的地址复制发给邀请跨团队协作的人，比如东方不败</li></ul><p><img src="/2021/09/02/Git/1662185789802.png" alt="1662185789802"></p><ul><li>在东方不败的 GitHub 账号里的地址栏复制收到的链接，然后点击 Fork 将项目叉到自己的本地仓库。</li></ul><p><img src="/2021/09/02/Git/4856e4845a7f0dbb54c79bd804892f5e.png" alt="img"></p><p>叉入中…</p><p><img src="/2021/09/02/Git/c641d9ba65f20ba58d3f98ec792ae0e5.png" alt="img"></p><p>叉成功后可以看到当前仓库信息。</p><p><img src="/2021/09/02/Git/3078d75badb2fd393dbe172327dc094c.png" alt="img"></p><ul><li>东方不败就可以在线编辑叉取过来的文件。</li></ul><p><img src="/2021/09/02/Git/40aa522895eb04a6c203a9bcbca25005-1662185925177.png" alt="img"></p><p><img src="/2021/09/02/Git/eb19249416069d158e2b4280a679063f.png" alt="img"></p><ul><li>编辑完毕后，填写描述信息并点击左下角绿色按钮提交。</li></ul><p><img src="/2021/09/02/Git/c87379a8a91eb65e2961475129362da4.png" alt="img"></p><ul><li>接下来点击上方的 Pull 请求，并创建一个新的请求。</li></ul><p><img src="/2021/09/02/Git/8bdb52dc24df07d8d846a4fe19985908.png" alt="img"></p><p><img src="/2021/09/02/Git/9c2f07c7ba5586e3923ba870a37c856d.png" alt="img"></p><p><img src="/2021/09/02/Git/996007e8e9fee91ef37af6818e164139.png" alt="img"></p><ul><li>回到岳岳 GitHub 账号可以看到有一个 Pull request 请求。</li></ul><p><img src="/2021/09/02/Git/c634b139396001cb2fcb64b8e2a078e1.png" alt="img"></p><p><img src="/2021/09/02/Git/d666e1f3544c07821e85b602d0beffc5.png" alt="img"></p><p>进入到聊天室，可以讨论代码相关内容。</p><p><img src="/2021/09/02/Git/3d97452ea50fffca42ec29308c842692.png" alt="img"></p><ul><li>如果代码没有问题，可以点击 Merge pull reque 合并代码。</li></ul><p><img src="/2021/09/02/Git/894bdb75678d7793e92f1099e5c1d080.png" alt="img"></p><h3 id="GitHub-SSH免密登录"><a href="#GitHub-SSH免密登录" class="headerlink" title="GitHub_SSH免密登录"></a>GitHub_SSH免密登录</h3><p>我们可以看到远程仓库中还有一个 SSH 的地址，因此我们也可以使用 SSH 进行访问。</p><p><img src="/2021/09/02/Git/197d6964ccfb06f1eaf22f795061826d.png" alt="img"></p><p>先到用户的主页目录，删除.ssh文件夹（如果没有.ssh文件夹，忽略此步）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~</span><br><span class="line">$ cd ~</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~</span><br><span class="line">$ pwd</span><br><span class="line">/c/Users/abc</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~</span><br><span class="line">$ ls -a .ssh</span><br><span class="line">./  ../  id_rsa  id_rsa.pub</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~</span><br><span class="line">$ rm -rf .ssh</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~</span><br><span class="line">$ ls -a .ssh</span><br><span class="line">ls: cannot access &#x27;.ssh&#x27;: No such file or directory</span><br></pre></td></tr></table></figure><p>运行命令ssh-keygen生成.ssh目录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~/Desktop/HelloGit-clone/HelloGit (master)</span><br><span class="line">$ ssh-keygen -t rsa -C abc@123.com</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/abc/.ssh/id_rsa):</span><br><span class="line">Created directory &#x27;/c/Users/abc/.ssh&#x27;.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /c/Users/abc/.ssh/id_rsa</span><br><span class="line">Your public key has been saved in /c/Users/abc/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:aeNMB/hP2yiH/Dka2jK9BJciSgA8yKKLlKXX8oei7J0 jallenkwong@163.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 3072]----+</span><br><span class="line">|=                |</span><br><span class="line">|++ .   .         |</span><br><span class="line">|+ = . . .        |</span><br><span class="line">|.= o . . +       |</span><br><span class="line">|o.o + + S o      |</span><br><span class="line">|o. o + @ * +     |</span><br><span class="line">|. o . ..O = .    |</span><br><span class="line">| o. . o+.=..     |</span><br><span class="line">|.. E  .o+oo.     |</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line"></span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~</span><br><span class="line">$ ls -a .ssh</span><br><span class="line">./  ../  id_rsa  id_rsa.pub</span><br><span class="line"></span><br><span class="line"># 生成公钥</span><br><span class="line">abc@DESKTOP-R85C9HV MINGW64 ~</span><br><span class="line">$ cat .ssh/id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQChXy8I20br9nu4GCNeZSDkozfHvlRFpXiImYnVlHVvyvFgjct1/zMeJgot1J6+yArSJbA4TMlS9nG8owCE6C9yqhPceDlKtQbARKS2pW7IyP5OhIbcqVmWmvvd+IMmsWrWgK9S6jqp0xSqv3Z3mlcHWOAK18oOe6wF6b3SyGgCP/EcwwUGX4NG7jukhK+In9joSuAxchEg/Ba2/LVjqtfBn3hXZx/SEt+rJ0UVPIT/eEe32HflrzokNcO7l0IgyLntv5QEAsSC2hiGxrM6vF5tQpb12MVZnt1/01ytP0ruQn2TVTI96vsOAa3Cj98dAH2Z0JdqZUSVBw+o3AqXP5oeF1JWkDHZzHQjLgu741wnUZn+vVXFBu1xQyApbvH7y7cNbq8PaxU+SyZbVXbq3RwTywJsyFQvsIOM5l0tG7jUD0QAd6dP3rcNODjFTaafJaBsR9aMwvKQd/d7H+BdwFPYOFp8HB2JAzhRpvlS4Av9MCIe0474wZ0T2QOJmcs7mns= abc@123.com</span><br></pre></td></tr></table></figure><p>然后，将生成的公钥添加至Github账号SSH设置。</p><p><img src="/2021/09/02/Git/1f54c4dccd3d8a17e909042c28181fb6.png" alt="img"></p><p>添加公钥后，可不用输入Github账号密码便可推送。</p><h2 id="IDEA-集成-Git"><a href="#IDEA-集成-Git" class="headerlink" title="IDEA 集成 Git"></a>IDEA 集成 Git</h2><h3 id="配置-Git-忽略文件"><a href="#配置-Git-忽略文件" class="headerlink" title="配置 Git 忽略文件"></a>配置 Git 忽略文件</h3><p><img src="/2021/09/02/Git/1662186580720.png" alt="1662186580720"></p><p>与项目的实际功能无关，不参与服务器上部署运行。把它们忽略掉能够屏蔽 IDE 工具之间的差异。例如，Maven工程根据src生成的target。</p><ul><li>创建忽略规则文件 xxxx.ignore（前缀名随便起，建议是 git.ignore），这个文件的存放位置原则上在哪里都可以，为了便于让~&#x2F;.gitconfig 文件引用，建议也放在用户家目录下。</li><li>git.ignore 文件模版内容如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure><ul><li>在.gitconfig 文件中引用忽略配置文件（此文件在 Windows 的家目录中）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = Layne</span><br><span class="line">    email = Layne@atguigu.com</span><br><span class="line">[core]</span><br><span class="line">excludesfile = C:/Users/asus./Git.ignore</span><br><span class="line">注意：这里要使用“正斜线（/）”，不要使用“反斜线（\）”</span><br></pre></td></tr></table></figure><h3 id="定位-Git-程序"><a href="#定位-Git-程序" class="headerlink" title="定位 Git 程序"></a>定位 Git 程序</h3><p><img src="/2021/09/02/Git/d86ae18c01b9a08bc73f02aa6c1b3708.png" alt="img"></p><h3 id="初始化本地库-1"><a href="#初始化本地库-1" class="headerlink" title="初始化本地库"></a>初始化本地库</h3><ul><li>在菜单栏VCS  -&gt; Create Git Repository</li></ul><p><img src="/2021/09/02/Git/1662186987800.png" alt="1662186987800"></p><p>选择要创建 Git 本地仓库的工程，也就是HelloGit工程，然后添加OK。</p><p><img src="/2021/09/02/Git/5dc609978787f3e5a83dbdf954a3e039.png" alt="img"></p><h3 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h3><p>创建一个HelloGit类，将其添加Git暂存区。</p><p>右键点击HelloGit类，选择Git-&gt;Add。可以右键点击HelloGit，更大范围地添加文件到暂存区。</p><p><img src="/2021/09/02/Git/42d316f8c5058311afc83779b0c13551.png" alt="img"></p><p>添加成功后，文件名会从红色变成绿色。</p><p><img src="/2021/09/02/Git/ec95c2b0b99d1f3a0ac8ad3291fdde50.png" alt="img"></p><h3 id="提交至本地库"><a href="#提交至本地库" class="headerlink" title="提交至本地库"></a>提交至本地库</h3><p>右键点击HelloGit，选择Git-&gt;Commit Directory。</p><p><img src="/2021/09/02/Git/9a73d7bbac024bfe61951662f5bf6ded.png" alt="img"></p><h3 id="切换版本"><a href="#切换版本" class="headerlink" title="切换版本"></a>切换版本</h3><p><img src="/2021/09/02/Git/69e6670ea5681781c173f1c86864ae1e.png" alt="img"></p><p>右键选择要切换的版本，然后在菜单里点击 Checkout Revision。</p><p><img src="/2021/09/02/Git/5530ac3d829954cebd23ed15a681769f.png" alt="img"></p><h3 id="创建分支-1"><a href="#创建分支-1" class="headerlink" title="创建分支"></a>创建分支</h3><p>右键点击HelloGit，Git -&gt; Repository -&gt; Branches，或者点击IDEA的右下角，如图红圈所示部位：</p><p><img src="/2021/09/02/Git/3e31e84cd2f7b5b95bb2639abcb1804f.png" alt="img"></p><p>在弹出的 Git Branches 框里，点击 New Branch 按钮。</p><p><img src="/2021/09/02/Git/b9c18ec9924788adfa432b7b924308ce.png" alt="img"></p><p>填写分支名称，创建 hot-fix 分支。</p><p><img src="/2021/09/02/Git/8a4a5e7cf7511d086ddac0be704e850f.png" alt="img"></p><h3 id="切换分支-1"><a href="#切换分支-1" class="headerlink" title="切换分支"></a>切换分支</h3><ul><li>跟<strong>创建分支</strong>步骤相似，如点击IDEA的右下角（它显示项目正处在那条分支），如图红圈所示部位，选择你想要切换的分支，然后checkout：</li></ul><p><img src="/2021/09/02/Git/c7544c1bade118b3177907ad903a8082.png" alt="img"></p><p><img src="/2021/09/02/Git/afbbe9a835629f522d0b02024fe2c11b.png" alt="img"></p><ul><li>或者在log窗口，右键点击分支，选择checkout：</li></ul><p><img src="/2021/09/02/Git/7ab6ab48e9b5a42009757b8b17b901f0.png" alt="img"></p><h3 id="合并分支-正常合并-1"><a href="#合并分支-正常合并-1" class="headerlink" title="合并分支(正常合并)"></a>合并分支(正常合并)</h3><p>先在hot-fix分支修改HelloGit类，并将其提交：</p><p><img src="/2021/09/02/Git/41667203b7e067b59d1310cce4d92b15.png" alt="img"></p><p>然后切换到master分支，右下角的hot-fix会变为master：</p><p><img src="/2021/09/02/Git/f183b86164b0e00e9d6e8c8c9a4a17da.png" alt="img"></p><p>然后，点击IDEA 窗口的右下角的master，将 hot-fix 分支合并到当前 master 分支。选择hot-fix-&gt;Merge into Current</p><p><img src="/2021/09/02/Git/fff1d4e014223aa2cc70f0fdc237f350.png" alt="img"></p><p>如果代码没有冲突， 分支直接合并成功，分支合并成功以后，代码自动提交，无需手动提交本地库。</p><p><img src="/2021/09/02/Git/271421c28750e86e69accd6ac687490c.png" alt="img"></p><h3 id="合并分支-冲突合并-1"><a href="#合并分支-冲突合并-1" class="headerlink" title="合并分支(冲突合并)"></a>合并分支(冲突合并)</h3><p>分别在master，hot-fix分支修改HelloGit类同一行，并提交，故意制作冲突：</p><p><img src="/2021/09/02/Git/53daad680bc796069dc1ce61682d4abc.png" alt="img"></p><p><img src="/2021/09/02/Git/f8fcf275169cdec742d31ce85ce20d7f.png" alt="img"></p><p>切换到master分支，将hot-fix的合并到master分支：</p><p><img src="/2021/09/02/Git/fff1d4e014223aa2cc70f0fdc237f350-1662187618450.png" alt="img"></p><p>冲突产生，需要人工解决：</p><p><img src="/2021/09/02/Git/eb3804e00dccfa2658aa33c972d8996e.png" alt="img"></p><p><img src="/2021/09/02/Git/a73d642f285f171eeff7ae0c9bb6111b.png" alt="img"></p><p><img src="/2021/09/02/Git/eafebea94008b4f1f0ae15f8b2092919.png" alt="img"></p><p>代码冲突解决，将代码提交本地库后，如图所示：</p><p><img src="/2021/09/02/Git/15a9058f7f35112b8605cd69aaf42e35.png" alt="img"></p><h2 id="IDEA集成GitHub"><a href="#IDEA集成GitHub" class="headerlink" title="IDEA集成GitHub"></a>IDEA集成GitHub</h2><h3 id="设置GitHub账号"><a href="#设置GitHub账号" class="headerlink" title="设置GitHub账号"></a>设置GitHub账号</h3><p>在菜单栏File-&gt;Setting-&gt;搜索栏搜GitHub，添加GitHub账号：</p><p><img src="/2021/09/02/Git/00572764f1ed257dbc2d0f668434e6a0.png" alt="img"></p><p>由于网络问题，会时常登陆不了：</p><p>解决方法：可通过Token登陆。</p><p><img src="/2021/09/02/Git/f3a64a809fa56624a997073836139140.png" alt="img"></p><p><img src="/2021/09/02/Git/200c556f6f0b6d44c442b58d6e8bb7ea.png" alt="img"></p><p><img src="/2021/09/02/Git/81a82fb47421c0a802cd1cfad7297e43.png" alt="img"></p><p><img src="/2021/09/02/Git/3f596f2f68d50d277eefe1a4e6035d2d.png" alt="img"></p><p>将生成的token用来IDEA登录。</p><p><img src="/2021/09/02/Git/704eafd9157658a0be35b081c3530ced.png" alt="img"></p><h3 id="分享项目到GitHub"><a href="#分享项目到GitHub" class="headerlink" title="分享项目到GitHub"></a>分享项目到GitHub</h3><p><img src="/2021/09/02/Git/e057d2e660c2033ef9eae0c638aee2bc.png" alt="img"></p><p><img src="/2021/09/02/Git/a5ba3e09a890113b94420c3939dac239.png" alt="img"></p><h3 id="push-推送本地库到远程库"><a href="#push-推送本地库到远程库" class="headerlink" title="push 推送本地库到远程库"></a>push 推送本地库到远程库</h3><p><img src="/2021/09/02/Git/84baeaa175c6faa3ff538e0313187eff.png" alt="img"></p><p><img src="/2021/09/02/Git/1ee51e1ed781404a93655f1ad10bd9ca.png" alt="img"></p><p><img src="/2021/09/02/Git/1662190343420.png" alt="1662190343420"></p><p><img src="/2021/09/02/Git/1662190517662.png" alt="1662190517662"></p><p>注意：<strong>push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说，要想 push 成功，一定要保证本地库的版本要比远程库的版本高！因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送！</strong></p><h3 id="pull-拉取远程库到本地库"><a href="#pull-拉取远程库到本地库" class="headerlink" title="pull 拉取远程库到本地库"></a>pull 拉取远程库到本地库</h3><p>右键点击项目，可以将远程仓库的内容 pull 到本地仓库。</p><p><img src="/2021/09/02/Git/193d00830bc1636e2ae2640b749b9899.png" alt="img"></p><p>注意： pull 是拉取远端仓库代码到本地，如果远程库代码和本地库代码不一致，会自动合并，如果自动合并失败，还会涉及到手动解决冲突的问题。</p><h3 id="clone-克隆远程库到本地"><a href="#clone-克隆远程库到本地" class="headerlink" title="clone 克隆远程库到本地"></a>clone 克隆远程库到本地</h3><p><img src="/2021/09/02/Git/f436b8f9156e5e5ce8c0e2b3b5fe3639.png" alt="img"></p><p>或者在菜单栏VCS-&gt;Get from Version Control。</p><p><img src="/2021/09/02/Git/63f9691dd0a7627bd44a125942be7f31.png" alt="img"></p><h2 id="国内代码托管中心-码云"><a href="#国内代码托管中心-码云" class="headerlink" title="国内代码托管中心-码云"></a>国内代码托管中心-码云</h2><h3 id="码云简介"><a href="#码云简介" class="headerlink" title="码云简介"></a>码云简介</h3><p>众所周知， GitHub 服务器在国外， 使用 GitHub 作为项目托管网站，如果网速不好的话，严重影响使用体验，甚至会出现登录不上的情况。针对这个情况， 大家也可以使用国内的项目托管网站-码云。</p><p>码云是开源中国推出的基于 Git 的代码托管服务中心， 网址是 https:&#x2F;.&#x2F;Gitee.com&#x2F; ，使用方式跟 GitHub 一样，而且它还是一个中文网站，如果你英文不是很好，它是最好的选择。</p><h3 id="导入GitHub项目"><a href="#导入GitHub项目" class="headerlink" title="导入GitHub项目"></a>导入GitHub项目</h3><p><img src="/2021/09/02/Git/1662190833525.png" alt="1662190833525"></p><p><img src="/2021/09/02/Git/1662190848719.png" alt="1662190848719"></p><p>如果 GitHub 项目更新了以后，在码云项目端可以手动重新同步，进行更新</p><p><img src="/2021/09/02/Git/1662190908466.png" alt="1662190908466"></p><h2 id="自建代码托管平台-GitLab"><a href="#自建代码托管平台-GitLab" class="headerlink" title="自建代码托管平台-GitLab"></a>自建代码托管平台-GitLab</h2><h3 id="GitLab简介"><a href="#GitLab简介" class="headerlink" title="GitLab简介"></a>GitLab简介</h3><p>GitLab 是由 GitLab Inc.开发，使用 MIT 许可证的基于网络的 Git 仓库管理工具，且具有wiki 和 issue 跟踪功能。使用 Git 作为代码管理工具，并在此基础上搭建起来的 web 服务。（可搭建局域网Git仓库）。</p><p>GitLab 由乌克兰程序员 DmitriyZaporozhets 和 ValerySizov 开发，它使用 Ruby 语言写成。后来，一些部分用 Go 语言重写。截止 2018 年 5 月，该公司约有 290 名团队成员，以及 2000 多名开源贡献者。 GitLab 被 IBM， Sony， JülichResearchCenter， NASA， Alibaba，Invincea， O’ReillyMedia， Leibniz-Rechenzentrum(LRZ)， CERN， SpaceX 等组织使用。</p><h3 id="GitLab官网地址"><a href="#GitLab官网地址" class="headerlink" title="GitLab官网地址"></a>GitLab官网地址</h3><p><a href="https://about.gitlab.com/">官网地址</a></p><p><a href="https://about.gitlab.com/installation/">安装说明</a></p><h3 id="GitLab安装准备"><a href="#GitLab安装准备" class="headerlink" title="GitLab安装准备"></a>GitLab安装准备</h3><ol><li>准备一个系统为 CentOS7 以上版本的服务器， 要求内存 4G，磁盘 50G。</li><li>关闭防火墙， 并且配置好主机名和 IP，保证服务器可以上网。</li><li>此教程使用虚拟机：主机名： root IP 地址： 192.168.182.128</li><li>Yum 在线安装 gitlab- ce 时，需要下载几百 M 的安装文件，非常耗时，所以最好提前把所需 RPM 包下载到本地，然后使用离线 rpm 的方式安装。<a href="https://packages.gitlab.com./Gitlab./Gitlab-ce/packages/el/7./Gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm">下载地址</a>。注：资料里提供了此 rpm 包，直接将此包上传到服务器&#x2F;opt&#x2F;module 目录下即可。</li></ol><p><img src="/2021/09/02/Git/1662195174601.png" alt="1662195174601"></p><h3 id="GitLab-安装-amp-初始化服务-amp-启动服务"><a href="#GitLab-安装-amp-初始化服务-amp-启动服务" class="headerlink" title="GitLab_安装&amp;初始化服务&amp;启动服务"></a>GitLab_安装&amp;初始化服务&amp;启动服务</h3><h4 id="编写安装脚本"><a href="#编写安装脚本" class="headerlink" title="编写安装脚本"></a>编写安装脚本</h4><p>安装 gitlab 步骤比较繁琐，因此我们可以参考<a href="https://packages.gitlab.com/install/repositories./Gitlab./Gitlab-ce/script.rpm.sh">官网编写 gitlab 的安装脚本</a>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@gitlab-server module]# vim gitlab-install.sh</span><br><span class="line">sudo rpm -ivh /opt/module./Gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">sudo yum install -y curl policycoreutils-python openssh-server cronie</span><br><span class="line"></span><br><span class="line">sudo lokkit -s http -s ssh</span><br><span class="line"></span><br><span class="line">sudo yum install -y postfix</span><br><span class="line"></span><br><span class="line">sudo service postfix start</span><br><span class="line"></span><br><span class="line">sudo chkconfig postfix on</span><br><span class="line"></span><br><span class="line">curl https://packages.gitlab.com/install/repositories./Gitlab./Gitlab-ce/script.rpm.sh | sudo bash</span><br><span class="line"></span><br><span class="line">sudo EXTERNAL_URL=&quot;http:/./Gitlab.example.com&quot; yum -y install gitlab-ce</span><br></pre></td></tr></table></figure><p>给脚本增加执行权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@gitlab-server module]# chmod +x gitlab-install.sh</span><br><span class="line">[root@gitlab-server module]# ll</span><br><span class="line">总用量 403104</span><br><span class="line">-rw-r--r--. 1 root root 412774002 4 月 7 15:47 gitlab-ce-13.10.2-</span><br><span class="line">ce.0.el7.x86_64.rpm</span><br><span class="line">-rwxr-xr-x. 1 root root 416 4 月 7 15:49 gitlab-install.sh</span><br></pre></td></tr></table></figure><p>然后执行该脚本，开始安装 gitlab-ce。注意一定要保证服务器可以上网。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@gitlab-server module]# ../Gitlab-install.sh</span><br><span class="line">警告： /opt/module./Gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm: 头 V4</span><br><span class="line">RSA/SHA1 Signature, 密钥 ID f27eab47: NOKEY</span><br><span class="line">准备中... #################################</span><br><span class="line">[100%]</span><br><span class="line">正在升级/安装...</span><br><span class="line">1:gitlab-ce-13.10.2-ce.0.el7</span><br><span class="line">################################# [100%]</span><br><span class="line">。 。 。 。 。 。</span><br></pre></td></tr></table></figure><h4 id="初始化GitLab服务"><a href="#初始化GitLab服务" class="headerlink" title="初始化GitLab服务"></a>初始化GitLab服务</h4><p>执行以下命令初始化 GitLab 服务，过程大概需要几分钟，耐心等待…</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@gitlab-server module]# gitlab-ctl reconfigure</span><br><span class="line">。 。 。 。 。 。</span><br><span class="line">Running handlers:</span><br><span class="line">Running handlers complete</span><br><span class="line">Chef Client finished, 425/608 resources updated in 03 minutes 08</span><br><span class="line">seconds</span><br><span class="line">gitlab Reconfigured!</span><br></pre></td></tr></table></figure><h4 id="启动GitLab服务"><a href="#启动GitLab服务" class="headerlink" title="启动GitLab服务"></a>启动GitLab服务</h4><p>执行以下命令启动 GitLab 服务，如需停止，执行 <code>gitlab-ctl stop</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@gitlab-server module]# gitlab-ctl start</span><br><span class="line">ok: run: alertmanager: (pid 6812) 134s</span><br><span class="line">ok: run: gitaly: (pid 6740) 135s</span><br><span class="line">ok: run: gitlab-monitor: (pid 6765) 135s</span><br><span class="line">ok: run: gitlab-workhorse: (pid 6722) 136s</span><br><span class="line">ok: run: logrotate: (pid 5994) 197s</span><br><span class="line">ok: run: nginx: (pid 5930) 203s</span><br><span class="line">ok: run: node-exporter: (pid 6234) 185s</span><br><span class="line">ok: run: postgres-exporter: (pid 6834) 133s</span><br><span class="line">ok: run: postgresql: (pid 5456) 257s</span><br><span class="line">ok: run: prometheus: (pid 6777) 134s</span><br><span class="line">ok: run: redis: (pid 5327) 263s</span><br><span class="line">ok: run: redis-exporter: (pid 6391) 173s</span><br><span class="line">ok: run: sidekiq: (pid 5797) 215s</span><br><span class="line">ok: run: unicorn: (pid 5728) 221s</span><br></pre></td></tr></table></figure><h4 id="使用浏览器访问-GitLab"><a href="#使用浏览器访问-GitLab" class="headerlink" title="使用浏览器访问 GitLab"></a>使用浏览器访问 GitLab</h4><p>使用主机名或者 IP 地址即可访问 GitLab 服务。需要提前配一下 windows 的 hosts 文件（C:\Windows\System32\drivers\etc）</p><p><img src="/2021/09/02/Git/1662197526651.png" alt="1662197526651"></p><p><img src="/2021/09/02/Git/1662197554840.png" alt="1662197554840"></p><p>首次登陆之前，需要修改下 GitLab 提供的 root 账户的密码，要求 8 位以上，包含大小写子母和特殊符号。因此我们修改密码为 Athua.123456</p><p>然后使用修改后的密码登录 GitLab。</p><p><img src="/2021/09/02/Git/1662197678506.png" alt="1662197678506"></p><h4 id="GitLab-创建远程库"><a href="#GitLab-创建远程库" class="headerlink" title="GitLab 创建远程库"></a>GitLab 创建远程库</h4><p><img src="/2021/09/02/Git/2ab639dfaa57cd499133c2c4cde1222a.png" alt="img"></p><p><img src="/2021/09/02/Git/f135a7b76c745c3aeef9034a82c8afaf.png" alt="img"></p><p><img src="/2021/09/02/Git/1662197907214.png" alt="1662197907214"></p><h3 id="IDEA集成GitLab"><a href="#IDEA集成GitLab" class="headerlink" title="IDEA集成GitLab"></a>IDEA集成GitLab</h3><p><img src="/2021/09/02/Git/1f34175126922c56c158f466dd4d665c.png" alt="img"></p><p>设置 GitLab 插件</p><p><img src="/2021/09/02/Git/1662198117337.png" alt="1662198117337"></p><p><img src="/2021/09/02/Git/1662198198088.png" alt="1662198198088"></p><p><img src="/2021/09/02/Git/1662198253221.png" alt="1662198253221"></p><p>push 本地代码到 GitLab 远程库</p><p><img src="/2021/09/02/Git/1662198338244.png" alt="1662198338244"></p><p>自定义远程连接</p><p><img src="/2021/09/02/Git/1662198369403.png" alt="1662198369403"></p><p>注意：gitlab 网页上复制过来的连接是：http:&#x2F;.&#x2F;Gitlab.example.com&#x2F;root.&#x2F;Git-test.git，需要手动修改为：http:&#x2F;.&#x2F;Gitlab-server&#x2F;root.&#x2F;Git-test.git选择 gitlab 远程连接，进行 push。</p><p><img src="/2021/09/02/Git/1662198399511.png" alt="1662198399511"></p><p>接下来插件配置，Git操作等与Github、Gitee的IDEA插件大同小异，不再赘述，自己触类旁通吧！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
