<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>RabbitMQ | 阿华</title><meta name="author" content="HUA"><meta name="copyright" content="HUA"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="消息队列MQ 的相关概念什么是 MQMQ (message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦 + 物理解耦” 的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。 为什么要用 MQ流量">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ">
<meta property="og:url" content="http://example.com/2022/09/03/RabbitMQ/index.html">
<meta property="og:site_name" content="阿华">
<meta property="og:description" content="消息队列MQ 的相关概念什么是 MQMQ (message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦 + 物理解耦” 的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。 为什么要用 MQ流量">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/page6.jpg">
<meta property="article:published_time" content="2022-09-03T05:32:01.131Z">
<meta property="article:modified_time" content="2023-05-30T08:35:03.078Z">
<meta property="article:author" content="HUA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/page6.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/09/03/RabbitMQ/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RabbitMQ',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-30 16:35:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">阿华</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">RabbitMQ</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-03T05:32:01.131Z" title="发表于 2022-09-03 13:32:01">2022-09-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-30T08:35:03.078Z" title="更新于 2023-05-30 16:35:03">2023-05-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">31.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>119分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RabbitMQ"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="MQ-的相关概念"><a href="#MQ-的相关概念" class="headerlink" title="MQ 的相关概念"></a>MQ 的相关概念</h3><h4 id="什么是-MQ"><a href="#什么是-MQ" class="headerlink" title="什么是 MQ"></a>什么是 MQ</h4><p>MQ (message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游 “逻辑解耦 + 物理解耦” 的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p>
<h4 id="为什么要用-MQ"><a href="#为什么要用-MQ" class="headerlink" title="为什么要用 MQ"></a>为什么要用 MQ</h4><h5 id="流量消峰"><a href="#流量消峰" class="headerlink" title="流量消峰"></a>流量消峰</h5><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p>
<h5 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h5><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/image.1ddl4r0fiusg.webp" alt="image"></p>
<h5 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h5><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。</p>
<p>以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。</p>
<p>使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作，A 服务还能及时的得到异步处理成功的消息。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1661862780613.png" alt="1661862780613"></p>
<h4 id="MQ的分类"><a href="#MQ的分类" class="headerlink" title="MQ的分类"></a>MQ的分类</h4><ul>
<li><p><strong>ActiveMQ</strong></p>
<p>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据（很少丢失消息）。</p>
<p>缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</p>
</li>
<li><p><strong>Kafka</strong></p>
<p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<strong>大数据而生</strong>的消息中间件，以其<strong>百万级 TPS 的吞吐量</strong>名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber，Twitter，Netflix 等大公司所采纳。</p>
<p>优点: 性能卓越，单机写入 TPS 约在百万条&#x2F;秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次；有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能 较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。</p>
<p>缺点：Kafka 单机超过 64 个队列&#x2F;分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢。</p>
</li>
<li><p><strong>RocketMQ</strong></p>
<p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p>
<p>优点：<strong>单机吞吐量十万级，可用性非常高</strong>，分布式架构,<strong>消息可以做到 0 丢失</strong>,MQ 功能较为完善，还是分布式的，扩展性好,<strong>支持 10 亿级别的消息堆积</strong>，不会因为堆积导致性能下降，源码是 java 我们可以自己阅读源码，定制自己公司的 MQ。</p>
<p>缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟；社区活跃度一般,没有在 MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码。</p>
</li>
<li><p><strong>RabbitMQ</strong></p>
<p>2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p>
<p>优点：由于 erlang 语言的<strong>高并发特性</strong>，性能较好；<strong>吞吐量到万级</strong>，MQ 功能比较完备,健壮、稳定、易用、跨平台、<strong>支持多种语言</strong> 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高。<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/news.html">官网</a></p>
<p>缺点：商业版需要收费,学习成本较高。</p>
</li>
</ul>
<h4 id="MQ的选择"><a href="#MQ的选择" class="headerlink" title="MQ的选择"></a>MQ的选择</h4><ul>
<li><p><strong>Kafka</strong></p>
<p>Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，<strong>适合产生大量数据</strong>的互联网服务的数据收集业务。<strong>大型公司</strong>建议可以选用，如果有<strong>日志采集</strong>功能，肯定是首选 kafka 了。</p>
</li>
<li><p><strong>RocketMQ</strong></p>
<p>天生为<strong>金融互联网</strong>领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p>
</li>
<li><p><strong>RabbitMQ</strong></p>
<p>结合 erlang 语言本身的并发优势，性能好<strong>时效性微秒级，社区活跃度也比较高</strong>，管理界面用起来十分 方便，如果你的<strong>数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ。</p>
</li>
</ul>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="RabbitMQ的概念"><a href="#RabbitMQ的概念" class="headerlink" title="RabbitMQ的概念"></a>RabbitMQ的概念</h4><p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p>
<h4 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h4><ul>
<li>生产者：产生数据发送消息的程序</li>
<li>交换机：是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息<strong>推送到特定队列还是推送到多个队列</strong>，亦或者是把消息丢弃，这个得有交换机类型决定</li>
<li>队列：是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</li>
<li>消费者：消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</li>
</ul>
<h4 id="RabbitMQ核心部分"><a href="#RabbitMQ核心部分" class="headerlink" title="RabbitMQ核心部分"></a>RabbitMQ核心部分</h4><ol>
<li>简单模式</li>
<li>工作模式</li>
<li>发布&#x2F;订阅模式</li>
<li>路由模式</li>
<li>主题模式</li>
<li>发布确认模式</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1661864017086.png" alt="1661864017086"></p>
<h4 id="各个名词介绍"><a href="#各个名词介绍" class="headerlink" title="各个名词介绍"></a>各个名词介绍</h4><p><img src="/img/loading.gif" data-original="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/image.15tq7c46aeyk.webp" alt="image"></p>
<ul>
<li><code>Producer</code>：生产者</li>
<li><code>Consumer</code>：消费者</li>
<li><code>Broker</code>：消息实体，接收和分发消息的应用，RabbitMQ Server 就是 Message Broker。</li>
<li><code>Virtual host</code>：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，就是在同一个消息实体，<strong>可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</strong>。</li>
<li><code>Connection</code>：publisher／consumer 和 broker 之间的 TCP 连接。</li>
<li><code>Channel</code>：信道（发消息的通道），如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销。</strong></li>
<li><code>Exchange</code>：交换机，message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point)，topic (publish-subscribe) and fanout (multicast)。</li>
<li><code>Queue</code>：队列，消息最终被送到这里等待 consumer 取走。</li>
<li><code>Binding</code>：绑定，<strong>exchange 和 queue 之间的虚拟连接</strong>，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据。</li>
</ul>
<h4 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h4><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p><a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-server/releases">RabbitMQ最新版下载地址</a></p>
<p>选择以 <code>noarch.rpm</code> 结尾的安装包</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1661865027511.png" alt="1661865027511"></p>
<p>RabbitMQ 是采用 Erlang 语言开发的，所以系统环境必须提供 Erlang 环境，需要先安装 Erlang。</p>
<p><code>Erlang</code> 和 <code>RabbitMQ</code> 版本对照：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/which-erlang.html">点击跳转</a></p>
<p>这里安装的是 3.8.8 版本的 RabbitMQ，需要的 Erlang 版本依然是21.3。</p>
<p><a target="_blank" rel="noopener" href="https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.16-1.el7.x86_64.rpm">Erlang 21.3下载地址</a></p>
<p><img src="/img/loading.gif" data-original="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/image.44zjpnbpbyo0.webp" alt="image"></p>
<blockquote>
<p>版本选择</p>
<p>CentOs 7.x 版本需要e17。</p>
<p>CentOs 8.x 版本需要e18。包括 Red Hat 8,modern Fedora 版本。</p>
</blockquote>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1661867221067.png" alt="1661867221067"></p>
<p>上传到 &#x2F;usr&#x2F;local&#x2F;rabbitmq目录下 (如果没有 rabbitmq需要自己创建)（windows上传路径为英文比较好）</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1661867287795.png" alt="1661867287795"></p>
<p>安装Erlang</p>
<p>进入 <code>/usr/local/rabbitmq</code> 目录，解压安装 Erlang</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/rabbitmq</span><br><span class="line">rpm -ivh erlang-21.3-1.el7.x86_64.rpm</span><br><span class="line">######################################</span><br><span class="line">i 代表 install</span><br><span class="line">vh 代表显示安装进度过程</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1661867710712.png" alt="1661867710712"></p>
<p> 安装RabbitMQ</p>
<p>在 <code>RabiitMQ</code> 安装过程中需要依赖 <code>socat</code> 插件，首先安装该插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install socat -y</span><br></pre></td></tr></table></figure>

<p>解压 <code>RabbitMQ</code> 安装包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1661867899782.png" alt="1661867899782"></p>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动服务</span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line"># 查看服务状态</span><br><span class="line">systemctl status rabbitmq-server</span><br><span class="line"># 开机自启动</span><br><span class="line">systemctl enable rabbitmq-server</span><br><span class="line"># 停止服务</span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line"># 重启服务</span><br><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>

<p>启动 <code>RabbitMQ</code> 服务后，查看该服务状态，显示绿色的 <code>active</code> 则表示服务安装并启动成功。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1661868173122.png" alt="1661868173122"></p>
<h5 id="管理界面及授权操作"><a href="#管理界面及授权操作" class="headerlink" title="管理界面及授权操作"></a>管理界面及授权操作</h5><blockquote>
<p>默认端口</p>
<p>RabbitMQ 的默认访问端口是 15672</p>
<p>如果 Linux 有防火墙，记得开放 15672 端口，否则 Windows 无法访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看防火墙状态</span><br><span class="line">systemctl status firewalld</span><br><span class="line">#关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">#下次启动自动关闭</span><br><span class="line">systemctl enable firewalld</span><br></pre></td></tr></table></figure>


</blockquote>
<p>先关闭rabbitmq服务在安装——systemctl stop rabbitmq-server</p>
<p>默认情况下，RabbiMQ 没有安装 Web 端的客户端软件，需要安装才可以生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>

<p>安装完毕以后，启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start rabbitmq-server</span><br></pre></td></tr></table></figure>

<p>通过 <code>http://ip:15672</code> 访问，ip 为 Linux 的 ip，(<a target="_blank" rel="noopener" href="http://192.168.182.128:15672/)%EF%BC%8C%60rabbitmq%60">http://192.168.182.128:15672/)，`rabbitmq`</a> 有一个默认的账号密码 <code>guest</code>，但是登录该账号密码会出现权限问题。默认情况只能在 localhost 本机下访问，所以需要添加一个远程登录的用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建账号和密码</span><br><span class="line">rabbitmqctl add_user admin 123456</span><br><span class="line"></span><br><span class="line"># 设置用户角色</span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"></span><br><span class="line"># 为用户添加资源权限，添加配置、写、读权限</span><br><span class="line"># set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">#当前用户和角色</span><br><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>

<p>角色固定有四种级别：</p>
<ul>
<li><code>administrator</code>：可以登录控制台、查看所有信息、并对rabbitmq进行管理</li>
<li><code>monToring</code>：监控者；登录控制台，查看所有信息</li>
<li><code>policymaker</code>：策略制定者；登录控制台指定策略</li>
<li><code>managment</code>：普通管理员；登录控制</li>
</ul>
<p>添加用户和权限后，再次访问 <code>http://ip:15672</code> 登录，输入添加好的用户名和密码，即可进入后台(<a target="_blank" rel="noopener" href="http://192.168.182.128:15672/">http://192.168.182.128:15672/</a>)</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1661868976660.png" alt="1661868976660"></p>
<p>其他命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#关闭应用的命令</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">#清除的命令</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">#重新启动命令</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"># 修改密码</span><br><span class="line">rabbitmqctl change_ password 用户名 新密码</span><br><span class="line"># 删除用户</span><br><span class="line">rabbitmqctl delete_user 用户名</span><br></pre></td></tr></table></figure>

<h2 id="Hello-RabbitMQ"><a href="#Hello-RabbitMQ" class="headerlink" title="Hello RabbitMQ"></a>Hello RabbitMQ</h2><p>用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者</p>
<p>在下图中，“ P” 是我们的生产者，“ C” 是我们的消费者。中间的框是一个队列 RabbitMQ 代表使用者保留的消息缓冲区</p>
<p><img src="/img/loading.gif" data-original="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/image.53zsdpm4hbk0.webp" alt="image"></p>
<blockquote>
<p>注意</p>
<p>Java 进行连接的时候，需要 Linux 开放 5672 端口，否则会连接超时</p>
<p>访问 Web 界面的端口是 15672，连接服务器的端口是 5672</p>
</blockquote>
<p>步骤图：</p>
<p><img src="/img/loading.gif" data-original="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/image.5zalz3u39nk0.webp" alt="image"></p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>先创建好 Maven 工程，pom.xml 添入依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--rabbitmq 依赖客户端--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">5.8</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--操作文件流的一个依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.6</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--指定 jdk 编译版本--&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;source&gt;<span class="number">8</span>&lt;/source&gt;</span><br><span class="line">                &lt;target&gt;<span class="number">8</span>&lt;/target&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><p>创建一个类作为生产者，最终生产消息到 RabbitMQ 的队列里</p>
<p>步骤：</p>
<ol>
<li>创建 RabbitMQ 连接工厂</li>
<li>进行 RabbitMQ 工厂配置信息</li>
<li>创建 RabbitMQ 连接</li>
<li>创建 RabbitMQ 信道</li>
<li>生成一个队列</li>
<li>发送一个消息到交换机，交换机发送到队列。”” 代表默认交换机</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/8/31 21:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//工厂IP 连接RabbitMQ的队列</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.182.128&quot;</span>);</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.队列名称</span></span><br><span class="line"><span class="comment">         *  2.队列里面的消息是否持久化（存储在磁盘中持久化），默认情况消息存储在内存中（非持久化false）</span></span><br><span class="line"><span class="comment">         *  3.该队列是否只供一个消费者进行消费，是否进行消息共享，true可以多个消费者消费，默认为false</span></span><br><span class="line"><span class="comment">         *  4.是否自动删除，最后一个消费者断开连接后，是否自动删除，true自动删除，false不自动删除</span></span><br><span class="line"><span class="comment">         *  5.其他参数</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消息</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.发送到那个交换机</span></span><br><span class="line"><span class="comment">         *  2.路由的Key值（本次是队列的名称）</span></span><br><span class="line"><span class="comment">         *  3.其他参数</span></span><br><span class="line"><span class="comment">         *  4.发送消息的消息体</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        System.out.printf(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1661955780328.png" alt="1661955780328"></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1661955750218.png" alt="1661955750218"></p>
<h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>创建一个类作为消费者，消费 RabbitMQ 队列的消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/8/31 22:26</span></span><br><span class="line"><span class="comment"> * 消息消费者    接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称 接收此队列的消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.182.128&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者消费消息</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.消费哪个队列</span></span><br><span class="line"><span class="comment">         *  2.消费成功之后是否要自动应答， false代表手动应答</span></span><br><span class="line"><span class="comment">         *  3.当一个消息发送过来后的回调接口</span></span><br><span class="line"><span class="comment">         *  4.当一个消费者取消订阅时的回调接口，消费者取消消费的回调</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//接收消息成功的回调</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag,message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息接收失败的回调</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">false</span>,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1661957754113.png" alt="1661957754113"></p>
<p>值得一提的是，<code>basicConsume</code> 的参数中，第三个和第四个参数都是接口，所以需要实现该接口的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicConsume(队列名字/String, 是否自动签收/<span class="type">boolean</span>, 消费时的回调/接口类, 无法消费的回调/接口类);</span><br></pre></td></tr></table></figure>

<h2 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h2><p>Work Queues 是工作队列（又称任务队列）的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程（消费者）时，这些<strong>工作线程将一起处理这些任务</strong>。</p>
<h3 id="轮询消费"><a href="#轮询消费" class="headerlink" title="轮询消费"></a>轮询消费</h3><p>轮询消费消息指的是轮流消费消息，即每个工作队列都会获取一个消息进行消费，并且获取的次数按照顺序依次往下轮流。</p>
<p>案例中生产者叫做 Task，一个消费者就是一个工作队列，启动两个工作队列消费消息，这个两个工作队列会以轮询的方式消费消息。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/image.3iwquz975vw0.webp" alt="image"></p>
<h3 id="轮询案例"><a href="#轮询案例" class="headerlink" title="轮询案例"></a>轮询案例</h3><ul>
<li>首先把 RabbitMQ 的配置参数封装为一个工具类：<code>RabbitMQUtils</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 20:02</span></span><br><span class="line"><span class="comment"> * rabbitmq连接工厂创建信道的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;19.168.182.128&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建两个工作队列，并且启动</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.two;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.utils.RabbitMQUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Delivery;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 20:11</span></span><br><span class="line"><span class="comment"> * 这是一个工作线程，相当于消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;</span><br><span class="line">    <span class="comment">//队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息的接收成功执行</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息接收失败执行</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息者取消消费消息回调逻辑：&quot;</span>+consumerTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;C1等待接收消息......&quot;</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建好一个工作队列，只需要以多线程方式启动两次该 main 函数即可，以 first、second 区别消息队列。</p>
<p>要开启多线程功能，首先启动该消息队列，然后如图开启多线程：</p>
<p><img src="/img/loading.gif" data-original="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/1658588553672.629xpapm6wg0.webp" alt="1658588553672"></p>
<p>两次main启动之后：</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1662037029891.png" alt="1662037029891"></p>
<ul>
<li>创建一个生产者，发送消息进程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.two;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.utils.RabbitMQUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 20:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task01</span>&#123;</span><br><span class="line">    <span class="comment">//队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//队列的声明</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从控制台接收消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,next.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息成功：&quot;</span>+next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果演示</li>
</ul>
<p>通过程序执行发现生产者总共发送 4 个消息，消费者 first 和消费者 second 分别分得两个消息，并且是按照有序的一个接收一次消息</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1662037164828.png" alt="1662037164828"></p>
<h3 id="Web页面添加队列"><a href="#Web页面添加队列" class="headerlink" title="Web页面添加队列"></a>Web页面添加队列</h3><p>进入自己的 RabbitMQ Web 页面，点击 Queues 菜单</p>
<p><img src="/img/loading.gif" data-original="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220723/image.701dj3uqk400.webp" alt="image"></p>
<ol>
<li>点击 <code>Queues</code> 菜单</li>
<li>点击 <code>Add a new queue</code>，弹出下拉菜单</li>
<li>下方的很多参数可以进行选择（旁边有 ？的参数），如优先级（<code>Lazy mode</code>）、绑定死信队列（<code>Dead letter exchange/routing key</code>）</li>
<li>执行步骤 3 后，在 <code>Arguments</code> 的第一个文本框弹出对应的参数，类似于 Map 的 key</li>
<li>第二个文本框填写参数，类似于 Map 的 value</li>
<li>第三个是下拉菜单，选择 value 类型</li>
<li>点击 <code>Add queue</code>，添加队列</li>
</ol>
<p>旁边有 ？的参数，就是 <code>channel.queueDeclare(队列名/String, 持久化/boolean, 共享消费/boolean, 自动删除/boolean, 配置参数/Map);</code> 或者 <code>channel.basicPublish(交换机名/String, 队列名/String, 配置参数/Map, 消息/String);</code> 的参数：配置参数&#x2F;Map 的 key</p>
<h3 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h3><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ <strong>一旦向消费者传递了一条消息，便立即将该消息标记为删除</strong>。在这种情况下，突然有个消费者挂掉了，我们将<strong>丢失正在处理的消息</strong>。以及后续发送给该消费者的消息，因为它无法接收到。</p>
<p>为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：<strong>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong></p>
<h4 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h4><p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，<strong>所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。</strong></p>
<h4 id="手动消息应答的方法"><a href="#手动消息应答的方法" class="headerlink" title="手动消息应答的方法"></a>手动消息应答的方法</h4><ul>
<li><code>Channel.basicAck</code> (肯定确认应答)：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">basicAck(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple);</span><br></pre></td></tr></table></figure>

<p>第一个参数是消息的标记，第二个参数表示是否应用于多消息，RabbitMQ 已知道该消息被处理并且成功的处理消息，可以将其丢弃了</p>
<ul>
<li><code>Channel.basicReject</code> (否定确认应答)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">basicReject(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> requeue);</span><br></pre></td></tr></table></figure>

<p>第一个参数表示拒绝 <code>deliveryTag</code> 对应的消息，第二个参数表示是否 <code>requeue</code>：true 则重新入队列，false 则丢弃或者进入死信队列。</p>
<p>该方法 reject 后，该消费者还是会消费到该条被 reject 的消息。</p>
<ul>
<li><code>Channel.basicNack</code> (用于否定确认)：示己拒绝处理该消息，可以将其丢弃了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">basicNack(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple, <span class="type">boolean</span> requeue);</span><br></pre></td></tr></table></figure>

<p>第一个参数表示拒绝 <code>deliveryTag</code> 对应的消息，第二个参数是表示否应用于多消息，第三个参数表示是否 <code>requeue</code>，与 basicReject 区别就是同时支持多个消息，可以 拒绝签收 该消费者先前接收未 ack 的所有消息。拒绝签收后的消息也会被自己消费到。</p>
<ul>
<li><code>Channel.basicRecover</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">basicRecover(<span class="type">boolean</span> requeue);</span><br></pre></td></tr></table></figure>

<p>是否恢复消息到队列，参数是是否 <code>requeue</code>，true 则重新入队列，并且尽可能的将之前 <code>recover</code> 的消息投递给其他消费者消费，而不是自己再次消费。false 则消息会重新被投递给自己。</p>
<p><strong>Multiple 的解释：</strong></p>
<p>手动应答的好处是可以批量应答并且减少网络拥堵</p>
<ul>
<li><p>true 代表批量应答 channel 上未应答的消息（批量应答可能丢失消息）</p>
<p>比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答</p>
</li>
<li><p>false 同上面相比只会应答 tag&#x3D;8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220724/image.3vspi8fu4v20.webp" alt="image"></p>
<h4 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h4><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220724/image.4hplocbhsdk0.webp" alt="image"></p>
<h4 id="手动应答案例"><a href="#手动应答案例" class="headerlink" title="手动应答案例"></a>手动应答案例</h4><p>默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答。</p>
<p>消费者启用两个线程，消费 1 一秒消费一个消息，消费者 2 十秒消费一个消息，然后在消费者 2 消费消息的时候，停止运行，这时正在消费的消息是否会重新进入队列，而后给消费者 1 消费呢？</p>
<ul>
<li>工具类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> second)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>*second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>消息生产者</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.utils.RabbitMQUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 21:41</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从控制台输入消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME,<span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发送消息：&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>消费者 1</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.utils.RabbitMQUtils;</span><br><span class="line"><span class="keyword">import</span> com.hua.study.utils.SleepUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.CancelCallback;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 21:49</span></span><br><span class="line"><span class="comment"> * 消息在手动应答时不丢失，并且放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1等待接收消息，处理时间较短&quot;</span>);</span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">//沉睡1秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 手动应答</span></span><br><span class="line"><span class="comment">             * params:</span></span><br><span class="line"><span class="comment">             *  1.消息的标记 表示应答的是哪个消息</span></span><br><span class="line"><span class="comment">             *  2.是否批量应答 false:不批量应答信道中的消息</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者取消消费回调：&quot;</span>+consumerTag);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>消费者 2</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.study.three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.study.utils.RabbitMQUtils;</span><br><span class="line"><span class="keyword">import</span> com.hua.study.utils.SleepUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 21:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker02</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C2等待接收消息，处理时间较长&quot;</span>);</span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">//沉睡1秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 手动应答</span></span><br><span class="line"><span class="comment">             * params:</span></span><br><span class="line"><span class="comment">             *  1.消息的标记 表示应答的是哪个消息</span></span><br><span class="line"><span class="comment">             *  2.是否批量应答 false:不批量应答信道中的消息</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者取消消费回调：&quot;</span>+consumerTag);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 效果演示</p>
<p>正常情况下消息生产者发送两个消息， first 和 second 分别接收到消息并进行处理</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1662042056767.png" alt="1662042056767"></p>
<p>当发送者发送消息 DD 到队列，此时是 second 来消费该消息，但是由于它处理时间较长，在还未处理完时间里停止运行，也就是说 second 还没有执行到 ack 代码的时候，second 被停掉了，此时会看到消息被 first 接收到了，说明消息 DD 被重新入队，然后分配给能处理消息的 first 处理了</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1662042127268.png" alt="1662042127268"></p>
<p><img src="/img/loading.gif" data-original="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220724/image.3mng0kiqphi0.webp" alt="image"></p>
<h4 id="RabbitMQ-持久化"><a href="#RabbitMQ-持久化" class="headerlink" title="RabbitMQ 持久化"></a>RabbitMQ 持久化</h4><p>当 RabbitMQ 服务停掉以后，让消息生产者发送过来的消息不丢失，要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它会忽视队列和消息（丢失掉），除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化。</strong></p>
<h5 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h5><p>之前我们创建的队列都是非持久化的，RabbitMQ 如果重启的话，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为true，代表开启持久化</p>
<p>在<strong>消息生产者</strong>开启持久化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 21:41</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        <span class="comment">//是否队列持久化</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME,durable,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从控制台输入消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="comment">//设置生产者发送消息为持久化消息（保存在磁盘上）MessageProperties.PERSISTENT_TEXT_PLAIN</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发送消息：&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列</p>
</blockquote>
<p>不然就会出现如下错误：</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.4nf70nwh0j60.webp" alt="image"></p>
<p>队列持久化的显示结果：</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.5tlb9m3bfh00.webp" alt="image"></p>
<h5 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h5><p>需要在<strong>消息生产者</strong>发布消息的时候，开启消息的持久化</p>
<p>在 basicPublish 方法的第二个参数添加这个属性： <code>MessageProperties.PERSISTENT_TEXT_PLAIN</code></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220904173448701.png" alt="image-20220904173448701"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 21:41</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        <span class="comment">//是否队列持久化</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME,durable,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从控制台输入消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="comment">//设置生产者发送消息为持久化消息（保存在磁盘上）MessageProperties.PERSISTENT_TEXT_PLAIN</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发送消息：&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 ，但还没有存储完，消息还在缓存的一个间隔点，此时并没 有真正写入磁盘，如果此时RabbitMQ或者消息发送者宕掉，也可能造成消息丢失。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p>
<h5 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h5><p><strong>介绍</strong></p>
<p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个<strong>消费者 1</strong> 处理任务的速度非常快，而另外一个<strong>消费者 2</strong> 处理速度却很慢，这个时候我们还是采用轮询分发的话，这个处理速度快的消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况，它依然很公平的进行分发。</p>
<p>为了避免这种情况，<strong>在消费者中消费消息之前</strong>（每个消费者都要设置），设置参数 <code>channel.basicQos(1);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 21:49</span></span><br><span class="line"><span class="comment"> * 消息在手动应答时不丢失，并且放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1等待接收消息，处理时间较短&quot;</span>);</span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">//沉睡1秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 手动应答</span></span><br><span class="line"><span class="comment">             * params:</span></span><br><span class="line"><span class="comment">             *  1.消息的标记 表示应答的是哪个消息</span></span><br><span class="line"><span class="comment">             *  2.是否批量应答 false:不批量应答信道中的消息</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//设置不公平分发(默认为0:公平分发 1:不公平分发 其他的为预取值如2，3，4...)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        channel.basicQos(prefetchCount);</span><br><span class="line">        <span class="comment">//手动应答</span></span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者取消消费回调：&quot;</span>+consumerTag);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启成功，会看到如下结果：</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.lhxynhnktlc.webp" alt="image"></p>
<p>不公平分发思想：如果一个工作队列还没有处理完或者没有应答签收一个消息，则拒绝 RabbitMQ 分配新的消息到该工作队列。此时 RabbitMQ 会优先分配给其他已经处理完消息或者空闲的工作队列。如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker (工作队列)或者改变其他存储任务的策略。</p>
<p><strong>效果演示</strong></p>
<p>生产者生产多个消息，两个消费者的消费时间不同，则消费消息的次数也不同</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220904174604270.png" alt="image-20220904174604270"></p>
<h5 id="预取值分发"><a href="#预取值分发" class="headerlink" title="预取值分发"></a>预取值分发</h5><p><strong>介绍</strong></p>
<p>带权的消息分发</p>
<p>默认消息的发送是异步发送的，所以在任何时候，channel 上不止只有一个消息来自消费者的手动确认，所以本质上是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小</strong>，<strong>以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过使用 <code>basic.qos</code> 方法设置「预取计数」值来完成的。</p>
<p>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。</p>
<p>通常，增加预取将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p>
<p>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.2anljpf3y134.webp" alt="image"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/1 21:49</span></span><br><span class="line"><span class="comment"> * 消息在手动应答时不丢失，并且放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1等待接收消息，处理时间较短&quot;</span>);</span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">//沉睡1秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 手动应答</span></span><br><span class="line"><span class="comment">             * params:</span></span><br><span class="line"><span class="comment">             *  1.消息的标记 表示应答的是哪个消息</span></span><br><span class="line"><span class="comment">             *  2.是否批量应答 false:不批量应答信道中的消息</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//设置不公平分发(默认为0:公平分发 1:不公平分发 其他的为预取值如2，3，4...)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        channel.basicQos(prefetchCount);</span><br><span class="line">        <span class="comment">//手动应答</span></span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者取消消费回调：&quot;</span>+consumerTag);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>笔记</p>
<p>不公平分发和预取值分发都用到 <code>basic.qos</code> 方法，如果取值为0(默认)，公平分发，取值为 1，代表不公平分发，取值不为1，代表预取值分发</p>
</blockquote>
<p><strong>效果演示</strong></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220904175606886.png" alt="image-20220904175606886"></p>
<p>worker2预设值为5，信道中存在5条消息，worker1不在接收，消息全在worker2信道当中</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220904175553228.png" alt="image-20220904175553228"></p>
<p>worker2接收消息接收为5条,worker1不变</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220904175714414.png" alt="image-20220904175714414"></p>
<h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>​	生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会 发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了， 如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产 者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p>
<p>​	 confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道 返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方 法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p>
<p><strong>确认发布指的是成功发送到了队列，并不是消费者消费了消息</strong></p>
<h3 id="发布确认的策略"><a href="#发布确认的策略" class="headerlink" title="发布确认的策略"></a><strong>发布确认的策略</strong></h3><h4 id="开启发布确认的方法"><a href="#开启发布确认的方法" class="headerlink" title="开启发布确认的方法"></a>开启发布确认的方法</h4><p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure>

<h4 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h4><p>这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，<code>waitForConfirmsOrDie(long)</code> 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p>
<p>这种确认方式有一个最大的缺点就是：<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/5 19:58</span></span><br><span class="line"><span class="comment"> * 发布确认模式：</span></span><br><span class="line"><span class="comment"> *  1.单个确认</span></span><br><span class="line"><span class="comment"> *  2.批量确认</span></span><br><span class="line"><span class="comment"> *  3.异步批量确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量发消息的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_COUNT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//单个确认</span></span><br><span class="line">        publishMessageIndividually();<span class="comment">//发布1000个单个确认消息，耗时：617ms</span></span><br><span class="line">        <span class="comment">//批量确认</span></span><br><span class="line">        <span class="comment">//publishMessageBatch();//发布1000个批量确认消息，耗时：127ms</span></span><br><span class="line">        <span class="comment">//异步批量确认</span></span><br><span class="line">        <span class="comment">//publishMessageAsync();//发布1000个异步发布确认消息，耗时：17ms</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个发布确认</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageIndividually</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//队列的声明</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量发送消息——单个发布确认</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            <span class="comment">//发布确认</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span>+ MESSAGE_COUNT + <span class="string">&quot;个单个确认消息，耗时：&quot;</span>+ (end-begin)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h4><p>单个确认发布方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/5 19:58</span></span><br><span class="line"><span class="comment"> * 发布确认模式：</span></span><br><span class="line"><span class="comment"> *  1.单个确认</span></span><br><span class="line"><span class="comment"> *  2.批量确认</span></span><br><span class="line"><span class="comment"> *  3.异步批量确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量发消息的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_COUNT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//单个确认</span></span><br><span class="line">        <span class="comment">//publishMessageIndividually();//发布1000个单个确认消息，耗时：617ms</span></span><br><span class="line">        <span class="comment">//批量确认</span></span><br><span class="line">        publishMessageBatch();<span class="comment">//发布1000个批量确认消息，耗时：127ms</span></span><br><span class="line">        <span class="comment">//异步批量确认</span></span><br><span class="line">        <span class="comment">//publishMessageAsync();//发布1000个异步发布确认消息，耗时：17ms</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量发布确认</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量确认个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//批量发布消息——批量发布确认</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            <span class="comment">//达到100条时批量确认一次</span></span><br><span class="line">            <span class="keyword">if</span> ((i+<span class="number">1</span>)%batchSize == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//发布确认</span></span><br><span class="line">                channel.waitForConfirms();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span>+ MESSAGE_COUNT + <span class="string">&quot;个批量确认消息，耗时：&quot;</span>+ (end-begin)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h4><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都很好，利用了回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功，下面详细讲解异步确认是怎么实现的。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.73gul8cwoq00.webp" alt="image"></p>
<p>添加回调函数，在回调函数里进行确认发布。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/5 19:58</span></span><br><span class="line"><span class="comment"> * 发布确认模式：</span></span><br><span class="line"><span class="comment"> *  1.单个确认</span></span><br><span class="line"><span class="comment"> *  2.批量确认</span></span><br><span class="line"><span class="comment"> *  3.异步批量确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量发消息的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_COUNT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//单个确认</span></span><br><span class="line">        <span class="comment">//publishMessageIndividually();//发布1000个单个确认消息，耗时：617ms</span></span><br><span class="line">        <span class="comment">//批量确认</span></span><br><span class="line">        <span class="comment">//publishMessageBatch();//发布1000个批量确认消息，耗时：127ms</span></span><br><span class="line">        <span class="comment">//异步批量确认</span></span><br><span class="line">        publishMessageAsync();<span class="comment">//发布1000个异步发布确认消息，耗时：17ms</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步发布确认</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//队列的声明</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息确认成功 回调失败</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.消息的标记</span></span><br><span class="line"><span class="comment">         *  2.是否为批量确认</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span>  ( deliveryTag,  multiple) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认的消息：&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息确认失败 回调失败</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.消息的标记</span></span><br><span class="line"><span class="comment">         *  2.是否为批量确认</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> ( deliveryTag,  multiple) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息：&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息的监听器 监听哪些消息成功，哪些消息失败</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.监听哪些消息成功了</span></span><br><span class="line"><span class="comment">         *  2.监听哪些消息失败了</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        channel.addConfirmListener(ackCallback,nackCallback);</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量发布消息——异步确认发布</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span>+ MESSAGE_COUNT + <span class="string">&quot;个异步发布确认消息，耗时：&quot;</span>+ (end-begin)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际案例里，将发布的消息存入 Map 里，方便获取。<code>headMap</code> 方法用于将已确认的消息存入新的 Map 缓存区里，然后清除该新缓存区的内容。因为 <code>headMap</code> 方法是浅拷贝，所以清除了缓存区，相当于清除了内容的地址，也就清除了队列的确认的消息。</p>
<h4 id="如何处理异步未确认消息"><a href="#如何处理异步未确认消息" class="headerlink" title="如何处理异步未确认消息?"></a><strong>如何处理异步未确认消息?</strong></h4><p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 <code>ConcurrentLinkedQueue</code> 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/5 19:58</span></span><br><span class="line"><span class="comment"> * 发布确认模式：</span></span><br><span class="line"><span class="comment"> *  1.单个确认</span></span><br><span class="line"><span class="comment"> *  2.批量确认</span></span><br><span class="line"><span class="comment"> *  3.异步批量确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量发消息的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MESSAGE_COUNT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//单个确认</span></span><br><span class="line">        <span class="comment">//publishMessageIndividually();//发布1000个单个确认消息，耗时：617ms</span></span><br><span class="line">        <span class="comment">//批量确认</span></span><br><span class="line">        <span class="comment">//publishMessageBatch();//发布1000个批量确认消息，耗时：127ms</span></span><br><span class="line">        <span class="comment">//异步批量确认</span></span><br><span class="line">        publishMessageAsync();<span class="comment">//发布1000个异步发布确认消息，耗时：17ms</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步发布确认</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//队列的声明</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程安全有序的一个哈希表 适用于高并发情况</span></span><br><span class="line"><span class="comment">         * 1.可以轻松的将序号和消息进行关联</span></span><br><span class="line"><span class="comment">         * 2.通过序号批量删除消息</span></span><br><span class="line"><span class="comment">         * 3.支持高并发（多线程）</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long,String&gt; outstandingConfirms =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息确认成功 回调失败</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.消息的标记</span></span><br><span class="line"><span class="comment">         *  2.是否为批量确认</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span>  ( deliveryTag,  multiple) -&gt; &#123;</span><br><span class="line">            <span class="comment">//判断是否为批量确认</span></span><br><span class="line">            <span class="keyword">if</span> (multiple)&#123;</span><br><span class="line">                <span class="comment">//2.删除已经确认的消息 剩下的为未确认的消息</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(deliveryTag);</span><br><span class="line">                confirmed.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                outstandingConfirms.remove(deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认的消息：&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息确认失败 回调失败</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.消息的标记</span></span><br><span class="line"><span class="comment">         *  2.是否为批量确认</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> ( deliveryTag,  multiple) -&gt; &#123;</span><br><span class="line">            <span class="comment">//3.打印未确认的消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> outstandingConfirms.get(deliveryTag);</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息：&quot;</span> + deliveryTag +<span class="string">&quot;&amp;&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息的监听器 监听哪些消息成功，哪些消息失败</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.监听哪些消息成功了</span></span><br><span class="line"><span class="comment">         *  2.监听哪些消息失败了</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        channel.addConfirmListener(ackCallback,nackCallback);</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量发布消息——异步确认发布</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            <span class="comment">//1.记录所有要发送的消息 消息的总和</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(),message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;发布&quot;</span>+ MESSAGE_COUNT + <span class="string">&quot;个异步发布确认消息，耗时：&quot;</span>+ (end-begin)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="以上-3-种发布确认速度对比"><a href="#以上-3-种发布确认速度对比" class="headerlink" title="以上 3 种发布确认速度对比:"></a><strong>以上 3 种发布确认速度对比:</strong></h4><ul>
<li><p>单独发布消息</p>
<p>同步等待确认，简单，但吞吐量非常有限。</p>
</li>
<li><p>批量发布消息</p>
<p>批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。</p>
</li>
<li><p>异步处理</p>
<p>最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</p>
</li>
</ul>
<h4 id="应答和发布区别"><a href="#应答和发布区别" class="headerlink" title="应答和发布区别"></a>应答和发布区别</h4><p>应答功能属于消费者，消费完消息告诉 RabbitMQ 已经消费成功。</p>
<p>发布功能属于生产者，生产消息到 RabbitMQ，RabbitMQ 需要告诉生产者已经收到消息。</p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>之前模式只有一个队列，只能被消费一次。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220906200649744.png" alt="image-20220906200649744"></p>
<p>通过交换机发送到多个队列，每个队列进行一次消费，实现了消息的多次消费。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220906200704206.png" alt="image-20220906200704206"></p>
<p>​	在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消 费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布&#x2F;订阅”。</p>
<p>​	为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘， 另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者。</p>
<h3 id="Exchanges"><a href="#Exchanges" class="headerlink" title="Exchanges"></a>Exchanges</h3><h4 id="Exchanges-概念"><a href="#Exchanges-概念" class="headerlink" title="Exchanges 概念"></a>Exchanges 概念</h4><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p>
<p>相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们放到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.54tzwxwrqco.webp" alt="image"></p>
<h4 id="Exchanges的类型"><a href="#Exchanges的类型" class="headerlink" title="Exchanges的类型"></a>Exchanges的类型</h4><ul>
<li><p>**直接(direct)**：处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上设置的路由键为 abc ，则只有被标记为 abc 的消息才被转发，不会转发 abc.def，也不会转发 dog.ghi，只会转发 abc。</p>
</li>
<li><p>**主题(topic)*<em>：将路由键和某模式进行匹配。此时队列需要绑定一个模式上。符号“#”匹配一个或多个词，符号 * 匹配不多不少一个词。因此 abc.# 能够匹配到 abc.def.ghi，但是 abc.</em> 只会匹配到 abc.def。</p>
</li>
<li><p><strong>标题(headers)<strong>：不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。在绑定 Queue 与 Exchange 时指定一组键值对；当消息发送到RabbitMQ 时会取到该消息的 headers 与 Exchange 绑定时指定的</strong>键值对进行匹配</strong>；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 属性是一个键值对，可以是 Hashtable，键值对的值可以是任何类型。而 fanout，direct，topic 的路由键都需要<strong>字符串形式</strong>的。</p>
<p>匹配规则 x-match 有下列两种类型：</p>
<p>x-match &#x3D; all ：表示所有的键值对都匹配才能接受到消息</p>
<p>x-match &#x3D; any ：表示只要有键值对匹配就能接受到消息</p>
</li>
<li><p>**扇出(fanout)**：不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout 交换机转发消息是最快的。</p>
</li>
</ul>
<h4 id="无名exchange（默认exchange）"><a href="#无名exchange（默认exchange）" class="headerlink" title="无名exchange（默认exchange）"></a>无名exchange（默认exchange）</h4><p>在本教程的前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过<strong>空字符串(“”)进行标识</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>第一个参数是交换机的名称。空字符串 表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey) 绑定指定的 key。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220906213000176.png" alt="image-20220906213000176"></p>
<h3 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h3><p>之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们来说至关重要，我们需要指定我们的消费者去消费哪个队列的消息。</p>
<p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有<strong>随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次<strong>一旦我们断开了消费者的连接，队列将被自动删除。</strong></p>
<p>创建临时队列的方式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.56c9qj8lnyo0.webp" alt="image"></p>
<h3 id="绑定-bindings"><a href="#绑定-bindings" class="headerlink" title="绑定(bindings)"></a>绑定(bindings)</h3><p>什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.1ryp1eu9xtnk.webp" alt="image"></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.2z1b1g3ou5e0.webp" alt="image"></p>
<h3 id="Fanout-扇出（发布订阅模式）"><a href="#Fanout-扇出（发布订阅模式）" class="headerlink" title="Fanout 扇出（发布订阅模式）"></a>Fanout 扇出（发布订阅模式）</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的所有队列中。系统中有默认的exchange 类型。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220906213331507.png" alt="image-20220906213331507"></p>
<h4 id="Fanout-实战"><a href="#Fanout-实战" class="headerlink" title="Fanout 实战"></a>Fanout 实战</h4><p>为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.2mdbijsttri0.webp" alt="image"></p>
<p>Logs 和临时队列的绑定关系如下图：</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220906213612013.png" alt="image-20220906213612013"></p>
<p>ReceiveLogs01 将接收到的消息打印在控制台：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/6 20:40</span></span><br><span class="line"><span class="comment"> * 消息的接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs01</span> &#123;</span><br><span class="line">    <span class="comment">//交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明一个交换机-扇出（发布订阅模式）</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 声明一个 临时队列</span></span><br><span class="line"><span class="comment">         * 队列名称是随机的</span></span><br><span class="line"><span class="comment">         * 当消费者断开与队列连接时 队列就自动删除</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queue</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//绑定交换机与队列</span></span><br><span class="line">        channel.queueBind(queue,EXCHANGE_NAME,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息，接收到的消息打印在屏幕上……&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> ( consumerTag,  message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queue,<span class="literal">true</span>,deliverCallback, (CancelCallback) <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReceiveLogs02 将接收到的消息存储在磁盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/6 20:40</span></span><br><span class="line"><span class="comment"> * 消息的接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs02</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">queue</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        channel.queueBind(queue,EXCHANGE_NAME,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息2，接收到的消息打印在屏幕上……&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> ( consumerTag,  delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span> + message);</span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\work\\rabbitmq_info.txt&quot;</span>);</span><br><span class="line">            FileUtils.writeStringToFile(file,message,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;数据写入文件成功&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queue,<span class="literal">true</span>,deliverCallback, cancelCallback -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EmitLog 发送消息给两个消费者接收:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/6 21:08</span></span><br><span class="line"><span class="comment"> * 发送消息给交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLog</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (input.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> input.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,<span class="string">&quot;&quot;</span>,<span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220906214222168.png" alt="image-20220906214222168"></p>
<h3 id="Direct-exchange-直接交换机（路由交换）"><a href="#Direct-exchange-直接交换机（路由交换）" class="headerlink" title="Direct exchange 直接交换机（路由交换）"></a>Direct exchange 直接交换机（路由交换）</h3><p>在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能——让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</p>
<p>我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： <strong>队列只对它绑定的交换机的消息感兴趣</strong>。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);</p>
<p>绑定之后的意义由其交换类型决定。</p>
<h4 id="Direct介绍"><a href="#Direct介绍" class="headerlink" title="Direct介绍"></a>Direct介绍</h4><p>上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.gi5bzb0sygo.webp" alt="image"></p>
<p>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列 Q1 绑定键为 orange， 队列 Q2 绑定键有两个：一个绑定键为 black，另一个绑定键为 green.</p>
<p>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p>
<h4 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a>多重绑定</h4><p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.6m5o5nqwvlw0.webp" alt="image"></p>
<p>当然如果 exchange 的绑定类型是direct，<strong>但是它绑定的多个队列的 key 如果都相同</strong>，在这种情况下虽然绑定类型是 direct <strong>但是它表现的就和 fanout 有点类似了</strong>，就跟广播差不多，如上图所示。</p>
<h4 id="Direct实战"><a href="#Direct实战" class="headerlink" title="Direct实战"></a>Direct实战</h4><p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.18f9o7wxc5uo.webp" alt="image"></p>
<p>项目结构：一个交换机+两个队列+三个Routing key</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.5x5pk7emz0k0.webp" alt="image"></p>
<p>C1 消费者：绑定 console 队列，routingKey 为 info、warning</p>
<p>C2 消费者：绑定 disk 队列，routingKey 为 error</p>
<p>当生产者生产消息到 <code>direct_logs</code> 交换机里，该交换机会检测消息的 routingKey 条件，然后分配到满足条件的队列里，最后由消费者从队列消费消息。</p>
<p><strong>消费者1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/6 22:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明一个直接交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;console&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//进行绑定</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;console&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;console&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;warning&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息1：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;console&quot;</span>,<span class="literal">true</span>,deliverCallback, cancelCallback -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>消费者2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/6 22:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明一个直接交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;disk&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//进行绑定</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;disk&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息2：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;disk&quot;</span>,<span class="literal">true</span>,deliverCallback, cancelCallback -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/6 22:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectLogs</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        String[] direct = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;info&quot;</span>,<span class="string">&quot;warning&quot;</span>,<span class="string">&quot;error&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (input.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> input.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,direct[i], <span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：随机分配</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220906225040227.png" alt="image-20220906225040227"></p>
<h3 id="Topics-主题交换机"><a href="#Topics-主题交换机" class="headerlink" title="Topics 主题交换机"></a>Topics 主题交换机</h3><p>在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而能实现有选择性地接收日志。</p>
<p>尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性——比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 <strong>topic</strong> 类型。</p>
<h4 id="Topic-的要求"><a href="#Topic-的要求" class="headerlink" title="Topic 的要求"></a><strong>Topic 的要求</strong></h4><p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是<strong>一个单词列表</strong>，<strong>以点号分隔开</strong>。这些单词可以是任意单词</p>
<p>比如说：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit” 这种类型的。</p>
<p>当然这个单词列表最多不能超过 255 个字节。</p>
<p>在这个规则列表中，其中有两个替换符是大家需要注意的：</p>
<ul>
<li>***(星号)可以代替一个位置**</li>
<li><strong>#(井号)可以替代零个或多个位置</strong></li>
</ul>
<h4 id="Topic匹配案例"><a href="#Topic匹配案例" class="headerlink" title="Topic匹配案例"></a>Topic匹配案例</h4><p>下图绑定关系如下</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.6a89pabmhtg0.webp" alt="image"></p>
<ul>
<li>Q1–&gt;绑定的是<ul>
<li>中间带 orange 带 3 个单词的字符串 <code>(*.orange.*)</code></li>
</ul>
</li>
<li>Q2–&gt;绑定的是<ul>
<li>最后一个单词是 rabbit 的 3 个单词 <code>(*.*.rabbit)</code></li>
<li>第一个单词是 lazy 的多个单词 <code>(lazy.#)</code></li>
</ul>
</li>
</ul>
<p>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的</p>
<table>
<thead>
<tr>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>quick.orange.rabbit</td>
<td>被队列 Q1Q2 接收到</td>
</tr>
<tr>
<td>azy.orange.elephant</td>
<td>被队列 Q1Q2 接收到</td>
</tr>
<tr>
<td>quick.orange.fox</td>
<td>被队列 Q1 接收到</td>
</tr>
<tr>
<td>lazy.brown.fox</td>
<td>被队列 Q2 接收到</td>
</tr>
<tr>
<td>lazy.pink.rabbit</td>
<td>虽然满足两个绑定但只被队列 Q2 接收一次</td>
</tr>
<tr>
<td>quick.brown.fox</td>
<td>不匹配任何绑定不会被任何队列接收到会被丢弃</td>
</tr>
<tr>
<td>quick.orange.male.rabbit</td>
<td>是四个单词不匹配任何绑定会被丢弃</td>
</tr>
<tr>
<td>lazy.orange.male.rabbit</td>
<td>是四个单词但匹配 Q2</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>当一个队列绑定键是 #，那么这个队列将接收所有数据，就有点像 fanout 了。</strong></p>
<p><strong>如果队列绑定键当中没有 # 和 * 出现，那么该队列绑定类型就是 direct 了。</strong></p>
</blockquote>
<h4 id="Topic实战"><a href="#Topic实战" class="headerlink" title="Topic实战"></a>Topic实战</h4><p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.5kvwh1z1ixk0.webp" alt="image"></p>
<p>生产多个消息到交换机，交换机按照通配符分配消息到不同的队列中，队列由消费者进行消费</p>
<ul>
<li><strong>生产者 EmitLogTopic</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 21:014</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogTopic</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Q1--&gt;绑定的是</span></span><br><span class="line"><span class="comment">         *      中间带 orange 带 3 个单词的字符串(*.orange.*)</span></span><br><span class="line"><span class="comment">         * Q2--&gt;绑定的是</span></span><br><span class="line"><span class="comment">         *      最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)</span></span><br><span class="line"><span class="comment">         *      第一个单词是 lazy 的多个单词(lazy.#)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        HashMap&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>, <span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>, <span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.fox&quot;</span>, <span class="string">&quot;被队列 Q1 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.brown.fox&quot;</span>, <span class="string">&quot;被队列 Q2 接收到&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>, <span class="string">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>, <span class="string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;quick.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词但匹配 Q2&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,String&gt; bindingKeyEntry : bindingKeyMap.entrySet())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,routingKey,<span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发送消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>消费者C1</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 20:39</span></span><br><span class="line"><span class="comment"> * 声明主题交换机及相关队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 消费者C1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic01</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Q1&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//进行绑定</span></span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息……&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收的消息Q1：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;接收队列：&quot;</span>+queueName+<span class="string">&quot;，绑定键：&quot;</span>+message.getEnvelope().getRoutingKey() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,deliverCallback ,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>消费者C2</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 20:39</span></span><br><span class="line"><span class="comment"> * 声明主题交换机及相关队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 消费者C2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic02</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;Q2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//进行绑定</span></span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息……&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收的消息Q2：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;接收队列：&quot;</span>+queueName+<span class="string">&quot;，绑定键：&quot;</span>+message.getEnvelope().getRoutingKey() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,deliverCallback ,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试结果</li>
</ul>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220907212138882.png" alt="image-20220907212138882"></p>
<h2 id="RabbitMQ-死信队列"><a href="#RabbitMQ-死信队列" class="headerlink" title="RabbitMQ 死信队列"></a>RabbitMQ 死信队列</h2><h3 id="死信的概念"><a href="#死信的概念" class="headerlink" title="死信的概念"></a>死信的概念</h3><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因<strong>导致 queue 中的某些消息无法被消费</strong>，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p>
<p>应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。</p>
<h3 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h3><ul>
<li><p>消息 TTL 过期</p>
<p>TTL是 Time To Live 的缩写, 也就是生存时间</p>
</li>
<li><p>队列达到最大长度</p>
<p>队列满了，无法再添加数据到 MQ 中</p>
</li>
<li><p>消息被拒绝</p>
<p>(basic.reject 或 basic.nack) 并且 requeue &#x3D; false</p>
</li>
</ul>
<h3 id="死信实战"><a href="#死信实战" class="headerlink" title="死信实战"></a>死信实战</h3><p>俩个交换机类型是 direct，两个消费者，一个生产者，两个队列：消息队列和死信队列</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.691xh9mh3yk0.webp" alt="image"></p>
<h4 id="消息TTL-过期"><a href="#消息TTL-过期" class="headerlink" title="消息TTL 过期"></a>消息TTL 过期</h4><ul>
<li><strong>生产者代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 22:04</span></span><br><span class="line"><span class="comment"> *  死信队列</span></span><br><span class="line"><span class="comment"> *  生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//发送死信消息 设置TTL time to live 10s</span></span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties()</span><br><span class="line">                .builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>,properties,message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>消费者 C1 代码</strong>(启动之后关闭该消费者 模拟其接收不到消息)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 21:37</span></span><br><span class="line"><span class="comment"> *  死信队列</span></span><br><span class="line"><span class="comment"> *  消费者C1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信交换机名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明普通和死信交换机</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通队列</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//过期时间10s</span></span><br><span class="line">        <span class="comment">//arguments.put(&quot;x-message-tt&quot;,10000);</span></span><br><span class="line">        <span class="comment">//正常队列设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,arguments);</span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//绑定普通交换机和队列</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//绑定死信交换机和队列</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息……&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者1接收的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE,<span class="literal">true</span>,deliverCallback,cancelCallback -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先启动消费者 C1，创建出队列，然后停止该 C1 的运行，则 C1 将无法收到队列的消息，无法收到的消息 10 秒后进入死信队列。启动生产者 producer 生产消息</p>
<p><strong>生产者未发送消息</strong></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.5ldx5kffws00.webp" alt="image"></p>
<p><strong>生产者发送了10条消息，此时正常消息队列有10条未消费消息</strong></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.4k5fjvtukpe0.webp" alt="image"></p>
<p><strong>时间过去10秒，正常队列里面的消息由于没有被消费，消息进入死信队列</strong></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.5g2svti1sec0.webp" alt="image"></p>
<ul>
<li><strong>消费者 C2 代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 21:37</span></span><br><span class="line"><span class="comment"> *  死信队列</span></span><br><span class="line"><span class="comment"> *  消费者C2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer02</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收死信消息……&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者2接收的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(DEAD_QUEUE,<span class="literal">true</span>,deliverCallback,cancelCallback -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>效果演示</strong></li>
</ul>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.3a1tkaqx5jm0.webp" alt="image"></p>
<p>死信队列里面的消息被C2消费掉</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220908200651208.png" alt="image-20220908200651208"></p>
<h4 id="队列达到最大长度"><a href="#队列达到最大长度" class="headerlink" title="队列达到最大长度"></a>队列达到最大长度</h4><ul>
<li>消息生产者代码去掉 TTL 属性，<code>basicPublish</code> 的第三个参数改为 null</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 22:04</span></span><br><span class="line"><span class="comment"> *  死信队列</span></span><br><span class="line"><span class="comment"> *  生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//发送死信消息 设置TTL time to live 10s</span></span><br><span class="line">       <span class="comment">/*AMQP.BasicProperties properties = new AMQP.BasicProperties()</span></span><br><span class="line"><span class="comment">                .builder().expiration(&quot;10000&quot;).build();*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>C1 消费者修改以下代码(<strong>启动之后关闭该消费者 模拟其接收不到消息</strong>)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 21:37</span></span><br><span class="line"><span class="comment"> *  死信队列</span></span><br><span class="line"><span class="comment"> *  消费者C1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信交换机名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明普通和死信交换机</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通队列</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//过期时间10s</span></span><br><span class="line">        <span class="comment">//arguments.put(&quot;x-message-tt&quot;,10000);</span></span><br><span class="line">        <span class="comment">//正常队列设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//设置正常队列的长度限制</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-max-length&quot;</span>,<span class="number">6</span>);</span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,arguments);</span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//绑定普通交换机和队列</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//绑定死信交换机和队列</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息……&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者1接收的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE,<span class="literal">true</span>,deliverCallback,cancelCallback -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>因为参数改变了，所以需要把原先队列删除</p>
</blockquote>
<ul>
<li>C2 消费者代码不变</li>
<li>启动消费者C1，创建出队列，然后停止该 C1 的运行，启动生产者</li>
</ul>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.6nv41w7ky0o0.webp" alt="image"></p>
<ul>
<li>启动 C2 消费者</li>
</ul>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.3mg5ph9jr020.webp" alt="image"></p>
<ul>
<li>控制台</li>
</ul>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.664h3njwl6w0.webp" alt="image"></p>
<h4 id="消息被拒"><a href="#消息被拒" class="headerlink" title="消息被拒"></a>消息被拒</h4><ol>
<li>消息生产者代码同上生产者一致</li>
<li>需求：消费者 C1 拒收消息 “info5”，开启手动应答</li>
</ol>
<p><strong>消费者C1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/7 21:37</span></span><br><span class="line"><span class="comment"> *  死信队列</span></span><br><span class="line"><span class="comment"> *  消费者C1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信交换机名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明普通和死信交换机</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通队列</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//过期时间10s</span></span><br><span class="line">        <span class="comment">//arguments.put(&quot;x-message-tt&quot;,10000);</span></span><br><span class="line">        <span class="comment">//正常队列设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//设置正常队列的长度限制</span></span><br><span class="line">        <span class="comment">//arguments.put(&quot;x-max-length&quot;,6);</span></span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,arguments);</span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//绑定普通交换机和队列</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE,NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//绑定死信交换机和队列</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE,DEAD_EXCHANGE,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息……&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(msg.equals(<span class="string">&quot;info5&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01接受的消息是：&quot;</span>+msg+<span class="string">&quot;： 此消息是被C1拒绝的&quot;</span>);</span><br><span class="line">                <span class="comment">//requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span></span><br><span class="line">                channel.basicReject(message.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1接收的消息：&quot;</span> + msg);</span><br><span class="line">                channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//关闭自动应答 开启手动应答</span></span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE,<span class="literal">false</span>,deliverCallback,cancelCallback -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>开启消费者C1，创建出队列，然后停止该 C1 的运行，启动生产者</li>
</ul>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.ncokzmns2t.webp" alt="image"></p>
<ul>
<li>再启动消费者 C2</li>
</ul>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.1xxchsmgsgdc.webp" alt="image"></p>
<ul>
<li>控制台</li>
</ul>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220908204825740.png" alt="image-20220908204825740"></p>
<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><h3 id="延迟队列介绍"><a href="#延迟队列介绍" class="headerlink" title="延迟队列介绍"></a>延迟队列介绍</h3><h4 id="延迟队列概念："><a href="#延迟队列概念：" class="headerlink" title="延迟队列概念："></a><strong>延迟队列概念：</strong></h4><p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p>
<h4 id="延迟队列使用场景："><a href="#延迟队列使用场景：" class="headerlink" title="延迟队列使用场景："></a><strong>延迟队列使用场景：</strong></h4><ol>
<li>订单在十分钟之内未支付则自动取消</li>
<li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒</li>
<li>用户注册成功后，如果三天内没有登陆则进行短信提醒</li>
<li>用户发起退款，如果三天内没有得到处理则通知相关运营人员</li>
<li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li>
</ol>
<p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？</p>
<p>如果数据量比较少，确实可以这样做，比如：对于「如果账单一周内未支付则进行自动结算」这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：「订单十分钟内未支付则关闭」，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.21tyby27zrog.webp" alt="image"></p>
<h3 id="RabbitMQ-中的-TTL"><a href="#RabbitMQ-中的-TTL" class="headerlink" title="RabbitMQ 中的 TTL"></a>RabbitMQ 中的 TTL</h3><p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。</p>
<p>换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为「死信」。如果同时配置了队列的 TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p>
<h4 id="队列设置-TTL"><a href="#队列设置-TTL" class="headerlink" title="队列设置 TTL"></a><strong>队列设置 TTL</strong></h4><p>在创建队列的时候设置队列的 x-message-ttl 属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">params.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">5000</span>);</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;QA&quot;</span>).withArguments(args).build(); <span class="comment">// QA 队列的最大存活时间位 5000 毫秒</span></span><br></pre></td></tr></table></figure>

<h4 id="消息设置-TTL"><a href="#消息设置-TTL" class="headerlink" title="消息设置 TTL"></a><strong>消息设置 TTL</strong></h4><p>针对每条消息设置 TTL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitTemplate.converAndSend(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XC&quot;</span>,message,correlationData -&gt; &#123;</span><br><span class="line">    correlationData.getMessageProperties().setExpiration(<span class="string">&quot;5000&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a><strong>两者区别</strong></h4><p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间，具体看下方案例。</p>
<p>另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p>
<h3 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h3><p>前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。</p>
<ol>
<li>创建一个 Maven 工程或者 Spring Boot工程</li>
<li>添加依赖，这里的 Spring Boot 是2.5.6 版本</li>
</ol>
<p>比如下面版本组合是兼容的</p>
<table>
<thead>
<tr>
<th>Spring Boot版本</th>
<th>Swagger 版本</th>
</tr>
</thead>
<tbody><tr>
<td>2.5.6</td>
<td>2.9.2</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--RabbitMQ 依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.2</span><span class="number">.47</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--swagger--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--RabbitMQ 测试依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>​	3.创建 <code>application.properties</code> 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.rabbitmq.host=<span class="number">192.168</span><span class="number">.182</span><span class="number">.128</span></span><br><span class="line">spring.rabbitmq.port=<span class="number">5672</span></span><br><span class="line">spring.rabbitmq.username=admin</span><br><span class="line">spring.rabbitmq.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>添加Swagger 配置类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/8 21:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">webApiConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">webApiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;hua&quot;</span>,<span class="string">&quot;http://atguigu.com&quot;</span>,<span class="string">&quot;2164277973@qq.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	5.新建主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootRabbitmqApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootRabbitmqApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列TTL"><a href="#队列TTL" class="headerlink" title="队列TTL"></a>队列TTL</h3><h4 id="代码架构图"><a href="#代码架构图" class="headerlink" title="代码架构图"></a><strong>代码架构图</strong></h4><p>创建两个队列 QA 和 QB，两个队列的 TTL 分别设置为 10S 和 40S，然后再创建一个交换机 X 和死信交换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.6ipia9redgw0.webp" alt="image"></p>
<p>原先配置队列信息，写在了生产者和消费者代码中，现在可写在配置类中，生产者只发消息，消费者只接受消息。</p>
<h4 id="配置文件类代码"><a href="#配置文件类代码" class="headerlink" title="配置文件类代码"></a>配置文件类代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/8 21:29</span></span><br><span class="line"><span class="comment"> *  TTL队列 配置文件类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TTLQueueConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">X_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信交换机名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_A</span> <span class="operator">=</span> <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_B</span> <span class="operator">=</span> <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信队列名称</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;QD&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明Exchange</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">xExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//路由交换机</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(X_EXCHANGE,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">yExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//路由交换机</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(Y_DEAD_LETTER_EXCHANGE,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span>&#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//设置TTL</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//设置TTL</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueD</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//死信队列</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DEAD_LETTER_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机队列绑定</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueABindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueDBindingY</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,<span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="消息生产者代码"><a href="#消息生产者代码" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h4><p><strong>Controller 层代码，获取消息，放到 RabbitMQ</strong> 里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/8 21:57</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  生产者 发送延迟消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sendMsgController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始发消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，发送一个消息给两个TTL队列：&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>().toString(),message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XA&quot;</span>,<span class="string">&quot;消息来自ttl为10s的队列：&quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XB&quot;</span>,<span class="string">&quot;消息来自ttl为40s的队列：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息消费者代码"><a href="#消息消费者代码" class="headerlink" title="消息消费者代码"></a>消息消费者代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.rabbitmq.springboot_rabbitmq.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/8 22:07</span></span><br><span class="line"><span class="comment"> *  队列TTL   消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterQueueConsumer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收消息</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，收到死信队列的消息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>().toString(),msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发起一个请求：<a target="_blank" rel="noopener" href="http://localhost:8888/ttl/sendMsg/%E5%98%BB%E5%98%BB%E5%98%BB">http://localhost:8080/ttl/sendMsg/嘻嘻嘻(opens new window)</a></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220908230222702.png" alt="image-20220908230222702"></p>
<p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。</p>
<p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p>
<h3 id="延时队列优化"><a href="#延时队列优化" class="headerlink" title="延时队列优化"></a>延时队列优化</h3><p>在这里新增了一个队列 QC，该队列不设置 TTL 时间，根据前端的请求确定 TTL 时间，绑定关系如下：</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.267zky9xj8dc.webp" alt="image"></p>
<h4 id="配置类代码"><a href="#配置类代码" class="headerlink" title="配置类代码"></a><strong>配置类代码</strong></h4><p>新增一个配置文件类，用于新增队列 QC，也可以放在上方的配置文件类里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgTtlQueueConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_C</span> <span class="operator">=</span> <span class="string">&quot;QC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死信交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Y_DEAD_LETTER_EXCHANGE=<span class="string">&quot;Y&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明QC</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">QueueC</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明队列 QC 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueCBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span>DirectExchange xExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生产者</strong></p>
<p><strong>Controller 新增方法</strong></p>
<p>该方法接收的请求要带有 TTL 时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.rabbitmq.springboot_rabbitmq.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.rabbitmq.springboot_rabbitmq.config.DelayedQueueConfig;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/8 21:57</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  生产者 发送延迟消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sendMsgController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始发消息和TTL</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> String ttlTime)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，发送一个时长&#123;&#125;毫秒TTL消息给QC队列：&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>().toString(),ttlTime,message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XC&quot;</span>,message,msg -&gt; &#123;</span><br><span class="line">            <span class="comment">//设置延迟时间</span></span><br><span class="line">            msg.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启下面，发送请求：</p>
<p><a target="_blank" rel="noopener" href="https://frxcat.fun/middleware/RabbitMQ/RabbitMQ_Delay_queue/">http://localhost:8080/ttl/sendExpirationMsg/你好1/20000</a></p>
<p><a target="_blank" rel="noopener" href="https://frxcat.fun/middleware/RabbitMQ/RabbitMQ_Delay_queue/">http://localhost:8080/ttl/sendExpirationMsg/你好2/2000</a></p>
<blockquote>
<p><strong>出现问题</strong>:</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/1658765665496.39yyrmljat80.webp" alt="1658765665496"></p>
</blockquote>
<p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时「死亡」</p>
<blockquote>
<p><strong>因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行</strong></p>
</blockquote>
<p>这也就是为什么如图的时间：你好 2 延时 2 秒，却后执行，还要等待你好 1 消费后再执行你好2</p>
<h3 id="Rabbitmq插件实现延迟队列"><a href="#Rabbitmq插件实现延迟队列" class="headerlink" title="Rabbitmq插件实现延迟队列"></a>Rabbitmq插件实现延迟队列</h3><p>上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的 TTL 时间及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。</p>
<p><strong>安装延时队列插件</strong></p>
<p>可去<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html">官网下载 (opens new window)</a>找到 <strong>rabbitmq_delayed_message_exchange</strong> 插件，放置到 RabbitMQ 的插件目录。</p>
<p>因为官网也是跳转去该插件的 GitHub 地址进行下载：<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases">点击跳转(opens new window)</a>，然后解压放置到 RabbitMQ 的插件目录。 进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 复制到plgins目录下</span><br><span class="line">cp rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins/</span><br><span class="line"># 进行plgins目录</span><br><span class="line">cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins/</span><br></pre></td></tr></table></figure>

<p>其中我的版本是 <code>/rabbitmq_server-3.8.0</code></p>
<p>进入目录后执行下面命令让该插件生效，然后重启 RabbitMQ</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br><span class="line"># 重启服务</span><br><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@master plugins]# rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br><span class="line">Enabling plugins on node rabbit@master:</span><br><span class="line">rabbitmq_delayed_message_exchange</span><br><span class="line">The following plugins have been configured:</span><br><span class="line">  rabbitmq_delayed_message_exchange</span><br><span class="line">  rabbitmq_management</span><br><span class="line">  rabbitmq_management_agent</span><br><span class="line">  rabbitmq_web_dispatch</span><br><span class="line">Applying plugin configuration to rabbit@master...</span><br><span class="line">The following plugins have been enabled:</span><br><span class="line">  rabbitmq_delayed_message_exchange</span><br><span class="line"></span><br><span class="line">started 1 plugins.</span><br><span class="line">[root@master plugins]# systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释</p>
<p>安装命令不能出现插件版本和后缀，如 <code>rabbitmq-plugins enable rabbitmq_delayed_message_exchange-3.8.0.ez</code> 会报错</p>
<p>必须是 <code>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</code>，后面不允许填入版本和文件后缀</p>
</blockquote>
<p>打开 Web 界面，查看交换机的新增功能列表，如果多出了如图所示，代表成功添加插件</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.3nqc69j0pws0.webp" alt="image"></p>
<h4 id="代码架构图-1"><a href="#代码架构图-1" class="headerlink" title="代码架构图"></a>代码架构图</h4><p>在这里新增了一个队列 delayed.queue，一个自定义交换机 delayed.exchange，绑定关系如下:</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.1tla4z5g4yps.webp" alt="image"></p>
<h4 id="配置类代码-1"><a href="#配置类代码-1" class="headerlink" title="配置类代码"></a>配置类代码</h4><p>新增一个配置类 <code>DelayedQueueConfig</code>，也可以放在原来的配置文件里，代码里使用了 <code>CustomExchange</code> 类，通过参数来自定义一个类型(direct、topic等)</p>
<p>在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/9 20:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayedQueueConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * routingKey</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingKey&quot;</span>;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机 基于插件的</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">delayedExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-delayed-type&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * params:</span></span><br><span class="line"><span class="comment">         *  1.交换机名称</span></span><br><span class="line"><span class="comment">         *  2.交换机的类型</span></span><br><span class="line"><span class="comment">         *  3.是否持久化</span></span><br><span class="line"><span class="comment">         *  4.是否自动删除</span></span><br><span class="line"><span class="comment">         *  5.其他参数</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME,<span class="string">&quot;x-delayed-message&quot;</span>,<span class="literal">true</span>,<span class="literal">true</span>,arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding  <span class="title function_">delayedQueueBindingDelayedExchange</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue delayedQueue,</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange</span></span><br><span class="line"><span class="params">    )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a><strong>生产者代码</strong></h4><p>在 controller 里新增一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hua.rabbitmq.springboot_rabbitmq.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hua.rabbitmq.springboot_rabbitmq.config.DelayedQueueConfig;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/8 21:57</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  生产者 发送延迟消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sendMsgController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">	</span><br><span class="line">    ........</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于插件 开始发消息及延迟时间</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> Integer delayTime)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，发送一个时长&#123;&#125;毫秒消息给延迟队列delayed.queue：&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>().toString(),delayTime,message);</span><br><span class="line">        rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME</span><br><span class="line">        ,DelayedQueueConfig.DELAYED_ROUTING_KEY,message,msg -&gt; &#123;</span><br><span class="line">            <span class="comment">//发送消息的延迟时间 ms</span></span><br><span class="line">            msg.getMessageProperties().setDelay(delayTime);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a><strong>消费者代码</strong></h4><p>监听延时队列，如果有消息进入该队列，则打印到控制台</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/9 20:56</span></span><br><span class="line"><span class="comment"> * 消费者 基于插件的延迟消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueueConsumer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听消息</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDelayQueue</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，收到延迟队列的消息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>().toString(),msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><a target="_blank" rel="noopener" href="http://localhost:8888/ttl/sendDelayMsg/hello1/20000">http://localhost:8080/ttl/sendDelayMsg/hello1/20000(opens new window)</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8888/ttl/sendDelayMsg/hello2/2000">http://localhost:8080/ttl/sendDelayMsg/hello2/2000(opens new window)</a></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.17h77dwilchs.webp" alt="image"></p>
<p>可以看到哪怕 hello1 需要20秒再进入延时队列，hello2 2 秒后直接进入延时队列，无需等待 hello1被消费。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。</p>
<p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景。</p>
<h2 id="RabbitMQ-发布确认高级"><a href="#RabbitMQ-发布确认高级" class="headerlink" title="RabbitMQ 发布确认高级"></a>RabbitMQ 发布确认高级</h2><p>在生产环境中由于一些不明原因，导致 RabbitMQ 重启，在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">应 用 [xxx] 在 [08-<span class="number">1516</span>:<span class="number">36</span>:<span class="number">04</span>] 发 生 [ 错 误 日 志 异 常 ] ， alertId=[xxx] 。 由</span><br><span class="line">[org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:<span class="number">620</span>] 触 发 。</span><br><span class="line">应用 xxx 可能原因如下</span><br><span class="line">服 务 名 为 ：</span><br><span class="line">异 常 为 ： org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:<span class="number">620</span>,</span><br><span class="line">产 生 原 因 如 下 :<span class="number">1.</span>org.springframework.amqp.rabbit.listener.QueuesNotAvailableException:</span><br><span class="line">Cannot prepare queue <span class="keyword">for</span> listener. Either the queue doesn<span class="string">&#x27;t exist or the broker will not</span></span><br><span class="line"><span class="string">allow us to use it.||Consumer received fatal=false exception on startup:</span></span><br></pre></td></tr></table></figure>

<h3 id="发布确认SpringBoot版本"><a href="#发布确认SpringBoot版本" class="headerlink" title="发布确认SpringBoot版本"></a>发布确认SpringBoot版本</h3><p>简单的发布确认机制在应答与签收已经介绍，本内容将介绍整合了 SpringBoot 的发布确认机制。</p>
<h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>首先发布消息后进行备份在缓存里，如果消息成功发布确认到交换机，则从缓存里删除该消息，如果没有成功发布，则设置一个定时任务，重新从缓存里获取消息发布到交换机，直到成功发布到交换机。</p>
<p>确认机制图例：</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.7c8btl8ibwo0.webp" alt="image"></p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>一个交换机：confirm.exchange，一个队列：confirm.queue，一个消费者：confirm.consumer</p>
<p>其中交换机类型时 direct，与队列关联的 routingKey 是 key1</p>
<p>代码架构图：</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.7ddz8ceuxk40.webp" alt="image"></p>
<p>在配置文件当中需要添加：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">192.168.182.128</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>NONE</code> 值是禁用发布确认模式，是默认值</li>
<li><code>CORRELATED</code> 值是发布消息成功到交换器后会触发回调方法</li>
<li><code>SIMPLE</code> 值经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后会使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker（相当于单个或者批量确认模式）;</li>
</ul>
<h4 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h4><p>声明交换机和队列，并且将交换机和队列进行绑定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 13:54</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 配置类 发布确认高级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备份交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * routingKey</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;key1&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">	<span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBindingExchange</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange,</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue</span></span><br><span class="line"><span class="params">    )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息生产者-1"><a href="#消息生产者-1" class="headerlink" title="消息生产者"></a><strong>消息生产者</strong></h4><p>也可以说是 Controller 层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 14:05</span></span><br><span class="line"><span class="comment"> *  发布确认高级 测试确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发消息</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">        <span class="comment">//指定消息 id 为 1</span></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                ConfirmConfig.CONFIRM_ROUTING_KEY,message+<span class="string">&quot;key1&quot;</span>,correlationData1);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息内容:&#123;&#125;&quot;</span>,message+<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息 id 为 2</span></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;key2&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                CONFIRM_ROUTING_KEY,message+<span class="string">&quot;key2&quot;</span>,correlationData2);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息内容:&#123;&#125;&quot;</span>,message+<span class="string">&quot;key2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息消费者-1"><a href="#消息消费者-1" class="headerlink" title="消息消费者"></a><strong>消息消费者</strong></h4><p>监听 <code>confirm.queue</code> 队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 14:11</span></span><br><span class="line"><span class="comment"> *  发布确认高级 接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConsumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.CONFIRM_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfirmMessage</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接收到Confirm.queue的消息：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="消息生产者发布消息后的回调接口"><a href="#消息生产者发布消息后的回调接口" class="headerlink" title="消息生产者发布消息后的回调接口"></a><strong>消息生产者发布消息后的回调接口</strong></h4><p>只要生产者发布消息，交换机不管是否收到消息，都会调用该类的 <code>confirm</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 14:25</span></span><br><span class="line"><span class="comment"> *  发布确认高级 回调接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将该方法注入到RabbitTemplate内部接口中</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机确认回调方法</span></span><br><span class="line"><span class="comment">     *  1.发消息 交换机成功接收 回调</span></span><br><span class="line"><span class="comment">     *      1.1 correlationData 保存回调消息的ID及相关消息</span></span><br><span class="line"><span class="comment">     *      1.2 ack = true  交换机收到消息</span></span><br><span class="line"><span class="comment">     *      1.3 cause = null  失败原因</span></span><br><span class="line"><span class="comment">     *  2.发消息 交换机接收失败 回调</span></span><br><span class="line"><span class="comment">     *      2.1 correlationData 保存回调消息的ID及相关消息</span></span><br><span class="line"><span class="comment">     *      2.2 ack = false  交换机未收到消息</span></span><br><span class="line"><span class="comment">     *      2.3 cause  失败原因</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> b, String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span>? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (b)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机收到ID为：&#123;&#125;的消息&quot;</span>,id);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机未收到ID为：&#123;&#125;的消息,失败原因为：&#123;&#125;&quot;</span>,id,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><a target="_blank" rel="noopener" href="http://localhost:8888/confirm/sendMessage/%E5%A4%A7%E5%AE%B6%E5%A5%BD1">http://localhost:8888/confirm/sendMessage/大家好1</a></p>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.5cpvzjf8zb40.webp" alt="image"></p>
<p>可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为 “key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。</p>
<p>丢弃的消息交换机是不知道的，所以生产者也不知道，需要解决告诉生产者消息传送失败。</p>
<h3 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h3><p>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。</p>
<p>那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p>
<h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>获取回退的消息，首先在配置文件开启该功能，然后需要自定义类实现 <code>RabbitTemplate.ReturnsCallback</code> 接口，并且初始化时，使用该自定义类作为回退消息的处理类，同时开启 <code>Mandatory</code>，设置为 true</p>
<p>在启动开启 Mandatory，或者在代码里手动开启 Mandatory 参数，或者都开启</p>
<p>配置类文件开启：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.template.mandatory</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>代码中开启:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h4><h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">192.168.182.128</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.mandatory</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h5 id="修改回调接口"><a href="#修改回调接口" class="headerlink" title="修改回调接口"></a>修改回调接口</h5><p>实现 <code>RabbitTemplate.ReturnsCallback</code> 接口，并实现方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 14:25</span></span><br><span class="line"><span class="comment"> *  发布确认高级 回调接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback, RabbitTemplate.ReturnsCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将该方法注入到RabbitTemplate内部接口中</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">		* true：</span></span><br><span class="line"><span class="comment">		* 交换机无法将消息进行路由时，会将该消息返回给生产者</span></span><br><span class="line"><span class="comment">		* false：</span></span><br><span class="line"><span class="comment">		* 如果发现消息无法进行路由，则直接丢弃</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="comment">//rabbitTemplate.setMandatory(true);</span></span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机确认回调方法</span></span><br><span class="line"><span class="comment">     *  1.发消息 交换机成功接收 回调</span></span><br><span class="line"><span class="comment">     *      1.1 correlationData 保存回调消息的ID及相关消息</span></span><br><span class="line"><span class="comment">     *      1.2 ack = true  交换机收到消息</span></span><br><span class="line"><span class="comment">     *      1.3 cause = null  失败原因</span></span><br><span class="line"><span class="comment">     *  2.发消息 交换机接收失败 回调</span></span><br><span class="line"><span class="comment">     *      2.1 correlationData 保存回调消息的ID及相关消息</span></span><br><span class="line"><span class="comment">     *      2.2 ack = false  交换机未收到消息</span></span><br><span class="line"><span class="comment">     *      2.3 cause  失败原因</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> b, String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span>? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (b)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机收到ID为：&#123;&#125;的消息&quot;</span>,id);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机未收到ID为：&#123;&#125;的消息,失败原因为：&#123;&#125;&quot;</span>,id,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以在当消息传递过程中不可达目的地时将消息返回给生产者</span></span><br><span class="line"><span class="comment">     *  只有不可达目的地的时候 才进行回退</span></span><br><span class="line"><span class="comment">     * 当消息无法路由的时候的回调方法</span></span><br><span class="line"><span class="comment">     *  message      消息</span></span><br><span class="line"><span class="comment">     *  replyCode    编码</span></span><br><span class="line"><span class="comment">     *  replyText    退回原因</span></span><br><span class="line"><span class="comment">     *  exchange     从哪个交换机退回</span></span><br><span class="line"><span class="comment">     *  routingKey   通过哪个路由 key 退回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息&#123;&#125;,被交换机&#123;&#125;退回，退回原因:&#123;&#125;,路由key:&#123;&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>(returnedMessage.getMessage().getBody()),returnedMessage.getExchange(),</span><br><span class="line">                returnedMessage.getReplyText(),returnedMessage.getRoutingKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开浏览器访问地址：<a target="_blank" rel="noopener" href="http://localhost:8888/confirm/sendMessage/%E5%A4%A7%E5%AE%B6%E5%A5%BD1">http://localhost:8080/confirm/sendMessage/大家好1(opens new window)</a></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.6ag1qfe3xws0.webp" alt="image"></p>
<h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？</p>
<p>前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。</p>
<p>什么是备份交换机呢？备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，<strong>当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</strong></p>
<h4 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h4><p>需要一个备份交换机 <code>backup.exchange</code>，类型为 <code>fanout</code>，该交换机发送消息到队列 <code>backup.queue</code> 和 <code>warning.queue</code></p>
<p>代码结构图:</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.109ugczigfdc.webp" alt="image"></p>
<h5 id="修改高级确认发布-配置类"><a href="#修改高级确认发布-配置类" class="headerlink" title="修改高级确认发布 配置类"></a><strong>修改高级确认发布 配置类</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 13:54</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 配置类 发布确认高级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备份交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备份队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 报警队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WARNING_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;warning_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * routingKey</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;key1&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME).durable(<span class="literal">true</span>)</span><br><span class="line">                .withArgument(<span class="string">&quot;alternate-exchange&quot;</span>,BACKUP_EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">backupExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(BACKUP_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明队列</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;backupQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">backupQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">warningQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBindingExchange</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange,</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue</span></span><br><span class="line"><span class="params">    )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">backupQueueBindingBackupExchange</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange,</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;backupQueue&quot;)</span> Queue backupQueue</span></span><br><span class="line"><span class="params">    )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(backupQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">waringQueueBindingBackupExchange</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange,</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue warningQueue</span></span><br><span class="line"><span class="params">    )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(warningQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="报警消费者"><a href="#报警消费者" class="headerlink" title="报警消费者"></a>报警消费者</h5><p>备份队列相同，由于备份交换机是fanout模式，全部绑定队列都可以接收到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 16:13</span></span><br><span class="line"><span class="comment"> * 备份交换机 报警消息 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarningConsumer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收报警消息</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.WARNING_QUEUE_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveWarningMsg</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.error(<span class="string">&quot;报警发现不可路由的消息：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于之前写过 <code>confirm.exchange</code> 交换机，当更改配置了，需要删掉，不然会报错</p>
<p>打开浏览器访问地址：<a target="_blank" rel="noopener" href="http://localhost:8888/confirm/sendMessage/%E5%A4%A7%E5%AE%B6%E5%A5%BD1">http://localhost:8080/confirm/sendMessage/大家好1(opens new window)</a></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.42foi4mawzq0.webp" alt="image"></p>
<p>Mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是<strong>备份交换机优先级高</strong>。</p>
<h2 id="RabbitMQ-其他知识点"><a href="#RabbitMQ-其他知识点" class="headerlink" title="RabbitMQ 其他知识点"></a>RabbitMQ 其他知识点</h2><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等。</p>
<p>可以理解为验证码，只能输入一次，再次重新输入会刷新验证码，原来的验证码失效。</p>
<h4 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h4><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过。</p>
<h4 id="消费端的幂等性保障"><a href="#消费端的幂等性保障" class="headerlink" title="消费端的幂等性保障"></a>消费端的幂等性保障</h4><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性，这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。</p>
<p>业界主流的幂等性有两种操作：</p>
<ul>
<li>唯一 ID+ 指纹码机制,利用数据库主键去重</li>
</ul>
<p>指纹码：我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p>
<ul>
<li>Redis 的原子性</li>
</ul>
<p>利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费。</p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧。</p>
<p>但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>Web页面添加</li>
</ul>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.2xm08z870l40.webp" alt="image"></p>
<ol>
<li>进入 Web 页面，点击 Queue 菜单，然后点击 <code>Add a new queue</code></li>
<li>点击下方的 <code>Maximum priority</code></li>
<li>执行第二步，则会自动在 <code>Argument</code> 生成 <code>x-max-priority</code> 字符串</li>
<li>点击 <code>Add queue</code> 即可添加优先级队列成功</li>
</ol>
<ul>
<li>声明队列的时候添加优先级</li>
</ul>
<p><strong>设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU，值越大的优先级越高；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">// 优先级为 10</span></span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项</p>
<p>队列实现优先级需要做的事情有如下：队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费，因为这样才有机会对消息进行排序</p>
</blockquote>
<h4 id="实战-3"><a href="#实战-3" class="headerlink" title="实战"></a>实战</h4><p>生产者发送十个消息，如果消息为 <code>info5</code>，则优先级是最高的，当消费者从队列获取消息的时候，优先获取 <code>info5</code> 消息</p>
<h5 id="生产者代码-1"><a href="#生产者代码-1" class="headerlink" title="生产者代码"></a>生产者代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 16:13</span></span><br><span class="line"><span class="comment"> * desc:优先级 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;priority_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给消息赋予一个priority属性</span></span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">1</span>).priority(<span class="number">10</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,properties,message.getBytes());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送完成：&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="消费者代码-1"><a href="#消费者代码-1" class="headerlink" title="消费者代码"></a>消费者代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : HUA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/9/10 16:13</span></span><br><span class="line"><span class="comment"> * desc:优先级 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;priority_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置队列的最大优先级 最大可以设置到255 官网推荐1-10 如果设置太高比较吃内存和CPU</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        params.put(<span class="string">&quot;x-max-priority&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,params);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//推送消息如何进行消费的接口回调</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt;&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;消费的消息: &quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a><strong>效果演示</strong></h5><p>info 5 的优先级为 10，优先级最高。消费者消费信息效果如图：</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.3vjjukfu3r00.webp" alt="image"></p>
<h3 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h3><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。<strong>惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中</strong>，它的一个重要的设计目标是<strong>能够支持更长的队列，即支持更多的消息存储。</strong>当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p>
<p>默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。</p>
<h4 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h4><p>队列具备两种模式：default 和 lazy。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 <code>channel.queueDeclare</code> 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p>
<p>在队列声明的时候可以通过 <code>x-queue-mode</code> 参数来设置队列的模式，取值为 default 和 lazy。下面示例中演示了一个惰性队列的声明细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br></pre></td></tr></table></figure>

<p>也可以在 Web 页面添加队列时，选择 <code>Lazy mode</code></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.m9m0vrilbw0.webp" alt="image"></p>
<h4 id="内存开销对比"><a href="#内存开销对比" class="headerlink" title="内存开销对比"></a>内存开销对比</h4><p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image.18hc40o0ctcw.webp" alt="image"></p>
<p>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅占用 1.5MB</p>
<h2 id="RabbitMQ-集群"><a href="#RabbitMQ-集群" class="headerlink" title="RabbitMQ 集群"></a>RabbitMQ 集群</h2><h3 id="clustering"><a href="#clustering" class="headerlink" title="clustering"></a>clustering</h3><h4 id="使用集群的原因"><a href="#使用集群的原因" class="headerlink" title="使用集群的原因"></a>使用集群的原因</h4><p>最开始我们介绍了如何安装及运行 RabbitMQ 服务，不过这些是单机版的，无法满足目前真实应用的 要求。如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ 服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要 RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是 解决实际问题的关键。</p>
<h4 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><ul>
<li>克隆三个虚拟机，分别代表不同RabbitMQ主机机器</li>
</ul>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911132605357.png" alt="image-20220911132605357"></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911133334009.png" alt="image-20220911133334009"></p>
<ul>
<li>修改 3 台机器的主机名称 <code>vim /etc/hostname</code>，然后重启<code>reboot</code></li>
</ul>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911134601724.png" alt="image-20220911134601724"></p>
<ul>
<li>配置各个节点的 hosts 文件，让各个节点都能互相识别对方<code>vim /etc/hosts</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.182.128 node1</span><br><span class="line">192.168.182.130 node2</span><br><span class="line">192.168.182.131 node3</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911135414547.png" alt="image-20220911135414547"></p>
<ul>
<li>以确保各个节点的 cookie 文件使用的是同一个值 <strong>在 node1 上执行远程操作命令</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cookie</span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/.erlang.cookie</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911135921495.png" alt="image-20220911135921495"></p>
<ul>
<li>启动 RabbitMQ 服务,顺带启动 Erlang 虚拟机和 RbbitMQ 应用服务(在三台节点上分别执行以 下命令) <code>rabbitmq-server -detached</code></li>
<li>在节点2  node2上执行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重置</span></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入到node1节点中</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@node1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">rabbitmqctl start_app(只启动应用服务)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]# rabbitmq-server -detached</span><br><span class="line">[root@node2 ~]# rabbitmqctl stop_app</span><br><span class="line">Stopping rabbit application on node rabbit@node2 ...</span><br><span class="line">[root@node2 ~]# rabbitmqctl reset</span><br><span class="line">Resetting node rabbit@node2 ...</span><br><span class="line">[root@node2 ~]# rabbitmqctl join_cluster rabbit@node1</span><br><span class="line">Clustering node rabbit@node2 with rabbit@node1</span><br><span class="line">[root@node2 ~]# rabbitmqctl start_app</span><br><span class="line">Starting node rabbit@node2 ...</span><br><span class="line">[root@node2 ~]# </span><br></pre></td></tr></table></figure>

<ul>
<li>在节点3  node3上执行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重置</span></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入到node1节点中</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@node2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">rabbitmqctl start_app(只启动应用服务)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node3 ~]# rabbitmqctl stop_app</span><br><span class="line">Stopping rabbit application on node rabbit@node3 ...</span><br><span class="line">[root@node3 ~]# rabbitmqctl reset</span><br><span class="line">Resetting node rabbit@node3 ...</span><br><span class="line">[root@node3 ~]# rabbitmqctl join_cluster rabbit@node2</span><br><span class="line">Clustering node rabbit@node3 with rabbit@node2</span><br><span class="line">[root@node3 ~]# rabbitmqctl start_app</span><br><span class="line">Starting node rabbit@node3 ...</span><br><span class="line">[root@node3 ~]# </span><br></pre></td></tr></table></figure>

<ul>
<li>查看集群状态（随便一个节点运行） <code>rabbitmqctl cluster_status</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># rabbitmqctl cluster_status</span></span><br><span class="line">Cluster status of node rabbit@node1 ...</span><br><span class="line">Basics</span><br><span class="line"></span><br><span class="line">Cluster name: rabbit@node1</span><br><span class="line"></span><br><span class="line">Disk Nodes</span><br><span class="line"></span><br><span class="line">rabbit@node1</span><br><span class="line">rabbit@node2</span><br><span class="line">rabbit@node3</span><br><span class="line"></span><br><span class="line">Running Nodes</span><br><span class="line"></span><br><span class="line">rabbit@node1</span><br><span class="line">rabbit@node2</span><br><span class="line">rabbit@node3</span><br><span class="line"></span><br><span class="line">Versions</span><br><span class="line"></span><br><span class="line">rabbit@node1: RabbitMQ 3.8.8 on Erlang 21.3</span><br><span class="line">rabbit@node2: RabbitMQ 3.8.8 on Erlang 21.3</span><br><span class="line">rabbit@node3: RabbitMQ 3.8.8 on Erlang 21.3</span><br><span class="line"></span><br><span class="line">Maintenance status</span><br><span class="line"></span><br><span class="line">Node: rabbit@node1, status: not under maintenance</span><br><span class="line">Node: rabbit@node2, status: not under maintenance</span><br><span class="line">Node: rabbit@node3, status: not under maintenance</span><br><span class="line"></span><br><span class="line">Alarms</span><br><span class="line"></span><br><span class="line">(none)</span><br><span class="line"></span><br><span class="line">Network Partitions</span><br><span class="line"></span><br><span class="line">(none)</span><br><span class="line"></span><br><span class="line">Listeners</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Feature flags</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">[root@node1 ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<ul>
<li>需要重新设置用户（随便一个节点运行）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建账号</span> </span><br><span class="line">rabbitmqctl add_user admin 123456</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置用户角色</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置用户权限</span></span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>登录查看<a target="_blank" rel="noopener" href="http://192.168.182.128:15672/#/%E6%88%96%E8%80%85http://192.168.182.130:15672/#/%E6%88%96%E8%80%85http://192.168.182.131:15672/#/%E9%9A%8F%E4%BE%BF%E4%B8%80%E4%B8%AA%E5%B0%B1%E5%8F%AF%E4%BB%A5">http://192.168.182.128:15672/#/或者http://192.168.182.130:15672/#/或者http://192.168.182.131:15672/#/随便一个就可以</a></li>
</ul>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911141520537.png" alt="image-20220911141520537"></p>
<ul>
<li>解除集群节点(node2 和 node3 机器分别执行)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在node2和node3上执行</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app rabbitmqctl cluster_status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在node1机器上执行</span></span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@node2</span><br></pre></td></tr></table></figure>

<h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><h4 id="使用镜像的原因"><a href="#使用镜像的原因" class="headerlink" title="使用镜像的原因"></a>使用镜像的原因</h4><p>如果 RabbitMQ 集群中只有一个 Broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并 且也可能会导致消息的丢失。可以将所有消息都设置为持久化，并且对应队列的durable属性也设置为true，但 是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘时执行刷盘动作之间存在一 个短暂却可能会产生问题的时间窗。通过 publisherconfirm 机制能够确保客户端知道哪些消息己经存入磁盘，尽 管如此，一般不希望遇到因单点故障导致的服务不可用。</p>
<p>引入镜像队列(Mirror Queue)的机制，可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中 的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。</p>
<h4 id="搭建步骤-1"><a href="#搭建步骤-1" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><p>​	1.启动三台集群节点</p>
<p>​	2.添加 policy</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911144013368.png" alt="image-20220911144013368"></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911150353066.png" alt="image-20220911150353066"></p>
<p>从界面上可以非常直观的看到一个Policy需要的元素：</p>
<ul>
<li>Name: 这个Policy的名称</li>
<li>Pattern: Policy根据正则表达式去匹配Queues&#x2F;Exchanges名称</li>
<li>Apply to: 这个Policy对Queue还是对Exchange生效，或者两者都适用</li>
<li>Priority: 优先级。</li>
<li>Definition: 添加的args，KV键值对。</li>
</ul>
<p>Definition 可添加的args参考以下文档：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/queues.html#properties">Queue Properties</a></li>
<li><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/dlx.html">Dead Letter Exchanges</a></li>
<li><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/parameters.html#policies">Parameters and Policies</a></li>
</ul>
<p>​	3.添加成功</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911150518540.png" alt="image-20220911150518540"></p>
<p>​	4.在 node1 上创建一个队列发送一条消息，队列存在镜像队列</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911150609715.png" alt="image-20220911150609715"></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911150634235.png" alt="image-20220911150634235"></p>
<p>​	5.停掉 node1 之后发现 node2 成为镜像队列<code>rabbitmqctl stop_app</code></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911150805804.png" alt="image-20220911150805804"></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911150826100.png" alt="image-20220911150826100"></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>就算整个集群只剩下一台机器了，依然能消费队列里面的消息，说明队列里面的消息被镜像队列传递到相应机器里面了。</p>
<h3 id="Haproxy-Keepalive-实现高可用负载均衡"><a href="#Haproxy-Keepalive-实现高可用负载均衡" class="headerlink" title="Haproxy+Keepalive 实现高可用负载均衡"></a>Haproxy+Keepalive 实现高可用负载均衡</h3><h4 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h4><p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911164140367.png" alt="image-20220911164140367"></p>
<h4 id="Haproxy-实现负载均衡"><a href="#Haproxy-实现负载均衡" class="headerlink" title="Haproxy 实现负载均衡"></a>Haproxy 实现负载均衡</h4><p>HAProxy 提供高可用性、负载均衡及基于TCPHTTP 应用的代理，支持虚拟主机，它是免费、快速并 且可靠的一种解决方案，包括 Twitter,Reddit,StackOverflow,GitHub 在内的多家知名互联网公司在使用。 HAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数。 </p>
<p>扩展 nginx,lvs,haproxy 之间的区别: <a target="_blank" rel="noopener" href="http://www.ha97.com/5646.html">http://www.ha97.com/5646.html</a></p>
<h5 id="搭建步骤-2"><a href="#搭建步骤-2" class="headerlink" title="搭建步骤"></a>搭建步骤</h5><ol>
<li>下载 haproxy(在 node1 和 node2)<code>yum -y install haproxy</code></li>
<li>修改 node1 和 node2 的 haproxy.cfg</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/haproxy/haproxy.cfg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line">        server  rabbitmq_node1 192.168.182.128:5672 check inter 5000 rise 2 fall 3 weight 1</span><br><span class="line">    server  rabbitmq_node2 192.168.182.130:5672 check inter 5000 rise 2 fall 3 weight 1</span><br><span class="line">    server  rabbitmq_node3 192.168.182.131:5672 check inter 5000 rise 2 fall 3 weight 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>3. 在两台节点启动 haproxy
</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">haproxy -f /etc/haproxy/haproxy.cfg</span><br><span class="line">ps -ef | grep haproxy</span><br></pre></td></tr></table></figure>

<pre><code>4. 访问地址http://192.168.182.128:8888/stats
</code></pre>
<h4 id="Keepalived-实现双机-主备-热备"><a href="#Keepalived-实现双机-主备-热备" class="headerlink" title="Keepalived 实现双机(主备)热备"></a>Keepalived 实现双机(主备)热备</h4><p>试想如果前面配置的 HAProxy 主机突然宕机或者网卡失效，那么虽然 RbbitMQ 集群没有任何故障但是 对于外界的客户端来说所有的连接都会被断开结果将是灾难性的为了确保负载均衡服务的可靠性同样显得 十分重要，这里就要引入 Keepalived 它能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现 故障转移。</p>
<h5 id="搭建步骤-3"><a href="#搭建步骤-3" class="headerlink" title="搭建步骤"></a>搭建步骤</h5><ol>
<li>下载 keepalived<code>yum -y install keepalived</code></li>
<li>节点 node1 配置文件 <ol>
<li><code>vim /etc/keepalived/keepalived.conf </code>把资料里面的 keepalived.conf 修改之后替换</li>
</ol>
</li>
<li>节点 node2 配置文件 <ol>
<li>需要修改global_defs 的 router_id,如:nodeB </li>
<li>其次要修改 vrrp_instance_VI 中 state 为”BACKUP”； </li>
<li>最后要将priority 设置为小于 100 的值</li>
</ol>
</li>
<li>添加 haproxy_chk.sh (为了防止 HAProxy 服务挂掉之后 Keepalived 还在正常工作而没有切换到 Backup 上，所以这里需要编写一个脚本来检测 HAProxy 务的状态,当 HAProxy 服务挂掉之后该脚本会自动重启 HAProxy 的服务，如果不成功则关闭 Keepalived 服务，这样便可以切换到 Backup 继续工作)</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/keepalived/haproxy_chk.sh(可以直接上传文件)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改权限</span> </span><br><span class="line">chmod 777 /etc/keepalived/haproxy_chk.sh</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>启动 keepalive 命令(node1 和 node2 启动)</p>
<p><code>systemctl start keepalived</code></p>
</li>
<li><p>观察 Keepalived 的日志</p>
<p><code>tail -f /var/log/messages -n 200</code></p>
</li>
<li><p>观察最新添加的 vip</p>
<p><code>ip add show</code></p>
</li>
<li><p>node1 模拟 keepalived 关闭状态</p>
<p><code>systemctl stop keepalived</code></p>
</li>
</ol>
<p>​	9. 使用 vip 地址来访问 rabbitmq 集群</p>
<h3 id="Federation-Exchange（联邦交换机）"><a href="#Federation-Exchange（联邦交换机）" class="headerlink" title="Federation Exchange（联邦交换机）"></a>Federation Exchange（联邦交换机）</h3><h4 id="使用它的原因"><a href="#使用它的原因" class="headerlink" title="使用它的原因"></a>使用它的原因</h4><p>​	(broker 北京)，(broker 深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题。有一个在北京 的业务(Client 北京) 需要连接(broker 北京)，向其中的交换器 exchangeA 发送消息，此时的网络延迟很小， (Client 北京)可以迅速将消息发送至 exchangeA 中，就算在开启了 publisherconfirm 机制或者事务机制的情 况下，也可以迅速收到确认信息。此时又有个在深圳的业务(Client 深圳)需要向 exchangeA 发送消息， 那 么(Client 深圳) (broker 北京)之间有很大的网络延迟，(Client 深圳) 将发送消息至 exchangeA 会经历一定 的延迟，尤其是在开启了 publisherconfirm 机制或者事务机制的情况下，(Client 深圳) 会等待很长的延迟 时间来接收(broker 北京)的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的阻 塞。</p>
<p>​	 将业务(Client 深圳)部署到北京的机房可以解决这个问题，但是如果业务(Client 深圳)调用的另些服务又部署在深圳，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？ 这里 使用 Federation 插件就可以很好地解决这个问题。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911152414312.png" alt="image-20220911152414312"></p>
<h4 id="搭建步骤-4"><a href="#搭建步骤-4" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><ol>
<li><p>需要保证每台节点单独运行</p>
</li>
<li><p>在每台机器上开启 federation 相关插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_federation</span><br><span class="line">rabbitmq-plugins enable rabbitmq_federation_management</span><br></pre></td></tr></table></figure>
</li>
<li><p>原理图(先运行 consumer 在 node2 创建 fed_exchange)</p>
<p>通过把node1节点（上游）数据同步到node2（下游），下游必须拥有一个交换机才可以进行同步。</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911152539898.png" alt="image-20220911152539898"></p>
<p>在node2上声明一个路由交换机，绑定一个队列</p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911155943875.png" alt="image-20220911155943875"></p>
</li>
<li><p>在 downstream(下游节点node2)配置 upstream(上游节点node1)地址</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911161415498.png" alt="image-20220911161415498"></p>
<pre><code>5. 添加 polic
</code></pre>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911160344287.png" alt="image-20220911160344287"></p>
<pre><code>6. 成功
</code></pre>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911160506465.png" alt="image-20220911160506465"></p>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911160625495.png" alt="image-20220911160625495"></p>
<h3 id="Federation-Queue（联邦队列）"><a href="#Federation-Queue（联邦队列）" class="headerlink" title="Federation Queue（联邦队列）"></a>Federation Queue（联邦队列）</h3><h4 id="使用它的原因-1"><a href="#使用它的原因-1" class="headerlink" title="使用它的原因"></a>使用它的原因</h4><p>联邦队列可以在多个 Broker 节点(或者集群)之间为单个队列提供均衡负载的功能。一个联邦队列可以 连接一个或者多个上游队列(upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息 的需求。</p>
<h4 id="搭建步骤-5"><a href="#搭建步骤-5" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><ol>
<li>原理图</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911162153372.png" alt="image-20220911162153372"></p>
<pre><code>2. 添加 upstream(同上)
2. 添加 policy
</code></pre>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911162258179.png" alt="image-20220911162258179"></p>
<pre><code>4. 结果
</code></pre>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911162338673.png" alt="image-20220911162338673"></p>
<h3 id="Shovel"><a href="#Shovel" class="headerlink" title="Shovel"></a>Shovel</h3><h4 id="使用它的原因-2"><a href="#使用它的原因-2" class="headerlink" title="使用它的原因"></a>使用它的原因</h4><p>Federation 具备的数据转发功能类似，Shovel 够可靠、持续地从一个 Broker 中的队列(作为源端，即 source)拉取数据并转发至另一个 Broker 中的交换器(作为目的端，即 destination)。作为源端的队列和作为 目的端的交换器可以同时位于同一个 Broker，也可以位于不同的 Broker 上。Shovel 可以翻译为”铲子”，是 一种比较形象的比喻，这个”铲子”可以将消息从一方”铲子”另一方。Shovel 行为就像优秀的客户端应用程 序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。</p>
<h4 id="搭建步骤-6"><a href="#搭建步骤-6" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><ol>
<li>开启插件(需要的机器都开启)</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_shovel</span><br><span class="line">rabbitmq-plugins enable rabbitmq_shovel_management</span><br></pre></td></tr></table></figure>

<pre><code>2. 原理图(在源头发送的消息直接回进入到目的地队列)
</code></pre>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911162451227.png" alt="image-20220911162451227"></p>
<ol start="3">
<li><p>添加 shovel 源和目的地</p>
<p>将Q1（源端）数据同步到Q2（目的端）</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911163757452.png" alt="image-20220911163757452"></p>
<pre><code>4. 成功
</code></pre>
<p><img src="/img/loading.gif" data-original="/2022/09/03/RabbitMQ/image-20220911164019286.png" alt="image-20220911164019286"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">HUA</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/09/03/RabbitMQ/">http://example.com/2022/09/03/RabbitMQ/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">阿华</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/page6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/13/MyBatis-Plus/"><img class="prev-cover" src="/img/loading.gif" data-original="/img/page2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MyBatis-Plus</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/02/Git/"><img class="next-cover" src="/img/loading.gif" data-original="/img/page2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Git</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HUA</div><div class="author-info__description">不要放弃</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/TINGTING-GIT" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromld=45&amp;fromSubld=1&amp;subcmd=all&amp;uin=2164277973&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:2164277973@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div></div><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople1.js"></script><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/zdog.dist.js"></script><script id="rendered-js" src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MQ-%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">MQ 的相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MQ"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是 MQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-MQ"><span class="toc-number">1.1.2.</span> <span class="toc-text">为什么要用 MQ</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%B6%88%E5%B3%B0"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">流量消峰</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">应用解耦</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">异步处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MQ%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text">MQ的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MQ%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.1.4.</span> <span class="toc-text">MQ的选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ"><span class="toc-number">1.2.</span> <span class="toc-text">RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RabbitMQ%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">RabbitMQ的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.2.</span> <span class="toc-text">四大核心概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RabbitMQ%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">RabbitMQ核心部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E5%90%8D%E8%AF%8D%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.4.</span> <span class="toc-text">各个名词介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85RabbitMQ"><span class="toc-number">1.2.5.</span> <span class="toc-text">安装RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">下载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%8F%8A%E6%8E%88%E6%9D%83%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">管理界面及授权操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-RabbitMQ"><span class="toc-number">2.</span> <span class="toc-text">Hello RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96"><span class="toc-number">2.1.</span> <span class="toc-text">添加依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">2.2.</span> <span class="toc-text">消息生产者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">2.3.</span> <span class="toc-text">消息消费者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Work-Queues"><span class="toc-number">3.</span> <span class="toc-text">Work Queues</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E6%B6%88%E8%B4%B9"><span class="toc-number">3.1.</span> <span class="toc-text">轮询消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E6%A1%88%E4%BE%8B"><span class="toc-number">3.2.</span> <span class="toc-text">轮询案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web%E9%A1%B5%E9%9D%A2%E6%B7%BB%E5%8A%A0%E9%98%9F%E5%88%97"><span class="toc-number">3.3.</span> <span class="toc-text">Web页面添加队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94"><span class="toc-number">3.4.</span> <span class="toc-text">消息应答</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94"><span class="toc-number">3.4.1.</span> <span class="toc-text">自动应答</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">手动消息应答的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%87%AA%E5%8A%A8%E9%87%8D%E6%96%B0%E5%85%A5%E9%98%9F"><span class="toc-number">3.4.3.</span> <span class="toc-text">消息自动重新入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%BA%94%E7%AD%94%E6%A1%88%E4%BE%8B"><span class="toc-number">3.4.4.</span> <span class="toc-text">手动应答案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RabbitMQ-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.4.5.</span> <span class="toc-text">RabbitMQ 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.4.5.1.</span> <span class="toc-text">队列持久化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.4.5.2.</span> <span class="toc-text">消息持久化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%85%AC%E5%B9%B3%E5%88%86%E5%8F%91"><span class="toc-number">3.4.5.3.</span> <span class="toc-text">不公平分发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E5%8F%96%E5%80%BC%E5%88%86%E5%8F%91"><span class="toc-number">3.4.5.4.</span> <span class="toc-text">预取值分发</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4"><span class="toc-number">4.</span> <span class="toc-text">发布确认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">4.2.</span> <span class="toc-text">发布确认的策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">开启发布确认的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-number">4.2.2.</span> <span class="toc-text">单个确认发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-number">4.2.3.</span> <span class="toc-text">批量确认发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-number">4.2.4.</span> <span class="toc-text">异步确认发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E6%9C%AA%E7%A1%AE%E8%AE%A4%E6%B6%88%E6%81%AF"><span class="toc-number">4.2.5.</span> <span class="toc-text">如何处理异步未确认消息?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8A-3-%E7%A7%8D%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E9%80%9F%E5%BA%A6%E5%AF%B9%E6%AF%94"><span class="toc-number">4.2.6.</span> <span class="toc-text">以上 3 种发布确认速度对比:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%AD%94%E5%92%8C%E5%8F%91%E5%B8%83%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.7.</span> <span class="toc-text">应答和发布区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">5.</span> <span class="toc-text">交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exchanges"><span class="toc-number">5.1.</span> <span class="toc-text">Exchanges</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exchanges-%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.1.</span> <span class="toc-text">Exchanges 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exchanges%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.2.</span> <span class="toc-text">Exchanges的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%8Dexchange%EF%BC%88%E9%BB%98%E8%AE%A4exchange%EF%BC%89"><span class="toc-number">5.1.3.</span> <span class="toc-text">无名exchange（默认exchange）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-number">5.2.</span> <span class="toc-text">临时队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A-bindings"><span class="toc-number">5.3.</span> <span class="toc-text">绑定(bindings)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fanout-%E6%89%87%E5%87%BA%EF%BC%88%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">Fanout 扇出（发布订阅模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fanout-%E5%AE%9E%E6%88%98"><span class="toc-number">5.4.2.</span> <span class="toc-text">Fanout 实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Direct-exchange-%E7%9B%B4%E6%8E%A5%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%88%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">Direct exchange 直接交换机（路由交换）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Direct%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.5.1.</span> <span class="toc-text">Direct介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%91%E5%AE%9A"><span class="toc-number">5.5.2.</span> <span class="toc-text">多重绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Direct%E5%AE%9E%E6%88%98"><span class="toc-number">5.5.3.</span> <span class="toc-text">Direct实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Topics-%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">5.6.</span> <span class="toc-text">Topics 主题交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Topic-%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">5.6.1.</span> <span class="toc-text">Topic 的要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Topic%E5%8C%B9%E9%85%8D%E6%A1%88%E4%BE%8B"><span class="toc-number">5.6.2.</span> <span class="toc-text">Topic匹配案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Topic%E5%AE%9E%E6%88%98"><span class="toc-number">5.6.3.</span> <span class="toc-text">Topic实战</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">RabbitMQ 死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">死信的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="toc-number">6.2.</span> <span class="toc-text">死信的来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E5%AE%9E%E6%88%98"><span class="toc-number">6.3.</span> <span class="toc-text">死信实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AFTTL-%E8%BF%87%E6%9C%9F"><span class="toc-number">6.3.1.</span> <span class="toc-text">消息TTL 过期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E8%BE%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6"><span class="toc-number">6.3.2.</span> <span class="toc-text">队列达到最大长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%A2%AB%E6%8B%92"><span class="toc-number">6.3.3.</span> <span class="toc-text">消息被拒</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.</span> <span class="toc-text">延迟队列介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">7.1.1.</span> <span class="toc-text">延迟队列概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">7.1.2.</span> <span class="toc-text">延迟队列使用场景：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E4%B8%AD%E7%9A%84-TTL"><span class="toc-number">7.2.</span> <span class="toc-text">RabbitMQ 中的 TTL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E8%AE%BE%E7%BD%AE-TTL"><span class="toc-number">7.2.1.</span> <span class="toc-text">队列设置 TTL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%AE%BE%E7%BD%AE-TTL"><span class="toc-number">7.2.2.</span> <span class="toc-text">消息设置 TTL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.3.</span> <span class="toc-text">两者区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%90%88SpringBoot"><span class="toc-number">7.3.</span> <span class="toc-text">整合SpringBoot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97TTL"><span class="toc-number">7.4.</span> <span class="toc-text">队列TTL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">7.4.1.</span> <span class="toc-text">代码架构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E4%BB%A3%E7%A0%81"><span class="toc-number">7.4.2.</span> <span class="toc-text">配置文件类代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-number">7.4.3.</span> <span class="toc-text">消息生产者代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-number">7.4.4.</span> <span class="toc-text">消息消费者代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96"><span class="toc-number">7.5.</span> <span class="toc-text">延时队列优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%B1%BB%E4%BB%A3%E7%A0%81"><span class="toc-number">7.5.1.</span> <span class="toc-text">配置类代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rabbitmq%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">7.6.</span> <span class="toc-text">Rabbitmq插件实现延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE-1"><span class="toc-number">7.6.1.</span> <span class="toc-text">代码架构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%B1%BB%E4%BB%A3%E7%A0%81-1"><span class="toc-number">7.6.2.</span> <span class="toc-text">配置类代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-number">7.6.3.</span> <span class="toc-text">生产者代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-number">7.6.4.</span> <span class="toc-text">消费者代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">7.6.5.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E9%AB%98%E7%BA%A7"><span class="toc-number">8.</span> <span class="toc-text">RabbitMQ 发布确认高级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4SpringBoot%E7%89%88%E6%9C%AC"><span class="toc-number">8.1.</span> <span class="toc-text">发布确认SpringBoot版本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">8.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-number">8.1.2.</span> <span class="toc-text">实战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">8.1.3.</span> <span class="toc-text">添加配置类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85-1"><span class="toc-number">8.1.4.</span> <span class="toc-text">消息生产者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85-1"><span class="toc-number">8.1.5.</span> <span class="toc-text">消息消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF%E5%90%8E%E7%9A%84%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.1.6.</span> <span class="toc-text">消息生产者发布消息后的回调接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="toc-number">8.1.7.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90"><span class="toc-number">8.1.8.</span> <span class="toc-text">结果分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%80%80%E6%B6%88%E6%81%AF"><span class="toc-number">8.2.</span> <span class="toc-text">回退消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">8.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98-1"><span class="toc-number">8.2.2.</span> <span class="toc-text">实战</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">修改配置文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.2.2.2.</span> <span class="toc-text">修改回调接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">8.3.</span> <span class="toc-text">备份交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">8.3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98-2"><span class="toc-number">8.3.2.</span> <span class="toc-text">实战</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%AB%98%E7%BA%A7%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83-%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">修改高级确认发布 配置类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%A5%E8%AD%A6%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">8.3.2.2.</span> <span class="toc-text">报警消费者</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">9.</span> <span class="toc-text">RabbitMQ 其他知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">9.1.</span> <span class="toc-text">幂等性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-number">9.1.2.</span> <span class="toc-text">消息重复消费</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">9.1.3.</span> <span class="toc-text">解决思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E4%BF%9D%E9%9A%9C"><span class="toc-number">9.1.4.</span> <span class="toc-text">消费端的幂等性保障</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">9.2.</span> <span class="toc-text">优先级队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.2.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98-3"><span class="toc-number">9.2.3.</span> <span class="toc-text">实战</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81-1"><span class="toc-number">9.2.3.1.</span> <span class="toc-text">生产者代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81-1"><span class="toc-number">9.2.3.2.</span> <span class="toc-text">消费者代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA"><span class="toc-number">9.2.3.3.</span> <span class="toc-text">效果演示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-number">9.3.</span> <span class="toc-text">惰性队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">9.3.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.3.2.</span> <span class="toc-text">两种模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%BC%80%E9%94%80%E5%AF%B9%E6%AF%94"><span class="toc-number">9.3.3.</span> <span class="toc-text">内存开销对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E9%9B%86%E7%BE%A4"><span class="toc-number">10.</span> <span class="toc-text">RabbitMQ 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#clustering"><span class="toc-number">10.1.</span> <span class="toc-text">clustering</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">10.1.1.</span> <span class="toc-text">使用集群的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-number">10.1.2.</span> <span class="toc-text">搭建步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97"><span class="toc-number">10.2.</span> <span class="toc-text">镜像队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">10.2.1.</span> <span class="toc-text">使用镜像的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">10.2.2.</span> <span class="toc-text">搭建步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">10.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Haproxy-Keepalive-%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">10.3.</span> <span class="toc-text">Haproxy+Keepalive 实现高可用负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">10.3.1.</span> <span class="toc-text">整体架构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Haproxy-%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">10.3.2.</span> <span class="toc-text">Haproxy 实现负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4-2"><span class="toc-number">10.3.2.1.</span> <span class="toc-text">搭建步骤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Keepalived-%E5%AE%9E%E7%8E%B0%E5%8F%8C%E6%9C%BA-%E4%B8%BB%E5%A4%87-%E7%83%AD%E5%A4%87"><span class="toc-number">10.3.3.</span> <span class="toc-text">Keepalived 实现双机(主备)热备</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4-3"><span class="toc-number">10.3.3.1.</span> <span class="toc-text">搭建步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Federation-Exchange%EF%BC%88%E8%81%94%E9%82%A6%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%89"><span class="toc-number">10.4.</span> <span class="toc-text">Federation Exchange（联邦交换机）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%83%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">10.4.1.</span> <span class="toc-text">使用它的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4-4"><span class="toc-number">10.4.2.</span> <span class="toc-text">搭建步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Federation-Queue%EF%BC%88%E8%81%94%E9%82%A6%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">10.5.</span> <span class="toc-text">Federation Queue（联邦队列）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%83%E7%9A%84%E5%8E%9F%E5%9B%A0-1"><span class="toc-number">10.5.1.</span> <span class="toc-text">使用它的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4-5"><span class="toc-number">10.5.2.</span> <span class="toc-text">搭建步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shovel"><span class="toc-number">10.6.</span> <span class="toc-text">Shovel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%83%E7%9A%84%E5%8E%9F%E5%9B%A0-2"><span class="toc-number">10.6.1.</span> <span class="toc-text">使用它的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4-6"><span class="toc-number">10.6.2.</span> <span class="toc-text">搭建步骤</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/06/Spring6/" title="Spring6"><img src="/img/loading.gif" data-original="/img/page4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring6"/></a><div class="content"><a class="title" href="/2023/04/06/Spring6/" title="Spring6">Spring6</a><time datetime="2023-04-06T07:37:05.751Z" title="发表于 2023-04-06 15:37:05">2023-04-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/29/Vue3-0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/" title="Vue3.0项目搭建"><img src="/img/loading.gif" data-original="/img/page6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue3.0项目搭建"/></a><div class="content"><a class="title" href="/2022/12/29/Vue3-0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/" title="Vue3.0项目搭建">Vue3.0项目搭建</a><time datetime="2022-12-29T02:31:40.241Z" title="发表于 2022-12-29 10:31:40">2022-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/29/vue2.0/" title="Vue2"><img src="/img/loading.gif" data-original="/img/page6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue2"/></a><div class="content"><a class="title" href="/2022/12/29/vue2.0/" title="Vue2">Vue2</a><time datetime="2022-12-29T02:31:40.237Z" title="发表于 2022-12-29 10:31:40">2022-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/29/SQL%E8%AF%AD%E5%8F%A5/" title="SQL语句"><img src="/img/loading.gif" data-original="/img/page3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SQL语句"/></a><div class="content"><a class="title" href="/2022/12/29/SQL%E8%AF%AD%E5%8F%A5/" title="SQL语句">SQL语句</a><time datetime="2022-12-29T02:31:40.236Z" title="发表于 2022-12-29 10:31:40">2022-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/29/npm%E5%88%87%E6%8D%A2%E5%AE%89%E8%A3%85%E6%BA%90/" title="npm切换安装源"><img src="/img/loading.gif" data-original="/img/page2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="npm切换安装源"/></a><div class="content"><a class="title" href="/2022/12/29/npm%E5%88%87%E6%8D%A2%E5%AE%89%E8%A3%85%E6%BA%90/" title="npm切换安装源">npm切换安装源</a><time datetime="2022-12-29T02:31:40.234Z" title="发表于 2022-12-29 10:31:40">2022-12-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By HUA</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="/img/loading.gif" data-original="https://fastly.jsdelivr.net/gh/tzy13755126023/BLOG_SOURCE/theme_f/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(e){e.imageLazyLoadSetting.processImages=t;var n=e.imageLazyLoadSetting.isSPA,i=e.imageLazyLoadSetting.preloadRatio||1,r=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){n&&(r=o());for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(e.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];e=function(){r=r.filter(function(t){return o!==t})},(t=o).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,t.removeAttribute("data-original"),e&&e()},t.src!==i&&(n.src=i))}()}function a(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",a),e.addEventListener("resize",a),e.addEventListener("orientationchange",a)}(this);</script></body></html>